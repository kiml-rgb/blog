[{"title":"Obsidian + Git + Hexo + 图床 = Blog + 个人笔记体系","url":"/2023/02/6870bf8bd223.html","content":"\n\n前言\n之前有过基于 Hexo 的博客搭建经历，但是由于时间繁忙，加上后续学习了解到的笔记软件，拥有我想要的全局搜索功能，而且比博客的格式、排版更加吸引人，就放弃了之前搭建的博客。但是出来找工作感觉拥有一个自己的技术博客会比较占优势，因此打算在笔记的基础上，加上原来的 Hexo 快速生成，转成技术博客输出。\n\n\n参考文章\n\n\n\n【保姆级】利用Github搭建自己的个人博客，看完就会\nHexo + Obsidian + Git 完美的博客部署与编辑方案\n\n\n更新\n\n22.12.11 初始记录(修改预计开始日期为元旦)23.02.24 环境部署，个人博客绑定到 Gitee Pages23.02.27 Obsidian 整合 等待Gitee Pages审核ing24.03.28 更新域名绑定等相关问题\n\n环境部署\n安装git\n\n\n访问 git 官方地址，下载对应的安装包，进行安装（简单的点击下一步）。\n\n\n安装好之后，鼠标右键可以看到：Git Bash Here，点击后打开了。\n\n\n输入：git --version\n出现版本号说明安装成功。\n\n\n安装node.js\n\n\n访问 node.js 官方地址，下载对应的安装包，进行安装（简单的点击下一步）。\n\n\n安装好之后，配置环境变量，并在终端里面输入：node -v\n出现版本号说明安装成功。\n\n\n安装 Hexo\n\n\n安装命令：\n\n\nnpm install hexo -g\n测试是否安装成功，命令：hexo -v\n出现版本号说明安装成功。\n\n\n安装 hexo 推送 git 拓展依赖，安装命令：\n\n\nnpm install hexo-deployer-git --save\ngit配置 SSH key\n\n\n先看本地是否配置好SSH key（命令：cd ~/.ssh）\nSSH key的保存位置在本地的C:\\Users\\&#123;你的用户名&#125;\\.ssh文件下，如果本地已存在SSH，此步不会有提示，否则出现No such file or directory。如果保存文件下没有文件id_rsa.pub 或 id_dsa.pub则也需要重新生成\n\n\n生成SSH key\n如果没有配置输入生成命令，然后连续回车三次即可：\n\n\nssh-keygen -t rsa -C &quot;邮件地址&quot; #该邮箱地址是绑定github账号的地址\ngithub\n\n\n打开SSH key的保存位置，复制id_rsa.pub文件里全部内容，接着打开github主页，点击个人设置，点击左侧的SSH and GPG keys，点击New SSH key\n\n\n\n将id_rsa.pub复制的内容粘贴到key中，title随便起一个就行。\n\n\n\n测试是否成功，输入命令：\n\n\nssh -T git@github.com\n出现 You've successfully authenticated, but GitHub does not provide shell access.说明成功\n\n\n配置账号和密码\n\n\n$ git config --global user.name &quot;liyunchen&quot; #你的github用户名 $ git config --global user.email &quot;xxx@163.com&quot; #填写你的github注册邮箱\ngitee\n\n除了Github Pages，也可以把博客搭建在Gitee Pages上，不翻墙的情况下，连接github经常会出现连接不上的情况，所以这次就直接改到Gitee上了。又换回来了（24.02.02）\n\n\n\n同样的配置SSH key，在Gitee的个人设置界面添加公钥\n\n\n\n测试是否成功，输入命令：\n\n\nssh -T git@gitee.com\n出现 You've successfully authenticated, but GITEE.COM does not provide shell access.说明成功\n搭建个人博客\n\n\n新建一个保存博客的存放目录，进入到本地博客存放目录，初始化个人博客，命令：\n\n\nhexo init\n出现不可获取错误说明github连接失败，再重新执行一遍命令就可以了\n\n\n\n生成静态网页，命令：\n\n\nhexo g\n\n\n本地预览，命令：\n\n\nhexo s\n访问localhost:4000\ngithub\n\n\n新建一个github仓库，给仓库起个名称，可以为用户名.github.io，这样这个名称就可以作为你github博客的访问地址\n\n\n编辑_config.yml，此文件在你博客存放目录下，需要编辑的github地址填写在最后deploy处\n\n\ndeploy: \ttype: git \trepository: #仓库地址\tbranch: main #查看自己仓库是master还是main\n\n\n发布到 github，命令：\n\n\nhexo d\n这样就已经把生成的静态文件推送到github仓库去了。\ngitee\n\n\n新建一个 gitee 仓库，给仓库起个名称，这里我直接用 blog 作为名称，这样博客的访问地址就是用户名.gitee.io/blog\n\n\n编辑_config.yml，此文件在你博客存放目录下，文件需要\n\n\ndeploy: \ttype: git \trepository: #仓库地址\tbranch: master #查看自己仓库是master还是main\n\n\n发布到 gitee，命令：\n\n\nhexo d\n\n\n在个人仓库界面，开启 Gitee Pages 服务（第一次使用还要手持身份证拍照的实名认证，蛮无语的，终于知道为什么用的人少了。。。）\n\n\n\n博客主题（Keep）\n\n在配置文件里可以看见 Hexo 主题商店的地址，配置文件中默认的主题为 landscape，不太喜欢打算换掉。原先博客使用的是Next主题，也是使用 Hexo 搭建博客用到最多的主题，但是也用腻了。现在发现一个新的主题 Keep，感觉蛮简洁舒适的，所以这次重新搭建也打算直接换上。\n\nKeep 主题的官方配置文档很详细，在演示博客中有一个使用指南，直接照着配置就行。\nObsidian整合\nObsidian知识库创建\n\n\n新建一个仓库或将之前的博客文件作为仓库打开\n\n\n\n忽略多余的文件。我们主要是编辑和管理Markdown文件，所以一些多余的文件要忽略掉，这样在知识库里搜索文件、关键字时才不会搜索到多余的，也能有效提高检索效率。打开：设置&gt;文件与链接&gt;Exclude Files\n\n\n\n设置新建笔记的存放位置，内部链接类型~~（关闭Wiki链接的使用，因为hexo的解析要求为markdown格式的文件）~~以及附件默认的存放路径\n\n\n\n在 hexo 项目的 .gitignore 文件中加入如下内容：\n\n\n.obsidian/workspace\n博客文章的管理\n\n新建文件在 hexo 的默认配置中放在 source/_post 目录下，随着文章数量的增多，文章也会变得难以寻找。因此采用以文件夹来分目录的方式，存放写好的文件。但是这样分类后，还需要手动维护文章开始前的定义文字，去修改文件所在的目录，较为麻烦。\n\n为了省去手动维护 categorys 字段的这个问题，我们可以使用 hexo-auto-category 这个插件。这个插件在 Hexo 进行 build 的时候会去自动根据文章目录情况来自动修改文章的 categories 信息，更详细的部分可以看作者的文章。除此之外最好修改一下 _config.yml 中的默认配置：\npermalink: :year/:month/:hash.html\n但是这里有一个问题，就是只有 hexo 在执行 hexo generate 或者 hexo server 时候才会去触发 categories 的生成，那么每次我们创建文章都要重新 hexo generate 以触发插件的自动校正功能，并再次把更新后的变更提交推送git。\n参考博客使用Husky完成git hook的操作：\n\n\n安装 huksy：npm install husky --save-dev\n\n\n执行 huksy 初始化指令：npx husky install\n\n\n在 package.json 中的 scripts 中写入：&quot;prepare&quot;: &quot;husky install&quot;\n\n\n在生成的 .husky 目录创建 pre-commit 文件（有的话就不用创建），并写入以下内容：\n\n\n#!/usr/bin/env sh. &quot;$(dirname -- &quot;$0&quot;)/_/husky.sh&quot;npx hexo generate &amp;&amp; git add .\n如果提交代码的时候，终端出现类似的构建过程，就说明由 husky 创建的 git hook 生效了。\n\nhexo 博客默认携带的两个文件夹为 categories 和 tags ，这两个标签可以在文章开始前定义，然后 hexo 会自动解析该文章所属的目录和标签。\n\n上面已经通过插件解决了目录的问题，还剩下文章的标题和 tags。Obsidian 是支持创建新文件时插入模板的，这就意味着我们可以不用重复写 Hexo 博客文的 Front-matter 部分。\n\n\n在 source 目录下创建 _obsidian 文件夹，并创建一篇 Post Template 的文章（md文件），内容为：\n\n\n---title: &#123;&#123;title&#125;&#125;date: &#123;&#123;date&#125;&#125;tags: []---\n\n\n然后进入到 Obsidian 的设置面板，选择核心插件，并启用模板功能。同时点击旁边的配置按钮，进入到模板配置的设置中，设置配置信息\n\n\n\n之后，我们再创建新文章的时候，只需要点击侧边栏的插入模板按钮就可以快速生成 Front-matter 信息：\n\n\n\n博客图片的管理\n\n在 Obsidian 中，可以直接粘贴截图，并设置默认保存位置。相对路径保存的格式如下：![](attachments/xxx.png)，但是这样部署到 hexo 中的图片会显示404加载不成功的错误。\n\n原先的办法是将 _config.yml 配置文件中的 post_asset_folder 选项设置为 true 来打开。该功能打开后，Hexo 将会在你每一次通过 hexo new [layout] &lt;title&gt; 命令创建新文章时自动创建一个文件夹。这个资源文件夹名与文章文件名相同。将所有与你的文章有关的资源（如图片）放在这个关联文件夹中之后，通过相对路径来引用它们。但是由于本次需要将 Obsidian 与 Hexo 结合，希望生成新文章不依靠于命令行。因此本次直接加入图床保存图片。使用的图床为Keep主题推荐的图床PicX。建议本地依旧备份一份图片，以防万一。\nGit 同步（后续弃用）\n\nObsidian内存在插件Obsidian Git 插件使我们可以在 Obsidian 内就可以实现 git commit 以及 push 的操作。\n\n\n\n在右侧命令面板处输入open source control view，可以打开Git面板，右侧会自动生成commit信息，commit信息可以在配置文件内自行配置\n\n\n\nFile Tree 定位\n\n用 Obsidian 控制文件有一个弊端在于左侧目录为全部文件，而我们编写 hexo 博客，一般只会在_posts文件下操作，可以使用Obsidian插件 File Tree Alternative Plugin\n\n安装插件后可以看到文件列变为了以下格式\n\n打开选中_post，右键Focus on Folder，则菜单栏只显示_post文件夹\n\n其他拓展\n更高级的 Markdown 渲染器\n\nHexo 默认的 Markdown 渲染器是hexo-renderer-marked，但其支持的渲染格式有限，比如重点符号的渲染就是不成功的，因此更换更好用的渲染器hexo-renderer-markdown-it\n\n\n\n卸载hexo-renderer-marked\n\n\nnpm un hexo-renderer-marked --save\n\n\n安装 hexo-renderer-markdown-it\n\n\nnpm i hexo-renderer-markdown-it --save\n\n\n将如下文本复制粘贴到 Hexo 的配置文件 _config.yml 的尾部\n\n\nmarkdown:  preset: &quot;default&quot;  render:    html: true    xhtmlOut: false    langPrefix: &quot;language-&quot;    breaks: true    linkify: true    typographer: true    quotes: &quot;“”‘’&quot;  enable_rules:  disable_rules:  plugins:    - markdown-it-abbr    - markdown-it-cjk-breaks    - markdown-it-deflist    - markdown-it-emoji    - markdown-it-footnote    - markdown-it-ins    - markdown-it-mark    - markdown-it-sub    - markdown-it-sup    - markdown-it-checkbox    - markdown-it-imsize    - markdown-it-expandable    - name: markdown-it-container      options: success    - name: markdown-it-container      options: tips    - name: markdown-it-container      options: warning    - name: markdown-it-container      options: danger  anchors:    level: 2    collisionSuffix: &quot;&quot;    permalink: false    permalinkClass: &quot;header-anchor&quot;    permalinkSide: &quot;left&quot;    permalinkSymbol: &quot;¶&quot;    case: 0    separator: &quot;-&quot;\n\n\n分别使用 npm 命令安装以下三个插件，其它插件 hexo-renderer-markdown-it 渲染器已有\n\n\nnpm i markdown-it-checkboxnpm i markdown-it-imsizenpm i markdown-it-expandable\n域名绑定\n\n\n域名的购买\n\n\n在仓库里添加CNAME文件并在文件中填写绑定的域名\n\n\n\nping 你的github域名得到IP地址\n\n\n\n解析域名到对应的地址\n\n\n\n问题\nHexo在部署到Github后CNAME文件会消失或改变\n问题详述：之前已经在github上对域名进行了绑定，但是hexo -d之后绑定生成的CNAME文件被删除。解决方式：参考网上博客的说法，把对应的CNAME文件放入source文件夹下，这样hexo -g重新生成public文件夹下的内容时，CNAME文件也会同步生成。再执行hexo -d操作后，CNAME文件被同步发布，页面刷新域名正常不会出现404问题。\n","categories":["博客"]},{"title":"Git及常用命令","url":"/2023/07/4a9f7c37553f.html","content":"\n\n前言\nGit部分知识以及常用命令\n\n\n更新\n\n\n23.07.11 初始记录\n\n安装\n之前在写 [[Obsidian + Git + Hexo + 图床 = Blog + 个人笔记体系]]这篇笔记的时候有提到过Git的安装。这里就直接把步骤贴过来，具体安装地址(https://git-scm.com/)\n\n\n访问 git 官方地址，下载对应的安装包，进行安装（简单的点击下一步）。\n\n\n安装好之后，鼠标右键可以看到：Git Bash Here，点击后打开了。\n\n\n输入：git --version\n出现版本号说明安装成功。\n\n\n\n\nlinux安装使用以下命令\n\n\nsudo apt-get install git\ngit配置 SSH key\nGit是分布式的代码管理工具，远程的代码管理是基于SSH的，所以要使用远程的Git则需要SSH的配置。一、设置Git的user name和email：\n$ git config --global user.name &quot;kiml&quot;  $ git config --global user.email &quot;1162278448@qq.com&quot;\n二、生成SSH密钥内链：[[Obsidian + Git + Hexo + 图床 = Blog + 个人笔记体系#git配置 SSH key]]\n外链：[Obsidian + Git + Hexo + 图床 = Blog + 个人笔记体系](https://kiml.site/2023/02/6870bf8bd223.html#git配置 SSH key)\ngit工具\nGitHub Desktop\n\n平时更多使用IntelliJ IDEA自带的git工具，偶然发现这个工具，近期打算使用官方文档：[https://docs.github.com/zh/desktop/installing-and-configuring-github-desktop/overview/getting-started-with-github-desktop]\n\n常用命令\nclone到本地\ngit clone git@gitee.com:kiml_rgb/blog.git\n提交代码\n# 进入项目工程目录cd hello/# 将当前修改的文件添加到暂存区git add .# 提交代码git commit -m &quot;first commit&quot;\n推送代码\ngit push\n拉取代码\ngit pull\n创建并提交分支\n# 切换并从当前分支创建一个dev分支git checkout -b dev# 将新创建的dev分支推送到远程仓库git push origin dev\n其他常用命令\n# 切换到dev分支git checkout dev# 查看本地仓库文件状况git status# 查看本地所有分支git branch# 查看提交记录git log","categories":["环境搭建"],"tags":["Git"]},{"title":"IntelliJ IDEA常用设置","url":"/2023/07/82fdef6c011a.html","content":"\n\n前言\nIntelliJ IDEA常用设置\n\n\n更新\n\n\n23.07.02 初始记录23.07.09 基本设置（初始）23.07.16 基本设置完成 推荐插件（初始）23.08.28 三个插件的添加\n\n基本设置\n基本风格及UI字体大小\n\n设置打开IDEA不直接打开项目\n\n这样默认打开IDEA时就是如下画面：\n点击Customize里的All settings，就可以为所有新项目设置配置。\n设置项目文件编码格式（很重要）\n建议将所有都设置成UTF-8格式\n\n设置代码提示的匹配格式\n\n设置新建类文件的注释模板\n/** * @author $&#123;USER&#125; * @date: $&#123;DATE&#125; $&#123;TIME&#125; * @description:*/\n\n设置多个类同时打开并不重叠隐藏\n\n设置maven配置\n\n设置SQL自动补全\n\n\n启用IDEA的database插件\n\n\n针对项目进行SQL Dialects配置\n\n\n基本设置导出\n为了更方便的迁移IDEA，可以将基本设置导出。\n\n推荐插件\nLombok\n\n通过注解不再需要编写getter、setter、equals等方法，可以在编译时自动生成，开发时常用的插件。IDEA在目前使用的版本中已经内置，SpringBoot 2.1.x之后的版本也在Starter中内置了Lombok依赖。\n\n集成\n在项目的pom.xml文件中可以添加Lombok依赖，SpringBoot 2.1.x版本后无需指定Lombok版本，SpringBoot在spring-boot-dependencies中已经内置。\n&lt;!--lombok依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;\nMyBatisX\n\nMybatisX 是一款基于 IDEA 的快速开发插件，为效率而生。\n\nMaven Helper\n\n可以右键项目快速完成项目maven的各个阶段。\npom.xml文件点击后，显示右边多了Dependency Analyzer的Tab选项，可以查看依赖冲突。同时也可以快速排除冲突的文件。\n\nGit Commit Template\n\n为git的提交提供模板。例子：fix(DAO):用户查询缺少username属性 feat(Controller):用户查询接口开发\n\n参数详解：\n\n\n\n参数\n类型\nshuoming\n\n\n\n\ntype(必须)\n\n用于说明git commit的类别，只允许使用下面的标识。\n\n\n\nfeat\n新功能（feature）\n\n\n\nfix/to\n修复bug，可以是QA发现的BUG，也可以是研发自己发现的BUG。\n\n\n\nfix\n产生diff并自动修复此问题。适合于一次提交直接修复问题\n\n\n\nto\n只产生diff不自动修复此问题。适合于多次提交。最终修复问题提交时使用fix。\n\n\n\ndocs\n文档（documentation）\n\n\n\nstyle\n格式（不影响代码运行的变动）。\n\n\n\nrefactor\n重构（即不是新增功能，也不是修改bug的代码变动）。\n\n\n\nperf\n优化相关，比如提升性能、体验。\n\n\n\ntest\n增加测试。\n\n\n\nchore\n构建过程或辅助工具的变动。\n\n\n\nrevert\n回滚到上一个版本。\n\n\n\nmerge\n代码合并。\n\n\n\nsync\n同步主线或分支的Bug。\n\n\nscope(可选)\n\nscope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。\n\n\nsubject(必须)\n\nsubject是commit目的的简短描述，不超过50个字符\n\n\n\nStatistic\n\n代码统计器\n\n","categories":["环境搭建"],"tags":["IDEA"]},{"title":"装机-软件安装","url":"/2023/11/4640726c232e.html","content":"\n\n前言\n找到工作之后每天就是躺平，好久没有更新技术上的内容了，之前学的好多东西也忘了……甚至md语法都忘了好多（每天CRUD，但是也很消耗精力。必须要不断学习，好痛苦，什么时候能退休😢）趁着618配了一台新电脑，顺便用半个多月的时间用新电脑打游戏。。。正好最近在装软件，整理一下装机要注意的事，以及一些必备软件，便于后面再次装机使用。\n\n\n更新\n\n\n23.06.24 初始记录23.07.02 IDEA常用插件 + 基本设置23.07.09 编程环境Java + MySQL23.07.11 Git23.08.28 Maven\n\n初始装机\n这部分都是照着b站上的视频完成的。总之时间就分两大块，把零件装上去，理线。具体可参照以下视频：B站 赵德柱装机\n系统安装\n系统安装需要准备一个U盘装系统。具体步骤可以参照以下视频：B站 赵德柱装系统安装系统完毕第一件事就是去对应官网安装对应驱动，这个依据配置不同，需要下载的东西也不一样。可以检查以下项目的驱动是否安装，每项都需要到对应的官网去下载对应的驱动包：\n\n\ncpu驱动\n\n\n主板驱动（涉及较多）\n\n\n显卡驱动\n\n\n鼠标驱动（调光需要）\n\n\n键盘驱动（调光需要）\n\n\n软件安装\n常用软件\nOffice全家桶\n这个直接登录原来的微软账户就可以安装了，之前买笔记本有配有家庭版可以直接使用。有的笔记本没有送，这个需要注意原来的不要卸载，不然重新下载比较麻烦（这是个付费软件）。直接去买个激活码就行\nSteam\n装机第一件事\nUU加速器\n用了这么多，最常用的还是这个，加速商店是足够用了，想要加速游戏可以进一步去贴吧下载\nChrome\n插件就不提供了，自己后续需要再搜，最好还是能整个账号，不然每次装机都要重新把收藏夹的导出来有点麻烦。\nSnipaste\n很好用的截屏软件，U盘里带有安装包，直接解压缩，开启后就可以F1截图了\nScreenToGif\n制作Gif的软件，以前下载过但是没有用到的机会\nToDesk\n远程连接工具，不想背电脑回家就带这个\nObsidian\n目前在用的All in One笔记软件，好用但是太繁琐了，一开始大半时间都浪费在插件和布局上面，目前用着还行，希望后面能完全用起来。当个md编辑器还是不错的。部分常用的基本用法如下：内链：Obsidian基本用法外链：\nTypora\n一款 Markdown 编辑器和阅读器。更便捷的浏览工具。\n网盘\n百度网盘\n之前参加活动，容量已经到5T了，但是不充会员完全没法使用，现在就是一个吉祥物的存在，有时候网上购买资源会发网盘链接，还是需要下载一个软件。\n阿里云盘\n需要备用一个\n编程专用\n开发环境\nJava\n目前用的还是1.8版本，在U盘内存了常用的几版JDK。有安装包双击下载就行，下载之后需要配置一下环境变量\nMySQL\n目前使用的是5.7.20版本，官网下载就行。同样也需要配置环境变量。\nRedis\n安装与SpringBoot下的使用方法如下：内链：Spring Data Redis\n外链：Spring Data Redis\nMaven\n一个Java项目管理工具，window需要官网下载可用的.zip包，之后解压到一个没有中文没有空格的路径下，同时也需要配置相应的环境变量。（可能出现IDEA不适配需要降低maven版本，当前IDEA 2020.3.2，可以安装Maven 3.6.3）打开安装目录conf/settings.xml文件，进行以下两项配置。\n\n\n开发工具\nIntelliJ IDEA\n这个不用多说，U盘里存了一个可用的破解版，从大学用到现在了。安装后还需要进行一些常用的设置。具体可以参考以下内链：[[IntelliJ IDEA常用设置]]\n外链：IntelliJ IDEA常用设置\nTabby\n一款终端工具，之前用的一直是FinalShell，后来想转成XSHELL，才知道 XSHELL &amp; XFTP的家庭版是免费的，后来是看博客，知道了一款22年的终端Tabby（不过这么多具体哪个好用确实也是不太了解，换成这个的原因主要是他可以结合远程连接和远程传输两块的内容。也看到把数据库连接，服务器监控，终端都结合在一起的工具，但是数据库工具还是比较习惯用navicat，所以暂时决定是先把终端工具换成Tabby）具体使用步骤参考（后面有时间再整理到自己的笔记里面吧）：(https://www.macrozheng.com/tool/tabby_start.html)\nNavicat\n一款好用的数据库管理工具，提供14天免费试用。但是这种一般都是有破解的，网盘里存了一个（会被杀毒软件杀掉）\nGit\n版本控制工具。（目前使用的博客工具Hexo也是依靠Git部署）具体使用介绍如下内链：[[Git及常用命令]]\n外链：Git及常用命令\n其他\n翻墙\n目前使用的教程是(https://github.com/Alvin9999/new-pac/blob/master/自建v2ray服务器教程.md)\n","categories":["环境搭建"],"tags":["工具"]},{"title":"华为OD","url":"/2024/03/7b994877e0f1.html","content":"\n\n前言\n为块术（不是），其实一直觉得二本毕业去这边也蛮好的，但是一直没有动力刷题。今天去面试，啥也没准备，就看了一天早已忘记的八股文，果然挂了。但是Boss上收到华为OD的Hr的消息（好像是最近突然加了岗位？），总之约了两周后机考（怎么敢的，真的一点都没准备过）\n\n\n更新\n\n\n24.03.28 初始记录-day1刷题记录\n\n刷题记录\n240328（牛客华为机试题库——https://www.nowcoder.com/ta/huawei）\n\n\nHJ1 字符串最后一个单词的长度\n\n\n思路居然是遍历，遇0清空计数，真的没想到。显得我的方法很笨。\n\n\nHJ2 计算某字符出现次数\n\n\nHJ3 明明的随机数\n\n\n语法糖就语法糖吧，我放弃了\n\n\nHJ4 字符串分隔\n\n\nHJ5 进制转换\n\n\n240330（牛客华为机试题库——https://www.nowcoder.com/ta/huawei）\n\n\nHJ6 质数因子\n\n\n240402（牛客华为机试题库——https://www.nowcoder.com/ta/huawei）\n\n\nHJ7 取近似值\n\n\n用了API\n\n\nHJ8 取近似值\n\n\nHJ9 提取不重复的整数\n\n\nHJ10 字符个数统计\n\n\nHJ11 数字颠倒\n\n\n240404（牛客华为机试题库——https://www.nowcoder.com/ta/huawei）\n\n\nHJ12 字符串反转\n\n\nHJ13 句子逆序\n\n\n// 忘了这个APIString.join(&quot; &quot;, strings)\n\n\nHJ14 字符串排序\n\n\nHJ15 求int型正整数在内存中存储时1的个数\n\n\n华为OD机试真题-寻找身高相近的小朋友（C卷）\n\n\n240406（华为OD机试2024年最新题库-C卷）\n\n\n华为OD机试真题-围棋的气（C卷）\n\n\n华为OD机试真题-用连续自然数之和来表达整数（C卷）\n\n\n本题用滑动窗口进行求解。之前都不会这个。标记一下需要二刷。\n\n\n华为OD机试真题-开源项目热榜（C卷）\n\n\n华为OD机试真题-API集群负载统计（C卷）\n\n\n华为OD机试真题-整数对最小和（C卷）\n\n\n华为OD机试真题-素数之积（C卷）\n\n\n华为OD机试真题-CPU算力分配（C卷）\n\n\n华为OD机试真题-最大坐标值（C卷）\n\n\n华为OD机试真题-寻找最富裕的小家庭（C卷）\n\n\n240407（华为OD机试2024年最新题库-C卷）\n\n\n华为OD机试真题-分月饼（C卷）\n\n\n不会，没有思路，先跳过。\n240408（华为OD机试2024年最新题库-C卷）\n\n\n华为OD机试真题-找城市（C卷）\n\n\n没有思路，200分题打算周末再刷了，先看看有没有类似的题解。\n\n\n华为OD机试真题-查找接口成功率最优时间段（C卷）\n\n\n严重超时，不知道是不是因为一边上班一边做的原因思路都是乱的\n240409（华为OD机试2024年最新题库-C卷）\n\n\n华为OD机试真题-分割均衡字符串（C卷）\n\n\n华为OD机试真题-虚拟游戏理财（C卷）\n\n\n华为OD机试真题-靠谱的车（C卷）\n\n\n华为OD机试真题-执行时长（C卷）\n\n\n华为OD机试真题-万能字符单词拼写（C卷）\n\n\n240410（华为OD机试2024年最新题库-C卷）\n\n\n华为OD机试真题-来自异国的客人（C卷）\n\n\n华为OD机试真题-求最多可以派出多少支团队（C卷）\n\n\n华为OD机试真题-最长子字符串的长度（C卷）\n\n\n华为OD机试真题-机场航班调度程序（C卷）\n\n\n华为OD机试真题-数的分解（C卷）\n\n\n240411（华为OD机试2024年最新题库-C卷）\n\n\n华为OD机试真题-智能成绩表（C卷）\n\n\n华为OD机试真题-提取字符串中的最长数学表达式并计算（C卷）\n\n\n不希望考到这题。怎么还有正则正则实在不太熟，这题硬记((+-)?(\\\\d+[+-*])*\\\\d)判断出最长正则式子之后的思路为：1、记录初始加减号2、如果是+，记录数乘1；如果是-，记录数乘-1；如果是乘，获取前一个数并乘并记录乘积\n机试（240417）\n没过。。。293但是要300分。算了。本来也没报多大希望。还是多刷点题再投简历。现阶段，辞不辞职都无所谓了（最好明天就把我裁了！！！大晚上10点群里@人是不是有病啊，又不是bug？？？？谁tm理你？？？！！！）\n1年多的Java现在真的狗都嫌，打算实在没有去处，6个月之后再考一次，反正本次刷题感觉还行，不是特别难。\n后续\n打算先刷点算法+八股了。实在不行啃点存款，反正还没辞职。。。\n","categories":["面试"],"tags":["面试","Java"]},{"title":"Spring Data Redis","url":"/2023/08/a52deee36df0.html","content":"\n\n前言\nSpring Data Redis 是Spring 框架提供的用于操作Redis的方式。涵盖Redis的安装、Spring Cache结合Redis的使用、Redis连接池的使用和RedisTemplate的使用等内容。\n\n\n参考文章\nSpring Data Redis 最佳实践！\n\n\n更新\n\n\n23.08.29 初始记录\n\nRedis安装\nLinux\n\n\n下载Redis5.0的Docker镜像\n\n\ndocker pull redis:5.0\n\n\n使用Docker命令启动Redis容器\n\n\ndocker run -p 6379:6379 --name redis \\-v /mydata/redis/data:/data \\-d redis:5.0 redis-server --appendonly yes\nWindows\n\n\n下载Windows版本的Redis\n\n\n\n下载后直接解压\n\n\n在当前地址栏输入cmd命令，执行对应的redis启动命令\n\n\n# 注册服务redis-server --service-install redis.windows.conf# 启动服务redis-server --service-start# 停止服务redis-server --service-stop# 删除服务redis-server --service-uninstall\nSpring Cache 操作Redis\nSpring Cache 简介\n\n当Spring Boot 结合Redis来作为缓存使用时，最简单的方式就是使用Spring Cache了，使用它我们无需知道Spring中对Redis的各种操作，仅仅通过它提供的@Cacheable 、@CachePut 、@CacheEvict 、@EnableCaching等注解就可以实现缓存功能。\n\n常用注解\n@EnableCaching\n开启缓存功能，一般放在启动类上。\n@Cacheable\n使用该注解的方法当缓存存在时，会从缓存中获取数据而不执行方法，当缓存不存在时，会执行方法并把返回结果存入缓存中。一般使用在查询方法上，可以设置如下属性：\n\n\nvalue：缓存名称（必填），指定缓存的命名空间；\n\n\nkey：用于设置在命名空间中的缓存key值，可以使用SpEL表达式定义；\n\n\nunless：条件符合则不缓存；\n\n\ncondition：条件符合则缓存。\n\n\n@CachePut\n使用该注解的方法每次执行时都会把返回结果存入缓存中。一般使用在新增方法上，可以设置如下属性：\n\n\nvalue：缓存名称（必填），指定缓存的命名空间；\n\n\nkey：用于设置在命名空间中的缓存key值，可以使用SpEL表达式定义；\n\n\nunless：条件符合则不缓存；\n\n\ncondition：条件符合则缓存。\n\n\n@CacheEvict\n使用该注解的方法执行时会清空指定的缓存。一般使用在更新或删除方法上，可以设置如下属性：\n\n\nvalue：缓存名称（必填），指定缓存的命名空间；\n\n\nkey：用于设置在命名空间中的缓存key值，可以使用SpEL表达式定义；\n\n\ncondition：条件符合则缓存。\n\n\n使用步骤\n基础步骤\n\n\n在pom.xml中添加项目依赖：\n\n\n&lt;!--redis依赖配置--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n修改配置文件application.yml，添加Redis的连接配置\n\n\nspring:  redis:    host: 192.168.6.139 # Redis服务器地址    database: 0 # Redis数据库索引（默认为0）    port: 6379 # Redis服务器连接端口    password: # Redis服务器连接密码（默认为空）    timeout: 1000ms # 连接超时时间\n\n\n在启动类上添加@EnableCaching注解启动缓存功能\n\n\n@EnableCaching@SpringBootApplicationpublic class Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Application.class, args);    &#125;&#125;\n\n\n类中实现缓存功能\n\n\n/** * PmsBrandService实现类 * Created by macro on 2019/4/19. */@Servicepublic class PmsBrandServiceImpl implements PmsBrandService &#123;    @Autowired    private PmsBrandMapper brandMapper;    @CacheEvict(value = RedisConfig.REDIS_KEY_DATABASE, key = &quot;&#x27;pms:brand:&#x27;+#id&quot;)    @Override    public int update(Long id, PmsBrand brand) &#123;        brand.setId(id);        return brandMapper.updateByPrimaryKeySelective(brand);    &#125;    @CacheEvict(value = RedisConfig.REDIS_KEY_DATABASE, key = &quot;&#x27;pms:brand:&#x27;+#id&quot;)    @Override    public int delete(Long id) &#123;        return brandMapper.deleteByPrimaryKey(id);    &#125;    @Cacheable(value = RedisConfig.REDIS_KEY_DATABASE, key = &quot;&#x27;pms:brand:&#x27;+#id&quot;, unless = &quot;#result==null&quot;)    @Override    public PmsBrand getItem(Long id) &#123;        return brandMapper.selectByPrimaryKey(id);    &#125;&#125;\n存储JSON格式数据\n\n给RedisTemplate设置JSON格式的序列化器，并通过配置RedisCacheConfiguration设置超时时间来实现以上需求，此时还需要去除启动类上的@EnableCaching注解，具体配置类RedisConfig代码如下\n\n/** * Redis配置类 * Created by macro on 2020/3/2. */@EnableCaching@Configurationpublic class RedisConfig extends CachingConfigurerSupport &#123;    /**     * redis数据库自定义key     */    public  static final String REDIS_KEY_DATABASE=&quot;mall&quot;;    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;        RedisSerializer&lt;Object&gt; serializer = redisSerializer();        RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();        redisTemplate.setConnectionFactory(redisConnectionFactory);        redisTemplate.setKeySerializer(new StringRedisSerializer());        redisTemplate.setValueSerializer(serializer);        redisTemplate.setHashKeySerializer(new StringRedisSerializer());        redisTemplate.setHashValueSerializer(serializer);        redisTemplate.afterPropertiesSet();        return redisTemplate;    &#125;    @Bean    public RedisSerializer&lt;Object&gt; redisSerializer() &#123;        //创建JSON序列化器        Jackson2JsonRedisSerializer&lt;Object&gt; serializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class);        ObjectMapper objectMapper = new ObjectMapper();        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        serializer.setObjectMapper(objectMapper);        return serializer;    &#125;    @Bean    public RedisCacheManager redisCacheManager(RedisConnectionFactory redisConnectionFactory) &#123;        RedisCacheWriter redisCacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory);        //设置Redis缓存有效期为1天        RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig()                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer())).entryTtl(Duration.ofDays(1));        return new RedisCacheManager(redisCacheWriter, redisCacheConfiguration);    &#125;&#125;\n使用Redis连接池\n\nSpringBoot 1.5.x版本Redis客户端默认是Jedis实现的，SpringBoot 2.x版本中默认客户端是用Lettuce实现的，我们先来了解下Jedis和Lettuce客户端。\n\nJedis vs Lettuce\nJedis在实现上是直连Redis服务，多线程环境下非线程安全，除非使用连接池，为每个 RedisConnection 实例增加物理连接。\nLettuce是一种可伸缩，线程安全，完全非阻塞的Redis客户端，多个线程可以共享一个RedisConnection，它利用Netty NIO框架来高效地管理多个连接，从而提供了异步和同步数据访问方式，用于构建非阻塞的反应性应用程序。\n使用步骤\n\n\n修改application.yml添加Lettuce连接池配置，用于配置线程数量和阻塞等待时间\n\n\nspring:  redis:    lettuce:      pool:        max-active: 8 # 连接池最大连接数        max-idle: 8 # 连接池最大空闲连接数        min-idle: 0 # 连接池最小空闲连接数        max-wait: -1ms # 连接池最大阻塞等待时间，负值表示没有限制\n\n\n由于SpringBoot 2.x中默认并没有使用Redis连接池，所以需要在pom.xml中添加commons-pool2的依赖\n\n\n&lt;dependency&gt;    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n不添加依赖则报错\n\n\nCaused by: java.lang.NoClassDefFoundError: org/apache/commons/pool2/impl/GenericObjectPoolConfig\tat org.springframework.data.redis.connection.lettuce.LettucePoolingClientConfiguration$LettucePoolingClientConfiguYrRUIQWOPrationBuilder.&lt;init&gt;(LettucePoolingClientConfiguration.java:84) ~[spring-data-redis-2.1.5.RELEASE.jar:2.1.5.RELEASE]\tat org.springframework.data.redis.connection.lettuce.LettucePoolingClientConfiguration.builder(LettucePoolingClientConfiguration.java:48) ~[spring-data-redis-2.1.5.RELEASE.jar:2.1.5.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration$PoolBuilderFactory.createBuilder(LettuceConnectionConfiguration.java:149) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration.createBuilder(LettuceConnectionConfiguration.java:107) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration.getLettuceClientConfiguration(LettuceConnectionConfiguration.java:93) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration.redisConnectionFactory(LettuceConnectionConfiguration.java:74) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration$$EnhancerBySpringCGLIB$$5caa7e47.CGLIB$redisConnectionFactory$0(&lt;generated&gt;) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration$$EnhancerBySpringCGLIB$$5caa7e47$$FastClassBySpringCGLIB$$b8ae2813.invoke(&lt;generated&gt;) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:244) ~[spring-core-5.1.5.RELEASE.jar:5.1.5.RELEASE]\tat org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:363) ~[spring-context-5.1.5.RELEASE.jar:5.1.5.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration$$EnhancerBySpringCGLIB$$5caa7e47.redisConnectionFactory(&lt;generated&gt;) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_91]\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_91]\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_91]\tat java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_91]\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\t... 111 common frames omitted\n自由操作Redis\n\n使用RedisTemplate自由缓存方法中产生的中间值\n\nRedisService\n/** * redis操作Service * Created by macro on 2020/3/3. */public interface RedisService &#123;    /**     * 保存属性     */    void set(String key, Object value, long time);    /**     * 保存属性     */    void set(String key, Object value);    /**     * 获取属性     */    Object get(String key);    /**     * 删除属性     */    Boolean del(String key);    /**     * 批量删除属性     */    Long del(List&lt;String&gt; keys);    /**     * 设置过期时间     */    Boolean expire(String key, long time);    /**     * 获取过期时间     */    Long getExpire(String key);    /**     * 判断是否有该属性     */    Boolean hasKey(String key);    /**     * 按delta递增     */    Long incr(String key, long delta);    /**     * 按delta递减     */    Long decr(String key, long delta);    /**     * 获取Hash结构中的属性     */    Object hGet(String key, String hashKey);    /**     * 向Hash结构中放入一个属性     */    Boolean hSet(String key, String hashKey, Object value, long time);    /**     * 向Hash结构中放入一个属性     */    void hSet(String key, String hashKey, Object value);    /**     * 直接获取整个Hash结构     */    Map&lt;Object, Object&gt; hGetAll(String key);    /**     * 直接设置整个Hash结构     */    Boolean hSetAll(String key, Map&lt;String, Object&gt; map, long time);    /**     * 直接设置整个Hash结构     */    void hSetAll(String key, Map&lt;String, Object&gt; map);    /**     * 删除Hash结构中的属性     */    void hDel(String key, Object... hashKey);    /**     * 判断Hash结构中是否有该属性     */    Boolean hHasKey(String key, String hashKey);    /**     * Hash结构中属性递增     */    Long hIncr(String key, String hashKey, Long delta);    /**     * Hash结构中属性递减     */    Long hDecr(String key, String hashKey, Long delta);    /**     * 获取Set结构     */    Set&lt;Object&gt; sMembers(String key);    /**     * 向Set结构中添加属性     */    Long sAdd(String key, Object... values);    /**     * 向Set结构中添加属性     */    Long sAdd(String key, long time, Object... values);    /**     * 是否为Set中的属性     */    Boolean sIsMember(String key, Object value);    /**     * 获取Set结构的长度     */    Long sSize(String key);    /**     * 删除Set结构中的属性     */    Long sRemove(String key, Object... values);    /**     * 获取List结构中的属性     */    List&lt;Object&gt; lRange(String key, long start, long end);    /**     * 获取List结构的长度     */    Long lSize(String key);    /**     * 根据索引获取List中的属性     */    Object lIndex(String key, long index);    /**     * 向List结构中添加属性     */    Long lPush(String key, Object value);    /**     * 向List结构中添加属性     */    Long lPush(String key, Object value, long time);    /**     * 向List结构中批量添加属性     */    Long lPushAll(String key, Object... values);    /**     * 向List结构中批量添加属性     */    Long lPushAll(String key, Long time, Object... values);    /**     * 从List结构中移除属性     */    Long lRemove(String key, long count, Object value);&#125;\nRedisServiceImpl\n/** * redis操作实现类 * Created by macro on 2020/3/3. */@Servicepublic class RedisServiceImpl implements RedisService &#123;    @Autowired    private RedisTemplate&lt;String, Object&gt; redisTemplate;    @Override    public void set(String key, Object value, long time) &#123;        redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);    &#125;    @Override    public void set(String key, Object value) &#123;        redisTemplate.opsForValue().set(key, value);    &#125;    @Override    public Object get(String key) &#123;        return redisTemplate.opsForValue().get(key);    &#125;    @Override    public Boolean del(String key) &#123;        return redisTemplate.delete(key);    &#125;    @Override    public Long del(List&lt;String&gt; keys) &#123;        return redisTemplate.delete(keys);    &#125;    @Override    public Boolean expire(String key, long time) &#123;        return redisTemplate.expire(key, time, TimeUnit.SECONDS);    &#125;    @Override    public Long getExpire(String key) &#123;        return redisTemplate.getExpire(key, TimeUnit.SECONDS);    &#125;    @Override    public Boolean hasKey(String key) &#123;        return redisTemplate.hasKey(key);    &#125;    @Override    public Long incr(String key, long delta) &#123;        return redisTemplate.opsForValue().increment(key, delta);    &#125;    @Override    public Long decr(String key, long delta) &#123;        return redisTemplate.opsForValue().increment(key, -delta);    &#125;    @Override    public Object hGet(String key, String hashKey) &#123;        return redisTemplate.opsForHash().get(key, hashKey);    &#125;    @Override    public Boolean hSet(String key, String hashKey, Object value, long time) &#123;        redisTemplate.opsForHash().put(key, hashKey, value);        return expire(key, time);    &#125;    @Override    public void hSet(String key, String hashKey, Object value) &#123;        redisTemplate.opsForHash().put(key, hashKey, value);    &#125;    @Override    public Map&lt;Object, Object&gt; hGetAll(String key) &#123;        return redisTemplate.opsForHash().entries(key);    &#125;    @Override    public Boolean hSetAll(String key, Map&lt;String, Object&gt; map, long time) &#123;        redisTemplate.opsForHash().putAll(key, map);        return expire(key, time);    &#125;    @Override    public void hSetAll(String key, Map&lt;String, Object&gt; map) &#123;        redisTemplate.opsForHash().putAll(key, map);    &#125;    @Override    public void hDel(String key, Object... hashKey) &#123;        redisTemplate.opsForHash().delete(key, hashKey);    &#125;    @Override    public Boolean hHasKey(String key, String hashKey) &#123;        return redisTemplate.opsForHash().hasKey(key, hashKey);    &#125;    @Override    public Long hIncr(String key, String hashKey, Long delta) &#123;        return redisTemplate.opsForHash().increment(key, hashKey, delta);    &#125;    @Override    public Long hDecr(String key, String hashKey, Long delta) &#123;        return redisTemplate.opsForHash().increment(key, hashKey, -delta);    &#125;    @Override    public Set&lt;Object&gt; sMembers(String key) &#123;        return redisTemplate.opsForSet().members(key);    &#125;    @Override    public Long sAdd(String key, Object... values) &#123;        return redisTemplate.opsForSet().add(key, values);    &#125;    @Override    public Long sAdd(String key, long time, Object... values) &#123;        Long count = redisTemplate.opsForSet().add(key, values);        expire(key, time);        return count;    &#125;    @Override    public Boolean sIsMember(String key, Object value) &#123;        return redisTemplate.opsForSet().isMember(key, value);    &#125;    @Override    public Long sSize(String key) &#123;        return redisTemplate.opsForSet().size(key);    &#125;    @Override    public Long sRemove(String key, Object... values) &#123;        return redisTemplate.opsForSet().remove(key, values);    &#125;    @Override    public List&lt;Object&gt; lRange(String key, long start, long end) &#123;        return redisTemplate.opsForList().range(key, start, end);    &#125;    @Override    public Long lSize(String key) &#123;        return redisTemplate.opsForList().size(key);    &#125;    @Override    public Object lIndex(String key, long index) &#123;        return redisTemplate.opsForList().index(key, index);    &#125;    @Override    public Long lPush(String key, Object value) &#123;        return redisTemplate.opsForList().rightPush(key, value);    &#125;    @Override    public Long lPush(String key, Object value, long time) &#123;        Long index = redisTemplate.opsForList().rightPush(key, value);        expire(key, time);        return index;    &#125;    @Override    public Long lPushAll(String key, Object... values) &#123;        return redisTemplate.opsForList().rightPushAll(key, values);    &#125;    @Override    public Long lPushAll(String key, Long time, Object... values) &#123;        Long count = redisTemplate.opsForList().rightPushAll(key, values);        expire(key, time);        return count;    &#125;    @Override    public Long lRemove(String key, long count, Object value) &#123;        return redisTemplate.opsForList().remove(key, count, value);    &#125;&#125;\nRedisController\n\n简单测试在Controller中进行操作\n\n/** * Redis测试Controller * Created by macro on 2020/3/3. */@Api(tags = &quot;RedisController&quot;, description = &quot;Redis测试&quot;)@Controller@RequestMapping(&quot;/redis&quot;)public class RedisController &#123;    @Autowired    private RedisService redisService;    @Autowired    private PmsBrandService brandService;    @ApiOperation(&quot;测试简单缓存&quot;)    @RequestMapping(value = &quot;/simpleTest&quot;, method = RequestMethod.GET)    @ResponseBody    public CommonResult&lt;PmsBrand&gt; simpleTest() &#123;        List&lt;PmsBrand&gt; brandList = brandService.list(1, 5);        PmsBrand brand = brandList.get(0);        String key = &quot;redis:simple:&quot; + brand.getId();        redisService.set(key, brand);        PmsBrand cacheBrand = (PmsBrand) redisService.get(key);        return CommonResult.success(cacheBrand);    &#125;    @ApiOperation(&quot;测试Hash结构的缓存&quot;)    @RequestMapping(value = &quot;/hashTest&quot;, method = RequestMethod.GET)    @ResponseBody    public CommonResult&lt;PmsBrand&gt; hashTest() &#123;        List&lt;PmsBrand&gt; brandList = brandService.list(1, 5);        PmsBrand brand = brandList.get(0);        String key = &quot;redis:hash:&quot; + brand.getId();        Map&lt;String, Object&gt; value = BeanUtil.beanToMap(brand);        redisService.hSetAll(key, value);        Map&lt;Object, Object&gt; cacheValue = redisService.hGetAll(key);        PmsBrand cacheBrand = BeanUtil.mapToBean(cacheValue, PmsBrand.class, true);        return CommonResult.success(cacheBrand);    &#125;    @ApiOperation(&quot;测试Set结构的缓存&quot;)    @RequestMapping(value = &quot;/setTest&quot;, method = RequestMethod.GET)    @ResponseBody    public CommonResult&lt;Set&lt;Object&gt;&gt; setTest() &#123;        List&lt;PmsBrand&gt; brandList = brandService.list(1, 5);        String key = &quot;redis:set:all&quot;;        redisService.sAdd(key, (Object[]) ArrayUtil.toArray(brandList, PmsBrand.class));        redisService.sRemove(key, brandList.get(0));        Set&lt;Object&gt; cachedBrandList = redisService.sMembers(key);        return CommonResult.success(cachedBrandList);    &#125;    @ApiOperation(&quot;测试List结构的缓存&quot;)    @RequestMapping(value = &quot;/listTest&quot;, method = RequestMethod.GET)    @ResponseBody    public CommonResult&lt;List&lt;Object&gt;&gt; listTest() &#123;        List&lt;PmsBrand&gt; brandList = brandService.list(1, 5);        String key = &quot;redis:list:all&quot;;        redisService.lPushAll(key, (Object[]) ArrayUtil.toArray(brandList, PmsBrand.class));        redisService.lRemove(key, 1, brandList.get(0));        List&lt;Object&gt; cachedBrandList = redisService.lRange(key, 0, 3);        return CommonResult.success(cachedBrandList);    &#125;&#125;","categories":["后端项目","准备工作"],"tags":["Redis","Spring"]},{"title":"MybatisPlus多表联查分页，Total计数异常","url":"/2024/04/d2f8111b68d4.html","content":"\n\n更新\n\n\n24.04.19 初始记录\n\n问题\n使用MP的分表联查，出现了查询出10条数据，但是Total数量显示4的问题。一开始以为是SQL书写错误，但是看了同样一张表的另一个SQL，只是加上了GROUP BY，就可以显示正确的Total数。\nDEBUG\n控制台输出SQL语句，发现count()语句的记录只到了left join前，所以计数异常。\n解决\n使用page方法时：加上以下语句\n// 需要手动把sql的优化关闭。不然计数的时候只会查主表的记录数page.setOptimizeCountSql(false);  \n这里在源码中默认是开启的\n如果不关闭将会导致计算总记录数据的时候，sql语句会丢弃后面的子查询，造成记录数结果不正确。\n","categories":["bug记录","2024"],"tags":["Java","MybatisPlus","BUG"]},{"title":"面试-数据结构和算法","url":"/2024/04/17423c76a0de.html","content":"\n\n前言\n根据刷题记录，整理各个类型的特点\n\n\n更新\n\n\n24.04.22 初始记录 数组的总结\n\n数据结构\n数组\n基础理论\n1、数组是存放在连续内存空间上的相同类型数据的集合。\n\n\n数组下标从0开始\n\n\n数组的内存空间地址连续\n\n\n2、因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。\n3、数组的元素是不能删的，只能覆盖。\n4、二维数组在内存的空间地址不连续\n经典题目\n二分法\n需要遵循循环不变量原则。这里的循环不变量原则在二分法中的表现就是，循环过程中左闭右开，这个规则是不变的。\n双指针法\n快慢指针法：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。\n双向指针法：一个指针从左向右一个指针从右向左。从左向右的找等于目标值的位置，从右向左找不等于目标的位置，每次找到一个用不等于覆盖等于。（就是自己第一次题解时的做法）\n滑动窗口\n动态更新窗口的大小，找到最优解。\n滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。\n模拟行为\n目前遇到的题型是螺旋矩阵。这类题目只要模拟数组需要执行的操作就行，需要注意边界值，遵循循环不变量原则。\n链表\n","categories":["面试"],"tags":["面试","数组"]},{"title":"代码随想录算法训练营第二天-977有序数组的平方、209长度最小的子数组、59螺旋矩阵II","url":"/2024/04/2059cc99cc5f.html","content":"\n\n前言\n状态：977、209通过。59没有思路\n\n\n更新\n\n\n24.04.18 初始记录24.04.21 补充螺旋矩阵的题解\n\n初步题解\n977有序数组的平方\n题目链接：https://leetcode.cn/problems/squares-of-a-sorted-array/\npublic class LE977 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          String s = scanner.nextLine();          int[] nums = Arrays.stream(s.substring(1, s.length() - 1).split(&quot;,&quot;))                  .mapToInt(Integer::parseInt)                  .toArray();          System.out.println(Arrays.toString(sortedSquares(nums)));      &#125;  \t// 关键在于非递增顺序，获取平方数，组成新的非递增序列\t// 新数组的最大数一定来自于旧数组的两端。平方的大小一定从两边向中间递减\t// 用双指针，依次将最大值添加到新数组，并向内移动    public static int[] sortedSquares(int[] nums) &#123;          int i = 0;          int j = nums.length - 1;          int k = nums.length - 1;          int[] ints = new int[nums.length];            while (i &lt;= j) &#123;              int i2 = nums[i] * nums[i];              int j2 = nums[j] * nums[j];              ints[k] = Math.max(i2, j2);              k--;              if (i2 &gt;= j2) &#123;                  i++;              &#125; else &#123;                  j--;              &#125;          &#125;        return ints;      &#125;  &#125;\n209长度最小的子数组\n题目链接：https://leetcode.cn/problems/minimum-size-subarray-sum/\npublic class LE209 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          int target = Integer.parseInt(scanner.nextLine());          String s = scanner.nextLine();          int[] nums = Arrays.stream(s.substring(1, s.length() - 1).split(&quot;,&quot;))                  .mapToInt(Integer::parseInt)                  .toArray();          System.out.println(minSubArrayLen(target, nums));      &#125;  \t// 看题就知道是滑动窗口，前几天刚好做过    public static int minSubArrayLen(int target, int[] nums) &#123;          int min = 0;          for (int i = 0, j = 0; i &lt; nums.length &amp;&amp; j &lt; nums.length; ) &#123;              int subArraySum = getSum(nums, i, j);              if (target == subArraySum) &#123;                  min = Math.min(min, j - i + 1);                  i++;                  j = i;                  if (min == 1) &#123;                      break;                  &#125;              &#125; else if (target &lt; subArraySum) &#123;                  i++;                  j = i;              &#125; else &#123;                  j++;              &#125;          &#125;          return min;      &#125;        private static int getSum(int[] nums, int i, int j) &#123;          int sum = 0;          for (int k = i; k &lt;= j; k++) &#123;              sum += nums[k];          &#125;          return sum;      &#125;  &#125;\n59螺旋矩阵II\n题目链接：https://leetcode.cn/problems/spiral-matrix-ii/\n// 看了题目没有什么算法上的思路，打算直接看题解\n看讲解\n977有序数组的平方\n文章讲解：https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html\n视频讲解： https://www.bilibili.com/video/BV1QB4y1D7ep\n// 这里的题解和我的想法差不多，就不多写了\n209长度最小的子数组\n文章讲解：https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html\n视频讲解：https://www.bilibili.com/video/BV1tZ4y1q7XE\n还有一个进阶的解法，打算明天再看看，不能再熬夜了。\n// 这里的题解和我的想法差不多，就不多写了// 进阶部分等之后有时间了补充\n59螺旋矩阵II\n文章讲解：https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html\n视频讲解：https://www.bilibili.com/video/BV1SL4y1N7mV/\n// 大致看了文章讲解，就是把四条边按规律读出。// 没有看答案，按讲解写了一个版本，但是很奇怪，输出的xy和我想象中的不一样// 打了断点才发现，二维数组的表现和坐标不一样。public class LE59 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          int n = Integer.parseInt(scanner.nextLine());          System.out.println(Arrays.deepToString(generateMatrix(n)));      &#125;        public static int[][] generateMatrix(int n) &#123;          int[][] ints = new int[n][n];          int startX = 0;          int startY = 0;          int k = 1;          int loop = 1;          int i, j;          // 这边需要加上边界条件        while (k &lt;= n * n &amp;&amp; loop &lt;= n / 2) &#123;              for (i = startX; i &lt; n - loop; i++) &#123;                  ints[i][startY] = k++;              &#125;              for (j = startY; j &lt; n - loop; j++) &#123;                  ints[i][j] = k++;              &#125;              for (; i &gt; startX; i--) &#123;                  ints[i][j] = k++;              &#125;              for (; j &gt; startY ; j--) &#123;                  ints[i][j] = k++;              &#125;              startX++;              startY++;              loop++;          &#125;          // 奇数矩阵需要特殊处理        if (n % 2 == 1) &#123;              ints[startX][startY] = k;          &#125;          return ints;      &#125;  &#125;// 重新按二维数组的写法写了一遍。这个需要加到总结中// 二位数组中：j才是横坐标，i是纵坐标public static int[][] generateMatrix(int n) &#123;      int[][] ints = new int[n][n];      int startX = 0;      int startY = 0;      int k = 1;      int loop = 1;      int i, j;        while (k &lt;= n * n &amp;&amp; loop &lt;= n / 2) &#123;          for (j = startY; j &lt; n - loop; j++) &#123;              ints[startX][j] = k++;          &#125;          for (i = startX; i &lt; n - loop; i++) &#123;              ints[i][j] = k++;          &#125;          for (; j &gt; startY ; j--) &#123;              ints[i][j] = k++;          &#125;          for (; i &gt; startX; i--) &#123;              ints[i][j] = k++;          &#125;          startX++;          startY++;          loop++;      &#125;      if (n % 2 == 1) &#123;          ints[startX][startY] = k;      &#125;      return ints;  &#125;\n","categories":["面试","代码随想录"],"tags":["数组","双指针","滑动窗口","螺旋数组"]},{"title":"代码随想录算法训练营第一天-704二分查找、27移除元素","url":"/2024/04/941022ae3938.html","content":"\n\n前言\n状态：可以通过\n\n\n更新\n\n\n24.04.17 初始记录\n\n初步题解\n704二分查找\n题目链接：https://leetcode.cn/problems/binary-search/\npublic class LE704 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          int[] nums = Arrays.stream(scanner.nextLine().split(&quot;,&quot;))                  .mapToInt(Integer::parseInt)                  .toArray();          int target = Integer.parseInt(scanner.nextLine());          System.out.println(search(nums, target));      &#125;        public static int search(int[] nums, int target) &#123;          for (int i = 0, j = nums.length - 1; i &lt;= j; ) &#123;              int k = (i + j) / 2;              if (nums[k] == target) &#123;                  return k;              &#125;              if (nums[k] &gt; target) &#123;                  j = k - 1;              &#125; else &#123;                  i = k + 1;              &#125;          &#125;            return -1;      &#125;  &#125;\n27移除元素\n题目链接：https://leetcode.cn/problems/remove-element/\npublic class LE27 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          int[] nums = Arrays.stream(scanner.nextLine().split(&quot;,&quot;))                  .mapToInt(Integer::parseInt)                  .toArray();          int val = Integer.parseInt(scanner.nextLine());          System.out.println(removeElement(nums, val));      &#125;        public static int removeElement(int[] nums, int val) &#123;          int i, j;          for (i = 0, j = nums.length - 1; i &lt;= j ; ) &#123;              // 第一次修改 -&gt; if改为while              // 第三次修改 -&gt; 加上j的边界值限制, 不然会数组越界              while (j &gt;= 0 &amp;&amp; nums[j] == val) &#123;                  j--;              &#125;              while (i &lt;= nums.length - 1 &amp;&amp; nums[i] != val) &#123;                  i++;              &#125;              // 第二次修改 -&gt; 加上i &lt; j的判断, 否则最后一次交换会把数组换乱              if (i &lt; j) &#123;                  int temp = nums[j];                  nums[j] = nums[i];                  nums[i] = temp;              &#125;          &#125;          return i;      &#125;  &#125;\n看讲解\n704二分查找\n文章讲解：https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html\n视频讲解：https://www.bilibili.com/video/BV1fA4y1o715\npublic static int search(int[] nums, int target) &#123;      for (int i = 0, j = nums.length - 1; i &lt;= j; ) &#123; \t    // 这里需要写成这种方式防止整数溢出\t    // 或者也可以写成 int k = i + ((j - i) &gt;&gt; 1);\t    int k = i + (j - i) / 2;        // int k = (i + j) / 2;          if (nums[k] == target) &#123;              return k;          &#125;          if (nums[k] &gt; target) &#123;              j = k - 1;          &#125; else &#123;              i = k + 1;          &#125;      &#125;      return -1;  &#125;\n27移除元素\n文章讲解：https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html\n视频讲解：https://www.bilibili.com/video/BV12A4y1Z7LP\n其实。。一开始看题目我没有反应过来暴力解法是什么。第一时间当然是想到iterator().remove()，但是不行。老实说，那个题目里的O(1)额外空间我也不知道怎么算的。暴力解法是双层循环，删除之后的所有都前移。双指针和我想的也完全不一样，我也不知道我写的这个叫什么。。\npublic static int removeElement(int[] nums, int val) &#123;      int i = 0;      for (int j = 0; j &lt; nums.length; j++) &#123;\t    // 当 val == nums[j]时，只有j++\t    // 下一次不相等时，前一个指针的后一位直接指向当前的j，相当于中间的元素都被删除了。        if (val != nums[j]) &#123;              nums[i++]= nums[j];          &#125;      &#125;      return i;  &#125;\n总结\n其实都属于已经知道题解方式再去看题，加上是简单算法，所以感觉难度不是很大。（也可能我只是为了找工作，对我来说解出来就OK）\n二分查找\n前提：\n1、有序数组\n2、数组中无重复元素注意：整数数值越界的问题\n","categories":["面试","代码随想录"],"tags":["数组","二分查找","双指针"]},{"title":"代码随想录算法训练营第三天-203移除链表元素、707设计链表、206反转链表","url":"/2024/04/0e035e5c3c54.html","content":"\n\n前言\n状态：链表定义有点不会，基本上是都是看了一半图解后写出来的，而且耗时比较长，可能二刷会好一点吧。\n\n\n更新\n\n\n24.04.24 初始记录24.05.15 完成题目\n\n初步题解\n203移除链表元素\n题目链接：https://leetcode.cn/problems/remove-linked-list-elements/description/\n刚开始看到有点懵，习惯了写输入输出，这里不知道怎么输入了。链表这块需要先初始化链表。没有写出来后面是查看了解析。在具体方法那里，一直尝试只用一个链表做操作，但是运行总是得不到想要的结果。\npublic class LE203 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          String s = scanner.nextLine();          if (&quot;&quot;.equals(s.trim())) &#123;              System.out.println(new LinkedList());              return;          &#125;          List&lt;Integer&gt; head = Arrays.stream(s.split(&quot;,&quot;)).map(Integer::parseInt).collect(Collectors.toList());          int val = Integer.parseInt(scanner.nextLine());            // 初始化链表          LinkedList linkedList = new LinkedList();          for (Integer integer : head) &#123;              linkedList.add(integer);          &#125;              ListNode listNode = removeElements(linkedList.head, val);          System.out.println(listNode);      &#125;  \t// 一开始只能写成这个样子    public static ListNode removeElements(ListNode head, int val) &#123;  \t\twhile (head != null &amp;&amp; head.val == val) &#123;  \t\t    head = head.next;  \t\t&#125;  \t\t  \t\tif (head == null) &#123;  \t\t    return head;  \t\t&#125;    &#125;        /**       * 链表的定义       */      public static class ListNode &#123;          int val;          ListNode next;            ListNode() &#123;          &#125;            ListNode(int val) &#123;              this.val = val;          &#125;            ListNode(int val, ListNode next) &#123;              this.val = val;              this.next = next;          &#125;      &#125;        public static class LinkedList &#123;          private ListNode head;            public ListNode getHead() &#123;              return head;          &#125;            public void setHead(ListNode head) &#123;              this.head = head;          &#125;            public ListNode getCurrent() &#123;              return current;          &#125;            public void setCurrent(ListNode current) &#123;              this.current = current;          &#125;            private ListNode current;            public void add(int val) &#123;              if (head == null) &#123;                  head = new ListNode(val);                  current = head;              &#125; else &#123;                  current.next = new ListNode(val);                  current = current.next;              &#125;          &#125;      &#125;  &#125;\n707设计链表\n题目链接：https://leetcode.cn/problems/design-linked-list/description/\n修修改改了很久才通过，要考虑头节点，尾节点。\npublic class LE707 &#123;      public static void main(String[] args) &#123;          MyLinkedList myLinkedList = new MyLinkedList();          myLinkedList.addAtHead(1);          myLinkedList.addAtTail(3);          // 链表变为 1-&gt;2-&gt;3        myLinkedList.addAtIndex(1, 2);          // 返回 2        myLinkedList.get(1);          // 现在，链表变为 1-&gt;3        myLinkedList.deleteAtIndex(1);          // 返回 3        myLinkedList.get(1);      &#125;        public static class ListNode &#123;          private int val;          private ListNode next;            public ListNode() &#123;          &#125;            public ListNode(int val) &#123;              this.val = val;          &#125;      &#125;        public static class MyLinkedList &#123;          private int size;          private ListNode head;            public MyLinkedList() &#123;              size = 0;              head = new ListNode(0);          &#125;            public int get(int index) &#123;              if (index &lt;= -1 || index &gt;= size) &#123;                  return -1;              &#125;                ListNode indexNode = head;              for (int i = 0; i &lt; index; i++) &#123;                  indexNode = indexNode.next;              &#125;                return indexNode.val;          &#125;            public void addAtHead(int val) &#123;              if (size == 0) &#123;                  size++;                  head = new ListNode(val);                  return;              &#125;              addAtIndex(0, val);          &#125;            public void addAtTail(int val) &#123;              addAtIndex(size, val);          &#125;            public void addAtIndex(int index, int val) &#123;              if (index &gt; size) &#123;                  return;              &#125;                if (index &lt; 0) &#123;                  index = 0;              &#125;                ListNode pre = head;              // 找到前一个节点的位置              for (int i = 0; i &lt; index - 1; i++) &#123;                  pre = pre.next;              &#125;                ListNode listNode = new ListNode(val);              // 如果插入节点为头节点              if (index == 0) &#123;                  listNode.next = pre;                  head = listNode;                  // 长度++                  size++;                  return;              &#125;              // 如果插入位置正好是尾节点 直接前节点指向这个节点 然后return              if (index == size) &#123;                  pre.next = listNode;                  // 长度++                  size++;                  return;              &#125;                // 否则              // 先把当前节点的后指针指向前节点的next              listNode.next = pre.next;              // 再把前节点的后指针指向当前节点              pre.next = listNode;              // 长度++              size++;          &#125;            public void deleteAtIndex(int index) &#123;              if (index &gt;= size || index &lt; 0) &#123;                  return;              &#125;                ListNode pre = head;              for (int i = 0; i &lt; index - 1; i++) &#123;                  pre = pre.next;              &#125;              // 如果删除节点为头节点              if (index == 0) &#123;                  head = head.next;                  size--;                  return;              &#125;              // 如果删除位置正好是尾节点 直接前节点指向null 然后return              if (index + 1 == size) &#123;                  pre.next = null;                  // 长度++                  size--;                  return;              &#125;              // 改变当前节点的前节点的后指针，指向下一个节点              pre.next = pre.next.next;              // 长度--              size--;          &#125;      &#125;  &#125;\n206反转链表\n题目链接：https://leetcode.cn/problems/reverse-linked-list/description/\n偷偷看了下视频图解，按这个思路写的代码：还是比较简单的\n\npublic static LE707.ListNode reverseList(LE707.ListNode head) &#123;      LE707.ListNode pre = null;      LE707.ListNode cur = head;      while (cur != null) &#123;          LE707.ListNode temp = cur.next;          cur.next = pre;          pre = cur;          cur = temp;      &#125;        return pre;  &#125;\n看讲解\n203移除链表元素\n题目链接/文章讲解/视频讲解：：https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html\n// 一开始没有搞懂，前面一个循环是用来干什么的。// 但是去除前面一步，执行[7,7,7,7] 7 这个用例会多出一个7public static ListNode removeElements(ListNode head, int val) &#123;      while (head != null &amp;&amp; head.val == val) &#123;          head = head.next;      &#125;        if (head == null) &#123;          return head;      &#125;        ListNode pre = head;      ListNode cur = head.next;      while (cur != null) &#123;          if (cur.val == val) &#123;              pre.next = cur.next;          &#125; else &#123;              pre = cur;          &#125;          cur = cur.next;      &#125;      return head;  &#125;\n这个题共有三种题解法：\n\n\n第一种：添加虚节点。在原先的链表前，添加一个虚拟节点，用于处理可能被删除的头节点。因为删除可能涉及到头节点，所以在方法二中，第一个循环把头节点可能需要删除的情况直接处理掉。\n\n\n第二种：不添加虚节点。用一个循环处理可能会被删除的头节点。\n\n\n第三种：不加虚节点，同时不添加pre节点。加上判断删除节点是否是尾节点。\n\n\n707设计链表\n题目链接/文章讲解/视频讲解：https://programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html\n//单链表class ListNode &#123;    int val;    ListNode next;    ListNode()&#123;&#125;    ListNode(int val) &#123;        this.val=val;    &#125;&#125;class MyLinkedList &#123;    //size存储链表元素的个数    int size;    //虚拟头结点    ListNode head;    //初始化链表    public MyLinkedList() &#123;        size = 0;        head = new ListNode(0);    &#125;    //获取第index个节点的数值，注意index是从0开始的，第0个节点就是头结点    public int get(int index) &#123;        //如果index非法，返回-1        if (index &lt; 0 || index &gt;= size) &#123;            return -1;        &#125;        ListNode currentNode = head;        //包含一个虚拟头节点，所以查找第 index+1 个节点        for (int i = 0; i &lt;= index; i++) &#123;            currentNode = currentNode.next;        &#125;        return currentNode.val;    &#125;    //在链表最前面插入一个节点，等价于在第0个元素前添加    public void addAtHead(int val) &#123;        addAtIndex(0, val);    &#125;    //在链表的最后插入一个节点，等价于在(末尾+1)个元素前添加    public void addAtTail(int val) &#123;        addAtIndex(size, val);    &#125;    // 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。    // 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点    // 如果 index 大于链表的长度，则返回空    public void addAtIndex(int index, int val) &#123;        if (index &gt; size) &#123;            return;        &#125;        if (index &lt; 0) &#123;            index = 0;        &#125;        size++;        //找到要插入节点的前驱        ListNode pred = head;        for (int i = 0; i &lt; index; i++) &#123;            pred = pred.next;        &#125;        ListNode toAdd = new ListNode(val);        toAdd.next = pred.next;        pred.next = toAdd;    &#125;    //删除第index个节点    public void deleteAtIndex(int index) &#123;        if (index &lt; 0 || index &gt;= size) &#123;            return;        &#125;        size--;        if (index == 0) &#123;            head = head.next;\t    return;        &#125;        ListNode pred = head;        for (int i = 0; i &lt; index ; i++) &#123;            pred = pred.next;        &#125;        pred.next = pred.next.next;    &#125;&#125;\n参考中是直接设置了虚拟头节点解决的，代码会更加简洁。还有一种双向链表的方法，没有仔细研究。\n206反转链表\n题目链接/文章讲解/视频讲解：https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html\n// 递归 class Solution &#123;    public ListNode reverseList(ListNode head) &#123;        return reverse(null, head);    &#125;    private ListNode reverse(ListNode prev, ListNode cur) &#123;        if (cur == null) &#123;            return prev;        &#125;        ListNode temp = null;        temp = cur.next;// 先保存下一个节点        cur.next = prev;// 反转        // 更新prev、cur位置        // prev = cur;        // cur = temp;        // 此时cur为前一个节点，temp为后一个节点。两个节点位置交换，做递归。        return reverse(cur, temp);    &#125;&#125;\n按照讲解，一开始写的是双指针方法。\nLeetCode进阶处写了还可以使用递归解决。解法在解析中给出。\n","categories":["面试","代码随想录"],"tags":["链表"]},{"title":"聚合支付项目介绍","url":"/2024/05/f729f2faf71f.html","content":"\n\n前言之前的项目已经接触了支付宝、微信、银联三种支付方式了。正好辞职把这个项目写一遍，看了技术栈有一些是没有接触过的，应该能学到很多。项目git地址：https://gitee.com/kiml_rgb/shanjupay.git\n\n\n更新\n\n\n24.05.16 初始记录（抄了一些项目描述）\n\n项目概述\n聚合支付目前主要的做法就是线上聚合收银台(开放API)，线下C2B一码多付、线下B2C商家扫码。平台应以SaaS服务形式提供给各商户订单管理、门店管理、财务数据统计等基础服务，闪聚支付还以支付为入口，通过广告、营销、金融等服务，构建一个移动支付的全生态系统。\n功能模块\n平台主要包括三个模块：官网&amp;开放平台、商户平台、运营平台，详细功能如下：\n\n\n\n\n功能模块名称\n功能说明\n\n\n\n\n官网&amp;开放平台\n产品展示、功能介绍、帮助中心和开发者中心\n\n\n商户平台-首页\n提供商户注册、登录、基本信息查看、数据看板\n\n\n商户平台-账户管理\n提供商户企业资质认证、企业信息查看和套餐购买\n\n\n商户平台-支付管理\n为商户提供应用创建、渠道参数配置、交易总览和开启支付(生成二维码)等\n\n\n商户平台-门店管理\n为商户提供新增门店、店长分配、门店导入等\n\n\n商户平台-员工管理\n为商户提供新增员工、定义角色、分配角色等\n\n\n商户平台-优惠管理\n为商户提供优惠券管理、活动统计等\n\n\n运营平台-商户管理\n对商户进行检索、审核和订单统计\n\n\n运营平台-优惠管理\n为商户设置优惠策略和优惠券发送\n\n\n运营平台-管理员管理\n运营平台-管理员管理\n\n\n\n业务主体流程\n\n项目技术架构\n技术架构\n\n技术栈\n\n重点了解微服务技术栈：服务端基于Spring Boot构建，采用Spring Cloud Alibaba微服务架构。\n\n\n基础设施业务数据持久化采用MySQL，数据缓存采用Redis，采用RocketMQ的事务消息机制完成部分场景下的分布式事务控制，采用第三方云平台完成文件上传与分布式存储。\n\n\n组件系统微服务基于SpringBoot开发，数据库连接池采用Druid，POJO构建采用Lombok，日志系统采用Log4j2， Guava工具类库，Mybatis Plus持久层接口实现，Sharding-jdbc分库分表组件，Swagger接口规范组件，XXL-job 分布式任务调度组件，Sentinel限流组件等。\n\n\n接入 Zuul网关完成客户端认证、路由转发等功能，Dubbo RPC完成微服务远程调用，JWT提供前后端令牌管理方案。\n\n\n视图平台支持H5、PC等各种前端。\n\n\n","categories":["后端项目","聚合支付"],"tags":["Java"]},{"title":"代码随想录算法训练营第四天-24两两交换链表中的节点、19删除链表的倒数第N个节点、142环形链表II","url":"/2024/05/19d5175a61d8.html","content":"\n\n前言\n状态：\n\n\n更新\n\n\n24.05.16 初始记录\n\n","tags":["链表"]}]