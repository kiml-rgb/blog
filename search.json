[{"title":"Obsidian + Git + Hexo + 图床 = Blog + 个人笔记体系","url":"/2023/02/27/100000002/","content":"\n\n前言\n之前有过基于 Hexo 的博客搭建经历，但是由于时间繁忙，加上后续学习了解到的笔记软件，拥有我想要的全局搜索功能，而且比博客的格式、排版更加吸引人，就放弃了之前搭建的博客。但是出来找工作感觉拥有一个自己的技术博客会比较占优势，因此打算在笔记的基础上，加上原来的 Hexo 快速生成，转成技术博客输出。\n\n\n参考文章\n\n\n\n【保姆级】利用Github搭建自己的个人博客，看完就会\nHexo + Obsidian + Git 完美的博客部署与编辑方案\n\n\n更新\n\n22.12.11 初始记录(修改预计开始日期为元旦)23.02.24 环境部署，个人博客绑定到 Gitee Pages23.02.27 Obsidian 整合 等待Gitee Pages审核ing24.03.28 更新域名绑定等相关问题\n\n环境部署\n安装git\n\n\n访问 git 官方地址，下载对应的安装包，进行安装（简单的点击下一步）。\n\n\n安装好之后，鼠标右键可以看到：Git Bash Here，点击后打开了。\n\n\n输入：git --version\n出现版本号说明安装成功。\n\n\n安装node.js\n\n\n访问 node.js 官方地址，下载对应的安装包，进行安装（简单的点击下一步）。\n\n\n安装好之后，配置环境变量，并在终端里面输入：node -v\n出现版本号说明安装成功。\n\n\n安装 Hexo\n\n\n安装命令：\n\n\nnpm install hexo -g\n测试是否安装成功，命令：hexo -v\n出现版本号说明安装成功。\n\n\n安装 hexo 推送 git 拓展依赖，安装命令：\n\n\nnpm install hexo-deployer-git --save\ngit配置 SSH key\n\n\n先看本地是否配置好SSH key（命令：cd ~/.ssh）\nSSH key的保存位置在本地的C:\\Users\\&#123;你的用户名&#125;\\.ssh文件下，如果本地已存在SSH，此步不会有提示，否则出现No such file or directory。如果保存文件下没有文件id_rsa.pub 或 id_dsa.pub则也需要重新生成\n\n\n生成SSH key\n如果没有配置输入生成命令，然后连续回车三次即可：\n\n\nssh-keygen -t rsa -C &quot;邮件地址&quot; #该邮箱地址是绑定github账号的地址\ngithub\n\n\n打开SSH key的保存位置，复制id_rsa.pub文件里全部内容，接着打开github主页，点击个人设置，点击左侧的SSH and GPG keys，点击New SSH key\n\n\n\n将id_rsa.pub复制的内容粘贴到key中，title随便起一个就行。\n\n\n\n测试是否成功，输入命令：\n\n\nssh -T git@github.com\n出现 You've successfully authenticated, but GitHub does not provide shell access.说明成功\n\n\n配置账号和密码\n\n\n$ git config --global user.name &quot;liyunchen&quot; #你的github用户名 $ git config --global user.email &quot;xxx@163.com&quot; #填写你的github注册邮箱\ngitee\n\n除了Github Pages，也可以把博客搭建在Gitee Pages上，不翻墙的情况下，连接github经常会出现连接不上的情况，所以这次就直接改到Gitee上了。又换回来了（24.02.02）\n\n\n\n同样的配置SSH key，在Gitee的个人设置界面添加公钥\n\n\n\n测试是否成功，输入命令：\n\n\nssh -T git@gitee.com\n出现 You've successfully authenticated, but GITEE.COM does not provide shell access.说明成功\n搭建个人博客\n\n\n新建一个保存博客的存放目录，进入到本地博客存放目录，初始化个人博客，命令：\n\n\nhexo init\n出现不可获取错误说明github连接失败，再重新执行一遍命令就可以了\n\n\n\n生成静态网页，命令：\n\n\nhexo g\n\n\n本地预览，命令：\n\n\nhexo s\n访问localhost:4000\ngithub\n\n\n新建一个github仓库，给仓库起个名称，可以为用户名.github.io，这样这个名称就可以作为你github博客的访问地址\n\n\n编辑_config.yml，此文件在你博客存放目录下，需要编辑的github地址填写在最后deploy处\n\n\ndeploy: \ttype: git \trepository: #仓库地址\tbranch: main #查看自己仓库是master还是main\n\n\n发布到 github，命令：\n\n\nhexo d\n这样就已经把生成的静态文件推送到github仓库去了。\ngitee\n\n\n新建一个 gitee 仓库，给仓库起个名称，这里我直接用 blog 作为名称，这样博客的访问地址就是用户名.gitee.io/blog\n\n\n编辑_config.yml，此文件在你博客存放目录下，文件需要\n\n\ndeploy: \ttype: git \trepository: #仓库地址\tbranch: master #查看自己仓库是master还是main\n\n\n发布到 gitee，命令：\n\n\nhexo d\n\n\n在个人仓库界面，开启 Gitee Pages 服务（第一次使用还要手持身份证拍照的实名认证，蛮无语的，终于知道为什么用的人少了。。。）\n\n\n\n博客主题（Keep）\n\n在配置文件里可以看见 Hexo 主题商店的地址，配置文件中默认的主题为 landscape，不太喜欢打算换掉。原先博客使用的是Next主题，也是使用 Hexo 搭建博客用到最多的主题，但是也用腻了。现在发现一个新的主题 Keep，感觉蛮简洁舒适的，所以这次重新搭建也打算直接换上。\n\nKeep 主题的官方配置文档很详细，在演示博客中有一个使用指南，直接照着配置就行。\nObsidian整合\nObsidian知识库创建\n\n\n新建一个仓库或将之前的博客文件作为仓库打开\n\n\n\n忽略多余的文件。我们主要是编辑和管理Markdown文件，所以一些多余的文件要忽略掉，这样在知识库里搜索文件、关键字时才不会搜索到多余的，也能有效提高检索效率。打开：设置&gt;文件与链接&gt;Exclude Files\n\n\n\n设置新建笔记的存放位置，内部链接类型~~（关闭Wiki链接的使用，因为hexo的解析要求为markdown格式的文件）~~以及附件默认的存放路径\n\n\n\n在 hexo 项目的 .gitignore 文件中加入如下内容：\n\n\n.obsidian/workspace\n博客文章的管理\n\n新建文件在 hexo 的默认配置中放在 source/_post 目录下，随着文章数量的增多，文章也会变得难以寻找。因此采用以文件夹来分目录的方式，存放写好的文件。但是这样分类后，还需要手动维护文章开始前的定义文字，去修改文件所在的目录，较为麻烦。\n\n为了省去手动维护 categorys 字段的这个问题，我们可以使用 hexo-auto-category 这个插件。这个插件在 Hexo 进行 build 的时候会去自动根据文章目录情况来自动修改文章的 categories 信息，更详细的部分可以看作者的文章。除此之外最好修改一下 _config.yml 中的默认配置：\npermalink: :year/:month/:hash.html\n但是这里有一个问题，就是只有 hexo 在执行 hexo generate 或者 hexo server 时候才会去触发 categories 的生成，那么每次我们创建文章都要重新 hexo generate 以触发插件的自动校正功能，并再次把更新后的变更提交推送git。\n参考博客使用Husky完成git hook的操作：\n\n\n安装 huksy：npm install husky --save-dev\n\n\n执行 huksy 初始化指令：npx husky install\n\n\n在 package.json 中的 scripts 中写入：&quot;prepare&quot;: &quot;husky install&quot;\n\n\n在生成的 .husky 目录创建 pre-commit 文件（有的话就不用创建），并写入以下内容：\n\n\n#!/usr/bin/env sh. &quot;$(dirname -- &quot;$0&quot;)/_/husky.sh&quot;npx hexo generate &amp;&amp; git add .\n如果提交代码的时候，终端出现类似的构建过程，就说明由 husky 创建的 git hook 生效了。\n\nhexo 博客默认携带的两个文件夹为 categories 和 tags ，这两个标签可以在文章开始前定义，然后 hexo 会自动解析该文章所属的目录和标签。\n\n上面已经通过插件解决了目录的问题，还剩下文章的标题和 tags。Obsidian 是支持创建新文件时插入模板的，这就意味着我们可以不用重复写 Hexo 博客文的 Front-matter 部分。\n\n\n在 source 目录下创建 _obsidian 文件夹，并创建一篇 Post Template 的文章（md文件），内容为：\n\n\n---title: &#123;&#123;title&#125;&#125;date: &#123;&#123;date&#125;&#125;tags: []---\n\n\n然后进入到 Obsidian 的设置面板，选择核心插件，并启用模板功能。同时点击旁边的配置按钮，进入到模板配置的设置中，设置配置信息\n\n\n\n之后，我们再创建新文章的时候，只需要点击侧边栏的插入模板按钮就可以快速生成 Front-matter 信息：\n\n\n\n博客图片的管理\n\n在 Obsidian 中，可以直接粘贴截图，并设置默认保存位置。相对路径保存的格式如下：![](attachments/xxx.png)，但是这样部署到 hexo 中的图片会显示404加载不成功的错误。\n\n原先的办法是将 _config.yml 配置文件中的 post_asset_folder 选项设置为 true 来打开。该功能打开后，Hexo 将会在你每一次通过 hexo new [layout] &lt;title&gt; 命令创建新文章时自动创建一个文件夹。这个资源文件夹名与文章文件名相同。将所有与你的文章有关的资源（如图片）放在这个关联文件夹中之后，通过相对路径来引用它们。但是由于本次需要将 Obsidian 与 Hexo 结合，希望生成新文章不依靠于命令行。因此本次直接加入图床保存图片。使用的图床为Keep主题推荐的图床PicX。建议本地依旧备份一份图片，以防万一。\nGit 同步（后续弃用）\n\nObsidian内存在插件Obsidian Git 插件使我们可以在 Obsidian 内就可以实现 git commit 以及 push 的操作。\n\n\n\n在右侧命令面板处输入open source control view，可以打开Git面板，右侧会自动生成commit信息，commit信息可以在配置文件内自行配置\n\n\n\nFile Tree 定位\n\n用 Obsidian 控制文件有一个弊端在于左侧目录为全部文件，而我们编写 hexo 博客，一般只会在_posts文件下操作，可以使用Obsidian插件 File Tree Alternative Plugin\n\n安装插件后可以看到文件列变为了以下格式\n\n打开选中_post，右键Focus on Folder，则菜单栏只显示_post文件夹\n\n其他拓展\n更高级的 Markdown 渲染器\n\nHexo 默认的 Markdown 渲染器是hexo-renderer-marked，但其支持的渲染格式有限，比如重点符号的渲染就是不成功的，因此更换更好用的渲染器hexo-renderer-markdown-it\n\n\n\n卸载hexo-renderer-marked\n\n\nnpm un hexo-renderer-marked --save\n\n\n安装 hexo-renderer-markdown-it\n\n\nnpm i hexo-renderer-markdown-it --save\n\n\n将如下文本复制粘贴到 Hexo 的配置文件 _config.yml 的尾部\n\n\nmarkdown:  preset: &quot;default&quot;  render:    html: true    xhtmlOut: false    langPrefix: &quot;language-&quot;    breaks: true    linkify: true    typographer: true    quotes: &quot;“”‘’&quot;  enable_rules:  disable_rules:  plugins:    - markdown-it-abbr    - markdown-it-cjk-breaks    - markdown-it-deflist    - markdown-it-emoji    - markdown-it-footnote    - markdown-it-ins    - markdown-it-mark    - markdown-it-sub    - markdown-it-sup    - markdown-it-checkbox    - markdown-it-imsize    - markdown-it-expandable    - name: markdown-it-container      options: success    - name: markdown-it-container      options: tips    - name: markdown-it-container      options: warning    - name: markdown-it-container      options: danger  anchors:    level: 2    collisionSuffix: &quot;&quot;    permalink: false    permalinkClass: &quot;header-anchor&quot;    permalinkSide: &quot;left&quot;    permalinkSymbol: &quot;¶&quot;    case: 0    separator: &quot;-&quot;\n\n\n分别使用 npm 命令安装以下三个插件，其它插件 hexo-renderer-markdown-it 渲染器已有\n\n\nnpm i markdown-it-checkboxnpm i markdown-it-imsizenpm i markdown-it-expandable\n域名绑定\n\n\n域名的购买\n\n\n在仓库里添加CNAME文件并在文件中填写绑定的域名\n\n\n\nping 你的github域名得到IP地址\n\n\n\n解析域名到对应的地址\n\n\n\n问题\nHexo在部署到Github后CNAME文件会消失或改变\n问题详述：之前已经在github上对域名进行了绑定，但是hexo -d之后绑定生成的CNAME文件被删除。解决方式：参考网上博客的说法，把对应的CNAME文件放入source文件夹下，这样hexo -g重新生成public文件夹下的内容时，CNAME文件也会同步生成。再执行hexo -d操作后，CNAME文件被同步发布，页面刷新域名正常不会出现404问题。\nHexo链接地址改变\n处理如下：\n\n内链：[[优化 Hexo 网站的永久链接格式]]\n外链：优化 Hexo 网站的永久链接格式\n\n","categories":["博客"]},{"title":"优化 Hexo 网站的永久链接格式","url":"/2024/05/22/100000002/","content":"\n\n前言\n浏览之前引用的文章地址，突然发现，地址全部变成了404。后来发现每次发布，地址链接都会改变。所以记录一下，怎么处理这个问题。\n\n\n参考文章\n\n\n\n优化 Hexo 网站的永久链接格式\n\n\n更新\n\n24.05.22 初始记录\n\n打开Hexo配置文件可以看到原先的配置处为：\nurl: https://kiml.github.iopermalink: :year/:month/:hash.htmlpermalink_defaults:pretty_urls:  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks\n照理说这样配置也是没有问题的，由于hash值的计算与文章标题有关，可能是因为这样，重新发布后，有部分页面会直接变成404的状态。\n优化\n安装插件\n在 Hexo 根目录打开终端安装插件\n# 使用npm安装插件npm install hexo-abbrlink2 --save# 使用yarn安装插件yarn add hexo-abbrlink2\n修改配置\n修改 Hexo 的配置文件的 permalink 字段。好像abbrlink的值月份内是有可能重复的？不加day有部分文章生成的链接是相同的不知道怎么回事\npermalink: :year/:month/:day/:abbrlink/\n插件配置默认为0，这里设置成100000000，添加到配置文件处\nabbrlink:  start: 100 # 启起始文章id，默认为0 ，可以自定义，比如100\n","categories":["博客"]},{"title":"IntelliJ IDEA常用设置","url":"/2023/07/02/100000003/","content":"\n\n前言\nIntelliJ IDEA常用设置\n\n\n更新\n\n\n23.07.02 初始记录23.07.09 基本设置（初始）23.07.16 基本设置完成 推荐插件（初始）23.08.28 三个插件的添加24.06.06 LeetCode插件\n\n基本设置\n基本风格及UI字体大小\n\n设置打开IDEA不直接打开项目\n\n这样默认打开IDEA时就是如下画面：\n点击Customize里的All settings，就可以为所有新项目设置配置。\n设置项目文件编码格式（很重要）\n建议将所有都设置成UTF-8格式，Maven下载不成功有时候和这个有关\n\n设置代码提示的匹配格式\n\n设置新建类文件的注释模板\n/** * @author $&#123;USER&#125; * @date: $&#123;DATE&#125; $&#123;TIME&#125; * @description:*/\n\n设置多个类同时打开并不重叠隐藏\n\n设置maven配置\n\n设置SQL自动补全\n\n\n启用IDEA的database插件\n\n\n针对项目进行SQL Dialects配置\n\n\n基本设置导出\n为了更方便的迁移IDEA，可以将基本设置导出。\n\n推荐插件\nLombok\n\n通过注解不再需要编写getter、setter、equals等方法，可以在编译时自动生成，开发时常用的插件。IDEA在目前使用的版本中已经内置，SpringBoot 2.1.x之后的版本也在Starter中内置了Lombok依赖。\n\n集成\n在项目的pom.xml文件中可以添加Lombok依赖，SpringBoot 2.1.x版本后无需指定Lombok版本，SpringBoot在spring-boot-dependencies中已经内置。\n&lt;!--lombok依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;\nMyBatisX\n\nMybatisX 是一款基于 IDEA 的快速开发插件，为效率而生。\n\nMaven Helper\n\n可以右键项目快速完成项目maven的各个阶段。\npom.xml文件点击后，显示右边多了Dependency Analyzer的Tab选项，可以查看依赖冲突。同时也可以快速排除冲突的文件。\n\nGit Commit Template\n\n为git的提交提供模板。例子：fix(DAO):用户查询缺少username属性 feat(Controller):用户查询接口开发\n\n参数详解：\n\n\n\n参数\n类型\nshuoming\n\n\n\n\ntype(必须)\n\n用于说明git commit的类别，只允许使用下面的标识。\n\n\n\nfeat\n新功能（feature）\n\n\n\nfix/to\n修复bug，可以是QA发现的BUG，也可以是研发自己发现的BUG。\n\n\n\nfix\n产生diff并自动修复此问题。适合于一次提交直接修复问题\n\n\n\nto\n只产生diff不自动修复此问题。适合于多次提交。最终修复问题提交时使用fix。\n\n\n\ndocs\n文档（documentation）\n\n\n\nstyle\n格式（不影响代码运行的变动）。\n\n\n\nrefactor\n重构（即不是新增功能，也不是修改bug的代码变动）。\n\n\n\nperf\n优化相关，比如提升性能、体验。\n\n\n\ntest\n增加测试。\n\n\n\nchore\n构建过程或辅助工具的变动。\n\n\n\nrevert\n回滚到上一个版本。\n\n\n\nmerge\n代码合并。\n\n\n\nsync\n同步主线或分支的Bug。\n\n\nscope(可选)\n\nscope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。\n\n\nsubject(必须)\n\nsubject是commit目的的简短描述，不超过50个字符\n\n\n\nStatistic\n\n代码统计器\n\nLeetCode Editor\n\nLeetCode 刷题\n\n中文乱码问题：在Help-&gt;Edit Custom VM Options添加如下：\n-Dfile.encoding=utf-8","categories":["环境搭建"],"tags":["IDEA"]},{"title":"Git及常用命令","url":"/2023/07/11/100000003/","content":"\n\n前言\nGit部分知识以及常用命令\n\n\n更新\n\n\n23.07.11 初始记录\n\n安装\n之前在写 [[Obsidian + Git + Hexo + 图床 = Blog + 个人笔记体系]]这篇笔记的时候有提到过Git的安装。这里就直接把步骤贴过来，具体安装地址(https://git-scm.com/)\n\n\n访问 git 官方地址，下载对应的安装包，进行安装（简单的点击下一步）。\n\n\n安装好之后，鼠标右键可以看到：Git Bash Here，点击后打开了。\n\n\n输入：git --version\n出现版本号说明安装成功。\n\n\n\n\nlinux安装使用以下命令\n\n\nsudo apt-get install git\ngit配置 SSH key\nGit是分布式的代码管理工具，远程的代码管理是基于SSH的，所以要使用远程的Git则需要SSH的配置。一、设置Git的user name和email：\n$ git config --global user.name &quot;kiml&quot;  $ git config --global user.email &quot;1162278448@qq.com&quot;\n二、生成SSH密钥\n\n内链：[[Obsidian + Git + Hexo + 图床 = Blog + 个人笔记体系#git配置 SSH key]]\n外链：[Obsidian + Git + Hexo + 图床 = Blog + 个人笔记体系](https://kiml.site/2023/02/27/100000002/#git配置 SSH key)\n\ngit工具\nGitHub Desktop\n\n平时更多使用IntelliJ IDEA自带的git工具，偶然发现这个工具，近期打算使用官方文档：[https://docs.github.com/zh/desktop/installing-and-configuring-github-desktop/overview/getting-started-with-github-desktop]\n\n常用命令\nclone到本地\ngit clone git@gitee.com:kiml_rgb/blog.git\n提交代码\n# 进入项目工程目录cd hello/# 将当前修改的文件添加到暂存区git add .# 提交代码git commit -m &quot;first commit&quot;\n推送代码\ngit push\n拉取代码\ngit pull\n创建并提交分支\n# 切换并从当前分支创建一个dev分支git checkout -b dev# 将新创建的dev分支推送到远程仓库git push origin dev\n其他常用命令\n# 切换到dev分支git checkout dev# 查看本地仓库文件状况git status# 查看本地所有分支git branch# 查看提交记录git log","categories":["环境搭建"],"tags":["Git"]},{"title":"装机-软件安装","url":"/2023/11/02/100000003/","content":"\n\n前言\n找到工作之后每天就是躺平，好久没有更新技术上的内容了，之前学的好多东西也忘了……甚至md语法都忘了好多（每天CRUD，但是也很消耗精力。必须要不断学习，好痛苦，什么时候能退休😢）趁着618配了一台新电脑，顺便用半个多月的时间用新电脑打游戏。。。正好最近在装软件，整理一下装机要注意的事，以及一些必备软件，便于后面再次装机使用。\n\n\n更新\n\n\n23.06.24 初始记录23.07.02 IDEA常用插件 + 基本设置23.07.09 编程环境Java + MySQL23.07.11 Git23.08.28 Maven\n\n初始装机\n这部分都是照着b站上的视频完成的。总之时间就分两大块，把零件装上去，理线。具体可参照以下视频：B站 赵德柱装机\n系统安装\n系统安装需要准备一个U盘装系统。具体步骤可以参照以下视频：B站 赵德柱装系统安装系统完毕第一件事就是去对应官网安装对应驱动，这个依据配置不同，需要下载的东西也不一样。可以检查以下项目的驱动是否安装，每项都需要到对应的官网去下载对应的驱动包：\n\n\ncpu驱动\n\n\n主板驱动（涉及较多）\n\n\n显卡驱动\n\n\n鼠标驱动（调光需要）\n\n\n键盘驱动（调光需要）\n\n\n软件安装\n常用软件\nOffice全家桶\n这个直接登录原来的微软账户就可以安装了，之前买笔记本有配有家庭版可以直接使用。有的笔记本没有送，这个需要注意原来的不要卸载，不然重新下载比较麻烦（这是个付费软件）。直接去买个激活码就行\nSteam\n装机第一件事\nUU加速器\n用了这么多，最常用的还是这个，加速商店是足够用了，想要加速游戏可以进一步去贴吧下载\nChrome\n插件就不提供了，自己后续需要再搜，最好还是能整个账号，不然每次装机都要重新把收藏夹的导出来有点麻烦。\nSnipaste\n很好用的截屏软件，U盘里带有安装包，直接解压缩，开启后就可以F1截图了\nScreenToGif\n制作Gif的软件，以前下载过但是没有用到的机会\nToDesk\n远程连接工具，不想背电脑回家就带这个\nObsidian\n目前在用的All in One笔记软件，好用但是太繁琐了，一开始大半时间都浪费在插件和布局上面，目前用着还行，希望后面能完全用起来。当个md编辑器还是不错的。\nTypora\n一款 Markdown 编辑器和阅读器。更便捷的浏览工具。\n网盘\n百度网盘\n之前参加活动，容量已经到5T了，但是不充会员完全没法使用，现在就是一个吉祥物的存在，有时候网上购买资源会发网盘链接，还是需要下载一个软件。\n阿里云盘\n需要备用一个\n编程专用\n开发环境\nJava\n目前用的还是1.8版本，在U盘内存了常用的几版JDK。有安装包双击下载就行，下载之后需要配置一下环境变量\nMySQL\n目前使用的是5.7.20版本，官网下载就行。同样也需要配置环境变量。\nRedis\n安装与SpringBoot下的使用方法如下：\n\n内链：[[Spring Data Redis]]\n外链：Spring Data Redis\n\nMaven\n一个Java项目管理工具，window需要官网下载可用的.zip包，之后解压到一个没有中文没有空格的路径下，同时也需要配置相应的环境变量。（可能出现IDEA不适配需要降低maven版本，当前IDEA 2020.3.2，可以安装Maven 3.6.3）打开安装目录conf/settings.xml文件，进行以下两项配置。\n\n\n其他\n还有很多其他环境配置，包括开发用的其他中间件。听说Windows也能配置Docker了，这部分应该会单独写文章。\n开发工具\nIntelliJ IDEA\n这个不用多说，U盘里存了一个可用的破解版，从大学用到现在了。安装后还需要进行一些常用的设置。具体可以参考以下\n\n内链：[[IntelliJ IDEA常用设置]]\n外链：IntelliJ IDEA常用设置\n\nWebStorm\n前端的IDEA，打算抛弃Vs Code用这个了。看了很多对比测评。用JetBrains的产品习惯了。\nPycharm\nPython的IDEA，也是JetBrains家的。\nTabby\n一款终端工具，之前用的一直是FinalShell，后来想转成XSHELL，才知道 XSHELL &amp; XFTP的家庭版是免费的，后来是看博客，知道了一款22年的终端Tabby（不过这么多具体哪个好用确实也是不太了解，换成这个的原因主要是他可以结合远程连接和远程传输两块的内容。也看到把数据库连接，服务器监控，终端都结合在一起的工具，但是数据库工具还是比较习惯用navicat，所以暂时决定是先把终端工具换成Tabby）具体使用步骤参考（后面有时间再整理到自己的笔记里面吧）：(https://www.macrozheng.com/tool/tabby_start.html)\nNavicat\n一款好用的数据库管理工具，提供14天免费试用。但是这种一般都是有破解的，网盘里存了一个（会被杀毒软件杀掉）\nGit\n版本控制工具。（目前使用的博客工具Hexo也是依靠Git部署）具体使用介绍如下\n\n内链：[[Git及常用命令]]\n外链：Git及常用命令\n\n其他\n翻墙\n目前使用的教程是(https://github.com/Alvin9999/new-pac/blob/master/自建v2ray服务器教程.md)\n","categories":["环境搭建"],"tags":["工具"]},{"title":"华为OD","url":"/2024/03/28/100000003/","content":"\n\n前言\n为块术（不是），其实一直觉得二本毕业去这边也蛮好的，但是一直没有动力刷题。今天去面试，啥也没准备，就看了一天早已忘记的八股文，果然挂了。但是Boss上收到华为OD的Hr的消息（好像是最近突然加了岗位？），总之约了两周后机考（怎么敢的，真的一点都没准备过）\n\n\n更新\n\n\n24.03.28 初始记录-day1刷题记录\n\n刷题记录\n240328（牛客华为机试题库——https://www.nowcoder.com/ta/huawei）\n\n\nHJ1 字符串最后一个单词的长度\n\n\n思路居然是遍历，遇0清空计数，真的没想到。显得我的方法很笨。\n\n\nHJ2 计算某字符出现次数\n\n\nHJ3 明明的随机数\n\n\n语法糖就语法糖吧，我放弃了\n\n\nHJ4 字符串分隔\n\n\nHJ5 进制转换\n\n\n240330（牛客华为机试题库——https://www.nowcoder.com/ta/huawei）\n\n\nHJ6 质数因子\n\n\n240402（牛客华为机试题库——https://www.nowcoder.com/ta/huawei）\n\n\nHJ7 取近似值\n\n\n用了API\n\n\nHJ8 取近似值\n\n\nHJ9 提取不重复的整数\n\n\nHJ10 字符个数统计\n\n\nHJ11 数字颠倒\n\n\n240404（牛客华为机试题库——https://www.nowcoder.com/ta/huawei）\n\n\nHJ12 字符串反转\n\n\nHJ13 句子逆序\n\n\n// 忘了这个APIString.join(&quot; &quot;, strings)\n\n\nHJ14 字符串排序\n\n\nHJ15 求int型正整数在内存中存储时1的个数\n\n\n华为OD机试真题-寻找身高相近的小朋友（C卷）\n\n\n240406（华为OD机试2024年最新题库-C卷）\n\n\n华为OD机试真题-围棋的气（C卷）\n\n\n华为OD机试真题-用连续自然数之和来表达整数（C卷）\n\n\n本题用滑动窗口进行求解。之前都不会这个。标记一下需要二刷。\n\n\n华为OD机试真题-开源项目热榜（C卷）\n\n\n华为OD机试真题-API集群负载统计（C卷）\n\n\n华为OD机试真题-整数对最小和（C卷）\n\n\n华为OD机试真题-素数之积（C卷）\n\n\n华为OD机试真题-CPU算力分配（C卷）\n\n\n华为OD机试真题-最大坐标值（C卷）\n\n\n华为OD机试真题-寻找最富裕的小家庭（C卷）\n\n\n240407（华为OD机试2024年最新题库-C卷）\n\n\n华为OD机试真题-分月饼（C卷）\n\n\n不会，没有思路，先跳过。\n240408（华为OD机试2024年最新题库-C卷）\n\n\n华为OD机试真题-找城市（C卷）\n\n\n没有思路，200分题打算周末再刷了，先看看有没有类似的题解。\n\n\n华为OD机试真题-查找接口成功率最优时间段（C卷）\n\n\n严重超时，不知道是不是因为一边上班一边做的原因思路都是乱的\n240409（华为OD机试2024年最新题库-C卷）\n\n\n华为OD机试真题-分割均衡字符串（C卷）\n\n\n华为OD机试真题-虚拟游戏理财（C卷）\n\n\n华为OD机试真题-靠谱的车（C卷）\n\n\n华为OD机试真题-执行时长（C卷）\n\n\n华为OD机试真题-万能字符单词拼写（C卷）\n\n\n240410（华为OD机试2024年最新题库-C卷）\n\n\n华为OD机试真题-来自异国的客人（C卷）\n\n\n华为OD机试真题-求最多可以派出多少支团队（C卷）\n\n\n华为OD机试真题-最长子字符串的长度（C卷）\n\n\n华为OD机试真题-机场航班调度程序（C卷）\n\n\n华为OD机试真题-数的分解（C卷）\n\n\n240411（华为OD机试2024年最新题库-C卷）\n\n\n华为OD机试真题-智能成绩表（C卷）\n\n\n华为OD机试真题-提取字符串中的最长数学表达式并计算（C卷）\n\n\n不希望考到这题。怎么还有正则正则实在不太熟，这题硬记((+-)?(\\\\d+[+-*])*\\\\d)判断出最长正则式子之后的思路为：1、记录初始加减号2、如果是+，记录数乘1；如果是-，记录数乘-1；如果是乘，获取前一个数并乘并记录乘积\n机试（240417）\n没过。。。293但是要300分。算了。本来也没报多大希望。还是多刷点题再投简历。现阶段，辞不辞职都无所谓了（最好明天就把我裁了！！！大晚上10点群里@人是不是有病啊，又不是bug？？？？谁tm理你？？？！！！）\n1年多的Java现在真的狗都嫌，打算实在没有去处，6个月之后再考一次，反正本次刷题感觉还行，不是特别难。\n后续\n打算先刷点算法+八股了。实在不行啃点存款，反正还没辞职。。。\n","categories":["面试"],"tags":["面试","Java"]},{"title":"面试-数据结构和算法","url":"/2024/04/22/100000004/","content":"\n\n前言\n根据刷题记录，整理各个类型的特点\n\n\n更新\n\n\n24.04.22 初始记录 数组的总结24.05.23 链表的总结24.05.24 哈希表的总结24.05.29 字符串的总结（KMP）24.06.09 二叉树总结\n\n数据结构\n数组\n基础理论\n1、数组是存放在连续内存空间上的相同类型数据的集合。\n\n\n数组下标从0开始\n\n\n数组的内存空间地址连续\n\n\n2、因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。\n3、数组的元素是不能删的，只能覆盖。\n4、二维数组在内存的空间地址不连续\n经典题目\n二分法\n需要遵循循环不变量原则。这里的循环不变量原则在二分法中的表现就是，循环过程中左闭右开，这个规则是不变的。\n双指针法\n快慢指针法：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。\n双向指针法：一个指针从左向右一个指针从右向左。从左向右的找等于目标值的位置，从右向左找不等于目标的位置，每次找到一个用不等于覆盖等于。（就是自己第一次题解时的做法）\n滑动窗口\n动态更新窗口的大小，找到最优解。\n滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。\n模拟行为\n目前遇到的题型是螺旋矩阵。这类题目只要模拟数组需要执行的操作就行，需要注意边界值，遵循循环不变量原则。\n链表\n基础理论\n分类\n\n\n单链表\n指针域只能指向节点的下一个节点。\n\n\n双链表\n每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。\n\n\n循环链表\n链表首尾相连。\n\n\n存储方式\n数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。链表是通过指针域的指针链接在内存中各个节点。\n所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。\n链表的定义\npublic class ListNode &#123;      public int val;      public ListNode next;        public ListNode() &#123;      &#125;        public ListNode(int val) &#123;          this.val = val;      &#125;  &#125;\n链表操作\n删除节点\n将该节点跳过，前一节点指向后一节点。\n添加节点\n前一节点指向该节点，该节点指向后一节点。\n性能分析\n\n\n\n\n插入/删除（时间复杂度）\n查询（时间复杂度）\n适用场景\n\n\n\n\n数组\nO(n)\nO(1)\n数据量固定，频繁查询，较少增删\n\n\n链表\nO(1)\nO(n)\n数据量不固定，频繁增删，较少查询\n\n\n\n经典题目\n虚拟头节点\n链表中的增删操作，都是需要操作前一个节点进行指向。但是对于头节点的操作，由于没有前一个节点，每次都需要单独处理。因此使用虚拟头结点的技巧。（基本上做题都是加上虚拟节点比较方便）\n链表的基本操作\n\n\n获取链表第index个节点的数值\n\n\n在链表的最前面插入一个节点\n\n\n在链表的最后面插入一个节点\n\n\n在链表第index个节点前面插入一个节点\n\n\n删除链表的第index个节点的数值\n\n\n反转链表\n\n\n迭代法用双指针，改变两个节点之间的指针方向\n\n\n递归法和迭代法的思路基本一样，把移动下一步的操作放到递归里进行。\n\n\n两两交换链表中的节点\n这题也用到了虚拟头节点的方法。\n\n\n需要交换的两个节点的前一个节点，指向需要交换的第二个节点\n\n\n节点交换\n\n\n删除倒数第N个节点\n运用虚拟头节点+双指针。思路是，一个指针先走N步，然后两个指针一起向后。当快指针指向末尾时，慢指针的位置正好是倒数第N个节点。然后完成删除操作。\n链表相交\n这里的相交指的是引用完全相同，即：内存地址完全相同的交点\n环形链表\n\n\n判断是否有环\n\n\n判断交点位置这是一道数学题，具体解析在对应的文章中给出。\n\n\n哈希表\n基础理论\n定义\n哈希表是根据关键码的值而直接进行访问的数据结构。\n\n一般使用\n一般哈希表都是用来快速判断一个元素是否出现集合里。\n哈希函数/哈希碰撞\n哈希函数是把传入的key映射到符号表的索引上。\n哈希碰撞处理有多个key映射到相同索引上时的情景，处理碰撞的普遍方式是拉链法和线性探测法。\n常见的三种哈希结构\n\n\n数组\n\n\nset（集合）\n\n\nmap（映射）\n\n\n哈希表经典题目\n数组作为哈希表\n一般题目中出现规定map大小（比如明说都是小写字母），就可以使用数组。这些题用map确实可以，但使用map的空间消耗要比数组大一些，因为map要维护红黑树或者符号表，而且还要做哈希函数的运算。所以数组更加简单直接有效！\n\n关联题目：\n有效的字母异位词\n赎金信\n\nset作为哈希表\n如果题目没有限制大小，就无法使用数组。主要因为：\n\n\n数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。\n\n\n如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。\n\n\n\n关联题目：\n两个数组的交集\n快乐数\n\nmap作为哈希表\nset是一个集合，里面放的元素只能是一个key，但是遇到key与value都要保存时，就需要使用map。\n字符串\n基础理论\n定义\n字符串是若干字符组成的有限序列，也可以理解为是一个字符数组。\n字符串经典题目\n双指针\n双指针法在数组，链表和字符串中很常用。\n\n关联题目：\n反转字符串：只是简单使用temp作为中间变量。\n替换字符：数组填充类的问题，可以先预先给数组扩容带填充后的大小，然后再从后向前进行操作。\n与移除操作有关的双指针操作：\n翻转字符串内的单词中的移除空格部分。\n之前数组部分中移除数组元素\n\n反转系列\n反转就是双指针（头尾指针一起向中间移动，然后交换数组元素）\n\n关联题目：\n反转字符串II\n翻转字符串内的单词：这题的反转用了两次，先整体反转，再分段反转。\n右旋转字符串：和上题一样需要先局部反转再整体反转。（这种题笔试遇到直接API快一点）\n\nKMP\nKMP算法是字符串查找最重要的算法。\nKMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。\n\n关联题目：\n实现 strStr() 、重复的子字符串\n\n前缀表\n作用：前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。\n常见的基础题目是在文本串中查找一个模式串，例：在aabaabaafa中查找aabaaf。这个查找是文本串指针顺序后移（不变），活动模式串进行匹配。前缀表用于记录查找失败后，模式串下一次返回查找的点。例：文本串指针到第二个b时，查找失败，这时模式串从b这个位置重新查询。\n什么是前缀表？\n记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。\n最长公共前后缀\n前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。\n后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。这个部分暂时是比较好理解的。\n为什么使用前缀表可以告诉我们匹配失败之后跳到哪里重新匹配？\n\n这张图是教程内的图，下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。\n如何找到一张前缀表\n不是很能理解，但是背下来了\n// 需要找到前缀表的字符串String s;// 初始化int j = 0;int[] next = new int[s.length];for(int i = 1; i &lt; s.length, i++) &#123;\t// 不相同的情况\twhile(j != 0 &amp;&amp; s.charAt[i] != s.charAt[j]) &#123;\t\tj = next[j - 1];\t&#125;\tif(s.charAt[i] == s.charAt[j]) &#123;\t\tj++;\t&#125;\tnext[i] = j;&#125;\n栈与队列\n基础理论\n队列是先进先出，栈是先进后出。\n栈与队列的基础可以通过下面两题回忆。\n\n用栈实现队列\n用队列实现栈\n\n栈经典题目\n\n有效的括号：括号匹配是使用栈解决的经典问题。\n删除字符串中的所有相邻重复项：思路就是可以把字符串顺序放到一个栈中，然后如果相同的话 栈就弹出，这样最后栈里剩下的元素都是相邻不相同的元素了。\n逆波兰表达式求值：这题主要在于题目中给出的百度链接，其中描述了逆波兰式子的意思。计算方式就是遍历式子，遇到数字入栈，遇到运算符出栈两个数字进行计算，计算结果再入栈。直到式子循环完毕。\n\n队列经典题目\n\n滑动窗口最大值：这题需要用到单调队列，即单调递减或单调递增的队列（需要自己定义数据结构）\n前 K 个高频元素：这题需要用到优先级队列，其实就是堆（堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。）\n\n二叉树\n基础理论\n二叉树的种类\n满二叉树\n满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。这棵二叉树为满二叉树，也可以说深度为k，有2^k-1个节点的二叉树。\n完全二叉树\n完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。\n优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。\n二叉搜索树\n二叉搜索树是一个有序树\n\n\n若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；\n\n\n若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；\n\n\n它的左、右子树也分别为二叉排序树\n\n\n平衡二叉搜索树\n平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。\n二叉树的存储方式\n二叉树可以链式存储，也可以顺序存储。\n那么链式存储方式就用指针， 顺序存储的方式就是用数组。\n用数组来存储二叉树如何遍历？如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。\n二叉树的遍历方式\n二叉树主要有两种遍历方式：\n\n\n深度优先遍历：先往深走，遇到叶子节点再往回走。\n\n\n广度优先遍历：一层一层的去遍历。\n这两种遍历是图论中最基本的两种遍历方式\n从深度优先遍历和广度优先遍历进一步拓展：\n\n\n\n\n深度优先遍历\n\n前序遍历（递归法，迭代法）\n中序遍历（递归法，迭代法）\n后序遍历（递归法，迭代法）\n\n\n\n广度优先遍历\n\n层次遍历（迭代法）\n这里前中后，其实指的就是中间节点的遍历顺序，前中后序指的就是中间节点的位置。\n\n\n\n\n❗二叉树的递归遍历\n二叉树的迭代遍历\n二叉树的统一迭代法：统一迭代法是在入栈的时候，如果该节点为要处理的节点，接上一个空指针。\n二叉树的层序遍历\n\n❗递归算法的三要素\n\n\n确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。\n\n\n确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。\n\n\n确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。\n\n\n二叉树的定义\npublic class TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    TreeNode() &#123;&#125;    TreeNode(int val) &#123; this.val = val; &#125;    TreeNode(int val, TreeNode left, TreeNode right) &#123;        this.val = val;        this.left = left;        this.right = right;    &#125;&#125;\n经典题目\n遍历方式\n\n❗二叉树的递归遍历\n二叉树的迭代遍历\n二叉树的统一迭代法：统一迭代法是在入栈的时候，如果该节点为要处理的节点，接上一个空指针。\n二叉树的层序遍历\n\n层序遍历相关的题目比较多，没有写到笔记里面。（一个模板可以做十道题，部分在github上提交了，部分没有做。）\n二叉树的属性\n\n\n是否对称、相同\n\n\n\n对称二叉树\n递归：后序遍历。判断左右子树：左右中、右左中是否相等。\n迭代：使用队列/栈将两个节点顺序放入容器中进行比较。\n\n\n\n求最大深度\n\n\n\n二叉树的最大深度\n递归：后序遍历，求根节点最大高度就是最大深度，通过递归函数的返回值做计算树的高度。\n\n\n\n求最小深度\n\n\n\n[二叉树的最小深度]\n递归：后序遍历，右节点为空，向左递归；左节点为空，向右递归。\n\n\n\n求节点数\n\n\n\n完全二叉树的节点个数\n普通二叉树的节点个数：层序遍历\n完全二叉树：\n分两种情况：满二叉树/最后一层节点没有满。但是这两种情况可以简化为一种，即孩子节点必定为满二叉树（按满二叉树算节点）\n于是就变成判断子树是否是满二叉树：向左递归的深度等于向右递归的深度\n\n\n\n是否平衡\n\n\n\n平衡二叉树\n递归：后序遍历。判断子树是否平衡并把结果向上传递。\n\n\n\n找所有路径\n\n\n\n二叉树的所有路径\n递归：前序遍历。涉及回溯。\n\n\n\n求左叶子之和\n\n\n\n左叶子之和\n递归：后序遍历。\n\n\n\n求左下角的值。\n\n\n\n找树左下角的值\n递归：顺序没有关系。找深度最大的左叶子节点（优先左遍历）。\n迭代：感觉层序遍历更简单一点。\n\n\n\n求路径总和\n\n\n\n路径总和、路径总和ii\n递归：需要回溯。\n\n二叉树的修改与构造\n\n\n翻转二叉树\n\n\n\n翻转二叉树\n递归：中序不行。左右两数交换指针。\n\n\n\n构造二叉树\n\n\n\n从中序与后序遍历序列构造二叉树、从前序与中序遍历序列构造二叉树\n最大二叉树\n递归：思路就是根据后序/前序的遍历结果。切割中序，再递归构造。\n\n\n\n合并二叉树\n\n\n\n合并二叉树\n递归：前序遍历。\n\n最近公共祖先\n\n二叉树的最近公共祖先：从底层向上传递信息（只能用后序）。找到一个节点的左子树含p，右子树含q（可以先交换两个数的大小顺序）\n二叉搜索树的最近公共祖先：遍历顺序随便。重点在当我们从上向下去递归遍历，第一次遇到 cur节点是数值在[q, p]区间中，那么cur就是 q和p的最近公共祖先。\n\n二叉搜索树的属性\n\n\n遍历\n\n\n\n二叉搜索树中的搜索：二叉搜索树的遍历是有方向的。\n\n\n\n中序遍历下，输出的二叉搜索树节点的数值是有序序列。\n\n\n\n验证二叉搜索树\n易错点：左子树所有节点小于中间节点，右子树所有节点大于中间节点\n\n\n\npre标记前节点的双指针用法\n\n\n\n验证二叉搜索树\n二叉搜索树的最小绝对差\n二叉搜索树中的众数\n把二叉搜索树转换为累加树\n\n二叉搜索树的修改与构造\n\n\n插入操作\n\n\n\n二叉搜索树中的插入操作：找到位置直接插入\n\n\n\n删除操作\n\n\n\n删除二叉搜索树中的节点：删除非叶子节点：用右子树顶位（比较好理解）。\n修剪二叉搜索树：需要注意修剪情况。\n\n\n\n构造二叉树\n\n\n\n将有序数组转换为二叉搜索树：与构造二叉树基本一致。找到中间节点后切割。\n\n总结\n\n\n涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。\n\n\n求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。\n\n\n求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。\n\n\n算法\n回溯算法\n理论基础\n\n回溯法也可以叫做回溯搜索法，它是一种搜索的方式。\n回溯法解决的问题都可以抽象为树形结构。因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度就构成了树的深度。\n\n效率：回溯法并不是什么高效的算法。因为回溯的本质是穷举\n能解决的问题：组合问题、切割问题、子集问题、排列问题、棋盘问题。\n回溯法模板\nfor循环横向遍历，递归纵向遍历，回溯不断调整结果集。\n\n\n回溯函数模板返回值以及参数回溯算法中函数返回值一般为void。\n\n\n回溯函数终止条件\n\n\n回溯搜索的遍历过程\n\n\nvoid backtracking(参数) &#123;    if (终止条件) &#123;        存放结果;        return;    &#125;    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;        处理节点;        backtracking(路径，选择列表); // 递归        回溯，撤销处理结果    &#125;&#125;\n剪枝\n剪枝精髓是：for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够 题目要求的k个元素了，就没有必要搜索了。\n经典题目\n组合问题\n","categories":["面试"],"tags":["面试","数组","双指针","滑动窗口","链表","哈希表","字符串","KMP"]},{"title":"MybatisPlus多表联查分页，Total计数异常","url":"/2024/04/19/100000004/","content":"\n\n更新\n\n\n24.04.19 初始记录\n\n问题\n使用MP的分表联查，出现了查询出10条数据，但是Total数量显示4的问题。一开始以为是SQL书写错误，但是看了同样一张表的另一个SQL，只是加上了GROUP BY，就可以显示正确的Total数。\nDEBUG\n控制台输出SQL语句，发现count()语句的记录只到了left join前，所以计数异常。\n解决\n使用page方法时：加上以下语句\n// 需要手动把sql的优化关闭。不然计数的时候只会查主表的记录数page.setOptimizeCountSql(false);  \n这里在源码中默认是开启的\n如果不关闭将会导致计算总记录数据的时候，sql语句会丢弃后面的子查询，造成记录数结果不正确。\n","categories":["bug记录","2024"],"tags":["Java","MybatisPlus","BUG"]},{"title":"RestTemplate使用GET请求，返回中文乱码","url":"/2024/05/23/100000004/","content":"\n\n更新\n\n\n24.05.23 初始记录\n\n问题\n测试 RestTemplate 的 Get 请求，返回中文乱码。\n原因\n当 RestTemplate 默认使用 String 存储 body 内容时默认使用 ISO_8859_1 字符集。\n解决\n配置 StringHttpMessageConverter 消息转换器，使用 utf-8 字符集。\n@Bean  public RestTemplate restTemplate() &#123;      RestTemplate restTemplate = new RestTemplate(new OkHttp3ClientHttpRequestFactory());      //消息转换器列表      List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = restTemplate.getMessageConverters();      //配置消息转换器StringHttpMessageConverter，并设置utf‐8      messageConverters.set(1, new StringHttpMessageConverter(StandardCharsets.UTF_8));      return restTemplate;  &#125;","categories":["bug记录","2024"],"tags":["Java","BUG","RestTemplate"]},{"title":"Spring Data Redis","url":"/2023/08/29/100000004/","content":"\n\n前言\nSpring Data Redis 是Spring 框架提供的用于操作Redis的方式。涵盖Redis的安装、Spring Cache结合Redis的使用、Redis连接池的使用和RedisTemplate的使用等内容。\n\n\n参考文章\nSpring Data Redis 最佳实践！\n\n\n更新\n\n\n23.08.29 初始记录\n\nRedis安装\nLinux\n\n\n下载Redis5.0的Docker镜像\n\n\ndocker pull redis:5.0\n\n\n使用Docker命令启动Redis容器\n\n\ndocker run -p 6379:6379 --name redis \\-v /mydata/redis/data:/data \\-d redis:5.0 redis-server --appendonly yes\nWindows\n\n\n下载Windows版本的Redis\n\n\n\n下载后直接解压\n\n\n在当前地址栏输入cmd命令，执行对应的redis启动命令\n\n\n# 注册服务redis-server --service-install redis.windows.conf# 启动服务redis-server --service-start# 停止服务redis-server --service-stop# 删除服务redis-server --service-uninstall\nSpring Cache 操作Redis\nSpring Cache 简介\n\n当Spring Boot 结合Redis来作为缓存使用时，最简单的方式就是使用Spring Cache了，使用它我们无需知道Spring中对Redis的各种操作，仅仅通过它提供的@Cacheable 、@CachePut 、@CacheEvict 、@EnableCaching等注解就可以实现缓存功能。\n\n常用注解\n@EnableCaching\n开启缓存功能，一般放在启动类上。\n@Cacheable\n使用该注解的方法当缓存存在时，会从缓存中获取数据而不执行方法，当缓存不存在时，会执行方法并把返回结果存入缓存中。一般使用在查询方法上，可以设置如下属性：\n\n\nvalue：缓存名称（必填），指定缓存的命名空间；\n\n\nkey：用于设置在命名空间中的缓存key值，可以使用SpEL表达式定义；\n\n\nunless：条件符合则不缓存；\n\n\ncondition：条件符合则缓存。\n\n\n@CachePut\n使用该注解的方法每次执行时都会把返回结果存入缓存中。一般使用在新增方法上，可以设置如下属性：\n\n\nvalue：缓存名称（必填），指定缓存的命名空间；\n\n\nkey：用于设置在命名空间中的缓存key值，可以使用SpEL表达式定义；\n\n\nunless：条件符合则不缓存；\n\n\ncondition：条件符合则缓存。\n\n\n@CacheEvict\n使用该注解的方法执行时会清空指定的缓存。一般使用在更新或删除方法上，可以设置如下属性：\n\n\nvalue：缓存名称（必填），指定缓存的命名空间；\n\n\nkey：用于设置在命名空间中的缓存key值，可以使用SpEL表达式定义；\n\n\ncondition：条件符合则缓存。\n\n\n使用步骤\n基础步骤\n\n\n在pom.xml中添加项目依赖：\n\n\n&lt;!--redis依赖配置--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n修改配置文件application.yml，添加Redis的连接配置\n\n\nspring:  redis:    host: 192.168.6.139 # Redis服务器地址    database: 0 # Redis数据库索引（默认为0）    port: 6379 # Redis服务器连接端口    password: # Redis服务器连接密码（默认为空）    timeout: 1000ms # 连接超时时间\n\n\n在启动类上添加@EnableCaching注解启动缓存功能\n\n\n@EnableCaching@SpringBootApplicationpublic class Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Application.class, args);    &#125;&#125;\n\n\n类中实现缓存功能\n\n\n/** * PmsBrandService实现类 * Created by macro on 2019/4/19. */@Servicepublic class PmsBrandServiceImpl implements PmsBrandService &#123;    @Autowired    private PmsBrandMapper brandMapper;    @CacheEvict(value = RedisConfig.REDIS_KEY_DATABASE, key = &quot;&#x27;pms:brand:&#x27;+#id&quot;)    @Override    public int update(Long id, PmsBrand brand) &#123;        brand.setId(id);        return brandMapper.updateByPrimaryKeySelective(brand);    &#125;    @CacheEvict(value = RedisConfig.REDIS_KEY_DATABASE, key = &quot;&#x27;pms:brand:&#x27;+#id&quot;)    @Override    public int delete(Long id) &#123;        return brandMapper.deleteByPrimaryKey(id);    &#125;    @Cacheable(value = RedisConfig.REDIS_KEY_DATABASE, key = &quot;&#x27;pms:brand:&#x27;+#id&quot;, unless = &quot;#result==null&quot;)    @Override    public PmsBrand getItem(Long id) &#123;        return brandMapper.selectByPrimaryKey(id);    &#125;&#125;\n存储JSON格式数据\n\n给RedisTemplate设置JSON格式的序列化器，并通过配置RedisCacheConfiguration设置超时时间来实现以上需求，此时还需要去除启动类上的@EnableCaching注解，具体配置类RedisConfig代码如下\n\n/** * Redis配置类 * Created by macro on 2020/3/2. */@EnableCaching@Configurationpublic class RedisConfig extends CachingConfigurerSupport &#123;    /**     * redis数据库自定义key     */    public  static final String REDIS_KEY_DATABASE=&quot;mall&quot;;    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;        RedisSerializer&lt;Object&gt; serializer = redisSerializer();        RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();        redisTemplate.setConnectionFactory(redisConnectionFactory);        redisTemplate.setKeySerializer(new StringRedisSerializer());        redisTemplate.setValueSerializer(serializer);        redisTemplate.setHashKeySerializer(new StringRedisSerializer());        redisTemplate.setHashValueSerializer(serializer);        redisTemplate.afterPropertiesSet();        return redisTemplate;    &#125;    @Bean    public RedisSerializer&lt;Object&gt; redisSerializer() &#123;        //创建JSON序列化器        Jackson2JsonRedisSerializer&lt;Object&gt; serializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class);        ObjectMapper objectMapper = new ObjectMapper();        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        serializer.setObjectMapper(objectMapper);        return serializer;    &#125;    @Bean    public RedisCacheManager redisCacheManager(RedisConnectionFactory redisConnectionFactory) &#123;        RedisCacheWriter redisCacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory);        //设置Redis缓存有效期为1天        RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig()                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer())).entryTtl(Duration.ofDays(1));        return new RedisCacheManager(redisCacheWriter, redisCacheConfiguration);    &#125;&#125;\n使用Redis连接池\n\nSpringBoot 1.5.x版本Redis客户端默认是Jedis实现的，SpringBoot 2.x版本中默认客户端是用Lettuce实现的，我们先来了解下Jedis和Lettuce客户端。\n\nJedis vs Lettuce\nJedis在实现上是直连Redis服务，多线程环境下非线程安全，除非使用连接池，为每个 RedisConnection 实例增加物理连接。\nLettuce是一种可伸缩，线程安全，完全非阻塞的Redis客户端，多个线程可以共享一个RedisConnection，它利用Netty NIO框架来高效地管理多个连接，从而提供了异步和同步数据访问方式，用于构建非阻塞的反应性应用程序。\n使用步骤\n\n\n修改application.yml添加Lettuce连接池配置，用于配置线程数量和阻塞等待时间\n\n\nspring:  redis:    lettuce:      pool:        max-active: 8 # 连接池最大连接数        max-idle: 8 # 连接池最大空闲连接数        min-idle: 0 # 连接池最小空闲连接数        max-wait: -1ms # 连接池最大阻塞等待时间，负值表示没有限制\n\n\n由于SpringBoot 2.x中默认并没有使用Redis连接池，所以需要在pom.xml中添加commons-pool2的依赖\n\n\n&lt;dependency&gt;    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n不添加依赖则报错\n\n\nCaused by: java.lang.NoClassDefFoundError: org/apache/commons/pool2/impl/GenericObjectPoolConfig\tat org.springframework.data.redis.connection.lettuce.LettucePoolingClientConfiguration$LettucePoolingClientConfiguYrRUIQWOPrationBuilder.&lt;init&gt;(LettucePoolingClientConfiguration.java:84) ~[spring-data-redis-2.1.5.RELEASE.jar:2.1.5.RELEASE]\tat org.springframework.data.redis.connection.lettuce.LettucePoolingClientConfiguration.builder(LettucePoolingClientConfiguration.java:48) ~[spring-data-redis-2.1.5.RELEASE.jar:2.1.5.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration$PoolBuilderFactory.createBuilder(LettuceConnectionConfiguration.java:149) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration.createBuilder(LettuceConnectionConfiguration.java:107) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration.getLettuceClientConfiguration(LettuceConnectionConfiguration.java:93) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration.redisConnectionFactory(LettuceConnectionConfiguration.java:74) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration$$EnhancerBySpringCGLIB$$5caa7e47.CGLIB$redisConnectionFactory$0(&lt;generated&gt;) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration$$EnhancerBySpringCGLIB$$5caa7e47$$FastClassBySpringCGLIB$$b8ae2813.invoke(&lt;generated&gt;) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:244) ~[spring-core-5.1.5.RELEASE.jar:5.1.5.RELEASE]\tat org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:363) ~[spring-context-5.1.5.RELEASE.jar:5.1.5.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration$$EnhancerBySpringCGLIB$$5caa7e47.redisConnectionFactory(&lt;generated&gt;) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_91]\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_91]\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_91]\tat java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_91]\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\t... 111 common frames omitted\n自由操作Redis\n\n使用RedisTemplate自由缓存方法中产生的中间值\n\nRedisService\n/** * redis操作Service * Created by macro on 2020/3/3. */public interface RedisService &#123;    /**     * 保存属性     */    void set(String key, Object value, long time);    /**     * 保存属性     */    void set(String key, Object value);    /**     * 获取属性     */    Object get(String key);    /**     * 删除属性     */    Boolean del(String key);    /**     * 批量删除属性     */    Long del(List&lt;String&gt; keys);    /**     * 设置过期时间     */    Boolean expire(String key, long time);    /**     * 获取过期时间     */    Long getExpire(String key);    /**     * 判断是否有该属性     */    Boolean hasKey(String key);    /**     * 按delta递增     */    Long incr(String key, long delta);    /**     * 按delta递减     */    Long decr(String key, long delta);    /**     * 获取Hash结构中的属性     */    Object hGet(String key, String hashKey);    /**     * 向Hash结构中放入一个属性     */    Boolean hSet(String key, String hashKey, Object value, long time);    /**     * 向Hash结构中放入一个属性     */    void hSet(String key, String hashKey, Object value);    /**     * 直接获取整个Hash结构     */    Map&lt;Object, Object&gt; hGetAll(String key);    /**     * 直接设置整个Hash结构     */    Boolean hSetAll(String key, Map&lt;String, Object&gt; map, long time);    /**     * 直接设置整个Hash结构     */    void hSetAll(String key, Map&lt;String, Object&gt; map);    /**     * 删除Hash结构中的属性     */    void hDel(String key, Object... hashKey);    /**     * 判断Hash结构中是否有该属性     */    Boolean hHasKey(String key, String hashKey);    /**     * Hash结构中属性递增     */    Long hIncr(String key, String hashKey, Long delta);    /**     * Hash结构中属性递减     */    Long hDecr(String key, String hashKey, Long delta);    /**     * 获取Set结构     */    Set&lt;Object&gt; sMembers(String key);    /**     * 向Set结构中添加属性     */    Long sAdd(String key, Object... values);    /**     * 向Set结构中添加属性     */    Long sAdd(String key, long time, Object... values);    /**     * 是否为Set中的属性     */    Boolean sIsMember(String key, Object value);    /**     * 获取Set结构的长度     */    Long sSize(String key);    /**     * 删除Set结构中的属性     */    Long sRemove(String key, Object... values);    /**     * 获取List结构中的属性     */    List&lt;Object&gt; lRange(String key, long start, long end);    /**     * 获取List结构的长度     */    Long lSize(String key);    /**     * 根据索引获取List中的属性     */    Object lIndex(String key, long index);    /**     * 向List结构中添加属性     */    Long lPush(String key, Object value);    /**     * 向List结构中添加属性     */    Long lPush(String key, Object value, long time);    /**     * 向List结构中批量添加属性     */    Long lPushAll(String key, Object... values);    /**     * 向List结构中批量添加属性     */    Long lPushAll(String key, Long time, Object... values);    /**     * 从List结构中移除属性     */    Long lRemove(String key, long count, Object value);&#125;\nRedisServiceImpl\n/** * redis操作实现类 * Created by macro on 2020/3/3. */@Servicepublic class RedisServiceImpl implements RedisService &#123;    @Autowired    private RedisTemplate&lt;String, Object&gt; redisTemplate;    @Override    public void set(String key, Object value, long time) &#123;        redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);    &#125;    @Override    public void set(String key, Object value) &#123;        redisTemplate.opsForValue().set(key, value);    &#125;    @Override    public Object get(String key) &#123;        return redisTemplate.opsForValue().get(key);    &#125;    @Override    public Boolean del(String key) &#123;        return redisTemplate.delete(key);    &#125;    @Override    public Long del(List&lt;String&gt; keys) &#123;        return redisTemplate.delete(keys);    &#125;    @Override    public Boolean expire(String key, long time) &#123;        return redisTemplate.expire(key, time, TimeUnit.SECONDS);    &#125;    @Override    public Long getExpire(String key) &#123;        return redisTemplate.getExpire(key, TimeUnit.SECONDS);    &#125;    @Override    public Boolean hasKey(String key) &#123;        return redisTemplate.hasKey(key);    &#125;    @Override    public Long incr(String key, long delta) &#123;        return redisTemplate.opsForValue().increment(key, delta);    &#125;    @Override    public Long decr(String key, long delta) &#123;        return redisTemplate.opsForValue().increment(key, -delta);    &#125;    @Override    public Object hGet(String key, String hashKey) &#123;        return redisTemplate.opsForHash().get(key, hashKey);    &#125;    @Override    public Boolean hSet(String key, String hashKey, Object value, long time) &#123;        redisTemplate.opsForHash().put(key, hashKey, value);        return expire(key, time);    &#125;    @Override    public void hSet(String key, String hashKey, Object value) &#123;        redisTemplate.opsForHash().put(key, hashKey, value);    &#125;    @Override    public Map&lt;Object, Object&gt; hGetAll(String key) &#123;        return redisTemplate.opsForHash().entries(key);    &#125;    @Override    public Boolean hSetAll(String key, Map&lt;String, Object&gt; map, long time) &#123;        redisTemplate.opsForHash().putAll(key, map);        return expire(key, time);    &#125;    @Override    public void hSetAll(String key, Map&lt;String, Object&gt; map) &#123;        redisTemplate.opsForHash().putAll(key, map);    &#125;    @Override    public void hDel(String key, Object... hashKey) &#123;        redisTemplate.opsForHash().delete(key, hashKey);    &#125;    @Override    public Boolean hHasKey(String key, String hashKey) &#123;        return redisTemplate.opsForHash().hasKey(key, hashKey);    &#125;    @Override    public Long hIncr(String key, String hashKey, Long delta) &#123;        return redisTemplate.opsForHash().increment(key, hashKey, delta);    &#125;    @Override    public Long hDecr(String key, String hashKey, Long delta) &#123;        return redisTemplate.opsForHash().increment(key, hashKey, -delta);    &#125;    @Override    public Set&lt;Object&gt; sMembers(String key) &#123;        return redisTemplate.opsForSet().members(key);    &#125;    @Override    public Long sAdd(String key, Object... values) &#123;        return redisTemplate.opsForSet().add(key, values);    &#125;    @Override    public Long sAdd(String key, long time, Object... values) &#123;        Long count = redisTemplate.opsForSet().add(key, values);        expire(key, time);        return count;    &#125;    @Override    public Boolean sIsMember(String key, Object value) &#123;        return redisTemplate.opsForSet().isMember(key, value);    &#125;    @Override    public Long sSize(String key) &#123;        return redisTemplate.opsForSet().size(key);    &#125;    @Override    public Long sRemove(String key, Object... values) &#123;        return redisTemplate.opsForSet().remove(key, values);    &#125;    @Override    public List&lt;Object&gt; lRange(String key, long start, long end) &#123;        return redisTemplate.opsForList().range(key, start, end);    &#125;    @Override    public Long lSize(String key) &#123;        return redisTemplate.opsForList().size(key);    &#125;    @Override    public Object lIndex(String key, long index) &#123;        return redisTemplate.opsForList().index(key, index);    &#125;    @Override    public Long lPush(String key, Object value) &#123;        return redisTemplate.opsForList().rightPush(key, value);    &#125;    @Override    public Long lPush(String key, Object value, long time) &#123;        Long index = redisTemplate.opsForList().rightPush(key, value);        expire(key, time);        return index;    &#125;    @Override    public Long lPushAll(String key, Object... values) &#123;        return redisTemplate.opsForList().rightPushAll(key, values);    &#125;    @Override    public Long lPushAll(String key, Long time, Object... values) &#123;        Long count = redisTemplate.opsForList().rightPushAll(key, values);        expire(key, time);        return count;    &#125;    @Override    public Long lRemove(String key, long count, Object value) &#123;        return redisTemplate.opsForList().remove(key, count, value);    &#125;&#125;\nRedisController\n\n简单测试在Controller中进行操作\n\n/** * Redis测试Controller * Created by macro on 2020/3/3. */@Api(tags = &quot;RedisController&quot;, description = &quot;Redis测试&quot;)@Controller@RequestMapping(&quot;/redis&quot;)public class RedisController &#123;    @Autowired    private RedisService redisService;    @Autowired    private PmsBrandService brandService;    @ApiOperation(&quot;测试简单缓存&quot;)    @RequestMapping(value = &quot;/simpleTest&quot;, method = RequestMethod.GET)    @ResponseBody    public CommonResult&lt;PmsBrand&gt; simpleTest() &#123;        List&lt;PmsBrand&gt; brandList = brandService.list(1, 5);        PmsBrand brand = brandList.get(0);        String key = &quot;redis:simple:&quot; + brand.getId();        redisService.set(key, brand);        PmsBrand cacheBrand = (PmsBrand) redisService.get(key);        return CommonResult.success(cacheBrand);    &#125;    @ApiOperation(&quot;测试Hash结构的缓存&quot;)    @RequestMapping(value = &quot;/hashTest&quot;, method = RequestMethod.GET)    @ResponseBody    public CommonResult&lt;PmsBrand&gt; hashTest() &#123;        List&lt;PmsBrand&gt; brandList = brandService.list(1, 5);        PmsBrand brand = brandList.get(0);        String key = &quot;redis:hash:&quot; + brand.getId();        Map&lt;String, Object&gt; value = BeanUtil.beanToMap(brand);        redisService.hSetAll(key, value);        Map&lt;Object, Object&gt; cacheValue = redisService.hGetAll(key);        PmsBrand cacheBrand = BeanUtil.mapToBean(cacheValue, PmsBrand.class, true);        return CommonResult.success(cacheBrand);    &#125;    @ApiOperation(&quot;测试Set结构的缓存&quot;)    @RequestMapping(value = &quot;/setTest&quot;, method = RequestMethod.GET)    @ResponseBody    public CommonResult&lt;Set&lt;Object&gt;&gt; setTest() &#123;        List&lt;PmsBrand&gt; brandList = brandService.list(1, 5);        String key = &quot;redis:set:all&quot;;        redisService.sAdd(key, (Object[]) ArrayUtil.toArray(brandList, PmsBrand.class));        redisService.sRemove(key, brandList.get(0));        Set&lt;Object&gt; cachedBrandList = redisService.sMembers(key);        return CommonResult.success(cachedBrandList);    &#125;    @ApiOperation(&quot;测试List结构的缓存&quot;)    @RequestMapping(value = &quot;/listTest&quot;, method = RequestMethod.GET)    @ResponseBody    public CommonResult&lt;List&lt;Object&gt;&gt; listTest() &#123;        List&lt;PmsBrand&gt; brandList = brandService.list(1, 5);        String key = &quot;redis:list:all&quot;;        redisService.lPushAll(key, (Object[]) ArrayUtil.toArray(brandList, PmsBrand.class));        redisService.lRemove(key, 1, brandList.get(0));        List&lt;Object&gt; cachedBrandList = redisService.lRange(key, 0, 3);        return CommonResult.success(cachedBrandList);    &#125;&#125;","categories":["后端项目","准备工作"],"tags":["Redis","Spring"]},{"title":"聚合支付-项目介绍","url":"/2024/05/15/100000004/","content":"\n\n前言\n之前的项目已经接触了支付宝、微信、银联三种支付方式了。正好辞职把这个项目写一遍，看了技术栈有一些是没有接触过的，应该能学到很多。\n项目git地址：https://gitee.com/kiml_rgb/shanjupay.git\n前端项目地址：https://gitee.com/kiml_rgb/shanjupay_web\n\n\n更新\n\n\n24.05.16 初始记录（抄了一些项目描述）\n\n项目概述\n聚合支付目前主要的做法就是线上聚合收银台(开放API)，线下C2B一码多付、线下B2C商家扫码。平台应以SaaS服务形式提供给各商户订单管理、门店管理、财务数据统计等基础服务，闪聚支付还以支付为入口，通过广告、营销、金融等服务，构建一个移动支付的全生态系统。\n功能模块\n平台主要包括三个模块：官网&amp;开放平台、商户平台、运营平台，详细功能如下：\n\n\n\n\n功能模块名称\n功能说明\n\n\n\n\n官网&amp;开放平台\n产品展示、功能介绍、帮助中心和开发者中心\n\n\n商户平台-首页\n提供商户注册、登录、基本信息查看、数据看板\n\n\n商户平台-账户管理\n提供商户企业资质认证、企业信息查看和套餐购买\n\n\n商户平台-支付管理\n为商户提供应用创建、渠道参数配置、交易总览和开启支付(生成二维码)等\n\n\n商户平台-门店管理\n为商户提供新增门店、店长分配、门店导入等\n\n\n商户平台-员工管理\n为商户提供新增员工、定义角色、分配角色等\n\n\n商户平台-优惠管理\n为商户提供优惠券管理、活动统计等\n\n\n运营平台-商户管理\n对商户进行检索、审核和订单统计\n\n\n运营平台-优惠管理\n为商户设置优惠策略和优惠券发送\n\n\n运营平台-管理员管理\n运营平台-管理员管理\n\n\n\n业务主体流程\n\n项目技术架构\n技术架构\n\n技术栈\n\n重点了解微服务技术栈：服务端基于Spring Boot构建，采用Spring Cloud Alibaba微服务架构。\n\n\n基础设施业务数据持久化采用MySQL，数据缓存采用Redis，采用RocketMQ的事务消息机制完成部分场景下的分布式事务控制，采用第三方云平台完成文件上传与分布式存储。\n\n\n组件系统微服务基于SpringBoot开发，数据库连接池采用Druid，POJO构建采用Lombok，日志系统采用Log4j2， Guava工具类库，Mybatis Plus持久层接口实现，Sharding-jdbc分库分表组件，Swagger接口规范组件，XXL-job 分布式任务调度组件，Sentinel限流组件等。\n\n\n接入 Zuul网关完成客户端认证、路由转发等功能，Dubbo RPC完成微服务远程调用，JWT提供前后端令牌管理方案。\n\n\n视图平台支持H5、PC等各种前端。\n\n\n","categories":["后端项目","聚合支付"],"tags":["Java"]},{"title":"聚合支付-环境搭建","url":"/2024/05/16/100000004/","content":"\n\n前言\n环境搭建先是在windows本机上，后面听说在windows上可以下载docker，所以会补充windows上的docker内的环境安装。\n\n\n更新\n\n\n24.05.16 初始记录（windows系统的环境安装）\n\n服务端搭建\n开发环境\nJava 1.8 这个网上教程很多，就不赘述了。\nMaven 使用本地仓库，可配置下载镜像路径。\nNacos服务发现与配置中心\n微服务开发需要构建服务发现中心、配置中心，本项目采用Nacos来实现。可以直接导入项目nacos文件夹下面的配置文件。注意需要新建命名空间，并修改配置文件中的命名空间变量。\nMybatis Plus\n本项目数据库使用 mysql-community-5.7，请自行安装MySQL数据库。本项目持久层采用Mybatis Plus作为技术构架，Mybatis Plus是在Mybatis基础上作了很好的封装，方便系统开 发。\n导入项目SQL\n使用客户端连接MySQL，执行项目sql文件夹下面的shanjupay-init.sql文件。数据库清单如下：\n\n\n\n数据库名称\n数据内容\n\n\n\n\nshanjupay_merchant_service\n用户中心数据\n\n\nshanjupay_transaction\n交易服务数据库\n\n\n\n\n\n\n\n搭建项目服务\n\n\n\n服务名\n职责\n\n\n\n\n\n商户平台应用(shanjupay-merchant-application)\n为前端提供商户管理功能\n\n\n\n商户服务API(shanjupay-merchant-api)\n实现商户服务提供的接口\n\n\n\n商户服务(shanjupay-merchant-service)\n实现商户服务的所有接口\n\n\n\n工程在架构中的位置如下：\n\n\n\n\n\n\n\n\n\n\n","categories":["后端项目","聚合支付"],"tags":["Java"]},{"title":"代码随想录算法训练营第一天-704二分查找、27移除元素","url":"/2024/04/17/100000004/","content":"\n\n前言\n状态：可以通过\n\n\n更新\n\n\n24.04.17 初始记录\n\n初步题解\n704二分查找\n题目链接：https://leetcode.cn/problems/binary-search/\npublic class LE704 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          int[] nums = Arrays.stream(scanner.nextLine().split(&quot;,&quot;))                  .mapToInt(Integer::parseInt)                  .toArray();          int target = Integer.parseInt(scanner.nextLine());          System.out.println(search(nums, target));      &#125;        public static int search(int[] nums, int target) &#123;          for (int i = 0, j = nums.length - 1; i &lt;= j; ) &#123;              int k = (i + j) / 2;              if (nums[k] == target) &#123;                  return k;              &#125;              if (nums[k] &gt; target) &#123;                  j = k - 1;              &#125; else &#123;                  i = k + 1;              &#125;          &#125;            return -1;      &#125;  &#125;\n27移除元素\n题目链接：https://leetcode.cn/problems/remove-element/\npublic class LE27 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          int[] nums = Arrays.stream(scanner.nextLine().split(&quot;,&quot;))                  .mapToInt(Integer::parseInt)                  .toArray();          int val = Integer.parseInt(scanner.nextLine());          System.out.println(removeElement(nums, val));      &#125;        public static int removeElement(int[] nums, int val) &#123;          int i, j;          for (i = 0, j = nums.length - 1; i &lt;= j ; ) &#123;              // 第一次修改 -&gt; if改为while              // 第三次修改 -&gt; 加上j的边界值限制, 不然会数组越界              while (j &gt;= 0 &amp;&amp; nums[j] == val) &#123;                  j--;              &#125;              while (i &lt;= nums.length - 1 &amp;&amp; nums[i] != val) &#123;                  i++;              &#125;              // 第二次修改 -&gt; 加上i &lt; j的判断, 否则最后一次交换会把数组换乱              if (i &lt; j) &#123;                  int temp = nums[j];                  nums[j] = nums[i];                  nums[i] = temp;              &#125;          &#125;          return i;      &#125;  &#125;\n看讲解\n704二分查找\n文章讲解：https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html\n视频讲解：https://www.bilibili.com/video/BV1fA4y1o715\npublic static int search(int[] nums, int target) &#123;      for (int i = 0, j = nums.length - 1; i &lt;= j; ) &#123; \t    // 这里需要写成这种方式防止整数溢出\t    // 或者也可以写成 int k = i + ((j - i) &gt;&gt; 1);\t    int k = i + (j - i) / 2;        // int k = (i + j) / 2;          if (nums[k] == target) &#123;              return k;          &#125;          if (nums[k] &gt; target) &#123;              j = k - 1;          &#125; else &#123;              i = k + 1;          &#125;      &#125;      return -1;  &#125;\n27移除元素\n文章讲解：https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html\n视频讲解：https://www.bilibili.com/video/BV12A4y1Z7LP\n其实。。一开始看题目我没有反应过来暴力解法是什么。第一时间当然是想到iterator().remove()，但是不行。老实说，那个题目里的O(1)额外空间我也不知道怎么算的。暴力解法是双层循环，删除之后的所有都前移。双指针和我想的也完全不一样，我也不知道我写的这个叫什么。。\npublic static int removeElement(int[] nums, int val) &#123;      int i = 0;      for (int j = 0; j &lt; nums.length; j++) &#123;\t    // 当 val == nums[j]时，只有j++\t    // 下一次不相等时，前一个指针的后一位直接指向当前的j，相当于中间的元素都被删除了。        if (val != nums[j]) &#123;              nums[i++]= nums[j];          &#125;      &#125;      return i;  &#125;\n总结\n其实都属于已经知道题解方式再去看题，加上是简单算法，所以感觉难度不是很大。（也可能我只是为了找工作，对我来说解出来就OK）\n二分查找\n前提：\n1、有序数组\n2、数组中无重复元素注意：整数数值越界的问题\n","categories":["面试","代码随想录"],"tags":["数组","二分查找","双指针"]},{"title":"代码随想录算法训练营第二天-977有序数组的平方、209长度最小的子数组、59螺旋矩阵II","url":"/2024/04/18/100000005/","content":"\n\n前言\n状态：977、209通过。59没有思路\n\n\n更新\n\n\n24.04.18 初始记录24.04.21 补充螺旋矩阵的题解\n\n初步题解\n977有序数组的平方\n题目链接：https://leetcode.cn/problems/squares-of-a-sorted-array/\npublic class LE977 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          String s = scanner.nextLine();          int[] nums = Arrays.stream(s.substring(1, s.length() - 1).split(&quot;,&quot;))                  .mapToInt(Integer::parseInt)                  .toArray();          System.out.println(Arrays.toString(sortedSquares(nums)));      &#125;  \t// 关键在于非递增顺序，获取平方数，组成新的非递增序列\t// 新数组的最大数一定来自于旧数组的两端。平方的大小一定从两边向中间递减\t// 用双指针，依次将最大值添加到新数组，并向内移动    public static int[] sortedSquares(int[] nums) &#123;          int i = 0;          int j = nums.length - 1;          int k = nums.length - 1;          int[] ints = new int[nums.length];            while (i &lt;= j) &#123;              int i2 = nums[i] * nums[i];              int j2 = nums[j] * nums[j];              ints[k] = Math.max(i2, j2);              k--;              if (i2 &gt;= j2) &#123;                  i++;              &#125; else &#123;                  j--;              &#125;          &#125;        return ints;      &#125;  &#125;\n209长度最小的子数组\n题目链接：https://leetcode.cn/problems/minimum-size-subarray-sum/\npublic class LE209 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          int target = Integer.parseInt(scanner.nextLine());          String s = scanner.nextLine();          int[] nums = Arrays.stream(s.substring(1, s.length() - 1).split(&quot;,&quot;))                  .mapToInt(Integer::parseInt)                  .toArray();          System.out.println(minSubArrayLen(target, nums));      &#125;  \t// 看题就知道是滑动窗口，前几天刚好做过    public static int minSubArrayLen(int target, int[] nums) &#123;          int min = 0;          for (int i = 0, j = 0; i &lt; nums.length &amp;&amp; j &lt; nums.length; ) &#123;              int subArraySum = getSum(nums, i, j);              if (target == subArraySum) &#123;                  min = Math.min(min, j - i + 1);                  i++;                  j = i;                  if (min == 1) &#123;                      break;                  &#125;              &#125; else if (target &lt; subArraySum) &#123;                  i++;                  j = i;              &#125; else &#123;                  j++;              &#125;          &#125;          return min;      &#125;        private static int getSum(int[] nums, int i, int j) &#123;          int sum = 0;          for (int k = i; k &lt;= j; k++) &#123;              sum += nums[k];          &#125;          return sum;      &#125;  &#125;\n59螺旋矩阵II\n题目链接：https://leetcode.cn/problems/spiral-matrix-ii/\n// 看了题目没有什么算法上的思路，打算直接看题解\n看讲解\n977有序数组的平方\n文章讲解：https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html\n视频讲解： https://www.bilibili.com/video/BV1QB4y1D7ep\n// 这里的题解和我的想法差不多，就不多写了\n209长度最小的子数组\n文章讲解：https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html\n视频讲解：https://www.bilibili.com/video/BV1tZ4y1q7XE\n还有一个进阶的解法，打算明天再看看，不能再熬夜了。\n// 这里的题解和我的想法差不多，就不多写了// 进阶部分等之后有时间了补充\n59螺旋矩阵II\n文章讲解：https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html\n视频讲解：https://www.bilibili.com/video/BV1SL4y1N7mV/\n// 大致看了文章讲解，就是把四条边按规律读出。// 没有看答案，按讲解写了一个版本，但是很奇怪，输出的xy和我想象中的不一样// 打了断点才发现，二维数组的表现和坐标不一样。public class LE59 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          int n = Integer.parseInt(scanner.nextLine());          System.out.println(Arrays.deepToString(generateMatrix(n)));      &#125;        public static int[][] generateMatrix(int n) &#123;          int[][] ints = new int[n][n];          int startX = 0;          int startY = 0;          int k = 1;          int loop = 1;          int i, j;          // 这边需要加上边界条件        while (k &lt;= n * n &amp;&amp; loop &lt;= n / 2) &#123;              for (i = startX; i &lt; n - loop; i++) &#123;                  ints[i][startY] = k++;              &#125;              for (j = startY; j &lt; n - loop; j++) &#123;                  ints[i][j] = k++;              &#125;              for (; i &gt; startX; i--) &#123;                  ints[i][j] = k++;              &#125;              for (; j &gt; startY ; j--) &#123;                  ints[i][j] = k++;              &#125;              startX++;              startY++;              loop++;          &#125;          // 奇数矩阵需要特殊处理        if (n % 2 == 1) &#123;              ints[startX][startY] = k;          &#125;          return ints;      &#125;  &#125;// 重新按二维数组的写法写了一遍。这个需要加到总结中// 二位数组中：j才是横坐标，i是纵坐标public static int[][] generateMatrix(int n) &#123;      int[][] ints = new int[n][n];      int startX = 0;      int startY = 0;      int k = 1;      int loop = 1;      int i, j;        while (k &lt;= n * n &amp;&amp; loop &lt;= n / 2) &#123;          for (j = startY; j &lt; n - loop; j++) &#123;              ints[startX][j] = k++;          &#125;          for (i = startX; i &lt; n - loop; i++) &#123;              ints[i][j] = k++;          &#125;          for (; j &gt; startY ; j--) &#123;              ints[i][j] = k++;          &#125;          for (; i &gt; startX; i--) &#123;              ints[i][j] = k++;          &#125;          startX++;          startY++;          loop++;      &#125;      if (n % 2 == 1) &#123;          ints[startX][startY] = k;      &#125;      return ints;  &#125;\n","categories":["面试","代码随想录"],"tags":["数组","双指针","滑动窗口","螺旋数组"]},{"title":"代码随想录算法训练营第三天-203移除链表元素、707设计链表、206反转链表","url":"/2024/04/24/100000005/","content":"\n\n前言\n状态：链表定义有点不会，基本上是都是看了一半图解后写出来的，而且耗时比较长，可能二刷会好一点吧。\n\n\n更新\n\n\n24.04.24 初始记录24.05.15 完成题目\n\n初步题解\n203移除链表元素\n题目链接：https://leetcode.cn/problems/remove-linked-list-elements/description/\n刚开始看到有点懵，习惯了写输入输出，这里不知道怎么输入了。链表这块需要先初始化链表。没有写出来后面是查看了解析。在具体方法那里，一直尝试只用一个链表做操作，但是运行总是得不到想要的结果。\npublic class LE203 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          String s = scanner.nextLine();          if (&quot;&quot;.equals(s.trim())) &#123;              System.out.println(new LinkedList());              return;          &#125;          List&lt;Integer&gt; head = Arrays.stream(s.split(&quot;,&quot;)).map(Integer::parseInt).collect(Collectors.toList());          int val = Integer.parseInt(scanner.nextLine());            // 初始化链表          LinkedList linkedList = new LinkedList();          for (Integer integer : head) &#123;              linkedList.add(integer);          &#125;              ListNode listNode = removeElements(linkedList.head, val);          System.out.println(listNode);      &#125;  \t// 一开始只能写成这个样子    public static ListNode removeElements(ListNode head, int val) &#123;  \t\twhile (head != null &amp;&amp; head.val == val) &#123;  \t\t    head = head.next;  \t\t&#125;  \t\t  \t\tif (head == null) &#123;  \t\t    return head;  \t\t&#125;    &#125;        /**       * 链表的定义       */      public static class ListNode &#123;          int val;          ListNode next;            ListNode() &#123;          &#125;            ListNode(int val) &#123;              this.val = val;          &#125;            ListNode(int val, ListNode next) &#123;              this.val = val;              this.next = next;          &#125;      &#125;        public static class LinkedList &#123;          private ListNode head;            public ListNode getHead() &#123;              return head;          &#125;            public void setHead(ListNode head) &#123;              this.head = head;          &#125;            public ListNode getCurrent() &#123;              return current;          &#125;            public void setCurrent(ListNode current) &#123;              this.current = current;          &#125;            private ListNode current;            public void add(int val) &#123;              if (head == null) &#123;                  head = new ListNode(val);                  current = head;              &#125; else &#123;                  current.next = new ListNode(val);                  current = current.next;              &#125;          &#125;      &#125;  &#125;\n707设计链表\n题目链接：https://leetcode.cn/problems/design-linked-list/description/\n修修改改了很久才通过，要考虑头节点，尾节点。\npublic class LE707 &#123;      public static void main(String[] args) &#123;          MyLinkedList myLinkedList = new MyLinkedList();          myLinkedList.addAtHead(1);          myLinkedList.addAtTail(3);          // 链表变为 1-&gt;2-&gt;3        myLinkedList.addAtIndex(1, 2);          // 返回 2        myLinkedList.get(1);          // 现在，链表变为 1-&gt;3        myLinkedList.deleteAtIndex(1);          // 返回 3        myLinkedList.get(1);      &#125;        public static class ListNode &#123;          private int val;          private ListNode next;            public ListNode() &#123;          &#125;            public ListNode(int val) &#123;              this.val = val;          &#125;      &#125;        public static class MyLinkedList &#123;          private int size;          private ListNode head;            public MyLinkedList() &#123;              size = 0;              head = new ListNode(0);          &#125;            public int get(int index) &#123;              if (index &lt;= -1 || index &gt;= size) &#123;                  return -1;              &#125;                ListNode indexNode = head;              for (int i = 0; i &lt; index; i++) &#123;                  indexNode = indexNode.next;              &#125;                return indexNode.val;          &#125;            public void addAtHead(int val) &#123;              if (size == 0) &#123;                  size++;                  head = new ListNode(val);                  return;              &#125;              addAtIndex(0, val);          &#125;            public void addAtTail(int val) &#123;              addAtIndex(size, val);          &#125;            public void addAtIndex(int index, int val) &#123;              if (index &gt; size) &#123;                  return;              &#125;                if (index &lt; 0) &#123;                  index = 0;              &#125;                ListNode pre = head;              // 找到前一个节点的位置              for (int i = 0; i &lt; index - 1; i++) &#123;                  pre = pre.next;              &#125;                ListNode listNode = new ListNode(val);              // 如果插入节点为头节点              if (index == 0) &#123;                  listNode.next = pre;                  head = listNode;                  // 长度++                  size++;                  return;              &#125;              // 如果插入位置正好是尾节点 直接前节点指向这个节点 然后return              if (index == size) &#123;                  pre.next = listNode;                  // 长度++                  size++;                  return;              &#125;                // 否则              // 先把当前节点的后指针指向前节点的next              listNode.next = pre.next;              // 再把前节点的后指针指向当前节点              pre.next = listNode;              // 长度++              size++;          &#125;            public void deleteAtIndex(int index) &#123;              if (index &gt;= size || index &lt; 0) &#123;                  return;              &#125;                ListNode pre = head;              for (int i = 0; i &lt; index - 1; i++) &#123;                  pre = pre.next;              &#125;              // 如果删除节点为头节点              if (index == 0) &#123;                  head = head.next;                  size--;                  return;              &#125;              // 如果删除位置正好是尾节点 直接前节点指向null 然后return              if (index + 1 == size) &#123;                  pre.next = null;                  // 长度++                  size--;                  return;              &#125;              // 改变当前节点的前节点的后指针，指向下一个节点              pre.next = pre.next.next;              // 长度--              size--;          &#125;      &#125;  &#125;\n206反转链表\n题目链接：https://leetcode.cn/problems/reverse-linked-list/description/\n偷偷看了下视频图解，按这个思路写的代码：还是比较简单的\n\npublic static LE707.ListNode reverseList(LE707.ListNode head) &#123;      LE707.ListNode pre = null;      LE707.ListNode cur = head;      while (cur != null) &#123;          LE707.ListNode temp = cur.next;          cur.next = pre;          pre = cur;          cur = temp;      &#125;        return pre;  &#125;\n看讲解\n203移除链表元素\n题目链接/文章讲解/视频讲解：：https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html\n// 一开始没有搞懂，前面一个循环是用来干什么的。// 但是去除前面一步，执行[7,7,7,7] 7 这个用例会多出一个7public static ListNode removeElements(ListNode head, int val) &#123;      while (head != null &amp;&amp; head.val == val) &#123;          head = head.next;      &#125;        if (head == null) &#123;          return head;      &#125;        ListNode pre = head;      ListNode cur = head.next;      while (cur != null) &#123;          if (cur.val == val) &#123;              pre.next = cur.next;          &#125; else &#123;              pre = cur;          &#125;          cur = cur.next;      &#125;      return head;  &#125;\n这个题共有三种题解法：\n\n\n第一种：添加虚节点。在原先的链表前，添加一个虚拟节点，用于处理可能被删除的头节点。因为删除可能涉及到头节点，所以在方法二中，第一个循环把头节点可能需要删除的情况直接处理掉。\n\n\n第二种：不添加虚节点。用一个循环处理可能会被删除的头节点。\n\n\n第三种：不加虚节点，同时不添加pre节点。加上判断删除节点是否是尾节点。\n\n\n707设计链表\n题目链接/文章讲解/视频讲解：https://programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html\n//单链表class ListNode &#123;    int val;    ListNode next;    ListNode()&#123;&#125;    ListNode(int val) &#123;        this.val=val;    &#125;&#125;class MyLinkedList &#123;    //size存储链表元素的个数    int size;    //虚拟头结点    ListNode head;    //初始化链表    public MyLinkedList() &#123;        size = 0;        head = new ListNode(0);    &#125;    //获取第index个节点的数值，注意index是从0开始的，第0个节点就是头结点    public int get(int index) &#123;        //如果index非法，返回-1        if (index &lt; 0 || index &gt;= size) &#123;            return -1;        &#125;        ListNode currentNode = head;        //包含一个虚拟头节点，所以查找第 index+1 个节点        for (int i = 0; i &lt;= index; i++) &#123;            currentNode = currentNode.next;        &#125;        return currentNode.val;    &#125;    //在链表最前面插入一个节点，等价于在第0个元素前添加    public void addAtHead(int val) &#123;        addAtIndex(0, val);    &#125;    //在链表的最后插入一个节点，等价于在(末尾+1)个元素前添加    public void addAtTail(int val) &#123;        addAtIndex(size, val);    &#125;    // 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。    // 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点    // 如果 index 大于链表的长度，则返回空    public void addAtIndex(int index, int val) &#123;        if (index &gt; size) &#123;            return;        &#125;        if (index &lt; 0) &#123;            index = 0;        &#125;        size++;        //找到要插入节点的前驱        ListNode pred = head;        for (int i = 0; i &lt; index; i++) &#123;            pred = pred.next;        &#125;        ListNode toAdd = new ListNode(val);        toAdd.next = pred.next;        pred.next = toAdd;    &#125;    //删除第index个节点    public void deleteAtIndex(int index) &#123;        if (index &lt; 0 || index &gt;= size) &#123;            return;        &#125;        size--;        if (index == 0) &#123;            head = head.next;\t    return;        &#125;        ListNode pred = head;        for (int i = 0; i &lt; index ; i++) &#123;            pred = pred.next;        &#125;        pred.next = pred.next.next;    &#125;&#125;\n参考中是直接设置了虚拟头节点解决的，代码会更加简洁。还有一种双向链表的方法，没有仔细研究。\n206反转链表\n题目链接/文章讲解/视频讲解：https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html\n// 递归 class Solution &#123;    public ListNode reverseList(ListNode head) &#123;        return reverse(null, head);    &#125;    private ListNode reverse(ListNode prev, ListNode cur) &#123;        if (cur == null) &#123;            return prev;        &#125;        ListNode temp = null;        temp = cur.next;// 先保存下一个节点        cur.next = prev;// 反转        // 更新prev、cur位置        // prev = cur;        // cur = temp;        // 此时cur为前一个节点，temp为后一个节点。两个节点位置交换，做递归。        return reverse(cur, temp);    &#125;&#125;\n按照讲解，一开始写的是双指针方法。\nLeetCode进阶处写了还可以使用递归解决。解法在解析中给出。\n","categories":["面试","代码随想录"],"tags":["双指针","链表","虚拟头节点"]},{"title":"代码随想录算法训练营第四天-24两两交换链表中的节点、19删除链表的倒数第N个节点、面试题02.07.链表相交、142环形链表II","url":"/2024/05/16/100000005/","content":"\n\n前言\n状态：24需要看部分题解才能AC，19直接看的题解解题，面试题02.07可以AC（但是还有一种解法，完全想不到），142不会（第一次做真的有人能有思路吗🥲）\n\n\n更新\n\n\n24.05.16 初始记录24.05.22 后两题的完成\n\n初步题解\n24两两交换链表中的节点\n题目链接：(https://leetcode.cn/problems/swap-nodes-in-pairs/description/)\n// 第一遍完全没有看题解的写法，不能通过public static LE707.ListNode swapPairs(LE707.ListNode head) &#123;      while (head.next != null) &#123;          LE707.ListNode temp = head.next.next;          head.next.next = head;          head.next = temp;          head = head.next.next;      &#125;      return head;  &#125;// 第二遍看了部分文字题解// 发现少了头节点，即前一个节点的后节点的指向那一步public static LE707.ListNode swapPairs(LE707.ListNode head) &#123;      LE707.ListNode dumyHead = new LE707.ListNode(-1);      dumyHead.next = head;        // 记录当前节点的位置，便于循环      LE707.ListNode cur = dumyHead;      while (cur.next != null &amp;&amp; cur.next.next != null) &#123;          // 记录原来，后一个节点需要指向的节点          LE707.ListNode temp = cur.next.next.next;          LE707.ListNode node2 = cur.next.next;          LE707.ListNode node1 = cur.next;          cur.next = node2;          cur.next.next = node1;          cur.next.next.next = temp;          cur = node1;      &#125;      return dumyHead.next;  &#125;\n19删除链表的倒数第N个节点\n题目链接：https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/\n这道题直接看的解析。\n面试题02.07链表相交\n题目链接：https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/\n提交是可以的，但是本地跑不行，看了一下可能是本地测试的add方法，每次都是新建一个对象，两个链表中的对象地址是不一致的，导致tempA == tempB这一步始终判断失败。\n/**   * 思路：最后都会合成到一个链   * 可以把两个链按末尾对其，即较长链的指针起始与短链对齐   * @param headA headA   * @param headB headB   * @return 相交部分   */  public static LE707.ListNode getIntersectionNode(LE707.ListNode headA, LE707.ListNode headB) &#123;      int intersectVal = 0;      int skipA = 0;      int skipB = 0;        LE707.ListNode tempA = headA;      LE707.ListNode tempB = headB;        int sizeA = 0;      while (tempA != null) &#123;          sizeA++;          tempA = tempA.next;      &#125;        int sizeB = 0;      while (tempB != null) &#123;          sizeB++;          tempB = tempB.next;      &#125;        if (sizeA == 0 || sizeB == 0) &#123;          return null;      &#125;        tempA = headA;      tempB = headB;      // 尾端对其      if (sizeA &gt;= sizeB) &#123;          for (int i = 0; i &lt; (sizeA - sizeB); i++) &#123;              tempA = tempA.next;              skipA++;          &#125;      &#125; else &#123;          for (int i = 0; i &lt; (sizeB - sizeA); i++) &#123;              tempB = tempB.next;              skipB++;          &#125;      &#125;        // 不相同，指针后移      while (tempA != null) &#123;          if (tempA == tempB) &#123;              intersectVal = tempA.val;              return tempA;          &#125;          tempA = tempA.next;          tempB = tempB.next;          skipA++;          skipB++;      &#125;        return null;  &#125;\n142环形链表II\n题目链接：https://leetcode.cn/problems/linked-list-cycle-ii/description/\n不会，直接看的解析。\n看讲解\n24两两交换链表中的节点\n题目链接/文章讲解/视频讲解：：https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html\n这题看题解图会比较容易：\n看完根据这个图，总算是写出来了。也还有别的方法（递归）：\npublic ListNode swapPairs(ListNode head) &#123;        // base case 退出提交        if(head == null || head.next == null) return head;        // 获取当前节点的下一个节点        ListNode next = head.next;        // 进行递归        ListNode newNode = swapPairs(next.next);        // 这里进行交换        next.next = head;        head.next = newNode;        return next;    &#125;\n注：将步骤二三互换，可以不定义temp节点。\n19删除链表的倒数第N个节点\n题目链接/文章讲解/视频讲解：https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html\n/**   * 第一想法是获取长度，然后长度-n得到节点位置。因为节点这个初始化操作之前是写了size的   * 但是题目中是没有这个初始化操作的。   * 直接看的解析，说是用快慢双指针的方式。   */  public static LE707.ListNode removeNthFromEnd(LE707.ListNode head, int n) &#123;      // 添加一个虚拟头节点      LE707.ListNode dumyHead = new LE707.ListNode(-1);      dumyHead.next = head;        LE707.ListNode fast = dumyHead;      for (int i = 0; i &lt; n; i++) &#123;          fast = fast.next;      &#125;      LE707.ListNode slow = dumyHead;      while (fast != null &amp;&amp; fast.next != null) &#123;          fast = fast.next;          slow = slow.next;      &#125;        // 此时慢指针指向的为要删除节点的前一个节点      slow.next = slow.next.next;        return dumyHead.next;  &#125;\n步骤一：先移动快指针，快指针移动的位置与n相同。步骤二：同时移动快慢指针，当快指针下一节点的位置为0时，此时慢指针指向的位置为要删除的节点的前一节点。步骤三：删除指定节点。注：为了避免多处理头节点的情况，添加虚拟头节点。\n面试题02.07链表相交\n题目链接/文章讲解：https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html\n除了初步题解那种解法，还有一种，但是不是很能看懂理解，可以说第一次完全想不到，下面是解法和图解：\nhttps://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/solutions/1190240/mian-shi-ti-0207-lian-biao-xiang-jiao-sh-b8hn/\n// 合并链表实现移动public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;\t// p1 指向 A 链表头结点，p2 指向 B 链表头结点\tListNode p1 = headA, p2 = headB;\twhile (p1 != p2) &#123;\t\t// p1 走一步，如果走到 A 链表末尾，转到 B 链表\t\tif (p1 == null) p1 = headB;\t\telse            p1 = p1.next;\t\t// p2 走一步，如果走到 B 链表末尾，转到 A 链表\t\tif (p2 == null) p2 = headA;\t\telse            p2 = p2.next;\t&#125;\treturn p1;&#125;\n142环形链表II\n题目链接/文章讲解/视频讲解：https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html\n\n题解思路：\n\n\n如何判断链表是否有环：首先这题使用快慢指针解法。如果无环，那么快指针到最后也不会与慢指针相遇；如果可以相遇，则说明有环。\n\n\n快指针一定先进入环形，慢指针后进入环形。当慢指针进入环形时，就变成了追击问题，由快追击慢。因为指定快指针速度为2个节点，慢指针为1个节点，相对速度为1个节点，因此快慢一定会在环内相遇。\n\n\n如图所示：假设相遇在点P，入口在start，三段路径分别如图所示，则此时A的行走路径为：x + n(y + z) + y，B的行走路径为x + y\n\n\n又因为快指针速度为满指针的两倍，所以x + n(y + z) + y = 2(x + y)，得出x = n(y + z) - y，等式变形为x = (n - 1)(y + z) + z，又n &gt;= 1。可以简化为，在相遇处，出发处各设一个指针，一起移动，两个指针一定会相遇。相遇处即为start。\n\n\n疑难点：\nQ：为什么B的路径一定在一圈以内？\nA：关键在当慢指针进入环形时，就变成了追击问题。也就是说，快指针的追击路线一定小于一圈，即追击时间一定不够慢指针跑满一圈。\nQ：快慢指针一定会在环内相遇？\nA：因为指定快指针速度为2个节点，慢指针为1个节点，相对速度为1个节点，因此快慢一定会在环内相遇。（如果快指针的速度为3，那就可能会跳过了）\npublic LE707.ListNode detectCycle(LE707.ListNode head) &#123;      LE707.ListNode fast = head;      LE707.ListNode slow = head;        while (fast!= null  &amp;&amp; fast.next != null) &#123;          fast = fast.next.next;          slow = slow.next;          // 找到相遇点          if (slow == fast) &#123;              LE707.ListNode index1 = head;              LE707.ListNode index2 = fast;              while (index1 != index2) &#123;                  index1 = index1.next;                  index2 = index2.next;              &#125;              return index1;          &#125;      &#125;      return null;  &#125;","categories":["面试","代码随想录"],"tags":["双指针","链表","虚拟头节点","环形链表"]},{"title":"代码随想录算法训练营第五天-242有效的字母异位词、349两个数组的交集、202快乐数、1两数之和","url":"/2024/05/23/100000006/","content":"\n\n前言\n状态：全部可以AC。看了解析之后，242、202可再优化。\n\n\n更新\n\n\n24.05.23 初始记录\n\n初步题解\n242有效的字母异位词\n题目链接：(https://leetcode.cn/problems/valid-anagram/description/)\npublic class LE242 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          String s = scanner.nextLine();          String t = scanner.nextLine();          System.out.println(isAnagram(s, t));      &#125;        /**       * 思路：       * 1.用map接收每个字符出现的次数       * 2.比较次数是否相同       */      public static boolean isAnagram(String s, String t) &#123;          char[] charsS = s.toCharArray();          char[] charsT = t.toCharArray();            HashMap&lt;String, Integer&gt; numMapS = getNumMap(charsS);          HashMap&lt;String, Integer&gt; numMapT = getNumMap(charsT);            if (numMapS.size() != numMapT.size()) &#123;              return false;          &#125;          for (String key : numMapS.keySet()) &#123;              if (!numMapS.get(key).equals(numMapT.get(key))) &#123;                  return false;              &#125;          &#125;          return true;      &#125;        /**       * 获取每个字符的数量       * @param charsS 字符串       * @return 每个字符的数量       */      private static HashMap&lt;String, Integer&gt; getNumMap(char[] charsS) &#123;          HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();          for (char c : charsS) &#123;              if (map.containsKey(String.valueOf(c))) &#123;                  map.put(String.valueOf(c) , map.get(String.valueOf(c)) + 1);              &#125; else &#123;                  map.put(String.valueOf(c), 1);              &#125;          &#125;          return map;      &#125;  &#125;\n349两个数组的交集\n题目链接：(https://leetcode.cn/problems/intersection-of-two-arrays/description/)\npublic class LE349 &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int[] nums1 = Arrays.stream(scanner.nextLine().split(&quot;,&quot;)).filter(Objects::nonNull).mapToInt(Integer::parseInt).toArray();        int[] nums2 = Arrays.stream(scanner.nextLine().split(&quot;,&quot;)).filter(Objects::nonNull).mapToInt(Integer::parseInt).toArray();        int[] intersection = intersection(nums1, nums2);    &#125;    public static int[] intersection(int[] nums1, int[] nums2) &#123;        HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();        HashSet&lt;Integer&gt; intersection = new HashSet&lt;&gt;();        for (int i : nums1) &#123;            set.add(i);        &#125;        for (int i : nums2) &#123;            if (set.contains(i)) &#123;                intersection.add(i);            &#125;        &#125;        return intersection.stream().filter(Objects::nonNull).mapToInt(i -&gt; i).toArray();    &#125;&#125;\n202快乐数\n题目链接：(https://leetcode.cn/problems/happy-number/description/)\npublic class LE202 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          String s = scanner.nextLine();          System.out.println(isHappy(Integer.parseInt(s)));      &#125;        /**       * 思路：放到set中，重复或者为1，跳出循环       * @param n 数       * @return 是否是快乐数       */      public static boolean isHappy(int n) &#123;          HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();          String num = n + &quot;&quot;;          set.add(n);          while (true) &#123;              int sum = 0;              for (int i = 0; i &lt; num.length(); i++) &#123;                  sum += Math.pow(Integer.parseInt(num.charAt(i) + &quot;&quot;), 2);              &#125;                if (sum == 1) &#123;                  return true;              &#125;                if (set.contains(sum)) &#123;                  return false;              &#125;              num = sum + &quot;&quot;;              set.add(sum);          &#125;      &#125;  &#125;\n1两数之和\n题目链接：(https://leetcode.cn/problems/two-sum/)\npublic class LE1 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          int[] nums = Arrays.stream(scanner.nextLine().split(&quot;,&quot;)).filter(Objects::nonNull).mapToInt(Integer::parseInt).toArray();          int target = Integer.parseInt(scanner.next());          twoSum(nums, target);      &#125;        /**       * 暴力解法肯定是循环两遍       * 但是这题放在哈希表专题里，就应该哈希表也能解决       * 用值为key，下标为value放入map       */    public static int[] twoSum(int[] nums, int target) &#123;          HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();          for (int i = 0; i &lt; nums.length; i++) &#123;              if (map.containsKey(target - nums[i])) &#123;                  return new int[]&#123;map.get(target - nums[i]), i&#125;;              &#125;              map.put(nums[i], i);          &#125;            return null;      &#125;  &#125;\n看讲解\n242有效的字母异位词\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0242.有效的字母异位词.html)\n/**   * 优化：   * 改为定义数组去接收数值（其实和map是一样的思想，但是这样代码量更少）   * 改为第二次遍历，在原数组上直接--（空间用得更少了）   */  public static boolean isAnagram1(String s, String t) &#123;      int[] record = new int[26];        for (int i = 0; i &lt; s.length(); i++) &#123;          record[s.charAt(i) - &#x27;a&#x27;]++;      &#125;        for (int i = 0; i &lt; t.length(); i++) &#123;          record[t.charAt(i) - &#x27;a&#x27;]--;      &#125;        for (int count : record) &#123;          if (count != 0) &#123;              return false;          &#125;      &#125;      return true;  &#125;\n349两个数组的交集\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0349.两个数组的交集.html)\n202快乐数\n题目链接/文章讲解：(https://programmercarl.com/0202.快乐数.html)\n// 可以再优化，一个数各个位数平方求和while (n &gt; 0) &#123;      int temp = n % 10;      sum += temp * temp;      n = n / 10;  &#125;\n1两数之和\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0001.两数之和.html)\n","categories":["面试","代码随想录"],"tags":["哈希表"]},{"title":"【代码模板】阿里云接口实现短信发送","url":"/2024/05/24/100000007/","content":"\n\n前言\n阿里云接口实现短信发送。\n\n\n更新\n\n\n24.05.24 初始记录\n\n依赖\n&lt;!--sms验证服务--&gt;  &lt;dependency&gt;      &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;      &lt;artifactId&gt;spring-cloud-alicloud-sms&lt;/artifactId&gt;      &lt;version&gt;2.2.0.RELEASE&lt;/version&gt;  &lt;/dependency&gt;\n代码\n\n\nService中要添加的代码\n\n\n@Override  public Boolean sendCode(String phone) &#123;      //非空校验      if (Strings.isNullOrEmpty(phone)) &#123;          throw new LogicException(&quot;手机号为空&quot;);      &#125;        StringBuilder sbCode = new StringBuilder();      // 6位随机密码    Stream.generate(() -&gt; new Random().nextInt(10))              .limit(6)              .forEach(sbCode::append);      //将验证码放入redis, 5分钟过期      redisTemplate.opsForValue().set(phone, sbCode.toString(), Duration.ofMinutes(5));      log.info(&quot;短信验证码：&quot; + sbCode.toString());      return smsSender.sendMsg(phone, sbCode.toString());  &#125;   \n\n\nSmsConfig.java\n\n\n@Configuration  @RefreshScope  public class SmsConfig &#123;      @Value(&quot;$&#123;sms.operator.signName&#125;&quot;)      private String signName;      @Value(&quot;$&#123;sms.operator.templateCode&#125;&quot;)      private String templateCode;        public String getSignName() &#123;          return signName;      &#125;        public String getTemplateCode() &#123;          return templateCode;      &#125;  &#125;\n\n\n配置文件中添加\n\n\nsms:  operator:    signName: 你的signName    templateCode: 你的templateCode  \n\n\nSmsSender.java\n\n\n@Component  @Slf4j  public class SmsSender &#123;      @Autowired      private SmsConfig smsConfig;      @Autowired      private ISmsService smsService;        /**       * 发送验证码短信       *       * @param telephone 手机号       * @param code     手机验证码       */      public boolean sendMsg(String telephone, String code) &#123;          SendSmsRequest request = new SendSmsRequest();            request.setPhoneNumbers(telephone);          request.setSignName(smsConfig.getSignName());          request.setTemplateCode(smsConfig.getTemplateCode());          ObjectMapper mapper = new ObjectMapper();          JsonNode rootNode = mapper.createObjectNode();          // 存入验证码          ((ObjectNode) rootNode).put(&quot;code&quot;, code);            try &#123;              request.setTemplateParam(mapper.writeValueAsString(rootNode));              val sendSmsResponse = smsService.sendSmsRequest(request);              log.info(&quot;短信发送接收：&quot; + JSONUtil.toJsonPrettyStr(sendSmsResponse));              if (sendSmsResponse.getCode() != null &amp;&amp; &quot;OK&quot;.equals(sendSmsResponse.getCode())) &#123;                  return true;              &#125; else &#123;                  throw new LogicException(&quot;验证码发送失败：&quot; + sendSmsResponse.getMessage());              &#125;          &#125; catch (Exception e) &#123;              log.error(&quot;send sms error.&quot; + e.getMessage());              val operLog = OperLog.builder().title(&quot;发送验证码&quot;)                      .businessType(BusinessType.OTHER.ordinal())                      .operParam(JSONUtil.toJsonPrettyStr(request))                      .status(BusinessStatus.FAIL.ordinal())                      .errorMsg(e.getMessage())                      .build();              AsyncManager.me().execute(AsyncFactory.recordOper(operLog));              throw new LogicException(&quot;验证码发送失败&quot;);          &#125;      &#125;  &#125;","categories":["后端项目","准备工作"],"tags":["Java","代码模板"]},{"title":"聚合支付-功能实现","url":"/2024/05/23/100000008/","content":"\n\n前言\n第一部分-商户注册和资质申请第二部分-对接SAAS\n第三部分-闪聚支付\n\n\n更新\n\n\n24.05.23 初始记录（商户注册&amp;资质申请）24.05.29 获取短信验证码24.05.30 文件上传24.06.02 Saas对接24.06.04 bug新增，烦，遇到bug，进展很缓慢。\n\n商户注册&amp;资质申请\n系统交互流程\n\n商户注册的流程由商户平台应用、商户服务、SaaS平台、验证码服务四个微服务之间进行交互完成，各微服务的职责介绍如下：\n1）商户平台应用：此应用主要为商户提供业务功能，包括：商户资质申请、员工管理、门店管理等功能。\n2）商户服务： 提供商户管理的相关服务接口，供其它微服务调用，主要为商户平台应用提供接口服务，功能包括：商户基本信息管理、资质申请（这个功能蛮莫名其妙的，写了但是没有后续的审核操作，不知道干什么用的😥）、商户应用管理、渠道参数配置、商户员工信息管理、商户门店管理等。\n3）SaaS平台：闪聚支付项目是一个SaaS平台 ，所谓SaaS平台即多个用户租用平台的业务功能，这样用户即可省去软件系统开发的成本，每个商户就是一个租户，所以又称为多租户系统。 SaaS平台提供租户管理、账号管理、权限管理、资源管理、套餐管理、系统认证授权等功业务功能。在上图商户注册的流程中，商户注册的账号等信息需要写入SaaS平台，由SaaS平台统一管理账号，分配权限，商户统一通过SaaS平台登录闪聚支付。\n4）验证码服务：提供获取短信验证码、校验验证码的接口。 商户使用手机号进行注册，平台通过校验手机验证码来确认是否本人在注册。\n\n获取短信验证码\n短信验证码为一个开源的服务，可单独开启使用。开源git地址：(https://github.com/fightingape/sailing)\n\n大致看了一下这个开源项目是根据传入的业务名称，获取配置好的code长度和Service实现。后续应该还可以加入别的实现（比如阿里云的短信服务等）\n其中生成验证信息这个方法。\n1.根据业务名称+随机UUID生成key存入redis。这个key会返回给服务请求方。\n2.根据配置好的Map获取名称对应的len即code码长度，如果传入不存在的name，会直接报错。\n3.验证服务就是根据返回给服务请求方的key，查询Redis缓存是否存在，不存在返回false，即验证码错误。\n\n本项目中没有使用，只是简单控制台打印了一下。也可以直接在这个服务里存入redis（因为要申请开通阿里云短信服务有点麻烦，又要多部署一个服务，而且这个功能比较简单不打算花时间开通了）。\n之前有写过阿里云的短信，关联文章：\n\n内链：[[【代码模板】阿里云接口实现短信发送]]\n外链：【代码模板】阿里云接口实现短信发送\n\n文件上传\n资质申请的流程中涉及到了文件上传的功能。之前已经写过使用Minio作为文件服务器和用阿里云OSS作为文件存储两种方式。这里的上传直接把七牛云换成了Minio。顺便整理了一下之前写过的两种方式。文件上传：\n\n内链：[[【代码模板】文件存储]]\n外链：【代码模板】文件存储\n\n支付参数配置\n\n这个部分是项目的核心，之前做别的项目的时候，接触了微信支付和支付宝支付。就和这个项目中说的一样，用户只能先选择支付类型。再调用对应的接口获取支付二维码。而通过聚合支付这个平台，可以只生成一个链接，根据用户扫码，跳转不同的支付。\n\n商户应该配置哪些第三方支付渠道的参数\n服务类型是闪聚支付平台为商户提供的聚合支付服务通道，共分为线上和线下两大类：\n线上支付服务通道：\n\n\n手机APP支付\n\n\nPC网页支付\n\n\n手机网页支付\n\n\n小程序支付线下支付服务通道：\n\n\n收款码支付(C扫B)：即商户出示付款码，用户扫收款码完成支付。\n\n\nB扫C：即顾客出示付款码，商户扫描付款码。\n\n\n系统交互流程\n\n\n商户应用创建流程\n\n\n\n商户渠道参数配置交互流程\n交易服务职责：提供支付渠道参数配置、订单、发起支付、转账、退款等功能。\n\n\n对接SAAS\n系统交互流程\n商户注册时与SAAS的交互流程已经在商户注册模块给出。\n分布式认证需求\n\n\n统一认证授权分布式系统的每个服务（系统）都会有认证、授权的需求，如果每个服务都实现一套认证授权逻辑会非常冗余，考虑分布式系统共享性的特点，需要由独立的认证服务来处理系统认证授权的请求。如下图，闪聚支付平台包括：商户平台应用、运营平台应用、门户应用，每个应用都需要身份认证，闪聚支付平台统一由UAA认证服务完成认证。\n\n\n\n开放认证体系考虑分布式系统开放性的特点，UAA认证服务不仅服务于平台自身，并且对第三方系统也要提供认证，平台应提供扩展和开放的认证机制，以开放API的方式供第三方应用接入，一方应用（内部系统服务）和三方应用（第三方应用）均采用统一机制接入。\n\n\n分布式系统认证技术方案详见下图：\n流程所涉及到统一账号服务、UAA服务、API网关这三个组件职责如下:\n1） 统一账号服务：提供商户和平台运营人员的登录账号、密码、角色、权限、资源等系统级信息的管理，不包含用户业务信息。\n2） 统一认证服务：它承载了OAuth2.0接入方认证、登入用户的认证、授权以及生成令牌的职责，完成实际的用户认证、授权功能。\n3） API网关：作为系统的唯一入口，API网关为接入方提供定制的API集合，它可能还具有其它职责，如身份验证、监控、负载 均衡、缓存等。API网关方式的核心要点是，所有的接入方和消费端都通过统一的网关接入微服务，在网关层处理 所有的非业务功能。\nBUG记录\nRestTemplate使用GET请求，返回中文乱码\n\n内链：[[RestTemplate使用GET请求，返回中文乱码]]\n外链：RestTemplate使用GET请求，返回中文乱码\n\n项目中访问Swagger地址，404（未解决）\n不管怎么访问swagger的页面地址，都返回404。但是直接用apifox的URL导入，是可以成功的🥴。\n使用mapstruct转换对象，报错Cannot find implementation for……\n这个项目中是因为User微服务没有依赖mapstruct。但是swagger中有这个依赖，他直接用了swagger中的依赖。网上搜索还有一种情况可能出现这个问题。\n\n内链：[[使用mapstruct转换对象，报错Cannot find implementation for……]]\n外链：使用mapstruct转换对象，报错Cannot find implementation for……\n\n前端JS在Long长度大于17位时，出现精度丢失的问题\n\n内链：[[Long长度大于17位时，精度丢失]]\n外链：[Long长度大于17位时，精度丢失\n\n","categories":["后端项目","聚合支付"],"tags":["Java"]},{"title":"代码随想录算法训练营第六天-454四数相加II、383赎金信、15三数之和、18四数之和","url":"/2024/05/24/100000009/","content":"\n\n前言\n状态：454和383可以AC，15超时，18根据15做出，还可以进一步优化\n\n\n更新\n\n\n24.05.24 初始记录\n\n初步题解\n454四数相加II\n题目链接：(https://leetcode.cn/problems/4sum-ii/)\npublic class LE454 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          int[] nums1 = Arrays.stream(scanner.nextLine().split(&quot;,&quot;)).filter(Objects::nonNull).mapToInt(Integer::parseInt).toArray();          int[] nums2 = Arrays.stream(scanner.nextLine().split(&quot;,&quot;)).filter(Objects::nonNull).mapToInt(Integer::parseInt).toArray();          int[] nums3 = Arrays.stream(scanner.nextLine().split(&quot;,&quot;)).filter(Objects::nonNull).mapToInt(Integer::parseInt).toArray();          int[] nums4 = Arrays.stream(scanner.nextLine().split(&quot;,&quot;)).filter(Objects::nonNull).mapToInt(Integer::parseInt).toArray();          System.out.println(fourSumCount(nums1, nums2, nums3, nums4));      &#125;  \t// 和昨天的最后一题差不多    public static int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) &#123;          int res = 0;          HashMap&lt;Integer, Integer&gt; map = new HashMap();          for (int k : nums1) &#123;              for (int i : nums2) &#123;                  int sum = k + i;                  map.put(sum, map.getOrDefault(sum, 0) + 1);              &#125;          &#125;            for (int i : nums3) &#123;              for (int j : nums4) &#123;                  res += map.getOrDefault(-i - j, 0);              &#125;          &#125;            return res;      &#125;  &#125;\n383赎金信\n题目链接：(https://leetcode.cn/problems/ransom-note/submissions/534463469/)\npublic class LE383 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          String ransomNote = scanner.nextLine();          String magazine = scanner.nextLine();          System.out.println(canConstruct(ransomNote, magazine));      &#125;  \t// 和242一样的思路    public static boolean canConstruct(String ransomNote, String magazine) &#123;          int[] ints = new int[26];          // 遍历存储数量          for (int i = 0; i &lt; magazine.length(); i++) &#123;              ints[magazine.charAt(i) - 97]++;          &#125;          // 遍历扣除数量          for (int i = 0; i &lt; ransomNote.length(); i++) &#123;              ints[ransomNote.charAt(i) - 97]--;          &#125;          for (int i : ints) &#123;              if (i &lt; 0) &#123;                  return false;              &#125;          &#125;          return true;      &#125;  &#125;\n15三数之和\n题目链接：(https://leetcode.cn/problems/3sum/description/)\n暴力解法，但是这样超时了。\npublic static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;      // 判断是否重复      HashMap&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();        for (int i = 0; i &lt; nums.length; i++) &#123;          for (int j = i + 1; j &lt; nums.length; j++) &#123;              for (int k = j + 1; k &lt; nums.length; k++) &#123;                  if (nums[i] + nums[j] + nums[k] == 0) &#123;                      List&lt;Integer&gt; list = new ArrayList&lt;&gt;();                      list.add(nums[i]);                      list.add(nums[j]);                      list.add(nums[k]);                      list.sort(Integer::compareTo);                      map.put(list.stream().map(integer -&gt; integer + &quot;&quot;).collect(Collectors.joining(&quot;,&quot;)), list);                  &#125;              &#125;          &#125;      &#125;      List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();      for (Map.Entry&lt;String, List&lt;Integer&gt;&gt; stringListEntry : map.entrySet()) &#123;          list.add(stringListEntry.getValue());      &#125;      return list;  &#125;\n看了部分解析改用双指针，可以通过，但是比较慢。而且费时\npublic static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;      nums = Arrays.stream(nums).sorted().toArray();      ArrayList&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();      // 递增序列，前三位和大于0，直接返回      if (nums[0] + nums[1] + nums[2] &gt; 0) &#123;          return list;      &#125;        int i = 0;      int j = i + 1;      int k = nums.length - 1;      while (i &lt; j &amp;&amp; j &lt; k) &#123;          System.out.println(i + &quot; &quot; + j + &quot; &quot; + k);          int sum = nums[i] + nums[j] + nums[k];          if (sum == 0) &#123;              list.add(Arrays.asList(nums[i], nums[j], nums[k]));              j++;          &#125; else if (sum &lt; 0) &#123;              j++;          &#125; else &#123;              k--;          &#125;          while (j &gt; i + 1 &amp;&amp; j &lt;= nums.length - 1 &amp;&amp; nums[j] == nums[j - 1]) &#123;              j++;          &#125;          while (k &gt; j &amp;&amp; k != nums.length - 1 &amp;&amp; nums[k] == nums[k + 1]) &#123;              k--;          &#125;          if (j &gt;= k) &#123;              i = i + 1;              while (i != 0 &amp;&amp; i &lt;= nums.length - 1 &amp;&amp; nums[i] == nums[i - 1]) &#123;                  i++;              &#125;              j = i + 1;              k = nums.length - 1;          &#125;      &#125;      return list;  &#125;\n18四数之和\n题目链接：(https://leetcode.cn/problems/4sum/description/)\n看到题目，就觉得是15的进阶版，按照上一题的思路写了一下\npublic static List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;      Arrays.sort(nums);        ArrayList&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();      for (int i = 0; i &lt; nums.length; i++) &#123;          if (i != 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;              continue;          &#125;            for (int j = i + 1; j &lt; nums.length; j++) &#123;              if (j != i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123;                  continue;              &#125;                int left = j + 1;              int right = nums.length - 1;              while (left &lt; right) &#123;                  long sum = (long) nums[i] + (long) nums[j] + (long) nums[left] + (long) nums[right];                  if (sum &lt; target) &#123;                      left++;                  &#125; else if (sum &gt; target) &#123;                      right--;                  &#125; else &#123;                      list.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));                      while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) &#123;                          left++;                      &#125;                      while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) &#123;                          right--;                      &#125;                      left++;                      right--;                  &#125;              &#125;          &#125;      &#125;      return list;  &#125;\n看讲解\n454四数相加II\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0454.四数相加II.html)\n383赎金信\n题目链接/文章讲解：(https://programmercarl.com/0383.赎金信.html)\n15三数之和\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0015.三数之和.html)\n确实用for循环更好理解。题解的思路更加清晰，而且更快。\npublic static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;      List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      Arrays.sort(nums);      for (int i = 0; i &lt; nums.length; i++) &#123;          // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了          if (nums[i] &gt; 0) &#123;              return result;          &#125;            /**           * 只能是与前一个比较进行去重           */          if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;              continue;          &#125;            int left = i + 1;          int right = nums.length - 1;          while (right &gt; left) &#123;              int sum = nums[i] + nums[left] + nums[right];              if (sum &gt; 0) &#123;                  right--;              &#125; else if (sum &lt; 0) &#123;                  left++;              &#125; else &#123;                  result.add(Arrays.asList(nums[i], nums[left], nums[right]));                  /**                   * 去重逻辑应该放在找到一个三元组之后                   * 否则获取不到结果集                   */                  while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) &#123;                      right--;                  &#125;                  while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) &#123;                      left++;                  &#125;                    right--;                  left++;              &#125;          &#125;      &#125;      return result;  &#125;\n18四数之和\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0018.四数之和.html)\n看了解析。加上剪枝操作。\npublic static List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;      Arrays.sort(nums);        ArrayList&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();      for (int i = 0; i &lt; nums.length; i++) &#123;          // nums[i] &gt; target 直接返回, 剪枝操作          if (nums[i] &gt; 0 &amp;&amp; nums[i] &gt; target) &#123;              return list;          &#125;            for (int j = i + 1; j &lt; nums.length; j++) &#123; \t        // 二级剪枝            if (nums[i] + nums[j] &gt; 0 &amp;&amp; nums[i] + nums[j] &gt; target) &#123;                  break;              &#125;                if (j != i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123;                  continue;              &#125;                int left = j + 1;              int right = nums.length - 1;              while (left &lt; right) &#123;                  long sum = (long) nums[i] + (long) nums[j] + (long) nums[left] + (long) nums[right];                  if (sum &lt; target) &#123;                      left++;                  &#125; else if (sum &gt; target) &#123;                      right--;                  &#125; else &#123;                      list.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));                      while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) &#123;                          left++;                      &#125;                      while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) &#123;                          right--;                      &#125;                      left++;                      right--;                  &#125;              &#125;          &#125;      &#125;      return list;  &#125;","categories":["面试","代码随想录"],"tags":["双指针","哈希表"]},{"title":"代码随想录算法训练营第七天-344反转字符串、541反转字符串II、卡码网54替换数字、151翻转字符串里的单词、卡码网55右旋转字符串","url":"/2024/05/27/100000010/","content":"\n\n前言\n状态：都是可以写出来的。但是有些与参考种给出的解析思路不同。\n\n\n更新\n\n\n24.05.27 初始记录\n\n初步题解\n344反转字符串\n题目链接：(https://leetcode.cn/problems/reverse-string/description/)\npublic class LE344 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          reverseString(scanner.nextLine().toCharArray());      &#125;        public static void reverseString(char[] s) &#123;          for (int i = 0, j = s.length - 1; i &lt;= j; i++, j--) &#123;              char temp = s[i];              s[i] = s[j];              s[j] = temp;          &#125;          System.out.println(Arrays.toString(s));      &#125;  &#125;\n541反转字符串II\n题目链接：(https://leetcode.cn/problems/reverse-string-ii/description/)\npublic class LE541 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          System.out.println(reverseStr(scanner.nextLine(), Integer.parseInt(scanner.nextLine())));      &#125;        /**       * 画图翻译了一下       * 大概意思就是奇数段反转       */      public static String reverseStr(String s, int k) &#123;          // 判断能拆分成几段          int size = s.length() / k;          if (s.length() % k != 0) &#123;              size = size + 1;          &#125;            StringBuilder reverseStr = new StringBuilder();          for (int i = 1; i &lt;= size; i++) &#123;              String substring = s.substring((i - 1) * k, Math.min(i * k, s.length()));              if (i % 2 != 0) &#123;                  char[] chars = substring.toCharArray();                  for (int n = 0, m = chars.length - 1; n &lt;= m; n++, m--) &#123;                      char temp = chars[n];                      chars[n] = chars[m];                      chars[m] = temp;                  &#125;                  reverseStr.append(chars);              &#125; else &#123;                  reverseStr.append(substring);              &#125;          &#125;            return reverseStr.toString();      &#125;  &#125;\n卡码网54替换数字\n题目链接：(https://kamacoder.com/problempage.php?pid=1064)\npublic class CM54 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          System.out.println(replaceNumber(scanner.nextLine()));      &#125;        public static String replaceNumber(String s) &#123;          StringBuilder stringBuilder = new StringBuilder();          char[] chars = s.toCharArray();          for (char c : chars) &#123;              if (&#x27;0&#x27; &lt;= c &amp;&amp; &#x27;9&#x27; &gt;= c) &#123;                  stringBuilder.append(&quot;number&quot;);              &#125; else &#123;                  stringBuilder.append(c);              &#125;          &#125;          return stringBuilder.toString();      &#125;  &#125;\n151翻转字符串里的单词\n题目链接：(https://leetcode.cn/problems/reverse-words-in-a-string/description/)\npublic static void main(String[] args) &#123;      Scanner scanner = new Scanner(System.in);      System.out.println(reverseWords(scanner.nextLine()));  &#125;    private static String reverseWords(String s) &#123;      String[] split = s.trim().split(&quot; &quot;);      StringBuilder stringBuilder = new StringBuilder();      for (int i = split.length - 1; i &gt;= 0; i--) &#123;          String trim = split[i].trim();          if (&quot;&quot;.equals(trim)) &#123;              continue;          &#125;          stringBuilder.append(trim).append(&quot; &quot;);      &#125;        return stringBuilder.toString().trim();  &#125;\n卡码网55右旋转字符串\n题目链接：(https://kamacoder.com/problempage.php?pid=1065)\npublic class CM55 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          int k = Integer.parseInt(scanner.nextLine());          String s = scanner.nextLine();          System.out.println(rightString(k, s));      &#125;        private static String rightString(int k, String s) &#123;          // 过界判断          if (k &gt;= s.length() || k &lt;= 0) &#123;              return s;          &#125;            return s.substring(s.length() - k) + s.substring(0, s.length() - k);      &#125;  &#125;\n看讲解\n344反转字符串\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0344.反转字符串.html)\n541反转字符串II\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0541.反转字符串II.html)\n卡码网54替换数字\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/kamacoder/0054.替换数字.html)\n根据讲解，这题本意是先扩充再分配。要用到双指针的方法。\npublic class Main &#123;    public static String replaceNumber(String s) &#123;        int count = 0; // 统计数字的个数        int sOldSize = s.length();        for (int i = 0; i &lt; s.length(); i++) &#123;            if(Character.isDigit(s.charAt(i)))&#123;                count++;            &#125;        &#125;        // 扩充字符串s的大小，也就是每个空格替换成&quot;number&quot;之后的大小        char[] newS = new char[s.length() + count * 5];        int sNewSize = newS.length;        // 将旧字符串的内容填入新数组        System.arraycopy(s.toCharArray(), 0, newS, 0, sOldSize);        // 从后先前将空格替换为&quot;number&quot;        for (int i = sNewSize - 1, j = sOldSize - 1; j &lt; i; j--, i--) &#123;            if (!Character.isDigit(newS[j])) &#123;                newS[i] = newS[j];            &#125; else &#123;                newS[i] = &#x27;r&#x27;;                newS[i - 1] = &#x27;e&#x27;;                newS[i - 2] = &#x27;b&#x27;;                newS[i - 3] = &#x27;m&#x27;;                newS[i - 4] = &#x27;u&#x27;;                newS[i - 5] = &#x27;n&#x27;;                i -= 5;            &#125;        &#125;        return new String(newS);    &#125;;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        String s = scanner.next();        System.out.println(replaceNumber(s));        scanner.close();    &#125;&#125;\n151翻转字符串里的单词\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0151.翻转字符串里的单词.html)\n这题。。。Java不好像没有办法空间复杂度为O(n)。（面试的话，不太清楚会不会这么细，平时可能就直接API搞定了。。。一般机考也不会考这个吧😶‍🌫️）只能说思路很重要：\n\n\n移除多余空格（）\n\n\n将整个字符串反转\n\n\n将每个单词反转\n\n\npublic class LE151 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          System.out.println(reverseWords(scanner.nextLine()));      &#125;        /**       * 本题考察点应该和上一题一样       * 步骤如下:       * 1.移除字符串中的空格       * 2.倒序       * 3.每个单词再反转       * 要求：不使用任何内置API       */    public static String reverseWords(String s) &#123;          String removeSpace = removeSpace(s);          System.out.println(removeSpace);          return reverseWord(removeSpace);      &#125;        /**       * 单个单词倒置       */      private static String reverseWord(String s) &#123;          String[] list = s.split(&quot; &quot;);          if (list.length &lt;= 0) &#123;              return &quot;&quot;;          &#125;          StringBuilder stringBuilder = new StringBuilder();          for (String s1 : list) &#123;              char[] chars = s1.toCharArray();              for (int i = 0, j = chars.length - 1; i &lt;= j; i++, j--) &#123;                  char temp = chars[i];                  chars[i] = chars[j];                  chars[j] = temp;              &#125;              stringBuilder.append(chars).append(&quot; &quot;);          &#125;          return stringBuilder.substring(0, stringBuilder.length() - 1);      &#125;        /**       * 去除字符串中的多余空格       * 并进行倒序       */      private static String removeSpace(String s) &#123;          char[] chars = s.toCharArray();          int start = 0;          int end = s.length() - 1;          while (s.charAt(start) == &#x27; &#x27;) &#123;              start++;          &#125;          while (s.charAt(end) == &#x27; &#x27;) &#123;              end--;          &#125;          if (start &gt; end) &#123;              return &quot;&quot;;          &#125;          StringBuilder stringBuilder = new StringBuilder();          for (int i = end; i &gt;= start; i--) &#123;              if (chars[i] == &#x27; &#x27; &amp;&amp; chars[i - 1] == &#x27; &#x27;) &#123;                  continue;              &#125;              stringBuilder.append(chars[i]);          &#125;          return stringBuilder.toString();      &#125;    &#125;\n卡码网55右旋转字符串\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/kama55.右旋字符串.html)\n这题也是。。。反正直接用API了，看了说《剑指Offer》有差不多的题目。没有再写一遍，直接抄了解析中的写法。\npublic class Main &#123;    public static void main(String[] args) &#123;        Scanner in = new Scanner(System.in);        int n = Integer.parseInt(in.nextLine());        String s = in.nextLine();        int len = s.length();  //获取字符串长度        char[] chars = s.toCharArray();        reverseString(chars, 0, len - 1);  //反转整个字符串        reverseString(chars, 0, n - 1);  //反转前一段字符串，此时的字符串首尾尾是0,n - 1        reverseString(chars, n, len - 1);  //反转后一段字符串，此时的字符串首尾尾是n,len - 1                System.out.println(chars);    &#125;    public static void reverseString(char[] ch, int start, int end) &#123;        //异或法反转字符串，参照题目 344.反转字符串的解释        while (start &lt; end) &#123;            ch[start] ^= ch[end];            ch[end] ^= ch[start];            ch[start] ^= ch[end];            start++;            end--;        &#125;    &#125;&#125;","categories":["面试","代码随想录"],"tags":["双指针","字符串","反转"]},{"title":"代码随想录算法训练营第八天-28实现 strStr() 、459重复的子字符串","url":"/2024/05/29/100000011/","content":"\n\n前言\n状态：28暴力（应为KMP）、459暴力（KMP不会）\n\n\n更新\n\n\n24-05-29 初始记录\n\n初步题解\n28实现 strStr()\n题目链接：(https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)\npublic class LE28 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          String haystack = scanner.nextLine();          String needle = scanner.nextLine();          System.out.println(strStr(haystack, needle));      &#125;        /**       * 思路：一个指针针对haystack遍历，一个指针针对needle遍历       * 当指针指过的路径相等，输出两者的差（即初始相等的指针位置）       * 当指向元素不同，haystack指针指向初始对比的下一个，needle指针重置       */      public static int strStr(String haystack, String needle) &#123;          int j = 0;          for (int i = 0; i &lt; haystack.length(); i++) &#123;              if (haystack.charAt(i) == needle.charAt(j)) &#123;                  if (j == needle.length() - 1) &#123;                      return i - j;                  &#125;                  j++;              &#125; else &#123;                  i = i - j;                  j = 0;              &#125;          &#125;          return  -1;      &#125;  &#125;\n459重复的子字符串\n题目链接：(https://leetcode.cn/problems/repeated-substring-pattern/description/)\n（虽然讲了KMP应该就用KMP，但是不会）\n// 暴力求解public class LE459 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          String nextLine = scanner.nextLine();          System.out.println(repeatedSubstringPattern(nextLine));      &#125;        public static boolean repeatedSubstringPattern(String s) &#123;          int n = s.length();          for (int i = 1; i * 2 &lt;= n; i++) &#123;              if (n % i == 0) &#123;                  boolean match = true;                  for (int j = i; j &lt; n; j++) &#123;                      if (s.charAt(j) != s.charAt(j - i)) &#123;                          match = false;                          break;                      &#125;                  &#125;                  if (match) &#123;                      return true;                  &#125;              &#125;          &#125;            return false;      &#125;  &#125;\n看讲解\n28实现 strStr()\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0028.实现strStr.html)\n本题应该用KMP思路，这个算法主要用在字符串匹配上。KMP的经典思想就是:当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。\n/**   * 思路：使用KMP算法。   * 之前双指针移动，不相等haystack的指针返回到初始匹配位置的下一位（暴力求解）   * 现在使用KMP算法，不相等移动到next表中标记的位置。   * 所以现在的关键就在于next表的计算：   * 1.初始化   * 2.当前后缀不相等时的思路（回退）   * 3.当前后缀相等时的思路（继续后移）   * 内部相当于也进行了KMP */  public static int strStr1(String haystack, String needle) &#123;      // 获取Next表      int[] ints = new int[needle.length()];      int[] next = getNext(ints, needle);        int j = 0;      if (needle.length() == 0) &#123;          return -1;      &#125;      for (int i = 0; i &lt; haystack.length(); i++) &#123;          // 不相等, j回退          while (j != 0 &amp;&amp; haystack.charAt(i) != needle.charAt(j)) &#123;              j = next[j - 1];          &#125;          // 相等          if (haystack.charAt(i) == needle.charAt(j)) &#123;              // 完全匹配，返回下标              if (j == needle.length() - 1) &#123;                  return i - j;              &#125;              j++;          &#125;        &#125;      return  -1;  &#125;    /**   * 获取next表，例：   * a a b a a f   * 0 1 0 1 2 0 * * 1.初始化   * 2.当前后缀不相等时的思路（回退）   * 3.当前后缀相等时的思路（继续后移）   *   * @param next 返回的next数组   * @param s 要求的字符串   * @return next数组   */  private static int[] getNext(int[] next, String s) &#123;      // 初始化 两个指针i和j，j指向前缀末尾位置(同时也是之前最长相等的前后缀长度)，i指向后缀末尾位置(随着字符串长度递增，递增)。      // 刚刚初始化时，字符串为a，所以j = 0      int j = 0;      next[0] = j;        // 这里i从1开始，没有搞懂(因为初始位置一定为0吗)      for (int i = 1; i &lt; s.length(); i++) &#123;          while (j != 0 &amp;&amp; s.charAt(i) != s.charAt(j)) &#123;              j = next[j - 1];          &#125;          if (s.charAt(i) == s.charAt(j)) &#123;              j++;          &#125;          next[i] = j;      &#125;      return next;  &#125;\n459重复的子字符串\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0459.重复的子字符串.html)\n/**   * KMP思路   * 如果这个字符串是由重复子串组成的，那么字符串长度-最长相等前后缀就为重复子串的长度   * 反过来说，如果一个字符串的最长相等前后缀与长度的差值（即可能是重复子串长度的这个值）能被字符串长度整除，那么就说明这个字符串是由重复子串组成的   * 但是这个反过来说。需要证明。（虽然画了几种情况都是这样）   *   * KMP复习：   * 1.初始化   * 2.不相等的情况   * 3.相等的情况   */  public static boolean repeatedSubstringPattern1(String s) &#123;      int[] next = getNext(s);      // 这里除了上面说的条件之外，还需要加上next[len - 1] != -1, 这说明字符串有最长相同的前后缀（就是字符串里的前缀子串和后缀子串相同的最长长度）      return next[s.length() - 1] != 0 &amp;&amp; s.length() % (s.length() - next[s.length() - 1]) == 0;  &#125;    private static int[] getNext(String s) &#123;      int j = 0;      int[] next = new int[s.length()];      next[j] = 0;        for (int i = 1; i &lt; s.length(); i++) &#123;          while (j != 0 &amp;&amp; s.charAt(i) != s.charAt(j)) &#123;              j = next[j - 1];          &#125;          if (s.charAt(i) == s.charAt(j)) &#123;              j++;          &#125;          next[i] = j;      &#125;        return next;  &#125;","categories":["面试","代码随想录"],"tags":["双指针","字符串","KMP"]},{"title":"代码随想录算法训练营第九天-232用栈实现队列、225用队列实现栈","url":"/2024/05/30/100000012/","content":"\n\n前言\n状态：都是直接看的解析，不是很难。\n\n\n更新\n\n\n24.05.30 初始记录\n\n初步题解\n232用栈实现队列\n题目链接：(https://leetcode.cn/problems/implement-queue-using-stacks/description/)\npublic class LE232 &#123;      public static void main(String[] args) &#123;          MyQueue queue = new MyQueue();          queue.push(1);          queue.push(2);          System.out.println(&quot;queue.peek() = &quot; + queue.peek());          System.out.println(&quot;queue.pop() = &quot; + queue.pop());          System.out.println(&quot;queue.empty() = &quot; + queue.empty());      &#125;        static class MyQueue &#123;          Stack&lt;Integer&gt; stackIn;          Stack&lt;Integer&gt; stackOut;            public MyQueue() &#123;              stackIn = new Stack&lt;&gt;();              stackOut = new Stack&lt;&gt;();          &#125;            public void push(int x) &#123;              stackIn.push(x);          &#125;            public int pop() &#123;              // 把in的内容复制到out              in2out();              return stackOut.pop();          &#125;            private void in2out() &#123;              if (stackOut.isEmpty()) &#123;                  while (!stackIn.isEmpty()) &#123;                      stackOut.push(stackIn.pop());                  &#125;              &#125;          &#125;            /**           * 返回列表开头的数据           * @return 结果           */          public int peek() &#123;              // 把in的内容复制到out              in2out();              return stackOut.peek();          &#125;            public boolean empty() &#123;              return stackIn.empty() &amp;&amp; stackOut.empty();          &#125;      &#125;  &#125;\n225用队列实现栈\n题目链接：(https://leetcode.cn/problems/implement-queue-using-stacks/description/)\npublic class LE225 &#123;      public static void main(String[] args) &#123;          MyStack myStack = new MyStack();          myStack.push(1);          myStack.push(2);          System.out.println(&quot;myStack.top() = &quot; + myStack.top());          System.out.println(&quot;myStack.pop() = &quot; + myStack.pop());          System.out.println(&quot;myStack.empty() = &quot; + myStack.empty());      &#125;        static class MyStack &#123;          Queue&lt;Integer&gt; queue;            public MyStack() &#123;              queue = new LinkedList&lt;&gt;();          &#125;            public void push(int x) &#123;              queue.offer(x);              int size = queue.size() - 1;              while (size != 0) &#123;                  size--;                  queue.offer(queue.poll());              &#125;          &#125;            public int pop() &#123;              return queue.poll();          &#125;            public int top() &#123;              return queue.peek();          &#125;            /**           * 判断是否为空           */          public boolean empty() &#123;              return queue.isEmpty();          &#125;      &#125;  &#125;\n看讲解\n232用栈实现队列\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0232.用栈实现队列.html)\n思路：用栈模拟队列需要两个栈。一个栈作为入栈，一个栈作为出栈。如果出栈为空，将入栈中的元素压入出栈。\n\n225用队列实现栈\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0225.用队列实现栈.html)\n思路：用队列模拟栈，可以只用一个队列。每当有新元素入队列，将原有的旧元素重新入队列，这样新元素就变成栈顶元素。（一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了。）\n\n","categories":["面试","代码随想录"],"tags":["栈","队列"]},{"title":"代码随想录算法训练营第十天-20有效的括号、1047删除字符串中的所有相邻重复项、150逆波兰表达式求值","url":"/2024/05/30/100000013/","content":"\n\n前言\n状态：20AC，1047AC，150AC\n\n\n更新\n\n\n24.05.30 初始记录\n\n初步题解\n20有效的括号\n题目链接：(https://leetcode.cn/problems/valid-parentheses/description/)\npublic class LE20 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          System.out.println(isValid(scanner.nextLine()));      &#125;        public static boolean isValid(String s) &#123;          Stack&lt;Character&gt; stack = new Stack&lt;&gt;();          for (char c : s.toCharArray()) &#123;              if (c == &#x27;(&#x27; || c == &#x27;[&#x27; || c == &#x27;&#123;&#x27;) &#123;                  stack.push(c);                  continue;              &#125;              if (stack.isEmpty()) &#123;                  return false;              &#125;              Character pop = stack.pop();              if ((c == &#x27;)&#x27; &amp;&amp; pop != &#x27;(&#x27; ) || (c == &#x27;]&#x27; &amp;&amp; pop != &#x27;[&#x27; ) || (c == &#x27;&#125;&#x27; &amp;&amp; pop != &#x27;&#123;&#x27; )) &#123;                  return false;              &#125;          &#125;          return stack.isEmpty();      &#125;  &#125;\n1047删除字符串中的所有相邻重复项\n题目链接：(https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/)\npublic static void main(String[] args) &#123;      Scanner scanner = new Scanner(System.in);      System.out.println(removeDuplicates(scanner.nextLine()));  &#125;    public static String removeDuplicates(String s) &#123;      Stack&lt;Character&gt; stack = new Stack&lt;&gt;();      for (char c : s.toCharArray()) &#123;          if (stack.isEmpty()) &#123;              stack.push(c);              continue;          &#125;          if (c == stack.peek()) &#123;              stack.pop();          &#125; else &#123;              stack.push(c);          &#125;      &#125;        StringBuilder str = new StringBuilder();      int size = stack.size();      for (int i = 0; i &lt; size; i++) &#123;          str.insert(0, stack.pop());      &#125;      return str.toString();  &#125;\n150逆波兰表达式求值\n题目链接：(https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/)\n可以直接根据题目中给的链接查看逆波兰表示法的意思\npublic int evalRPN(String[] tokens) &#123;      Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();      int num = Integer.parseInt(tokens[0]);      for (String token : tokens) &#123;          switch (token) &#123;              case &quot;+&quot;: &#123;                  num = stack.pop() + stack.pop();                  stack.push(num);                  break;              &#125;              case &quot;-&quot;: &#123;                  Integer num2 = stack.pop();                  Integer num1 = stack.pop();                  num = num1 - num2;                  stack.push(num);                  break;              &#125;              case &quot;*&quot;: &#123;                  num = stack.pop() * stack.pop();                  stack.push(num);                  break;              &#125;              case &quot;/&quot;: &#123;                  Integer num2 = stack.pop();                  Integer num1 = stack.pop();                  num = num1 / num2;                  stack.push(num);                  break;              &#125;              default: &#123;                  stack.push(Integer.parseInt(token));              &#125;          &#125;      &#125;      return num;  &#125;\n看解析\n20有效的括号\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0020.有效的括号.html)\n1047删除字符串中的所有相邻重复项\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/1047.删除字符串中的所有相邻重复项.html)\n150逆波兰表达式求值\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0150.逆波兰表达式求值.html)\n","categories":["面试","代码随想录"],"tags":["栈"]},{"title":"【代码模板】文件存储","url":"/2024/05/30/100000014/","content":"\n\n前言\n项目中常用到文件上传的功能。\n\n\n更新\n\n\n24.05.30 初始记录（Minio，阿里云OSS）\n\n文件上传\n\n\n校验\n\n文件是否为空\n文件的格式\n文件的大小\n\n\n\n文件重命名\n\n\n文件目录分离\n\n使用目录分离算法(Hash把hash值作为目录名称)\n按照日期分目录(每天创建一个新的目录)\n按照用户名分目录\n\n\n\n图片保存地点\n\nweb服务器（项目所运行在的电脑）\n云存储服务商\n自己搭建文件服务器（FastDFS Minio）\n\n\n\n通用部分代码\n/**   * 文件上传   *   * @param file 文件   * @return Boolean   */@RestController@RequestMapping(&quot;common&quot;)public class CommonController &#123;    @PostMapping(&quot;upload&quot;)    public R uploadPic(MultipartFile file) throws IOException &#123;        // 校验        // 校验文件是否为空        if (ObjectUtil.isNull(file)) return R.error(&quot;上传文件不能为空&quot;);        // 校验文件的格式        if (!StrUtil.containsAnyIgnoreCase(FileUtil.getSuffix(file.getOriginalFilename()), &quot;jpg&quot;, &quot;png&quot;)) &#123;            return R.error(&quot;上传文件格式错误&quot;);        &#125;        // 校验文件的大小        if (file.getSize() / 1024 / 1024 &gt; 2) return R.error(&quot;文件过大，限制在2MB以内&quot;);                // 给文件进行重命名        String fileName = UUID.fastUUID().toString() + &quot;.&quot; + FileUtil.getSuffix(file.getOriginalFilename());        // 给文件目录分离                // 图片保存地点（不同保存地点实现方式不同）        .....        return R.success(fileName);    &#125;&#125;\n不同的保存地点\nweb服务器（项目所运行在的电脑）\n\n\n文件上传部分代码\n\n\n// 这种情况下，文件存储路径为服务器上的路径名称file.transferTo(new File(&quot;D:\\\\images\\\\&quot; + fileName));\n\n\n下载\n\n\n\n\n前端直接访问服务器域名+存储地址\n\n\n// 这种情况下，代码中需要添加访问资源映射地址// 在拦截器中配置@Configuration  public class WebMvcConfig implements WebMvcConfigurer &#123;      @Autowired      private AuthInterceptor authInterceptor;          private static final String DWG = &quot;file:&quot; + &quot;D:/images/&quot;;      @Override      public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;    // 添加访问资源的地址        registry.addResourceHandler(&quot;/virtual/**&quot;).addResourceLocations(DWG);      &#125;        @Override      public void addInterceptors(InterceptorRegistry registry) &#123;          registry.addInterceptor(authInterceptor)                  .addPathPatterns(&quot;/**&quot;)                  .excludePathPatterns(&quot;/**/login/**&quot;, &quot;/**/*.html&quot;, &quot;/**/*.js&quot;, &quot;/**/*.css&quot;, &quot;/doc.*&quot;,                          &quot;/swagger-ui.*&quot;,                          &quot;/swagger-resources&quot;,                          &quot;/webjars/**&quot;,                          &quot;/v2/api-docs/**&quot;,                          &quot;/virtual/**&quot;                  );      &#125;  &#125;\n\n\n前端通过接口下载文件\n\n\n@GetMapping(&quot;download&quot;)public void downloadPic(String name, HttpServletResponse response) throws IOException &#123;    FileInputStream fileInputStream = new FileInputStream(&quot;D:\\\\images\\\\&quot; + name);    ServletOutputStream outputStream = response.getOutputStream();    byte[] bytes = new byte[1024];    int len = 0;    while ((len = fileInputStream.read(bytes)) != -1) &#123;        outputStream.write(bytes, 0, len);    &#125;    fileInputStream.close();    outputStream.close();&#125;\n云存储服务商\n通过开通云存储服务商的OSS服务，调用提供的API，实现文件存储。一般后面两种情况会直接编写Util类方便多处调用。\n阿里云\nMaven依赖\n&lt;dependency&gt;      &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;      &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;      &lt;version&gt;3.4.2&lt;/version&gt;  &lt;/dependency&gt;\n配置文件\naliyun:    oss:      endpoint: oss-cn-hangzhou.aliyuncs.com      accessKeyId: xxxxxxxxxxxxxxxx      accessKeySecret: xxxxxxxxxxxxxxxx      bucket:  xxxxxxxxxxxxxxxx    userFolder: user/      managerFolder: manager/\n代码\n\n\nOssAutoConfiguration.java\n\n\n@Configuration  @ConditionalOnClass(&#123;OSSClient.class&#125;)  @EnableConfigurationProperties(OssProperties.class)  public class OssAutoConfiguration &#123;        private final OssProperties ossProperties;        public OssAutoConfiguration(final OssProperties ossProperties) &#123;          this.ossProperties = ossProperties;      &#125;        @Bean      public OssClientFactoryBean ossClientFactoryBean() &#123;          final OssClientFactoryBean factoryBean = new OssClientFactoryBean();          factoryBean.setEndpoint(this.ossProperties.getEndpoint());          factoryBean.setAccessKeyId(this.ossProperties.getAccessKeyId());          factoryBean.setAccessKeySecret(this.ossProperties.getAccessKeySecret());          return factoryBean;      &#125;  &#125;\n\n\nOssClientFactoryBean.class\n\n\npublic class OssClientFactoryBean implements FactoryBean&lt;OSSClient&gt;, InitializingBean, DisposableBean &#123;        private OSSClient ossClient;      private String endpoint;      private String accessKeyId;      private String accessKeySecret;        @Override      public OSSClient getObject() throws Exception &#123;          return this.ossClient;      &#125;        @Override      public Class&lt;?&gt; getObjectType() &#123;          return OSSClient.class;      &#125;        @Override      public boolean isSingleton() &#123;          return true;      &#125;        @Override      public void destroy() throws Exception &#123;          if (this.ossClient != null) &#123;              this.ossClient.shutdown();          &#125;      &#125;        @Override      public void afterPropertiesSet() throws Exception &#123;          Assert.notNull(this.endpoint, &quot;&#x27;aliyun.oss.endpoint&#x27; must be not null&quot;);          Assert.notNull(this.accessKeyId, &quot;&#x27;aliyun.oss.accessKeyId&#x27; must be not null&quot;);          Assert.notNull(this.accessKeySecret, &quot;&#x27;aliyun.oss.accessKeySecret&#x27; must be not null&quot;);          this.ossClient = new OSSClient(this.endpoint, this.accessKeyId, this.accessKeySecret);      &#125;        public void setEndpoint(final String endpoint) &#123;          this.endpoint = endpoint;      &#125;        public void setAccessKeyId(final String accessKeyId) &#123;          this.accessKeyId = accessKeyId;      &#125;        public void setAccessKeySecret(final String accessKeySecret) &#123;          this.accessKeySecret = accessKeySecret;      &#125;  &#125;\n\n\nOssProperties.java\n\n\n@Getter  @Setter  @ConfigurationProperties(prefix = &quot;aliyun.oss&quot;)  public class OssProperties &#123;      private String endpoint;      private String accessKeyId;      private String accessKeySecret;      private String bucket;      private String userFolder;      private String managerFolder;  &#125;\n\n\nOssUtil.class\n\n\n@Slf4j  @Component  public class OssUtil &#123;      @Autowired      private OSSClient ossClient;        @Autowired      private OssProperties ossProperties;        /**       * 上传文件       * @param folder &quot;需要加/ 如&quot;xxx/&quot;&quot;       * @return 文件地址       */      public String upload(MultipartFile file, String folder) &#123;          String bucketName = ossProperties.getBucket();            // 判断Bucket的存在          if (!ossClient.doesBucketExist(bucketName)) &#123;              // 创建存储空间              Bucket bucket = ossClient.createBucket(bucketName);              bucketName = bucket.getName();          &#125;            String objectName = &quot;&quot;;          try &#123;              // 以输入流的形式上传文件              InputStream is = file.getInputStream();              // 文件名              String originalFilename = file.getOriginalFilename();              if (ObjectUtil.isNull(originalFilename)) &#123;                  throw new LogicException(&quot;文件名称获取失败&quot;);              &#125;              val suffix = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));              String fileName = UUID.fastUUID().toString() + suffix.toLowerCase();              objectName = folder + DateUtil.format(new Date(), &quot;yy-MM/dd&quot;) + &quot;/&quot; + fileName;                // 文件大小              long fileSize = file.getSize();                // 创建上传Object的Metadata              ObjectMetadata metadata = new ObjectMetadata();              // 上传的文件的长度              metadata.setContentLength(is.available());              // 指定该Object被下载时的网页的缓存行为              metadata.setCacheControl(&quot;no-cache&quot;);              // 指定该Object下设置Header              metadata.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);              // 指定该Object被下载时的内容编码格式              metadata.setContentEncoding(&quot;utf-8&quot;);              // 文件的MIME，定义文件的类型及网页编码，决定浏览器将以什么形式、什么编码读取文件。如果用户没有指定则根据Key或文件名的扩展名生成，              // 如果没有扩展名则填默认值application/octet-stream              metadata.setContentType(AliyunOssFileTypeEnum.getText(suffix.toLowerCase()));              // 指定该Object被下载时的名称（指示MINME用户代理如何显示附加的文件，打开或下载，及文件名称）              metadata.setContentDisposition(&quot;filename/filesize=&quot; + originalFilename + &quot;/&quot; + fileSize + &quot;Byte.&quot;);              // 上传文件 (上传文件流的形式)              PutObjectResult putResult = ossClient.putObject(bucketName, objectName, is, metadata);              // 解析结果              String resultStr = putResult.getETag();              log.info(&quot;唯一MD5数字签名:&quot; + resultStr);          &#125; catch (OSSException oe) &#123;              // oe.printStackTrace();              log.error(&quot;上传阿里云OSS服务器异常.&quot; + oe.getMessage(), oe);          &#125; catch (ClientException ce) &#123;              // ce.printStackTrace();              log.error(&quot;阿里云OSS服务连接异常.&quot; + ce.getMessage(), ce);          &#125; catch (IOException e) &#123;              // e.printStackTrace();              log.error(&quot;文件流异常.&quot; + e.getMessage(), e);          &#125;          return &quot;https://&quot; + ossProperties.getBucket() + &quot;.&quot; + ossProperties.getEndpoint() + &quot;/&quot; + objectName;      &#125;        /**       * 上传文件 byte ()       * @param folder &quot;需要加/ 如&quot;xxx/&quot;&quot;       * @return 文件地址       */      public String imgUploadByByte(byte[] bytes, String folder) &#123;          String bucketName = ossProperties.getBucket();            // 判断Bucket的存在          if (!ossClient.doesBucketExist(bucketName)) &#123;              // 创建存储空间              Bucket bucket = ossClient.createBucket(bucketName);              bucketName = bucket.getName();          &#125;            String objectName = &quot;&quot;;          try &#123;              InputStream inputStream = new ByteArrayInputStream(bytes);                val suffix = &quot;jpg&quot;;              String fileName = UUID.fastUUID().toString() +suffix;              objectName = folder + DateUtil.format(new Date(), &quot;yy-MM/dd&quot;) + &quot;/&quot; + fileName;                // 创建上传Object的Metadata              ObjectMetadata metadata = new ObjectMetadata();              // 上传的文件的长度              metadata.setContentLength(inputStream.available());              // 指定该Object被下载时的网页的缓存行为              metadata.setCacheControl(&quot;no-cache&quot;);              // 指定该Object下设置Header              metadata.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);              // 指定该Object被下载时的内容编码格式              metadata.setContentEncoding(&quot;utf-8&quot;);              // 文件的MIME，定义文件的类型及网页编码，决定浏览器将以什么形式、什么编码读取文件。如果用户没有指定则根据Key或文件名的扩展名生成，              // 如果没有扩展名则填默认值application/octet-stream              metadata.setContentType(AliyunOssFileTypeEnum.getText(suffix));              // 上传文件 (上传文件流的形式)              PutObjectResult putResult = ossClient.putObject(bucketName, objectName, inputStream, metadata);              // 解析结果              String resultStr = putResult.getETag();              log.info(&quot;唯一MD5数字签名:&quot; + resultStr);          &#125; catch (OSSException oe) &#123;              // oe.printStackTrace();              log.error(&quot;上传阿里云OSS服务器异常.&quot; + oe.getMessage(), oe);          &#125; catch (ClientException ce) &#123;              // ce.printStackTrace();              log.error(&quot;阿里云OSS服务连接异常.&quot; + ce.getMessage(), ce);          &#125; catch (IOException e) &#123;              // e.printStackTrace();              log.error(&quot;文件流异常.&quot; + e.getMessage(), e);          &#125;          return &quot;https://&quot; + ossProperties.getBucket() + &quot;.&quot; + ossProperties.getEndpoint() + &quot;/&quot; + objectName;      &#125;        /**       * 根据objectName删除OSS服务器上的文件       *       * @param objectName     模拟文件夹名 如&quot;qj_nanjing/&quot; + Bucket下的文件的路径名+文件名 如：&quot;upload/cake.jpg&quot;       */       public Boolean deleteFile(String objectName) &#123;          String bucketName = ossProperties.getBucket();          ossClient.deleteObject(bucketName, objectName);          log.info(&quot;删除&quot; + bucketName + &quot;下的文件&quot; + objectName + &quot;成功&quot;);          return true;      &#125;        /**       * 根据url获取objectName       *     * @param url url       */    public String getObjectNameByUrl(String url) &#123;  //        url = url.replace(&quot;https://&quot; + ossProperties.getBucket() + &quot;.&quot; + ossProperties.getEndpoint() + &quot;/&quot;, &quot;&quot;);          int firstIndex = url.indexOf(&quot;/&quot;);          int secondIndex = url.indexOf(&quot;/&quot;, firstIndex + 1);          int thirdIndex = url.indexOf(&quot;/&quot;, secondIndex + 1);          int suffix = url.lastIndexOf(&quot;?&quot;) &gt; 0 ? url.lastIndexOf(&quot;?&quot;) : url.length();          url = url.substring(thirdIndex + 1, suffix);          return url;      &#125;        /**       * 获取上传文件url (非公共读写时)       *     * @param objectName 模拟文件夹名 如&quot;qj_nanjing/&quot; + Bucket下的文件的路径名+文件名 如：&quot;upload/cake.jpg&quot;       * @return url       */    public String getUrl(String objectName) &#123;          //设置URl过期时间为99年：3600L*1000*24*365*99          Date expiration = new Date(new Date().getTime() + 3600L * 1000 * 24 * 365 * 99);          GeneratePresignedUrlRequest generatePresignedUrlRequest = new GeneratePresignedUrlRequest(ossProperties.getBucket(), objectName);          generatePresignedUrlRequest.setExpiration(expiration);          URL url = ossClient.generatePresignedUrl(generatePresignedUrlRequest);          return url.toString();      &#125;&#125;\nMinio\nMaven依赖\n&lt;dependencies&gt;      &lt;dependency&gt;          &lt;groupId&gt;io.minio&lt;/groupId&gt;          &lt;artifactId&gt;minio&lt;/artifactId&gt;          &lt;version&gt;7.1.0&lt;/version&gt;      &lt;/dependency&gt;\t&lt;!--SPI--&gt;    &lt;dependency&gt;          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;          &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;          &lt;optional&gt;true&lt;/optional&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;          &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;      &lt;/dependency&gt;  &lt;/dependencies&gt;\n配置文件\nminio:    endpoint: xxxxxxxxxxxxxxxxxxxxxx #MinIO服务所在地址    bucketName: xxxxxxxxxxx #存储桶名称    accessKey: xxxxxxxxxxxxxxxx #访问的key    secretKey: xxxxxxxxxxxxxxxxxxx #访问的秘钥\n代码\n\n\nMinioProp.java\n\n\n@ConfigurationProperties(prefix = &quot;minio&quot;)  public class MinioProp &#123;      private String endpoint;      private String accessKey;      private String secretKey;      private String bucketName;        public String getEndpoint() &#123;          return endpoint;      &#125;        public void setEndpoint(String endpoint) &#123;          this.endpoint = endpoint;      &#125;        public String getAccessKey() &#123;          return accessKey;      &#125;        public void setAccessKey(String accessKey) &#123;          this.accessKey = accessKey;      &#125;        public String getSecretKey() &#123;          return secretKey;      &#125;        public void setSecretKey(String secretKey) &#123;          this.secretKey = secretKey;      &#125;        public String getBucketName() &#123;          return bucketName;      &#125;        public void setBucketName(String bucket) &#123;          this.bucketName = bucket;      &#125;  &#125;\n\n\nOSSFile.java\n\n\n@Data  public class OSSFile &#123;      /**       * 文件名       */      private String fileName;      /**       * 文件存储地址       */      private String url;      /**       * 文件ObjectName       */        private String objectName;  &#125;\n\n\nMinioUtil.java\n\n\n@Component  @Slf4j  @EnableConfigurationProperties(MinioProp.class)  public class MinioUtil &#123;      @Resource      private MinioProp prop;        private MinioClient minioClient;        /**       * 创建minioClient       */    @PostConstruct      public void createMinioClient() &#123;          try &#123;              if (null == minioClient) &#123;                  log.info(&quot;minioClient create start&quot;);                  minioClient = MinioClient.builder().endpoint(prop.getEndpoint())                          .credentials(prop.getAccessKey(), prop.getSecretKey())                          .build();                  createBucket();                  log.info(&quot;minioClient create end&quot;);              &#125;          &#125; catch (Exception e) &#123;              log.error(&quot;连接MinIO服务器异常：&quot; + e);          &#125;      &#125;        /**       * 初始化Bucket       *     * @throws Exception 异常       */      private void createBucket()              throws IOException, InvalidKeyException, InvalidResponseException, InsufficientDataException, NoSuchAlgorithmException, ServerException, InternalException, XmlParserException, InvalidBucketNameException, ErrorResponseException, RegionConflictException &#123;          if (!minioClient.bucketExists(BucketExistsArgs.builder().bucket(prop.getBucketName()).build())) &#123;              minioClient.makeBucket(MakeBucketArgs.builder().bucket(prop.getBucketName()).build());          &#125;      &#125;        /**       * 查看存储bucket是否存在       * @return boolean       */    public Boolean bucketExists(String bucketName) &#123;          Boolean found;          try &#123;              found = minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());          &#125; catch (Exception e) &#123;              e.printStackTrace();              return false;          &#125;          return found;      &#125;        /**       * 创建存储bucket       * @return Boolean       */        public Boolean makeBucket(String bucketName) &#123;          try &#123;              if (!bucketExists(bucketName)) &#123;                  minioClient.makeBucket(MakeBucketArgs.builder()                          .bucket(bucketName)                          .build());                  String policyJson = &quot;&#123;\\n&quot; +                          &quot;\\t\\&quot;Version\\&quot;: \\&quot;&quot;+new SimpleDateFormat(&quot;yyyy-mm-dd&quot;).format(System.currentTimeMillis())+&quot;\\&quot;,\\n&quot; +                          &quot;\\t\\&quot;Statement\\&quot;: [&#123;\\n&quot; +                          &quot;\\t\\t\\&quot;Effect\\&quot;: \\&quot;Allow\\&quot;,\\n&quot; +                          &quot;\\t\\t\\&quot;Principal\\&quot;: &#123;\\n&quot; +                          &quot;\\t\\t\\t\\&quot;AWS\\&quot;: [\\&quot;*\\&quot;]\\n&quot; +                          &quot;\\t\\t&#125;,\\n&quot; +                          &quot;\\t\\t\\&quot;Action\\&quot;: [\\&quot;s3:GetBucketLocation\\&quot;, \\&quot;s3:ListBucket\\&quot;, \\&quot;s3:ListBucketMultipartUploads\\&quot;],\\n&quot; +                          &quot;\\t\\t\\&quot;Resource\\&quot;: [\\&quot;arn:aws:s3:::&quot; + bucketName + &quot;\\&quot;]\\n&quot; +                          &quot;\\t&#125;, &#123;\\n&quot; +                          &quot;\\t\\t\\&quot;Effect\\&quot;: \\&quot;Allow\\&quot;,\\n&quot; +                          &quot;\\t\\t\\&quot;Principal\\&quot;: &#123;\\n&quot; +                          &quot;\\t\\t\\t\\&quot;AWS\\&quot;: [\\&quot;*\\&quot;]\\n&quot; +                          &quot;\\t\\t&#125;,\\n&quot; +                          &quot;\\t\\t\\&quot;Action\\&quot;: [\\&quot;s3:AbortMultipartUpload\\&quot;, \\&quot;s3:DeleteObject\\&quot;, \\&quot;s3:GetObject\\&quot;, \\&quot;s3:ListMultipartUploadParts\\&quot;, \\&quot;s3:PutObject\\&quot;],\\n&quot; +                          &quot;\\t\\t\\&quot;Resource\\&quot;: [\\&quot;arn:aws:s3:::&quot; + bucketName + &quot;/*\\&quot;]\\n&quot; +                          &quot;\\t&#125;]\\n&quot; +                          &quot;&#125;\\n&quot;;                  minioClient.setBucketPolicy(SetBucketPolicyArgs.builder().bucket(bucketName).config(policyJson).build());                  log.info(&quot;buckets：【&#123;&#125;】,创建[readwrite]策略成功！&quot;, bucketName);              &#125; else &#123;                  log.info(&quot;minio bucket-&gt;&gt;&gt;【&#123;&#125;】already exists&quot;, bucketName);              &#125;          &#125; catch (Exception e) &#123;              e.printStackTrace();              return false;          &#125;          return true;      &#125;      /**       * 删除存储bucket       * @return Boolean       */        public Boolean removeBucket(String bucketName) &#123;          try &#123;              minioClient.removeBucket(RemoveBucketArgs.builder()                      .bucket(bucketName)                      .build());          &#125; catch (Exception e) &#123;              e.printStackTrace();              return false;          &#125;          return true;      &#125;      /**       * 获取全部bucket       */        public List&lt;Bucket&gt; getAllBuckets() &#123;          try &#123;              List&lt;Bucket&gt; buckets = minioClient.listBuckets();              return buckets;          &#125; catch (Exception e) &#123;              e.printStackTrace();          &#125;          return null;      &#125;      /**       * 文件上传       *       * @param file 文件       * @return Boolean       */        public OSSFile upload(MultipartFile file) &#123;          String originalFilename = file.getOriginalFilename();          if (StrUtil.isBlank(originalFilename))&#123;              throw new RuntimeException();          &#125;          // 重命名          String fileName = UUID.fastUUID() + originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));          String objectName = DateUtil.format(new Date(), &quot;yy-MM/dd&quot;) + &quot;/&quot; + fileName;          try &#123;              PutObjectArgs objectArgs = PutObjectArgs.builder().bucket(prop.getBucketName()).object(objectName)                      .stream(file.getInputStream(), file.getSize(), -1).contentType(file.getContentType()).build();              //文件名称相同会覆盖              minioClient.putObject(objectArgs);          &#125; catch (Exception e) &#123;              e.printStackTrace();              return null;          &#125;            OSSFile ossFile = new OSSFile();          ossFile.setFileName(originalFilename);          ossFile.setObjectName(objectName);          ossFile.setUrl(prop.getEndpoint() + &quot;/&quot; + prop.getBucketName() + &quot;/&quot; + objectName);          return ossFile;      &#125;        /**       * 预览图片       * @param fileName       * @return       */      public String preview(String fileName)&#123;          // 查看文件地址          GetPresignedObjectUrlArgs build = new GetPresignedObjectUrlArgs().builder().bucket(prop.getBucketName()).object(fileName).method(Method.GET).build();          try &#123;              String url = minioClient.getPresignedObjectUrl(build);              return url;          &#125; catch (Exception e) &#123;              e.printStackTrace();          &#125;          return null;      &#125;        /**       * 文件下载       * @param fileName 文件名称       * @param res response       * @return Boolean       */        public void download(String fileName, HttpServletResponse res) &#123;          GetObjectArgs objectArgs = GetObjectArgs.builder().bucket(prop.getBucketName())                  .object(fileName).build();          try (InputStream response = minioClient.getObject(objectArgs))&#123;              byte[] buf = new byte[1024];              int len;              try (FastByteArrayOutputStream os = new FastByteArrayOutputStream())&#123;                  while ((len=response.read(buf))!=-1)&#123;                      os.write(buf,0,len);                  &#125;                  os.flush();                  byte[] bytes = os.toByteArray();                  res.setCharacterEncoding(&quot;utf-8&quot;);                  // 设置强制下载不打开                  // res.setContentType(&quot;application/force-download&quot;);                  res.addHeader(&quot;Content-Disposition&quot;, &quot;attachment;fileName=&quot; + fileName);                  try (ServletOutputStream stream = res.getOutputStream())&#123;                      stream.write(bytes);                      stream.flush();                  &#125;              &#125;          &#125; catch (Exception e) &#123;              e.printStackTrace();          &#125;      &#125;        /**       * 查看文件对象       * @return 存储bucket内文件对象信息       */      public List&lt;Item&gt; listObjects() &#123;          Iterable&lt;Result&lt;Item&gt;&gt; results = minioClient.listObjects(                  ListObjectsArgs.builder().bucket(prop.getBucketName()).build());          List&lt;Item&gt; items = new ArrayList&lt;&gt;();          try &#123;              for (Result&lt;Item&gt; result : results) &#123;                  items.add(result.get());              &#125;          &#125; catch (Exception e) &#123;              e.printStackTrace();              return null;          &#125;          return items;      &#125;        /**       * 删除       * @param fileName       * @return       * @throws Exception       */      public boolean remove(String fileName)&#123;          try &#123;              minioClient.removeObject( RemoveObjectArgs.builder().bucket(prop.getBucketName()).object(fileName).build());          &#125;catch (Exception e)&#123;              return false;          &#125;          return true;      &#125;  &#125;\n拓展\nMinio这个被写成了SPI加载到别的服务中，这边再加一下关于SPI的知识。\n如图resources文件夹下的META-INF文件夹下的spring.factories文件。如果要把MinioUtil这个方法加载到别的项目中，可以这么写。\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=com.hzjzxx.minio.utils.MinioUtil\n关于SPI的知识：\n\n内链：[[面试-SPI]]\n外链：SPI相关\n\n","categories":["后端项目","准备工作"],"tags":["Minio","Oss"]},{"title":"代码随想录算法训练营第十一天-239滑动窗口最大值、347前 K 个高频元素","url":"/2024/05/31/100000016/","content":"\n\n前言\n状态：239超时，347直接用的Stream流。\n\n\n更新\n\n\n24.05.31 初始记录24.06.01 完成题目\n\n初步题解\n239滑动窗口最大值\n题目链接：(https://leetcode.cn/problems/sliding-window-maximum/description/)\n暴力解法：循环判断最大值（超时）\npublic class LE239 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          String s = scanner.nextLine();          int[] split = Arrays.stream(s.split(&quot;,&quot;)).mapToInt(Integer::parseInt).toArray();          int[] ints = maxSlidingWindow(split, Integer.parseInt(scanner.nextLine()));          for (int anInt : ints) &#123;              System.out.println(anInt);          &#125;      &#125;        public static int[] maxSlidingWindow(int[] nums, int k) &#123;          if (nums.length &lt;= k) &#123;              return new int[]&#123;getMax(nums, 0, nums.length - 1)&#125;;          &#125;            ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();          for (int i = 0; i &lt;= nums.length - k; i++) &#123;              int max = getMax(nums, i, i + k - 1);              list.add(max);          &#125;          return list.stream().mapToInt(i -&gt; i).toArray();      &#125;        private static int getMax(int[] nums, int i, int j) &#123;          int max = Integer.MIN_VALUE;          for (int k = i; k &lt;= j; k++) &#123;              max = Math.max(max, nums[k]);          &#125;          return max;      &#125;  &#125;\n347前 K 个高频元素\n题目链接：(https://leetcode.cn/problems/top-k-frequent-elements/description/)\n直接用Stream流的解法，估计上班会用这个。。。甚至可以优化成一行\npublic static int[] topKFrequent(int[] nums, int k) &#123;      // map用于计数      TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;();      for (int num : nums) &#123;          map.put(num, map.getOrDefault(num, 0) + 1);      &#125;        return map.entrySet().stream()              .sorted((o1, o2) -&gt; o2.getValue() - o1.getValue())              .limit(k)              .map(Map.Entry::getKey)              .mapToInt(i -&gt; i)              .toArray();  &#125;\n看解析\n239滑动窗口最大值\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0239.滑动窗口最大值.html#思路)\n\n思路：这题放在队列专题，肯定是要用到队列思想的。按暴力的解法，求最大值的那个循环（这样效率就是O(n * k)），在这边可以用单调队列解决。\n其实队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。\n那么这个维护元素单调递减的队列就叫做单调队列，即单调递减或单调递增的队列。Java中没有直接支持单调队列，需要我们自己来实现一个单调队列\n\n设计单调队列的时候，pop，和push操作要保持如下规则：\n\n\npop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作\n\n\npush(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止（所以这里要用while）\n\n\n保持如上规则，每次窗口移动的时候，只要问que.peek()就可以返回当前窗口的最大值。\n/**   * 定义一个单调队列   */  static class MyQueue &#123;      Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();        public void push(int num) &#123;          while (!deque.isEmpty() &amp;&amp; num &gt; deque.getLast()) &#123;              deque.removeLast();          &#125;          deque.add(num);      &#125;        /**       * 判断队顶元素是否是要移除的元素       */      public void pull(int num) &#123;          if (!deque.isEmpty() &amp;&amp; deque.peek() == num) &#123;              deque.poll();          &#125;      &#125;        public int peek() &#123;          return deque.peek();      &#125;  &#125;    public static int[] maxSlidingWindow(int[] nums, int k) &#123;      MyQueue myQueue = new MyQueue();      for (int i = 0; i &lt; k; i++) &#123;          myQueue.push(nums[i]);      &#125;        int j = 0;      int[] ints = new int[nums.length - k + 1];      ints[j++] = myQueue.peek();      for (int i = k; i &lt;nums.length; i++) &#123;          // 窗口滑动，移除元素（移除时要判断元素是否在单调队列内）          myQueue.pull(nums[i - k]);          // 窗口滑动，添加最新元素到单调队列          myQueue.push(nums[i]);          // 获取单调队列队顶元素（根据定义的规则，一定是区间内最大的）          ints[j++] = myQueue.peek();      &#125;      return ints;  &#125;\n347前 K 个高频元素\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0347.前K个高频元素.html)\n这题属于：前K个大数问题。这种问题一般用大顶堆（根节点最大）或小顶堆（根节点最小）。需要使用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。\nemmmmm感觉和Stream流没有什么区别（可能在于他用的容器吧）。\n/*Comparator接口说明: * 返回负数，形参中第一个参数排在前面；返回正数，形参中第二个参数排在前面 * 对于队列：排在前面意味着往队头靠 * 对于堆（使用PriorityQueue实现）：从队头到队尾按从小到大排就是最小堆（小顶堆）， *                                从队头到队尾按从大到小排就是最大堆（大顶堆）---&gt;队头元素相当于堆的根节点 * */class Solution &#123;    //解法1：基于大顶堆实现    public int[] topKFrequent1(int[] nums, int k) &#123;        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); //key为数组元素值,val为对应出现次数        for (int num : nums) &#123;            map.put(num, map.getOrDefault(num,0) + 1);        &#125;        //在优先队列中存储二元组(num, cnt),cnt表示元素值num在数组中的出现次数        //出现次数按从队头到队尾的顺序是从大到小排,出现次数最多的在队头(相当于大顶堆)        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((pair1, pair2) -&gt; pair2[1] - pair1[1]);        for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;//大顶堆需要对所有元素进行排序            pq.add(new int[]&#123;entry.getKey(), entry.getValue()&#125;);        &#125;        int[] ans = new int[k];        for (int i = 0; i &lt; k; i++) &#123; //依次从队头弹出k个,就是出现频率前k高的元素            ans[i] = pq.poll()[0];        &#125;        return ans;    &#125;    //解法2：基于小顶堆实现    public int[] topKFrequent2(int[] nums, int k) &#123;        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); //key为数组元素值,val为对应出现次数        for (int num : nums) &#123;            map.put(num, map.getOrDefault(num, 0) + 1);        &#125;        //在优先队列中存储二元组(num, cnt),cnt表示元素值num在数组中的出现次数        //出现次数按从队头到队尾的顺序是从小到大排,出现次数最低的在队头(相当于小顶堆)        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((pair1, pair2) -&gt; pair1[1] - pair2[1]);        for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; //小顶堆只需要维持k个元素有序            if (pq.size() &lt; k) &#123; //小顶堆元素个数小于k个时直接加                pq.add(new int[]&#123;entry.getKey(), entry.getValue()&#125;);            &#125; else &#123;                if (entry.getValue() &gt; pq.peek()[1]) &#123; //当前元素出现次数大于小顶堆的根结点(这k个元素中出现次数最少的那个)                    pq.poll(); //弹出队头(小顶堆的根结点),即把堆里出现次数最少的那个删除,留下的就是出现次数多的了                    pq.add(new int[]&#123;entry.getKey(), entry.getValue()&#125;);                &#125;            &#125;        &#125;        int[] ans = new int[k];        for (int i = k - 1; i &gt;= 0; i--) &#123; //依次弹出小顶堆,先弹出的是堆的根,出现次数少,后面弹出的出现次数多            ans[i] = pq.poll()[0];        &#125;        return ans;    &#125;&#125;\n","categories":["面试","代码随想录"],"tags":["队列","单调队列","优先级队列"]},{"title":"面试-SPI","url":"/2024/05/30/100000017/","content":"\n\n前言\nSPI相关的面试问题及用法\n\n\n更新\n\n\n24.05.30 初始记录\n\nSPI介绍\n​SPI全称Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。\nJava的SPI机制就是将一些==类信息写在约定的文件中==，然后由特定的类加载器ServiceLoader加载解析文件获取资源。\nJava SPI 基于 “接口编程＋策略模式＋配置文件(约定)”组合实现的动态加载机制。它提供了一种服务发现机制，允许在程序外部动态指定具体实现。一般情况下是调用方调用实现好的接口，但是当接口存在于调用方这边时，就是 SPI ，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。​以下是SPI的一些运用场景:\n\n\n\n场景\n说明\n\n\n\n\n数据库驱动\n数据库驱动加载接口实现类的加载 JDBC加载不同类型数据库的驱动\n\n\n日志门面SLF4J接口实现类加载\nSLF4J加载不同提供商的日志实现类\n\n\nSpring\nSpring中大量使用了SPI,比如：对servlet3.0规范对ServletContainerInitializer的实现、自动类型转换Type Conversion SPI(Converter SPI、Formatter SPI)等\n\n\nDubbo\nDubbo中也大量使用SPI的方式实现框架的扩展, 不过它对Java提供的原生SPI做了封装，允许用户扩展实现Filter接口\n\n\nSpringBoot\nSpringBoot基于SPI思想实现自动装配\n\n\n插件扩展\n开源框架，想使用别人的插件，扩展某个功能。\n\n\n\nServiceLoader\n点击标题跳转链接到JavaGuide。\n面试大白话\nJava中的SPI就是你提供一个接口，然后让别人提供实现类。然后将这个实现放在resources/META-INF/services/中。这样Java启动的时候就会去扫描这个下面的jar包，并把他加载进来。一般来说用在开源框架中的插件扩展，然后比较常见的思想提现就是Java的JDBC实现，可以根据自己使用的数据库，将对应的jar包引用进来。\n（Dubbo中可能问到的问题）Dubbo中也使用了这个思想: 比如说有一行代码是：\nProtocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();\n然后在使用Protocol接口时，dubbo他会去找一个你配置的Protocol，他就会将你配置的Protocol实现类，加载到jvm中来，然后实例化对象，就用你的那个Protocol实现类就可以了。这个Protocol就是用来配置他的网络协议的，然后在源码中可以看到，默认使用的是dubbo协议，就是DubboProtocol。dubbo里面提供了大量的类似上面的扩展点，就是说，你如果要扩展一个东西，只要自己写个jar，让你的consumer或者是provider工程，依赖你的那个jar，在你的jar里指定目录下配置好接口名称对应的文件，里面通过key=实现类（这些都可以在官网的文档里找到）。\n","categories":["面试","八股文"],"tags":["SPI","面试题","Java基础"]},{"title":"代码随想录算法训练营第十二天-二叉树理论基础、递归遍历、迭代遍历、统一迭代","url":"/2024/06/01/100000019/","content":"\n\n前言\n递归、迭代、统一迭代。都是看完解析之后完成的。统一迭代有点难理解。\n\n\n更新\n\n\n24-06-03 初始记录\n\n144二叉树的前序遍历\n题目链接：(https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)\npublic List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;      ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();      preOrder(root, list);      return list;  &#125;/**   * 前序遍历 * @param root 节点   * @param list 遍历结果   */  private void preOrder(TreeNode root, ArrayList&lt;Integer&gt; list) &#123;      if (root == null) &#123;          return;      &#125;      // 当前      list.add(root.val);      // 左子树      preOrder(root.left, list);      // 右子树      preOrder(root.right, list);  &#125;\n/**   * 迭代法   * 前序遍历 中左右   * @param root 根节点   * @return 结果   */  public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;      ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();      if (root == null) &#123;          return list;      &#125;      Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();      stack.push(root);      while (!stack.isEmpty()) &#123;          TreeNode pop = stack.pop();          list.add(pop.val);            // 栈先进后出，先进右          if (pop.right != null) &#123;              stack.push(pop.right);          &#125;          if (pop.left != null) &#123;              stack.push(pop.left);          &#125;      &#125;        return list;  &#125;\npublic List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;      ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();      Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();      if (root != null) &#123;          stack.push(root);      &#125;      while (!stack.isEmpty()) &#123;          TreeNode node = stack.peek();          if (node != null) &#123;              stack.pop();              // 判断右节点              if (node.right != null) &#123;                  stack.push(node.right);              &#125;              // 左节点              if (node.left != null) &#123;                  stack.push(node.left);              &#125;              // 中间节点              stack.push(node);              stack.push(null);              // 只有到最后一个节点，才会进这个else          &#125; else &#123;              // 遇到空节点，说明后一个是要处理的节点，先弹出空节点              stack.pop();                // 再把要处理的节点弹出并加入到列表中              node = stack.peek();              stack.pop();              list.add(node.val);          &#125;      &#125;      return list;  &#125;\n94二叉树的中序遍历\n题目链接：(https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)\n中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了处理顺序和访问顺序是不一致的。\n那么在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。\npublic List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;      ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();      inOrder(root, list);      return list;  &#125;/**   * 中序遍历   * @param root 节点   * @param list 遍历结果   */  private void inOrder(TreeNode root, ArrayList&lt;Integer&gt; list) &#123;      if (root == null) &#123;          return;      &#125;      inOrder(root.left, list);      list.add(root.val);      inOrder(root.right, list);  &#125;\n/**   * 迭代法   * 中序遍历 左中右   * @param root 根节点   * @return 结果   */  public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;      ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();      if (root == null) &#123;          return list;      &#125;      Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();      TreeNode cur = root;      while (!stack.isEmpty() || cur != null) &#123;          if (cur != null) &#123;              // 先遍历左子节点(直至到最后一个左子节点)              stack.push(cur);              cur = cur.left;          &#125; else &#123;              // 此时从栈里弹出的数据，就是要处理的数据              cur = stack.pop();              list.add(cur.val);              cur = cur.right;          &#125;      &#125;        return list;  &#125;\n/**   * 中序遍历   * @param root 根节点   * @return 返回遍历结果   */  public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;      ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();      Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();      if (root != null) &#123;          stack.push(root);      &#125;      while (!stack.isEmpty()) &#123;          TreeNode node = stack.peek();          if (node != null) &#123;              stack.pop();              // 判断右节点              if (node.right != null) &#123;                  stack.push(node.right);              &#125;              // 中间节点              stack.push(node);              stack.push(null);              // 左节点              if (node.left != null) &#123;                  stack.push(node.left);              &#125;              // 只有到最后一个节点，才会进这个else          &#125; else &#123;              // 遇到空节点，说明后一个是要处理的节点，先弹出空节点              stack.pop();                // 再把要处理的节点弹出并加入到列表中              node = stack.peek();              stack.pop();              list.add(node.val);          &#125;      &#125;      return list;  &#125;\n145二叉树的后序遍历\n题目链接：(https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)\n// 递归法public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;      ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();      postOrder(root, list);      return list;  &#125;    /**   * 后序遍历   * @param root 节点   * @param list 遍历结果   */  private void postOrder(TreeNode root, ArrayList&lt;Integer&gt; list) &#123;      if (root == null) &#123;          return;      &#125;      postOrder(root.left, list);      postOrder(root.right, list);      list.add(root.val);  &#125;\n/**   * 后序遍历 左右中   * @param root 根节点   * @return 结果   */  public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;      ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();      if (root == null) &#123;          return list;      &#125;      Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();      stack.push(root);      while (!stack.isEmpty()) &#123;          TreeNode pop = stack.pop();          list.add(pop.val);            // 栈先进后出，先进右          if (pop.left != null) &#123;              stack.push(pop.left);          &#125;          if (pop.right != null) &#123;              stack.push(pop.right);          &#125;      &#125;      // 上部分代码与前序相同，left和right遍历顺序颠倒。得到的数组为中右左遍历得出的结果      // 翻转得到的结果，即为左右中遍历得出的结果      Collections.reverse(list);      return list;  &#125;\npublic List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;      ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();      Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();      if (root != null) &#123;          stack.push(root);      &#125;      while (!stack.isEmpty()) &#123;          TreeNode node = stack.peek();          if (node != null) &#123;              stack.pop();              // 中间节点              stack.push(node);              stack.push(null);              // 判断右节点              if (node.right != null) &#123;                  stack.push(node.right);              &#125;              // 左节点              if (node.left != null) &#123;                  stack.push(node.left);              &#125;              // 只有到最后一个节点，才会进这个else          &#125; else &#123;              // 遇到空节点，说明后一个是要处理的节点，先弹出空节点              stack.pop();                // 再把要处理的节点弹出并加入到列表中              node = stack.peek();              stack.pop();              list.add(node.val);          &#125;      &#125;      return list;  &#125;\n看解析\n❗递归的三要素\n文章讲解：(https://programmercarl.com/二叉树的递归遍历.html)\n\n\n确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。\n\n\n确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。\n\n\n确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。\n\n\n迭代法\n递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中所以所有递归的题目，理论上都可以使用栈解决。\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/二叉树的迭代遍历.html)\n统一迭代\n迭代法实现的先中后序，其实风格也不是那么统一，除了先序和后序，有关联，中序完全就是另一个风格了，一会用栈遍历，一会又用指针来遍历。\n在迭代法的中序遍历中提到说使用栈的话，无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况。那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。 这种方法也可以叫做标记法。\n题目链接/文章讲解：(https://programmercarl.com/二叉树的统一迭代法.html)\n","categories":["面试","代码随想录"],"tags":["二叉树"]},{"title":"面试-集合","url":"/2024/06/01/100000020/","content":"\n\n前言\n集合常见问题，其中HashMap很重要❗表示必掌握，❔表示基本不会问\n\n\n更新\n\n\n24.06.01 初始记录\n\nJava集合\n集合分为单列集合(collection)和双列集合(map)。单列集合又包括List(可重复)和Set(不可重复)，List分为ArrayList和LinkedList，Set分为HashSet和TreeSet。双列集合Map分为TreeMap和HashMap。单列集合是实现Iterable接口产成的对象，支持迭代器和增强for。\n迭代器\n基础\n所有的单列集合都可以使用迭代器，因为他们都继承了Iterable接口，这个接口里的Iterator方法可以返回一个Iterator对象，这个Iterator对象就是迭代器对象，底层针对不同类型的集合都写了不同的实现类，所以集合可以直接使用迭代器进行遍历查询。这种只需要提供一种方法（iterator方法）访问一个容器对象中各个元素，而又不暴露该对象的内部细节的方式就是迭代器设计模式。\n迭代器倒序\nList集合可以使用迭代器倒着遍历，ListIterator有previous()方法和hasprevious()方法，可以自动指向并取出上一个元素。Set集合不能用迭代器倒着遍历，但可以根据它的大小顺序倒着取出。\n使用foreach、iterator、for在有什么区别？效率上哪个更高？\n区别上：普通for循环一般用来处理比较简单的有序的，可预知大小的集合或数组.\nforeach可用于遍历任何集合或数组，而且操作简单易懂，唯一的不好就是需要了解集合内部类型，它的底层有函数式编程注解 @FunctionalInterface，也就是说它可以进行Lamda形式简写。\niterator是最强大的，他可以随时修改或者删除集合内部的元素，并且是在不需要知道元素和集合的类型的情况下进行的，当你需要对不同的容器实现同样的遍历方式时，迭代器是最好的选择！至于增强for和iterator其实是一样的，增强for编译后的.class文件中，就是iterator，所以二者除了写法是用第三方参数来表示，效率上没有任何区别。\n效率上：这个需要多方考虑，比如普通for循环用在数组是遍历最快的，它是直接获取数据，但普通for不能用在不知道长度的集合中，这就需要用iterator或者foreach，相对来说，iterator效率会高于foreach，因为foreach在访问过程中产生一个额外的Enumerator对象，这个对象会进行版本检查处理，所以它是线安全的。对于ArrayList来说，它是通过一个数组实现的，可以随机存取；但是LinkedList是通过链表实现的，当要遍历依个取出时，for循环时要取的每个元素都必须从头开始遍历，而iterator遍历则从头开始，边遍历边取，取完只需要一次遍历，所以for循环需要的时间远远超过foreach循环。 对于数组来说，for和foreach循环效率差不多，但是对于链表来说，for循环效率明显比foreach低。\nArrayList和LinkedList的底层原理\n首先，List集合是有序集合，即存取有序，List集合的特点是存取顺序一致，存储元素可重复，都有索引。\nArrayList的底层是数组，一个索引对应一个元素，所以查询速度快；但是在增删时，需要调整整组数据的移动，所以增删较慢。而LinkedList的底层是双向链表，每次查询时都要从两头开始查询（离头近就从头查，离尾近就从尾查），所以查询较慢；但是增删时，只需要将链表头结点和尾结点指向新插入的结点即可，所以增删速度较快。但如果是新增的数据量较大的情况下，ArrayList的新增效率反面比LinkedList的效率更高。因为ArrayListr底层数组的扩容是1.5倍，数据量越大，扩容的速度就越快，而链表仍需一个个断开链接和重续新链接。最后，jdk8版还对ArrayList做了懒加载优化，在之前是构造ArrayList时就默认开辟10个空间，jdk8之后变成了只有放入第1个元素时，才会开辟10个空间。\n❗❗数组的起始长度是0，在向数组中添加第一个元素时，数组容量扩为10。 后续扩容因子为1.5倍。每次扩容都是复制到新的数组。\n分别讲一下Set集合和Tree这种数据结构\nSet集合的特点是必须排序，没有索引，不可重复。Set集合分为HashSet和TreeSet，HashSet底层使用的是哈希表，它的排序规则是按照底Hash函数决定的，无法人为设置；而TreeSet的底层则是使用红黑树，可以使用自然排序（自定义类中实现Comparable接口，重写CompareTo方法）或比较器排序（在创建TreeSet对象创建一个Comparator的匿名内部类，并重写Compare方法），扩容时通过结点链接。\n \n ### TreeSet使用Iterator遍历的过程是怎么样的？\n 因为TreeSet是按大小排序的，所以会根据从左往右，从下往上的顺序打印。\n \n ## List集合是线程不安全的，你是怎么使用List集合的呢？\n 使用Collections集合工具类，对集合进行同步处理：\n   List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); \n但是在多线程开发中，对其进行遍历，需要添加 synchronized 关键字，因为List的 add、index 等方法中都是带有synchronized 关键字，但是在 iterator 中没有synchronized 关键字。\nHashMap\n❗HashMap底层的数据结构\n数组 + 最简单的原理。对存入的key进行hash计算，根据计算出的hash值，对数组长度进行取模，获取到要存入的位置。\nJDK8以前，Hash表的底层是【数组】+【链表】\nJDK8及之后，变成了【数组】+【链表】+【红黑树】\n❗JDK 1.8 中对hash算法和寻址算法是如何优化的？\nhash算法：hash值与hash值右移16位进行异或计算。得到结果位高16位+高16位与低16位的异或值。（这一步主要为了低16位在下一步寻址的时候，使低16位保留高16位的特征，减少哈希冲突）寻址：(n - 1)&amp;hash 算出数组内的一个位置。\n为什么使用&amp;运算不使用取模运算？\n取模运算性能比较差，而且(n - 1)&amp;hash的效果和hash对n取模，效果是一样的。为什么效果是一样的？因为数组的长度一直是2的n次方，只要他保持数组长度是2的n次方，那么效果就是一样的。\n❗HashMap如何解决hash碰撞？\nhash冲突，链表+红黑树，O(n)和O(logn)\n❗HashMap如何进行扩容？\n2倍扩容。扩容之后要进行rehash。即hash值与新数组长度(n - 1)进行与操作。如果值与原来不一样，新的index就是旧index + oldCap，通过这个方式，避免了rehash的时候，进行取模（效率不高）。\nHash表中数组的分手手动初始化，和自动初始化，自动初初始会在第一次插入元素时开辟空间，默认长度为16，扩容因子为0.75，每次扩容量为自身的2倍长度，扩容之后存入数组的新索引位置就会改变。手动初始化的话，可以在创建对象时自定义初始数组长度，但HashMap不一定会自主设置的数值初始化数组，而按2的n次方创建。\nHashMap1.7版本的的扩容时机是先判断是否达到阈值，达到先扩容，再添加元素，并且采用的是头插法，也就是旧元素挂在新元素下。而HashMap1.8的扩容时机是先添加元素是否达到阈值，达到直接扩容，且使用的是尾插法，即新元素挂在旧元素下面。\n初始化后，当存入新的键值对时，会先判断数组长度是否大于64，再判断链表元素是否大于等于8时，如果两者都成立，链表会自动转换成红黑树，如果数组小于64，会从第9个开始先扩容，直到数组大于等于64时，链表长度再增加，就会转为红黑树。\n❔为什么要转为红黑树呢？\n链表取一个数需要遍历链表，而红黑树相对效率要高。\n❔为什么不直接使用红黑树呢？\nHashMap源码中有相关描述： “因为树节点的大小是链表节点大小的两倍，所以只有在容器中包含足够的节点保证使用才用它”，显然尽管转为树使得查找的速度更快，但是在节点数比较小的时候，此时对于红黑树来说内存上的劣势会超过查找等操作的优势，自然使用链表更加好，但是在节点数比较多的时候，综合考虑，红黑树比链表要好。\n❔为什么转为红黑树的条件是8而不是第9第10个呢？\n源码中有对这个进行计算，正常的随机哈希码下，哈希冲突多到超过8个的概率不到千万分之一，几乎可以忽略不计了，再往后调整并没有很大意义。如果哈希冲突有那么多，说明极大可能是人为设置，故意制造哈希冲突导致，这时候就转为化红黑树，来保证查询效率。\n❔那什么时候退出红黑树呢？\n当哈希冲突个数从第8个变到第6个时，红黑树转化为链表。\n❔6与8之间的第7个冲突时，会是什么状态？\n分情况看。8退6，是红黑树转链表，6进8，是链表转红黑树，中间的7是防止频繁变动做的一个预留位，如果是8退6，中间的7就是红黑树；如果是6进8，中间的7就是链表。\n为什么1.7是头插法，1.8是尾插法？\n1.7版本使用头插法是因为头插法是操作速度最快的，找到数组位置就直接找到插入位置了，但这样插入方法在并发场景下会因为多个线程同时扩容出现循环列表，也就是Hashmap的死锁问题。\n1.8版本加入了红黑树来优化哈希桶中的遍历效率，相比头插法而言，尾插法在操作额外的遍历消耗（指遍历哈希桶）已经小很多，也可以避免之前的循环列表问题，同时如果已经变成红黑树了，也不能再用头插法了，而是按红黑树自己的规则排列了。\n❗多线程下的HashMap线程安全吗？为什么？\nHashMap本身就是不安全的，多线程下，在添加元素时容易出现数据覆盖情况而丢失数据，也可能在扩容时，迁移数据出现数据覆盖情况而丢失数据。\n","categories":["面试","八股文"],"tags":["Java","Java基础","HashMap"]},{"title":"面试-总览","url":"/2024/06/02/100000021/","content":"\n\n前言\n这个部分作为一个背题打卡List。展示面试前必须掌握的东西。\n\n\n更新\n\n\n24.06.02 初始记录\n\n集合HashMap\n\n\nput的过程\n\n\n头插法和尾插法的区别\n\n\n1.7和1.8的扩容机制(先扩容在添加调整为先添加在扩容)\n\n\n链表和红黑树的转化过程\n\n\n线程不安全的问题(解决方案)\n\n\nConcurrentHashMap的1.7和1.8原理和区别\n\n\nArrayList\n\n\n什么是双向链表\n\n\n底层原理\n\n\n和LinkedList的区别\n\n\n线程不安全如何解决\n\n\n多线程\n\n\n实现方式，每种实现方式的区别\n\n\nVolatile关键字\n\n\nCAS自旋锁\n\n\nLock锁是公平锁还是非公平锁\n\n\n你了解AQS机制它的核心原理是什么\n\n\n公平锁，非公平锁，偏向锁，轻量锁\n\n\n线程的6种状态\n\n\n线程池的7大核心参数\n\n\n4个拒绝策略\n\n\n多线程的执行流程\n\n\n线程池的常用实现方法\n\n\nThreadLocal的原理\n\n\nJVM\n\n\n说一下 JVM 的主要组成部分及其作用\n\n\n说一下 JVM 运行时数据区\n\n\n堆里面的分区：Eden，survival （from+ to），老年代，各自的特点是什么\n\n\n说一下 JVM 调优的工具\n\n\n常用的 JVM 调优的参数都有哪些\n\n\n简述Java垃圾回收机制\n\n\n什么是Full GC\n\n\n什么情况下会触发\n\n\n说一下 JVM 有哪些垃圾回收算法\n\n\n数据库\n\n\n索引的机制和底层原理\n\n\n什么是组合索引\n\n\n最左匹配原则\n\n\n数据库的事务\n\n\n引擎的原理\n\n\n数据库悲观锁和乐观锁的实现\n\n\nb+树的好处\n\n\n数据库的优化\n\n\n多个数据源如何操作\n\n\n数据库的优化\n\n\n框架\n\n\nSpring的事务传播机制\n\n\nbean 的生命周期\n\n\nSpringMVC的执行流程\n\n\nioc\n\n\ndi\n\n\naop\n\n\nSpringBoot异常处理机制\n\n\n简化操作的原理\n\n\n自定义注解\n\n\nSpringcloud的组件\n\n\nRedis\n\n\nRedis的数据类型\n\n\n常用命令\n\n\n持久化方法\n\n\n雪崩、击穿、穿透\n\n\n过期策略\n\n\n淘汰策略\n\n\n与数据库的一致性\n\n\n哨兵模式\n\n\n集群\n\n\n分布式锁\n\n\n异步队列\n\n\n延时队列\n\n\n线程模型\n\n\n分区\n\n\nMQ\n\n\n为什么要用MQ\n\n\nMQ的优势\n\n\n消息补偿机制\n\n\n一致性\n\n\n预防消息丢失\n\n\n可靠性\n\n\n不重复消费\n\n\n集群镜像模式\n\n\nMQ的工作模式\n\n\n项目应用场景\n\n\n场景\n\n\n请求量大如何拦截\n\n\n如何去两个库查数据\n\n\n","categories":["面试","八股文"]},{"title":"面试-并发🤕","url":"/2024/06/03/100000024/","content":"\n\n前言\n❗表示必掌握，❔表示基本不会问\n\n\n更新\n\n\n24.06.03 初始记录24.06.04 AQS24.06.05 线程池24.06.06 高并发24.06.10 总结\n\n高并发（锁）\n❗Java内存模型的理解\n大白话：Java的对象都是处于主内存之中，而线程拥有自己的工作内存（CPU级别的缓存）。操作过程，1) 线程把主内存中的数据读出read，2) 线程把值加载到工作内存中load，3) 线程使用这个值use，4) 线程把算好的值设置到工作内存assign，5) 把值存入store，6) 写入主内存write。如果有两个线程，会同时操作，即并发（操作结果可能只有一次的结果）。\n\n首先，JAVA内存模型是指JMM，而不是指内存结构，内存结构是在物理上的区域划分，而JMM则是抽象概念上的划分。\nJMM（内存模型）主要包括两块：主内存+工作内存。\n主内存：多个线程间通信的共享内存称之为主内存，即，数据是多个线程工共享的，在物理内存结构上通常对应“堆”中的线程共享数据。\n工作内存：多个线程各自对应自己的本地内存，即，数据只属于该线程自己的，在物理内存结构上通常对应“本地方法栈”中的线程私有数据。\nJava内存模型规定了所有的变量都存储在主内存(Main Memory)中，每条线程还有自己的工作内存(Working Memory)，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作(读取、赋值等)都必须在工作内存中进行，而不能直接读写主内存中的变量，不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值得传递均需要通过主内存来实现。\n\n❗Java内存模型中的原子性、有序性、可见性\n可见性：一个线程操作完，另一个线程必须读取操作后的数据。原子性：同时只有一个线程能操作。（不加操作默认情况下就是没有原子性的）有序性：编译之后，可能会指令重排。如果具备有序性，就不会发生指令重排。\n❗从Java底层角度聊聊volatile关键字的原理\n\nvolatile关键字与可见性的关系\n\nvolatile关键字是用来解决可见性和有序性。给数据加上volatile关键字，在线程更新数据时，会把其他线程内缓存的数据值失效，这时其他线程会强制重新从主内存加载数据值（变成新的缓存）。\n在很多开源中间件系统中，大量使用volatile。例子：在main方法中，会有一段逻辑，如果主线程在执行，不可以后台退出（这里的执行状态用一个值表示，根据值判断系统是否在运行）。如果提供了一个方法，需要关闭主线程，如果不加volatile关键字，其他线程更新状态，主线程没有同步，就会出问题。（这个类似的用法会在多处使用）\n❗指令重排以及happens-before原则\n\nvolatile关键字与有序性的关系、连带问题\n\n❔happens-before原则：\n\n\n程序次序规则：一个线程内，代码按写的顺序执行\n\n\n锁定规则：一个unLock操作先行与后一个Lock的操作（先解锁，后加锁）\n\n\nvolatile变量规则：加了volatile关键字，写操作先，读操作后\n\n\n传递规则：如果A先于B，B先于C，那么A一定先于C\n\n\n线程启动规则：线程的启动start()方法先于此线程的每个操作\n\n\n线程中断规则：对线程的interrupt()调用，先于检测到终端的发生\n\n\n线程终结规则：线程的所有操作都先于线程的终止检测操作\n\n\n对象终结规则：对象的初始化在finalize()之前\n\n\n这个规则制定了在特殊情况下，不允许指令重排。而因为这个规则，volatile关键字有一定的防止指令重排的效果（只能先写后读）。\n同时，volatile关键字本身，就有其他避免指令重排的规则（就是底层。。。最好不要问这个，谁记得住啊）。\n❗volatile底层是如何基于内存屏障保证可见性和有序性的\nvolatile不能保证原子性。（只能加锁synchronized、lock）。\nvolatile保证可见性：对于volatile修饰的变量，执行写操作，JVM会发送一条lock前缀指令给CPU，CPU在计算完之后将值强制刷回主内存。其他线程有一个嗅探机制（MESI缓存一致性协议），会去失效线程内的缓存。\nvolatile保证有序性：加入内存屏障，可以禁止指令重排。\n\n对于volatile修改变量的读写操作，都会加入内存屏障。每个volatile写操作前面，加StoreStore屏障，禁止上面的普通写和他重排；每个volatile写操作后面，加StoreLoad屏障，禁止跟下面的volatile读/写重排。每个volatile读操作后面，加LoadLoad屏障，禁止下面的普通读和voaltile读重排；每个volatile读操作后面，加LoadStore屏障，禁止下面的普通写和volatile读重排。\n\nsynchronized为什么又叫内置锁？\nsynchronized是内置于JDK中的，底层实现是native，由C/C++语言实现；同时，加锁、解锁都是JDK自动完成，不需要用户显示控制，非常方便。\n❗说说synchronized关键字的底层原理\n因为synchronized可以同时保证原子性、可见性和有序性，所以在并发编程中经常会用到他，synchronized主要有三种用法：修饰实例方法、修饰静态方法、修饰代码块。\nsynchronized 修饰代码块时，JVM 采用monitorenter 、monitorexit 两个指令来实现同步，monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指向同步代码块的结束位置。\nsynchronized 修饰同步方法时，JVM 采用ACC_SYNCHRONIZED 标记符来实现同步，这个标了该方法是一个同步方法。\n❗大白话（修饰代码块）：每个对象实例都会关联一个monitor，一个类的class对象也会关联一个monitor。一个线程过来，把monitor置1（可以重复加锁，二次加monitor变成2、3…）。当线程走出synchronized，执行monitorexit，底层获取对应的monitor进行释放。线程2加锁失败，陷入一个阻塞等待的状态。\nSyncrhronized怎么保证可见性？\nJMM中使用happens-before语义：\n\n\n线程解锁前，必须把共享变量的最新值刷新到主内存中。\n\n\n线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新获取最新的值。（注意：加锁与解锁需要是同一把锁）\n\n\nSynchronized怎么保证原子性？\n为什么会有两个monitorexit呢？\n这个主要是防止在同步代码块中线程因异常退出，而锁没有得到释放，这必然会造成死锁（等待的线程永远获取不到锁）。因此最后一个monitorexit是保证在异常情况下，锁也可以得到释放，避免死锁，它由编译器自动产生的一个异常处理器来执行。\nsynchronized可重入的原理\n重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁，且不再被阻塞。底层原理维护一个计数器，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。\nSynchronized怎么保证有序性？\n首先，Synchronized保证有序性，但不表示他能禁止指令重排。\n而之所以会有序性问题，是因为硬件层面做了很多优化，比如处理器做强化和指令重排等，这些技术引入会导致有序性问题。这有序性问题主要出在多线程中，因为单线程中是遵循JMM的as-if-serial语义的，能保证数据间的依赖关系的，比如A依赖于B，B依赖于C，那A的实现之前，必须会先执行C。as-if-serial语义的意思是：不管怎么重排序，单线程程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。\n但是多线程就可能因为指令重排导致在另一个线程中先执行到了C，多线程程序的语义就被重排序破坏了！Synchronized同步代码块可以锁住当前线程，这样每个线程单独执行，就可以保证有序性了。\nSynchronized和监视器（monitor）有什么关系？为什么Synchronized可以使用任意对象？\n首先，每个对象都可以被认为是一个“监视器monitor”，这个监视器由三部分组成：独占锁、入口队列，等待队列。\n注意：一个对象只能有一个独占锁，但是任意线程都可以拥有这个独占锁（说白了，锁占锁就是一个标记）。\nSynchronized需要获取对象锁，实际上就是获取的是对象中的独占锁，通过这个标记来判断是否已有线程进入占用（所以synchronized无论使用什么对象都可以，每个对象在堆中都有独占锁）。\n而入口队列中放的则是要竞争锁资源的其他线程，如果线程使用了wait方法，则进入对象的等待列队中。\nSynchronized中的锁中什么是重量锁（对象锁），自旋锁，自适应自旋锁，轻量锁，偏向锁，锁消除，锁粗化？\n线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的，所以引入自旋锁。\n就是等待锁的线程并不进入阻塞状态，而是执行一个无意义的循环。在循环结束后查看锁是否已经被释放，若已经释放则直接进入执行状态。因为长时间无意义循环也会大量浪费系统资源，因此自旋锁适用于间隔时间短的加锁场景。\n自适应自旋锁：\n\n\n自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。\n\n\n偏向锁：\n\n\n偏向于第一个获得它的线程。当线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID，以后该线程在进入和退出同步块时不需要花进行CAS加锁和解锁操作。适用于只有1个线程的情况。无法代替重量锁。\n\n\n轻量锁：\n\n\n如果有第二线程过来竞争，则从偏向锁升级为轻量锁，线程尝试使用 CAS 将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败。适用于只有2个线程情况。无法代替重量锁。\n\n\n重量锁：\n\n\n当有3个及以上的线程竞争时，升级为重量锁，获得锁的执行，没获得锁的阻塞挂起，直到持有锁的线程执行完同步块唤醒它们。重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。\n\n\n锁消除：\n\n\nJVM检测到不可能存在共享数据竞争，这时JVM会对这些同步锁进行锁消除。比如一个方法中使用变量是属于自己方法中的，那么这个变量是只属于该线程自己的，其他线程抢不走，这时候这个方法中的变量就没必要加锁了。锁消除的依据是逃逸分析（底层判断该数据是否有被全局引用或者程序指向无法被访问到的地方等）的数据支持。\n\n\n锁粗化：\n\n\n锁粗化就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如上面实例：vector每次add的时候都需要加锁操作，JVM检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。\n\n\n多线程中 synchronized 锁升级的原理是什么？\n偏向所锁，轻量级锁都是乐观锁，重量级锁是悲观锁。\n一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁。偏向第一个线程，这个线程在修改对象头成为偏向锁的时候使用CAS操作，并将对象头中的ThreadID改成自己的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS在进行操作。\n一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象时偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，（偏向锁就是这个时候升级为轻量级锁的）。如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。\n轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。\nSynchronized锁只会自动升级，不会降级（ReentrantReadWriteLock读写锁可以降级）。\nsynchronized 和 volatile 的区别是什么？\nsynchronized 表示只有一个线程可以获取作用对象的锁，执行代码，阻塞其他线程。\nvolatile 表示变量在 CPU 的寄存器中是不确定的，必须从主存中读取。保证多线程环境下变量的可见性；禁止指令重排序。\n区别：\n\n\nvolatile 是变量修饰符；synchronized 可以修饰类、方法、变量。\n\n\nvolatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。\n\n\nvolatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。\n\n\nvolatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。\n\n\n❗对CAS的理解及其底层实现原理\nCAS 叫做比较并交换，CAS 指令包含 3 个参数：新值，旧值，内存值（内存位置），线程会先获取内存值，然后复制到变量副本，生成旧值，旧值在一系列操作后生成新值。\n若旧值=内存值，说明没有被其他线程抢先占有，则修改内存值为新值；\n若旧值≠内存值，说明内存值已经被其他线程修改，则自旋获取新的内存值，然后重新操作。\n大白话：比如说使用synchronized对于代码块进行加锁，这个时候多个线程的执行是串行的。比如一个累加的计数器，优化可以把int类型的累加字段改成AtomicInteger类型（原子类），方法改为incrementAndGet，此时不用synchronized也是线程安全的。这个原子类底层就是CAS（Compare and Set）。在线程执行incrementAndGet时，会先读取，再尝试设置：当一个线程成功执行CAS操作（就是对比旧值是否是原来的值），另一个就会失败，失败就会重新读取，再次设置。\n❗CAS会出现经典的ABA问题\n原因：第一个线程刚获得A，第二个线程就抢走也获得A，然后改成B后又改成A，这时候第一个线程发现变量是A，就继续执行。但是这样会出现潜藏的问题，比如修改的是金额，存一笔和存两笔是两个概念。\n解决：加入版本号解决。\n❗对JDK中的AQS的理解，AQS的实现原理\n多线程访问数据除了synchronized，CAS，ConcurrentHashMap，还有Lock。ReentrantLock的底层就是AQS（Abstract Queue Synchronizer）。\nReentrantLock lock = new ReentrantLock(); // 默认使用非公平锁// 传入参数true，就使用公平锁ReentrantLock lock = new ReentrantLock(true);lock.lock();look.unlock();\n大白话：AQS底层有个state，多个线程执行CAS更新state；还有一个变量记录加锁线程。AQS中会有一个等待队列的概念。当前一个线程释放了锁，会去唤醒等待队列中的队首元素。\n非公平锁：在唤醒等待队列的过程中，如果有另一个线程抢占锁，是可以成功的。公平锁：在唤醒等待队列的过程中，如果需要抢占锁，需要加入到等待队列内，进行等待。\nReetrantReadWriteLock读写锁和RenntrantLock有什么区别？\nReentrantLock有一定的局限性，它的读锁与读锁间也会互斥，但读数据并不会改动数据，没有必要加锁保护，这就降低了程序的性能。\n因以上问题，诞生了读写锁，读写锁一种读写分离技术，它的读锁是共享的，写锁是独占的，也就是说，多个线程是可以一起读数据的，只有写数据的时候，才会同步线程。\n读写锁ReentrantReadWriteLock有什么特点？\n\n\n公平性可以选择：支持非公平(默认)和公平的锁获取，吞吐量非公平优于公平。\n\n\n重进入：读锁和写锁都支持线程重进入。\n\n\n锁降级：获取写锁，再获取读锁，然后释放写锁，这样写锁就降级为了读锁。（注：Synchronized是不能进行锁降级的，意义不一样）。\n\n\nReentrantLock与Synchronized的区别。\n\n\n二者的本质区别：synchronized 是关键字，ReentrantLock 是一个类 相同点：这两个都是可重入锁。\n\n\nReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁\n\n\nReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等。\n\n\n什么是死锁？\nA需要B解锁，B需要A解锁，两个都在中间互相等待，却谁也无法满足条件，从而发生阻塞，就是死锁。\n怎么防止死锁？\n\n\n不要写嵌套锁，容易死锁；\n\n\n尽量少用同步代码块(Synchronized);\n\n\n尽量使用ReentrantLock的tryLock方法设置超时时间，超时可以退出，防止死锁；\n\n\n尽量降低锁粒度，尽量不要几个功能一把锁；\n\n\n尽量使用JUC包；\n\n\n❗ConcurrentHashMap实现线程安全的底层原理\nJDK1.8以前，多个数组，分段加锁，一个数组一个锁。他将一个大的 ConcurrentHashMap分成16个小的 Segment。也就是说可以同时承受16个线程的并发。\nJDK1.8以后，数组里每个元素进行put操作，都是有一个不同的锁，对当个位置进行put操作时，采取的是CAS的策略。如果CAS操作失败，就使用synchronized对这个位置的对象进行锁定，然后基于链表或红黑树，对数组元素进行写入。\n多线程\n❗创建线程的4种方法\n\n\n继承 Thread 类通过继承 Thread 类，并重写它的 run 方法，我们就可以创建一个线程。\n\n\n\n\n首先定义一个类来继承 Thread 类，重写 run 方法。\n\n\n然后创建这个子类对象，并调用 start 方法启动线程。\n\n\npublic class MyThread extends Thread &#123;      private int count = 5;        /**       * 重写父类中的run()， 执行具体的业务逻辑       */      @Override      public void run() &#123;          count--;          System.out.println(count);      &#125;        public static void main(String[] args) &#123;          //1. 创建线程对象的实例， 该对象必须继承Thread类及重写了run()          MyThread my = new MyThread();            //2. 创建多个线程的实例， 进入线程的初始化状态          Thread t1 = new Thread(my);          Thread t2 = new Thread(my);          Thread t3 = new Thread(my);          /*3. 启动线程， 线程只有执行start()之后才算是真正的启动, 才会执行run()方法里面的具体逻辑           线程启动后会进入线程的就绪状态，等待CPU的调用*/          t1.start();          t2.start();          t3.start();      &#125;  &#125;\n\n\n实现 Runnable 接口通过实现 Runnable ，并实现 run 方法，也可以创建一个线程。\n\n\n\n\n首先定义一个类实现 Runnable 接口，并实现 run 方法。\n\n\n然后创建 Runnable 实现类对象，并把它作为 target 传入 Thread 的构造函数中\n\n\n最后调用 start 方法启动线程。\n\n\npublic class RunnableThread implements Runnable &#123;      @Override      public void run() &#123;          System.out.println(&quot;thread run ......&quot;);      &#125;        public static void main(String[] args) &#123;          new Thread(new RunnableThread()).run();      &#125;  &#125;\n\n\n实现 Callable 接口，并结合 Future 实现\n\n\n\n\n首先定义一个 Callable 的实现类，并实现 call 方法。call 方法是带返回值的。\n\n\n然后通过 FutureTask 的构造方法，把这个 Callable 实现类传进去。\n\n\n把 FutureTask 作为 Thread 类的 target ，创建 Thread 线程对象。\n\n\n通过 FutureTask 的 get 方法获取线程的执行结果。\n\n\npublic class TestFuture &#123;      public static void main(String[] args) throws ExecutionException, InterruptedException &#123;         FutureTask futureTask = new FutureTask&lt;&gt;(new CallableThread());          new Thread(futureTask).start();          Object o = futureTask.get();          System.out.println(o);      &#125;  &#125;    class CallableThread implements Callable &#123;      @Override      public Object call() throws Exception &#123;          System.out.println(&quot;call一下&quot;);          return 1;      &#125;  &#125;\n\n\n通过线程池创建线程此处用 JDK 自带的 Executors 来创建线程池对象。\n\n\n\n\n首先，定一个 Runnable 的实现类，重写 run 方法。\n\n\n然后创建一个拥有固定线程数的线程池。\n\n\n最后通过 ExecutorService 对象的 execute 方法传入线程对象。\n\n\npublic class ExecutorThread implements Runnable&#123;      @Override      public void run() &#123;          System.out.println(&quot;run一下&quot;);      &#125;        public static void main(String[] args) &#123;          ExecutorService executorService = Executors.newFixedThreadPool(10);          executorService.execute(new ExecutorThread());          executorService.shutdown();      &#125;  &#125;\n说一下 runnable 和 callable 有什么区别？\n相同点：\n\n\n都是接口\n\n\n都可以编写多线程程序\n\n\n都采用Thread.start()启动线程\n\n\n主要区别：\n\n\nRunnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。\n\n\nRunnable 接口 run 方法只能抛出运行时异常，且无法捕获处理；Callable 接口 call 方法允许抛出异常，可以获取异常信息。\n\n\n注：Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。\n线程的 run()和 start()有什么区别？\n每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，run()方法称为线程体。通过调用Thread类的start()方法来启动一个线程。\nstart() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。\nstart()方法来启动一个线程，真正实现了多线程运行。调用start()方法无需等待run方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， run()方法运行结束， 此线程终止。然后CPU再调度其它线程。\nrun()方法是在本线程里的，只是线程里的一个函数，而不是多线程的。 如果直接调用run()，其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。\n为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？\nnew 一个 Thread，线程进入了新建状态。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。\n而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。\n总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。\nstart()方法为什么能开启多线程？\n真正实现开启多线程的是start() 方法中的 start0() 方法。\n调用start0()方法后，该线程并不一定会立马执行，只是将线程变成了可运行状态（NEW —&gt; RUNNABLE）；具体什么时候执行，取决于 CPU ，由 CPU 统一调度；我们又知道 Java 是跨平台的，可以在不同系统上运行，每个系统的 CPU 调度算法不一样，所以就需要做不同的处理，这件事情就只能交给 JVM 来实现了，start0() 方法自然就表标记成了 native。\n如何避免线程死锁\n我们只要破坏产生死锁的四个条件中的其中一个就可以了。\n破坏互斥条件\n\n\n这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。\n\n\n破坏请求与保持条件\n\n\n一次性申请所有的资源。\n\n\n破坏不剥夺条件\n\n\n占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。\n\n\n破坏循环等待条件\n\n\n靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。\n\n\n线程的6种状态是什么？\n\n\n新建状态（new）：创建线程对象。\n\n\n就绪状态（runnable）：start方法。\n\n\n阻塞状态（blocked）：无法获得锁对象（线程没抢到）。\n\n\n等待状态（waiting）：wait方法。\n\n\n计时状态（timed_waiting）：sleep方法。\n\n\n死亡状态（terminated）：全部代码运行完毕。\n\n\n线程的调度模式是什么？\n分时调度：轮流获取CPU使用权。\n抢占式调度：优先级高的线程占用CPU。\n请说出与线程同步以及线程调度相关的方法。\n\n\nwait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；\n\n\nsleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常；\n\n\nnotify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；\n\n\nnotityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；\n\n\nsleep() 和 wait() 有什么区别？\n相同点：两者都可以暂停线程的执行。\n不同点：\n\n\nsleep方法，不会释放资源（本质是占用线程），如果占具锁资源，则其他线程不可进；wait方法会释放锁资源，即其他线程可进来。\n\n\nwait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。\n\n\nJava 中你怎样唤醒一个阻塞的线程？\n首先 ，wait()、notify() 方法是针对对象的，调用任意对象的 wait()方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的 notify()方法则将随机解除该对象阻塞的线程，但它需要重新获取该对象的锁，直到获取成功才能往下执行；\n其次，wait、notify 方法必须在 synchronized 块或方法中被调用，并且要保证同步块或方法的锁对象与调用 wait、notify 方法的对象是同一个，如此一来在调用 wait 之前当前线程就已经成功获取某对象的锁，执行 wait 阻塞后当前线程就将之前获取的对象锁释放。\nnotify() 和 notifyAll() 有什么区别？\n如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。\nnotifyAll() 会唤醒所有的线程，notify() 只会唤醒一个线程。\nnotifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。\n为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？\n这是 JDK 强制的，wait()方法和 notify()/notifyAll()方法在调用前都必须先获得对象的锁，也就是synchronized对象锁。\nJava 线程数过多会造成什么异常？\n\n\n线程的生命周期开销非常高\n\n\n消耗过多的 CPU资源如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争 CPU资源时还将产生其他性能的开销。\n\n\n降低稳定性.JVM在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出OutOfMemoryError 异常。\n\n\nThreadLocal\nThreadlocal是一个线程内部的存储类，提供了线程内存储变量的能力,可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据。这些变量不同之处在于每一个线程读取的变量是对应的互相独立的。\n其内部维护了一个ThreadLocalMap，该Map用于存储每一个线程的变量副本。并且key为线程对象，value为对应线程的变量副本。\n线程池\nExecutors类有哪几种常见的线程池？\n4种：单例线程池、固定大小线程池、可缓存线程池、大小无限线程池。\n（1）newSingleThreadExecutor：创建一个单例线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。\n（2）newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。如果希望在服务器上使用线程池，建议使用 newFixedThreadPool方法来创建线程池，这样能获得更好的性能。\n（3） newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。\n（4）newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。\n❗说说线程池的底层工作原理\n避免频繁的创建线程，销毁线程……\nExecutorService threadPool = Executors.newFixedThreadPool(10) // corePoolSize\n如果线程池内数量小于corePoolSize，就会创建一个线程执行任务。线程池一般会带一个队列，当线程执行任务完成，会等待阻塞在队列上（队首），尝试从队列继续获取任务。如果任务多于corePoolSize，会进入阻塞队列。如果阻塞队列满了，可以根据maximumPoolSize创建额外的线程。额外线程的空闲时间根据keepAliveTime进行自行销毁。\n如果额外的线程都创建完了，队列还是满的，还有新来的任务。会reject掉，有几种reject策略，可以传入RejectedExecutionHandler。\n\n\nAbortPolicy：抛异常\n\n\nDiscardPolicy：扔掉\n\n\nDiscardOldestPolicy：删除最旧的任务\n\n\nCallerRunsPolicy\n\n\n自定义\n\n\n（常用）FixedThreadPool的队列是LinkedBlockingQueue，无界阻塞队列，即队列长度无线大。corePoolSize与maximumPoolSize一样大。\n❗线程池的核心配置参数\n代表线程池的类是ThreadPoolExecutor。corePoolSize（核心线程数），maximumPoolSize（线程池），keepAliveTime（多余的空闲线程在终止之前等待新任务的最长时间），workQueue（阻塞队列）。\n七个核心参数：\n\n\n参数一：核心线程数（不能小于0）\n\n\n参数二：最大线程数（&gt;=核心线程数）\n\n\n参数三：临时线程最大存活时间（不能小于0）\n\n\n参数四：时间单位（参数三的单位）\n\n\n参数五：等待列队（不能为null）\n\n\n参数六：创建线程工厂（不能为null，一般用默认线程工厂）\n\n\n参数七：任务的拒绝策略（不能为null）\n\n\n拒绝策略有哪些\n\n\nThreadPoolExecutor.AbortPolicy：丢弃任务并抛出异常（默认）；\n\n\nThreadPoolExecutor.DiscardPolicy：丢弃任务，不抛异常（不推荐）；\n\n\nThreadPoolExecutor.DiscardOldestPolicy：丢弃等待最久的线程；\n\n\nThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程（main）运行run方法。\n\n\n❗如果在线程池中使用无界阻塞队列会发生什么问题？\n\n面试题：在远程服务异常的情况下，使用无界阻塞队列，是否会导致内存异常飙升？\n调用超时，队列变得越来越大，会导致内存飙升，可能还会导致OOM\n\n❗线程池队列满了之后，会发生什么事情\n无界队列，内存溢出。有界队列，但是如果maximumPoolSize数量很大，可以无限制创建线程，但是每个线程占用栈内存，可能会导致内存资源耗尽，或者线程太多，CPU负载太高。有界队列，maximumPoolSize数量固定，多余的任务会被拒绝。\n建议：自定义一个reject策略，如果线程池无法执行更多任务，可以把任务信息持久化写入磁盘。等负载降低重新执行这些任务。\n❗如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？\n线程池内积压的任务丢失。解决：在提交任务前，在数据库内插入任务信息，并更新他的状态：已提交、未提交、已完成……。系统重启后把任务状态重新提交。\n","categories":["面试","八股文"],"tags":["面试","八股文","多线程","线程池"]},{"title":"面试-基础","url":"/2024/06/03/100000025/","content":"\n\n前言\n❗表示必掌握，❔表示基本不会问\n\n\n更新\n\n\n24.06.03 初始记录\n\n❗Java的基本数据类型\nbyte，short，int，long，float，double，char，boolean\n面向对象的三大特性\n继承、多态、封装\nJDK和JRE的区别\nJRE：Java 运⾏时环境。它是运⾏已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，Java 命令和其他的⼀些基础构件。但是，它不能⽤于创建新程序。\nJDK(Java Development Kit)：它是功能⻬全的 Java SDK。它拥有 JRE 所拥有的⼀切，还有编译器（javac）和⼯具（如 javadoc 和 jdb）。它能够创建和编译程序。\n简单来说，JDK 包含 JRE，JRE 包含 JVM。\nJava支持多继承和多实现吗\n不支持多继承，支持多实现。\n构造函数和一般函数有什么区别\n\n\n定义格式不同\n\n\n构造函数是在对象创建时，就被调用，用于初始化，而且初始化动作只执行一次。 一般函数，是对象创建后，需要调用才执行，可以被调用多次。\n\n\nJava怎么创建对象\n\n\n使用 new 关键字\n\n\n使用newInstance方法\n\n\n\nJava 反射中有一个 newInstance() 方法，可以创建对象，步骤如下：获取要创建的类的 Class 对象。如果只需要调用这个类的访问权限为 public 无参构造器，直接使用 Class 类的实例方法 newInstance()。获取 Class 对象的构造器对象，通过调用 Class 类的实例方法 getDeclaredConstractors() 来获取构造器对象的数组。(获取所有构造器，无视访问权限的限制，数组顺序按照代码中的顺序决定)如果调用的构造器是 private 的，需要调用 Constractor 类的父类 AccessibleObject 类的实例方法 setAccessible(true) 来打破访问限制。使用 Constractor 类的实例方法 newInstance()。获取 Class 对象的方法有3个，此处不多赘述。获取Constractor 对象的方法有4个，此处不多赘述。\n\n\n\n使用clone()方法\n\n\n\nObject 类是所有类的直接或间接父类，Object 类中提供了 实例方法 native()，在给定对象的基础上，创建一个完全相同的对象。步骤如下：想要使用 clone() 方法创建对象的类，实现 Cloneable 接口。在类的内部，重写 Object 类的 clone() 方法。备注：没有实现 Cloneable 接口，会抛出 CloneNotSupportedException 异常。Object 类提供的 clone() 方法，访问权限是 protected，所以如果不重写 clone() 方法，是没有权限调用的。Object 类的 clone() 方法，是 native 方法。\n\n\n\n❔使用反序列化的readObject()方法\n\n\n\n这个方法一共分两步：将对象序列化，存储到一个文件中。从文件中反序列化，得到类对象。\n序列化：想要序列化对象的类，实现Serializable接口。使用文件输出流FileOutputStream创建存储序列化之后对象的文件。使用对象输出流ObjectOutputStream的实例方法writeObject(obj)。判断类中是否存在，名为writeReplace()，返回类型为Object的方法，若有，写入这个方法的返回值；否则，写入obj对象。\n反序列化：使用文件输入流FileInputStream找到存储序列化对象的文件。使用对象输入流ObjectInputStream的实例方法readObject()。判断类中是否存在，名为readResolve()，返回类型为Object的方法，若有读取这个对象；否则，反序列化文件中的对象流。\n备注：在类中，writeReplace()和readResoleve()是两个非常特殊的方法，其特征签名需要严格限制：方法名限定，参数个数限定为0，返回类型必须是Object，不能为Object的子类，但是可以抛出不同的异常。访问修饰符没有限制，但一般推荐为private，防止误操作。其特殊的地方还在于将其设为private方法，没有其他方法调用的情况下，编译器不会发出警告。\n\nJava中的异常\nThrowable -&gt;Exception -&gt; ClassNotFoundException\t\t\t\t\t  -&gt; IOException\t\t\t\t\t  -&gt; RuntimeException      -&gt; NullPointerException\t\t\t\t\t\t\t\t\t\t\t  -&gt; NumberFormatException\t\t\t\t\t\t\t\t\t\t\t  -&gt; IndexOutOfBoundsException\t\t\t\t\t  ......          -&gt;Error\n❗抽象类和接口的区别\n\n\n定义：接口定义：interface；抽象类：abstrat class;\n\n\n抽象类可以定义构造方法供子类调用，接口不可以；\n\n\n接口的所有方法都是抽象方法，所有属性都是常量：static final 类型；而抽象类中可以有不是抽象的方法和不是常量的属性；\n\n\n抽象类只能单继承，而接口之间可以多继承，接口之间的继承用extexds,类实现接口用implements.\n\n\n==和equals()\n==：\n\n\n如果比较的对象是基本数据类型，则比较的是其存储的值是否相等；\n\n\n如果比较的是引用数据类型，则比较的是所指向对象的地址值是否相等（是否是同一个对象）。equals：\n\n\n如果没有对 equals 方法进行重写，则相当于==，比较的是引用类型的变量所指向的对象的地址值。\n\n\n一般情况下，类会重写equals方法用来比较两个对象的内容是否相等。比如String类中的equals()是被重写了，比较的是对象的值。\n\n\n为什么重写equals方法，还必须要重写hashcode方法\n\n\n保证是同一个对象，如果重写了equals方法，而没有重写hashcode方法，会出现equals相等的对象，hashcode不相等的情况，重写hashcode方法就是为了避免这种情况的出现。\n\n\n使用hashcode方法提前校验，可以避免每一次比对都调用equals方法，提高效率\n\n\n重写后：\n\n\nequals()相等的两个对象，hashcode()一定相等；\n\n\nhashcode()不等，一定能推出equals()也不等；\n\n\nhashcode()相等，equals()可能相等，也可能不等。\n\n\n所以先进行hashcode（）判断，不等就不用equals（）方法了。\n\n\n但equels是是根据对象的特征进行重写的，有时候特征相同，但hash值不同，也不是一个对象。 所以两个都重写才能保障是同一个对象。\n\n\n","categories":["面试","八股文"],"tags":["面试","八股文"]},{"title":"代码随想录算法训练营第十四天-104二叉树的最大深度、111二叉树的最小深度、222完全二叉树的节点个数","url":"/2024/06/05/100000026/","content":"\n\n前言\n状态：104、111可以AC，222没有思路\n\n\n更新\n\n\n24.06.04 初始记录\n\n初步题解\n104二叉树的最大深度\n题目链接：(https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)\n/**   * 思路：递归计算左右子树的深度。取较大值   * @param root 根节点   * @return 结果   */  public int maxDepth(TreeNode root) &#123;      if (root == null) &#123;          return 0;      &#125;      int leftLength = maxDepth(root.left);      int rightLength = maxDepth(root.right);      return 1 + Math.max(leftLength, rightLength);  &#125;\n111二叉树的最小深度\n题目链接：(https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/)\n/**   * 思路：   * 递归终止条件   * 1.根节点为空，直接返回0   * 2.根节点的左右节点有一个为空，返回另一个节点的最小深度   *   * @param root 根节点   * @return 结果   */  public int minDepth(TreeNode root) &#123;      if (root == null) &#123;          return 0;      &#125;        if (root.right == null) &#123;          return 1 + minDepth(root.left);      &#125;      if (root.left == null) &#123;          return 1 + minDepth(root.right);      &#125;        return 1 + Math.min(minDepth(root.right), minDepth(root.left));  &#125;\n222完全二叉树的节点个数\n题目链接:(https://leetcode.cn/problems/count-complete-tree-nodes/description/)\n没有AC，思路只有一半。根据题解：递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后按满二叉树的情况来算。\n// 错误解法，正确解法在看解析部分。/**   * 思路：既然是完全二叉树。深度可以很简单的求出来   * @param root 根节点   * @return 结果   */  public int countNodes(TreeNode root) &#123;      int depth = getDepth(root);      // n - 1 层的节点数量      int num = (depth - 1) ^ 2 - 1;  &#125;      /**   * 求完全二叉树的深度   * @param root 根节点   * @return 结果   */  private int getDepth(TreeNode root) &#123;      int depth = 0;      while (root != null) &#123;          depth++;          root = root.left;      &#125;      return depth;  &#125;\n看解析\n104二叉树的最大深度\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0104.二叉树的最大深度.html)\n本题可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是深度，使用后序求的是高度。\n\n\n二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）\n\n\n二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）\n根节点的高度就是二叉树的最大深度。\n\n\n559. N 叉树的最大深度\n题目链接(https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/)\npublic int maxDepth(Node root) &#123;      if (root == null) &#123;          return 0;      &#125;        int max = 0;      for (Node child : root.children) &#123;          max = Math.max(maxDepth(child), max);      &#125;      return 1 + max;  &#125;\n111二叉树的最小深度\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0111.二叉树的最小深度.html)\n最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 注意是叶子节点。（左右孩子都为空的节点才是叶子节点）\n222完全二叉树的节点个数\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0222.完全二叉树的节点个数.html)\n递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后按满二叉树的情况来算。所以需要判断是否是满二叉树\n/**   * 完全二叉树求节点   * @param root 根节点   * @return 结果   */  public int countNodes(TreeNode root) &#123;      if (root == null) &#123;          return 0;      &#125;        TreeNode left = root.left;      TreeNode right = root.right;        int leftLength = 0, rightLength = 0;      while (left != null) &#123;          left = left.left;          leftLength++;      &#125;      while (right != null) &#123;          right = right.right;          rightLength++;      &#125;      if (leftLength == rightLength) &#123;          return (2 &lt;&lt; leftLength) - 1;      &#125;      return countNodes(root.left) + countNodes(root.right) + 1;  &#125;","categories":["面试","代码随想录"],"tags":["二叉树"]},{"title":"使用mapstruct转换对象，报错Cannot find implementation for……","url":"/2024/06/05/100000027/","content":"\n\n前言\n参考文章：mapstruct 报错 java.lang.ClassNotFoundException: Cannot find implementation for\n\n\n更新\n\n\n24.06.05 初始记录\n\n问题\n使用mapstruct转换对象，接口可以启动，但是执行报错：\njava.lang.ClassNotFoundException: Cannot find implementation for com.…….convert.AuthorizationPrivilegeConvert\n原因\n注解没有引用全。\n解决\n添加依赖，重启服务。\n&lt;dependency&gt;   &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;   &lt;artifactId&gt;mapstruct-jdk8&lt;/artifactId&gt;   &lt;version&gt;……&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;    &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt;    &lt;version&gt;……&lt;/version&gt;&lt;/dependency&gt;\n","categories":["bug记录","2024"],"tags":["Java","BUG"]},{"title":"代码随想录算法训练营第十五天-110平衡二叉树 、257二叉树的所有路径、404左叶子之和","url":"/2024/06/06/100000028/","content":"\n\n前言\n状态：110，404AC，257不会。迭代法没有写\n\n\n更新\n\n\n24.06.06 初始记录\n\n初步题解\n110平衡二叉树\n题目链接：(https://leetcode.cn/problems/balanced-binary-tree/)\npublic class LE110 &#123;      public boolean isBalanced(TreeNode root) &#123;          return getHeight(root) != -1;      &#125;        private int getHeight(TreeNode root) &#123;          if (root == null) &#123;              return 0;          &#125;            int leftHeight = getHeight(root.left);          if (leftHeight == -1) &#123;              return -1;          &#125;          int rightHeight = getHeight(root.right);          if (rightHeight == -1) &#123;              return -1;          &#125;            if (Math.abs(leftHeight - rightHeight) &gt; 1) &#123;              return -1;          &#125;          return 1 + Math.max(leftHeight, rightHeight);      &#125;  &#125;\n257二叉树的所有路径\n题目链接：(https://leetcode.cn/problems/binary-tree-paths/description/)\n(不会)\n404左叶子之和\npublic int sumOfLeftLeaves(TreeNode root) &#123;      if (root == null) &#123;          return 0;      &#125;        int sum = 0;      if (root.left != null &amp;&amp; root.left.left == null &amp;&amp; root.left.right == null) &#123;          sum += root.left.val;      &#125;      return sum + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);  &#125;\n看解析\n110平衡二叉树\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0110.平衡二叉树.html)\n分别求出其左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度，否则返回-1，表示已经不是二叉平衡树了。\n257二叉树的所有路径\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0257.二叉树的所有路径.html)\n主要是这个回溯有点懵，不知道怎么写了。但是写完代码跟着断点跑一遍，可以看到：在有下个节点时，会一直递归，直到进入到最后一个节点。在返回的途中，会把所有的进入操作，回退回去（即回退到交叉节点那个位置）。可能表述的不是很清楚，写完代码跑一遍就清楚了。\npublic static List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;      List&lt;String&gt; pathString = new ArrayList&lt;&gt;();      if (root == null) &#123;          return pathString;      &#125;      List&lt;Integer&gt; path = new ArrayList&lt;&gt;();      binaryTree(root, path, pathString);      return pathString;  &#125;    private static void binaryTree(TreeNode root, List&lt;Integer&gt; path, List&lt;String&gt; pathString) &#123;     path.add(root.val);        if (root != null &amp;&amp; (root.right == null &amp;&amp; root.left == null)) &#123;          pathString.add(path.stream().map(Object::toString).collect(Collectors.joining(&quot;-&gt;&quot;)));          return;      &#125;        if (root.left != null) &#123;          binaryTree(root.left, path, pathString);          path.remove(path.size() - 1);      &#125;      if (root.right != null) &#123;          binaryTree(root.right, path, pathString);          path.remove(path.size() - 1);      &#125;  &#125;\n404左叶子之和\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0404.左叶子之和.html)\n","categories":["面试","代码随想录"],"tags":["二叉树"]},{"title":"Long长度大于17位时，精度丢失","url":"/2024/06/06/100000029/","content":"\n\n更新\n\n\n24.06.06 初始记录\n\n问题\n前端JS在Long长度大于17位时，出现精度丢失的问题\n解决\n在此处添加注 解将返回给前端的门店ID自动转为string类型。\n\n\n使用jackson来完成自动转换，添加依赖\n\n\n&lt;dependency&gt;      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;2.9.8&lt;/version&gt;&lt;/dependency&gt;\n\n\n在对应的实体类中添加注解\n\n\n@JsonSerialize(using= ToStringSerializer.class) private Long id;","categories":["bug记录","2024"],"tags":["Java","BUG"]},{"title":"WebStorm常用设置","url":"/2024/06/06/100000030/","content":"\n\n前言\nWebStorm常用设置\n\n\n更新\n\n\n24.06.06 初始记录\n\n基本设置\n因为是同一家公司，一些基本的配置与IntelliJ IDEA是相同的，这里就不再赘述了。\n\n[[IntelliJ IDEA常用设置]]\nIntelliJ IDEA常用设置\n\n推荐插件\nESLint Restart Service Action\n\n使用 ESLint自动格式化代码。\n\n\nGitToolBox\n\n显示更详细的git信息很多 Git 的功能增强，比如自动 fetch 代码，状态栏中显示当前 Git 分支的未提交和落后提交数显示，过时分支清理，commit 窗口支持 emoji 表情，Inline Blame 可以看到每行代码是谁提交的、什么时候提交的、以及 commit 信息等等，如果你经常用 Git，这个插件必装了。\n\nHighlightBracketPair\n\n高亮括号\n\nKey Promoter X\n\n快捷键提示\n\nIntelliVue\n\nWebstorm 上对 Vue 支持很棒的插件，现在已经支持 Vue3 的一些语法，可以快速创建 Vue2 的 data、methods 等，或者 Vue3 的 setup method 等，帮你少些一些模板代码。\n\n.ignore\n\n.ignore 插件支持创建多种 .ignore 文件比如 .gitignore、.eslintignore、.dockerignore 等等，我们最常用的基本都支持，新建的时候支持选择不同类型的框架或库常用的忽略配置，如 node_modules、dist、.cache 等。\n\n","categories":["环境搭建"]},{"title":"代码随想录算法训练营第十六天-513找树左下角的值、112路径总和、113路径总和ii、106从中序与后序遍历序列构造二叉树、105从前序与中序遍历序列构造二叉树","url":"/2024/06/07/100000032/","content":"\n\n前言\n状态：513用层序AC、112AC（但时间复杂度较高））（解析中给的方法和想的不一样），113AC、106不会\n\n\n更新\n\n\n24.06.07 初始记录\n\n初步题解\n513找树左下角的值\n题目链接：(https://leetcode.cn/problems/find-bottom-left-tree-value)\n/**   * 看题目感觉层序遍历简单一点   * @param root 根节点   * @return 结果   */  public int findBottomLeftValue(TreeNode root) &#123;      List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();      findBottomDFS(root, 0, list);      List&lt;Integer&gt; theLastLayer = list.get(list.size() - 1);      return theLastLayer.stream().filter(Objects::nonNull).collect(Collectors.toList()).get(0);  &#125;    private void findBottomDFS(TreeNode root, int i, List&lt;List&lt;Integer&gt;&gt; list) &#123;      if (root == null) &#123;          return;      &#125;        // 深度增加      i++;        if (list.size() &lt; i) &#123;          ArrayList&lt;Integer&gt; innerList = new ArrayList&lt;&gt;();          list.add(innerList);      &#125;      list.get(i - 1).add(root.val);        findBottomDFS(root.left, i, list);      findBottomDFS(root.right, i, list);  &#125;\n112路径总和、113路径总和ii\n题目链接：(https://leetcode.cn/problems/path-sum/description/)\n/**   * 感觉之前做过求路径的题（递归+迭代）这题应该变换一下   * 时间复杂度好像有点高，剩下那题等看完解析后再写 * 后面改用sum直接加减不遍历求总和，但是leetcode不通过，本地倒是测试没问题 * @param root 根节点   * @param targetSum 目标和   * @return 结果   */  public boolean hasPathSum(TreeNode root, int targetSum) &#123;      if (root == null) &#123;          return false;      &#125;      List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();      return hasPathSumBFS(root, list, targetSum);  &#125;    private boolean hasPathSumBFS(TreeNode root, List&lt;Integer&gt; list, int targetSum) &#123;      list.add(root.val);        if (root.left == null &amp;&amp; root.right == null) &#123;          // 求list中的总和          long sum = list.stream().collect(Collectors.summarizingInt(value -&gt; value)).getSum();          return sum == targetSum;      &#125;        boolean left = false;      boolean right = false;      if (root.left != null) &#123;          left = hasPathSumBFS(root.left, list, targetSum);          list.remove(list.size() - 1);      &#125;      if (root.right != null) &#123;          right = hasPathSumBFS(root.right, list, targetSum);          list.remove(list.size() - 1);      &#125;            return left || right;  &#125;\n题目链接：(https://leetcode.cn/problems/path-sum-ii/)\npublic static List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) &#123;      List&lt;Integer&gt; list = new ArrayList&lt;&gt;();      List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      pathSumBFS(root, targetSum, result, list);      return result;  &#125;    private static void pathSumBFS(TreeNode root, int targetSum, List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; list) &#123;      if (root == null) &#123;          return;      &#125;        targetSum -= root.val;      list.add(root.val);        if (root.left == null &amp;&amp; root.right == null) &#123;          if (targetSum == 0) &#123;              List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(list);              result.add(arrayList);          &#125;      &#125;        if (root.left != null) &#123;          pathSumBFS(root.left, targetSum, result, list);          list.remove(list.size() - 1);      &#125;      if (root.right != null) &#123;          pathSumBFS(root.right, targetSum, result, list);          list.remove(list.size() - 1);      &#125;  &#125;\n106从中序与后序遍历序列构造二叉树、105从前序与中序遍历序列构造二叉树\n题目链接：(https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/)\n不会，直接看解析\n题目链接：(https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n更快的解法是把inorder放到map内，这样查找不用遍历。\npublic static TreeNode buildTree(int[] preorder, int[] inorder) &#123;      if (preorder.length == 0) &#123;          return null;      &#125;      TreeNode root = new TreeNode(preorder[0]);      if (preorder.length == 1) &#123;          return root;      &#125;        int indexIn = -1;      for (int i = 0; i &lt; inorder.length; i++) &#123;          if (inorder[i] == preorder[0]) &#123;              indexIn = i;              break;          &#125;      &#125;      // 左子树      int[] leftTreeInorder = Arrays.copyOfRange(inorder, 0, indexIn);      // 右子树      int[] rightTreeInorder = Arrays.copyOfRange(inorder, indexIn + 1, inorder.length);        root.left = buildTree(Arrays.copyOfRange(preorder, 1, leftTreeInorder.length + 1), leftTreeInorder);      root.right = buildTree(Arrays.copyOfRange(preorder, inorder.length - rightTreeInorder.length, inorder.length), rightTreeInorder);      return root;  &#125;\n看解析\n513找树左下角的值\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0513.找树左下角的值.html)\n那么如何找最左边的呢？可以使用前序遍历（当然中序，后序都可以，因为本题没有 中间节点的处理逻辑，只要左优先就行），保证优先左边搜索，然后记录深度最大的叶子节点，此时就是树的最后一行最左边的值。\n// 递归法int value;  int maxDeep = Integer.MIN_VALUE;  public int findBottomLeftValueBFS(TreeNode root) &#123;      value = root.val;      findLeftValue(root,0);      return value;  &#125;    private void findLeftValue(TreeNode root, int deep) &#123;      if (root == null) &#123;          return;      &#125;      if (root.left == null &amp;&amp; root.right == null) &#123;          if (deep &gt; maxDeep) &#123;              value = root.val;              maxDeep = deep;          &#125;      &#125;        if (root.left != null) &#123;          findLeftValue(root.left, deep + 1);      &#125;      if (root.right != null) &#123;          findLeftValue(root.right, deep + 1);      &#125;  &#125;\n112路径总和、113路径总和ii\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0112.路径总和.html)\n绕晕了，如果把targetSum -= root.val;这句话写在函数最前面，就不用回溯。可以看三行简化的那个注释。我理解的是Java里int不能传递值，递归内层对targetSum的值进行改变，外层不会变化，所以就不用回溯了。\n// 没搞懂怎么就不用回溯了，因为int不能传值吗？/**   * 感觉之前做过求路径的题（递归+迭代）这题应该变换一下   * @param root 根节点   * @param targetSum 目标和   * @return 结果   */  public static boolean hasPathSum(TreeNode root, int targetSum) &#123;      if (root == null) &#123;          return false;      &#125;      targetSum -= root.val;      return hasPathSumBFS(root, targetSum);  &#125;    private static boolean hasPathSumBFS(TreeNode root, int targetSum) &#123;      if (root.left == null &amp;&amp; root.right == null) &#123;          // 求list中的总和          return targetSum == 0;      &#125;        if (root.left != null) &#123;          targetSum -= root.left.val;          if (hasPathSumBFS(root.left, targetSum)) &#123;              return true;          &#125;          // 这里的回溯就是把当前节点减掉（数值加上）。包括之前也是，但是之前是list不太好移除，所以选择移除最后一位        targetSum += root.left.val;      &#125;    \t/*\t// 上面三行可以简化成  \tif (root.left != null) &#123;  \t    // 这里targetSum的值是没有变化的。减完的值进入循环，就不用回溯了  \t    hasPathSumBFS(root.left, targetSum - root.left.val);  \t&#125;\t*/\t    if (root.right != null) &#123;          targetSum -= root.right.val;          if (hasPathSumBFS(root.right, targetSum)) &#123;              return true;          &#125;          targetSum += root.right.val;      &#125;        return false;  &#125;/**   * 简化版本   */  public static boolean hasPathSum(TreeNode root, int targetSum) &#123;      if (root == null) &#123;          return false;      &#125;        if (root.left == null &amp;&amp; root.right == null) &#123;          return targetSum == 0;      &#125;            return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);  &#125;\n106从中序与后序遍历序列构造二叉树、105从前序与中序遍历序列构造二叉树\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0106.从中序与后序遍历序列构造二叉树.html)\n更快的解法是把inorder放到map内，这样查找不用遍历。\n/**   * 1.后序最后一个节点为根节点   * 2.根据这个节点切割中序数组（节点前为左子树，节点后为右子树）   * 3.根据中序数组的切割切割后序数组   * 4.递归   * @param inorder 中序遍历结果   * @param postorder 后序遍历结果   * @return 树   */  public static TreeNode buildTree(int[] inorder, int[] postorder) &#123;      if (inorder.length != postorder.length) &#123;          return null;      &#125;        if (postorder.length == 0) &#123;          return null;      &#125;      TreeNode root = new TreeNode(postorder[postorder.length - 1]);      if (postorder.length == 1) &#123;          return root;      &#125;        int indexIn = -1;      for (int i = 0; i &lt; inorder.length; i++) &#123;          if (inorder[i] == postorder[postorder.length - 1]) &#123;              indexIn = i;              break;          &#125;      &#125;      // 左子树      int[] leftTreeInorder = Arrays.copyOfRange(inorder, 0, indexIn);      // 右子树      int[] rightTreeInorder = Arrays.copyOfRange(inorder, indexIn + 1, inorder.length);        root.left = buildTree(leftTreeInorder, Arrays.copyOfRange(postorder, 0, leftTreeInorder.length));      root.right = buildTree(rightTreeInorder, Arrays.copyOfRange(postorder, leftTreeInorder.length, postorder.length - 1));      return root;  &#125;\n","categories":["面试","代码随想录"],"tags":["二叉树"]},{"title":"代码随想录算法训练营第十七天-654最大二叉树、617合并二叉树、700二叉搜索树中的搜索、98验证二叉搜索树","url":"/2024/06/07/100000033/","content":"\n\n前言\n状态：654AC、617AC可优化、700AC、98不会\n\n\n更新\n\n\n24.06.07 初始记录\n\n初步题解\n654最大二叉树\n题目链接：(https://leetcode.cn/problems/maximum-binary-tree/)\npublic static TreeNode constructMaximumBinaryTree(int[] nums) &#123;      if (nums.length == 0) &#123;          return null;      &#125;        int maxIndex = getMaxIndex(nums);      TreeNode root = new TreeNode(nums[maxIndex]);      if (nums.length == 1) &#123;          return root;      &#125;        root.left = constructMaximumBinaryTree(Arrays.copyOfRange(nums, 0, maxIndex));      root.right = constructMaximumBinaryTree(Arrays.copyOfRange(nums, maxIndex + 1, nums.length));      return root;  &#125;    private static int getMaxIndex(int[] nums) &#123;      int max = Integer.MIN_VALUE;      int maxIndex = -1;      for (int i = 0; i &lt; nums.length; i++) &#123;          if (nums[i] &gt; max) &#123;              maxIndex = i;              max = nums[i];          &#125;      &#125;      return maxIndex;  &#125;\n617合并二叉树\n题目链接：(https://leetcode.cn/problems/merge-two-binary-trees/)\npublic TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;      if (root1 == null &amp;&amp; root2 == null) &#123;          return null;      &#125;        int value1 = root1 == null ? 0 : root1.val;      int value2 = root2 == null ? 0 : root2.val;        TreeNode node = new TreeNode(value1 + value2);        if (root1 == null) &#123;          node.left = mergeTrees(null, root2.left);          node.right = mergeTrees(null, root2.right);      &#125; else if (root2 == null)&#123;          node.left = mergeTrees(root1.left, null);          node.right = mergeTrees(root1.right, null);      &#125; else &#123;          node.left = mergeTrees(root1.left, root2.left);          node.right = mergeTrees(root1.right, root2.right);      &#125;      return node;  &#125;\n700二叉搜索树中的搜索\n题目链接：(https://leetcode.cn/problems/search-in-a-binary-search-tree)\n/**   * BFS  */public TreeNode searchBST(TreeNode root, int val) &#123;      if (root == null) &#123;          return null;      &#125;      if (val == root.val) &#123;          return root;      &#125; else if (val &lt; root.val) &#123;          return searchBST(root.left, val);      &#125; else &#123;          return searchBST(root.right, val);      &#125;  &#125;    /**   * DFS  */ public TreeNode searchBSTDFS(TreeNode root, int val) &#123;      while (root != null) &#123;          if (val == root.val) &#123;              return root;          &#125; else if (val &lt; root.val)&#123;              root = root.left;          &#125; else &#123;              root = root.right;          &#125;      &#125;      return null;  &#125;\n98验证二叉搜索树\n题目链接：(https://leetcode.cn/problems/validate-binary-search-tree/)\n只比较了左节点小于中间节点，右节点大于中间节点，实际上要加上左子树所有节点小于中间节点，右子树所有节点大于中间节点\n// 没有通过，少算了一种情况public boolean isValidBST(TreeNode root) &#123;      if (root == null) &#123;          return true;      &#125;        // 左子树不为空并且大于      if (root.left != null &amp;&amp; root.left.val &gt;= root.val) &#123;          return false;          // 右子树不为空并且小于      &#125; else if (root.right != null &amp;&amp; root.right.val &lt;= root.val) &#123;          return false;      &#125;        return isValidBST(root.left) &amp;&amp; isValidBST(root.right);  &#125;\n看解析\n654最大二叉树\n题目链接/文章讲解：(https://programmercarl.com/0654.最大二叉树.html)\n视频讲解：https://www.bilibili.com/video/BV1MG411G7ox\n617合并二叉树\n题目链接/文章讲解：(https://programmercarl.com/0617.合并二叉树.html)\n视频讲解：https://www.bilibili.com/video/BV1m14y1Y7JK\n// 优化后public TreeNode mergeTrees1(TreeNode root1, TreeNode root2) &#123;      if (root1 == null &amp;&amp; root2 != null) &#123;          return root2;      &#125; else if (root1 != null &amp;&amp; root2 == null) &#123;          return root1;      &#125; else if (root1 == null &amp;&amp; root2 == null) &#123;          return null;      &#125; else &#123;          TreeNode node = new TreeNode(root1.val + root2.val);          node.left = mergeTrees(root1.left, root2.left);          node.right = mergeTrees(root1.right, root2.right);          return node;      &#125;  &#125;\n700二叉搜索树中的搜索\n题目链接/文章讲解：(https://programmercarl.com/0700.二叉搜索树中的搜索.html)\n视频讲解：https://www.bilibili.com/video/BV1wG411g7sF\n二叉搜索树是一个有序树：\n\n\n若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；\n\n\n若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；\n\n\n它的左、右子树也分别为二叉搜索树\n\n\n98验证二叉搜索树\n题目链接/文章讲解：(https://programmercarl.com/0098.验证二叉搜索树.html)\n视频讲解：https://www.bilibili.com/video/BV18P411n7Q4\n关键在于：中序遍历下，输出的二叉搜索树节点的数值是有序序列。\npublic boolean isValidBST(TreeNode root) &#123;      List&lt;Integer&gt; list = new ArrayList&lt;&gt;();      inorder(root, list);        if (list.size() &lt;= 1) &#123;          return true;      &#125;      for (int i = 0; i &lt; list.size() - 1; i++) &#123;          if (list.get(i) &gt;= list.get(i + 1)) &#123;              return false;          &#125;      &#125;      return true;  &#125;    private void inorder(TreeNode root, List&lt;Integer&gt; list) &#123;      if (root == null) &#123;          return;      &#125;      inorder(root.left, list);      list.add(root.val);      inorder(root.right, list);  &#125;    /**   * 单次循环搞定 * 双指针法 */  TreeNode max;  public boolean isValidBST1(TreeNode root) &#123;      if (root == null) &#123;          return true;      &#125;      // 左      boolean left = isValidBST1(root.left);      if (!left) &#123;          return false;      &#125;      // 中      if (max != null &amp;&amp; root.val &lt;= max.val) &#123;          return false;      &#125;      max = root;      // 右      return isValidBST1(root.right);  &#125;","categories":["面试","代码随想录"],"tags":["双指针","二叉树","二叉搜索树"]},{"title":"Leetcode与本地结果不一致问题","url":"/2024/06/08/100000034/","content":"\n\n前言\n参考文章：Leetcode与本地结果不一致问题解决及分析\n\n\n更新\n\n\n24.06.08 初始记录\n\n问题\nLeetcode提交的代码，测试用例不通过。想在本地调式查看，但是本地是没有问题的。\n原因\n本地在main方法中直接调试，部分全局变量使用了static关键字，Leetcode只加载了一次Solution类。导致全局变量没有恢复初始值。\n解决\n全部变量再提交到Leetcode时，手动删除static关键字。\n","categories":["bug记录","2024"]},{"title":"代码随想录算法训练营第十八天-530二叉搜索树的最小绝对差、501二叉搜索树中的众数、236二叉树的最近公共祖先","url":"/2024/06/08/100000035/","content":"\n\n前言\n状态：530暴力遍历、501暴力、236不会。看了昨天的题解把530改成了双指针。\n\n\n更新\n\n\n24.06.08 初始记录\n\n初步题解\n530二叉搜索树的最小绝对差\n题目链接：(https://leetcode.cn/problems/minimum-absolute-difference-in-bst)\n// 暴力遍历public int getMinimumDifference(TreeNode root) &#123;      List&lt;Integer&gt; list = new ArrayList&lt;&gt;();      getMinDiff(root, list);      int min = Math.abs(list.get(0) - list.get(1));        for (int i = 2; i &lt; list.size(); i++) &#123;          min = Math.min(Math.abs(list.get(i) - list.get(i - 1)), min);      &#125;        return min;  &#125;    private void getMinDiff(TreeNode root, List&lt;Integer&gt; list) &#123;      if (root == null) &#123;          return;      &#125;        getMinDiff(root.left, list);      list.add(root.val);      getMinDiff(root.right, list);  &#125;// 后面看了昨天最后一题的题解，这里可以用双指针/**   * 双指针的解法   * @param root 根节点   */  Integer min = Integer.MAX_VALUE;  TreeNode pre;  public int getMinimumDifference1(TreeNode root) &#123;      if (root == null) &#123;          return min;      &#125;        getMinimumDifference1(root.left);        // 中间遍历      if (pre != null) &#123;          min = Math.min(Math.abs(root.val - pre.val), min);      &#125;      pre = root;        getMinimumDifference1(root.right);        return min;  &#125;\n501二叉搜索树中的众数\n题目链接：(https://leetcode.cn/problems/find-mode-in-binary-search-tree)\npublic static int[] findMode(TreeNode root) &#123;      if (root == null) &#123;          return new int[]&#123;&#125;;      &#125;        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();      find(root, map);      List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; collect = map.entrySet().stream()              .sorted((o1, o2) -&gt; o2.getValue() - o1.getValue())              .collect(Collectors.toList());      List&lt;Integer&gt; list = new ArrayList&lt;&gt;();      list.add(collect.get(0).getKey());      for (int i = 1; i &lt; collect.size(); i++) &#123;          if (collect.get(i).getValue().equals(collect.get(0).getValue())) &#123;              list.add(collect.get(i).getKey());          &#125;      &#125;      return list.stream().mapToInt(i -&gt; i).toArray();  &#125;    private static void find(TreeNode root, Map&lt;Integer, Integer&gt; map) &#123;      if (root == null)&#123;          return;      &#125;        find(root.left, map);      map.put(root.val, map.getOrDefault(root.val, 0) + 1);      find(root.right, map);  &#125;\n236二叉树的最近公共祖先\n题目链接：(https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree)\n没有思路。\n看解析\n530二叉搜索树的最小绝对差\n题目链接/文章讲解：https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html\n视频讲解：https://www.bilibili.com/video/BV1DD4y11779\n501二叉搜索树中的众数\n题目链接/文章讲解：https://programmercarl.com/0501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.html\n视频讲解：https://www.bilibili.com/video/BV1fD4y117gp\n// 双指针的前一个节点  TreeNode pre = null;  int count = 0;  int maxCount = 0;    /**   * 双指针解法   * @param root 根节点   * @return 结果   */  public int[] findMode(TreeNode root) &#123;      List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        // 递归逻辑      findModeTravel(root, list);        return list.stream().mapToInt(i -&gt; i).toArray();  &#125;    private void findModeTravel(TreeNode root, List&lt;Integer&gt; list) &#123;      if (root == null) &#123;          return;      &#125;        findModeTravel(root.left, list);        if (pre == null) &#123;          count = 1;      &#125;else if (pre.val == root.val)&#123;          count++;      &#125; else &#123;          count = 1;      &#125;      pre = root;        if (count == maxCount) &#123;          list.add(root.val);      &#125; else if (count &gt; maxCount) &#123;          maxCount = count;          list.clear();          list.add(root.val);      &#125;        findModeTravel(root.right, list);  &#125;\n236二叉树的最近公共祖先\n题目链接/文章讲解：https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html\n视频讲解：https://www.bilibili.com/video/BV1jd4y1B7E2\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;      // return root也是空 可以和下面一起写      if (root == null) &#123;          return null;      &#125;      if (root == p || root == q) &#123;          return root;      &#125;        TreeNode left = lowestCommonAncestor(root.left, p, q);      TreeNode right = lowestCommonAncestor(root.right, p, q);        if (left!= null &amp;&amp; right != null) &#123;          return root;      &#125; else if (left != null &amp;&amp; right == null) &#123;          return left;      &#125; else if (right != null &amp;&amp; left == null) &#123;          return right;      &#125; else &#123;          return null;      &#125;  &#125;","categories":["面试","代码随想录"],"tags":["双指针","二叉树","二叉搜索树"]},{"title":"代码随想录算法训练营第十九天-235二叉搜索树的最近公共祖先、701二叉搜索树中的插入操作、450删除二叉搜索树中的节点","url":"/2024/06/09/100000036/","content":"\n\n前言\n状态：235、701AC，701还有更简单的写法。450通过失败。\n\n\n更新\n\n\n24-06-09 初始记录\n\n初步题解\n235二叉搜索树的最近公共祖先\n题目链接：(https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree)\n看了一部分的解析。主要在于当我们从上向下去递归遍历，第一次遇到 cur节点是数值在[q, p]区间中，那么cur就是 q和p的最近公共祖先。\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;      if (p.val &lt; q.val) &#123;          return lowestCommonAncestorTravel(root, p, q);      &#125; else &#123;          return lowestCommonAncestorTravel(root, q, p);      &#125;  &#125;    private TreeNode lowestCommonAncestorTravel(TreeNode root, TreeNode p, TreeNode q) &#123;      if (root == null || (p.val &lt;= root.val &amp;&amp; root.val &lt;= q.val)) &#123;          return root;      &#125; else if (root.val &gt; q.val) &#123;          return lowestCommonAncestor(root.left, p, q);      &#125; else &#123;          return lowestCommonAncestor(root.right, p, q);      &#125;  &#125;\n701二叉搜索树中的插入操作\n题目链接：(https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/)\n// 用双指针TreeNode pre;  public TreeNode insertIntoBST(TreeNode root, int val) &#123;      if (pre == null) &#123;          if (root == null) &#123;              return new TreeNode(val);          &#125;      &#125; else &#123;          if (root == null) &#123;              if (pre.val &gt; val)&#123;                  pre.left = new TreeNode(val);              &#125; else if (pre.val &lt; val) &#123;  \t                pre.right = new TreeNode(val);              &#125;              return root;          &#125;      &#125;      pre = root;        if (root.val &gt; val) &#123;          insertIntoBST(root.left, val);      &#125; else if (root.val &lt; val) &#123;          insertIntoBST(root.right, val);      &#125;        return root;  &#125;\n450删除二叉搜索树中的节点\n题目链接：(https://leetcode.cn/problems/delete-node-in-a-bst)\n想的是左子树顶位子的情况。看了解析用了右子树顶位，好像确实好理解一点。（包括讲解中的普通二叉树删除，也是用了右子树顶位）\n// 这样子用例85不能通过public TreeNode deleteNode(TreeNode root, int key) &#123;      // 为空直接返回      if (root == null) &#123;          return root;      &#125;        if (root.val == key) &#123;          if (root.left == null) &#123;              root = root.right;          &#125; else if (root.right == null) &#123;              root = root.left;          &#125; else &#123;          // 应该是这里写得不对            TreeNode right = root.right;              TreeNode leftRight = root.left.right;              root = root.left;              if (leftRight != null) &#123;                  root.right = leftRight;                  root.right.right = right;              &#125; else &#123;                  root.right = right;              &#125;          &#125;          return root;      &#125;        if (root.val &gt; key) &#123;          root.left = deleteNode(root.left, key);      &#125; else &#123;          root.right = deleteNode(root.right, key);      &#125;        return root;  &#125;\n看解析\n235二叉搜索树的最近公共祖先\n题目链接/文章讲解：https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html\n视频讲解：[https://www.bilibili.com/video/BV1Zt4y1F7ww](https://www.bilibili.com/video/BV1Zt4y1F7ww\n701二叉搜索树中的插入操作\n题目链接/文章讲解：https://programmercarl.com/0701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html\n视频讲解：https://www.bilibili.com/video/BV1Et4y1c78Y\n// 文章中给的简化版本，确实这样子思路更清晰了    public TreeNode insertIntoBST(TreeNode root, int val) &#123;        if (root == null) // 如果当前节点为空，也就意味着val找到了合适的位置，此时创建节点直接返回。            return new TreeNode(val);                    if (root.val &lt; val)&#123;            root.right = insertIntoBST(root.right, val); // 递归创建右子树        &#125;else if (root.val &gt; val)&#123;            root.left = insertIntoBST(root.left, val); // 递归创建左子树        &#125;        return root;    &#125;\n450删除二叉搜索树中的节点\n题目链接/文章讲解：https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html\n视频讲解：https://www.bilibili.com/video/BV1tP41177us\npublic TreeNode deleteNode(TreeNode root, int key) &#123;  if (root == null) return root;  if (root.val == key) &#123;    if (root.left == null) &#123;      return root.right;    &#125; else if (root.right == null) &#123;      return root.left;    &#125; else &#123;    // 只有这部分不一样      TreeNode cur = root.right;      while (cur.left != null) &#123;        cur = cur.left;      &#125;      cur.left = root.left;      root = root.right;      return root;    &#125;  &#125;  if (root.val &gt; key) root.left = deleteNode(root.left, key);  if (root.val &lt; key) root.right = deleteNode(root.right, key);  return root;&#125;","categories":["面试","代码随想录"],"tags":["二叉树","二叉搜索树"]},{"title":"代码随想录算法训练营第二十天-669修剪二叉搜索树、108将有序数组转换为二叉搜索树、538把二叉搜索树转换为累加树","url":"/2024/06/09/100000037/","content":"\n\n前言\n状态：669通过，但是有更简单的方法。108AC。538没有思路，看了解题思路写出来了。\n\n\n更新\n\n\n24-06-09 初始记录\n\n初步题解\n669修剪二叉搜索树\n题目链接：(https://leetcode.cn/problems/trim-a-binary-search-tree)\n\t/**     * 思路：查找节点，删除节点     *      * @param root 根节点     * @param low  区间左范围     * @param high 区间右范围     * @return     */    public static TreeNode trimBST(TreeNode root, int low, int high) &#123;        if (root == null) &#123;            return root;        &#125;        // 先剪枝        cut(root, low, high);        // 再减单个        return travel(root, low, high);    &#125;    private static TreeNode travel(TreeNode root, int low, int high) &#123;        if (root == null) &#123;            return root;        &#125;        if (low &lt;= root.val &amp;&amp; root.val &lt;= high) &#123;            root.left = travel(root.left, low, high);            root.right = travel(root.right, low, high);        &#125; else &#123;            if (root.left == null) &#123;                return root.right;            &#125; else if (root.right == null) &#123;                return root.left;            &#125; else &#123;                // 删除这个节点                // 1.右子树补位(找到右子树的最左侧节点)                TreeNode cur = root.right;                while (cur.left != null) &#123;                    cur = cur.left;                &#125;                cur.left = root.left;                root = root.right;                return root;            &#125;        &#125;        root.left = travel(root.left, low, high);        root.right = travel(root.right, low, high);        return root;    &#125;    private static void cut(TreeNode root, int low, int high) &#123;        if (root == null) &#123;            return;        &#125;        // 整条剪掉        if (root.val &gt; high) &#123;            root.right = null;            root.left = trimBST(root.left, low, high);        &#125;        if (root.val &lt; low) &#123;            root.left = null;            root.right = trimBST(root.right, low, high);        &#125;        cut(root.left, low, high);        cut(root.right, low, high);    &#125;// 因为时间复杂度太高，后面又写了一个版本，但是这个版本AC不了public static TreeNode trimBST(TreeNode root, int low, int high) &#123;          if (root == null) &#123;              return root;          &#125;            if (root.val &gt; high) &#123;  \t\t\treturn root.left;              // return trimBST(root.left, low, high);          &#125;          if (root.val &lt; low) &#123;              // 继续向右遍历  \t\t\treturn root.right;              // return trimBST(root.right, low, high);          &#125;            if (low &lt;= root.val &amp;&amp; root.val &lt;= high) &#123;              root.left = trimBST(root.left, low, high);              root.right = trimBST(root.right, low, high);          &#125;            while (root != null &amp;&amp; (root.val &lt; low || root.val &gt; high)) &#123;              if (root.left == null) &#123;                  root = root.right;              &#125; else if (root.right == null) &#123;                  root = root.left;              &#125; else &#123;                  // 删除这个节点                  // 1.右子树补位(找到右子树的最左侧节点)                  TreeNode cur = root.right;                  while (cur.left != null) &#123;                      cur = cur.left;                  &#125;                  cur.left = root.left;                  root = root.right;              &#125;          &#125;          return root;      &#125;\n108将有序数组转换为二叉搜索树\n题目链接：(https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)\npublic static TreeNode sortedArrayToBST(int[] nums) &#123;      if (nums.length == 0) &#123;          return null;      &#125;      return sortedBFS(nums, 0, nums.length);  &#125;    private static TreeNode sortedBFS(int[] nums, int i, int j) &#123;      if (i &gt;= j) &#123;          return null;      &#125;        int mid = (j - i) / 2 + i;      TreeNode treeNode = new TreeNode(nums[mid]);      treeNode.left = sortedBFS(nums, i, mid);      treeNode.right = sortedBFS(nums , mid + 1, j);      return treeNode;  &#125;\n538把二叉搜索树转换为累加树\n题目链接：(https://leetcode.cn/problems/convert-bst-to-greater-tree)\n/**   * 看了题解之后写出来的   * 思路：   * 1.二叉搜索树，中序遍历（左中右）有序   * 2.要按倒序相加，遍历方向相反   * 3.取一个指针指向前节点不断累加   */  TreeNode pre = new TreeNode(0);  public TreeNode convertBST(TreeNode root) &#123;      getTreeNodeTravel(root);      return root;  &#125;    private void getTreeNodeTravel(TreeNode root) &#123;      if (root == null) &#123;          return;      &#125;        getTreeNodeTravel(root.right);        root.val = pre.val + root.val;      pre = root;      getTreeNodeTravel(root.left);  &#125;\n看解析\n669修剪二叉搜索树\n题目链接/文章讲解： https://programmercarl.com/0669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html\n视频讲解： [https://www.bilibili.com/video/BV17P41177ud](https://www.bilibili.com/video/BV17P41177ud\n看了题解发现是下面两行导致不能AC。这里不能直接剪掉，忽略了情况。并且用了下面的继续递归，就不用再删除节点了。\nif (root.val &gt; high) &#123;  \treturn root.left;      // return trimBST(root.left, low, high);  &#125;  if (root.val &lt; low) &#123;      // 继续向右遍历  \treturn root.right;      // return trimBST(root.right, low, high);  &#125;  \n正确方法（🥴好难）：\npublic static TreeNode trimBST(TreeNode root, int low, int high) &#123;      if (root == null) &#123;          return root;      &#125;      if (root.val &gt; high) &#123;          return trimBST(root.left, low, high);      &#125;      if (root.val &lt; low) &#123;           return trimBST(root.right, low, high);      &#125;      if (low &lt;= root.val &amp;&amp; root.val &lt;= high) &#123;          root.left = trimBST(root.left, low, high);          root.right = trimBST(root.right, low, high);      &#125;      return root;  &#125;\n108将有序数组转换为二叉搜索树\n题目链接/文章讲解： https://programmercarl.com/0108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html\n视频讲解：[https://www.bilibili.com/video/BV1uR4y1X7qL](https://www.bilibili.com/video/BV1uR4y1X7qL\n538把二叉搜索树转换为累加树\n题目链接/文章讲解： https://programmercarl.com/0538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html\n视频讲解：https://www.bilibili.com/video/BV1d44y1f7wP\n","categories":["面试","代码随想录"],"tags":["二叉树","二叉搜索树","累加树"]},{"title":"代码随想录算法训练营第十三天-层序遍历、226翻转二叉树、101对称二叉树","url":"/2024/06/03/100000038/","content":"\n\n前言\n状态：层序遍历直接看解析。226、101看了部分解析。可以完成递归法。\n\n\n更新\n\n\n24.06.03 初始记录\n\n初步题解\n102二叉树的层序遍历\n题目链接：(https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)\npublic List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;      ArrayList&lt;List&lt;Integer&gt;&gt; resultList = new ArrayList&lt;&gt;();      levelOrderDFS(root, 0, resultList);      levelOrderBFS(root, resultList);      return resultList;  &#125;    /**   * 迭代法实现层序遍历（广度优先）   * @param root 根节点   * @param resultList 返回的list   */private void levelOrderBFS(TreeNode root, ArrayList&lt;List&lt;Integer&gt;&gt; resultList) &#123;      if (root == null) &#123;          return;      &#125;        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();      queue.offer(root);      while (!queue.isEmpty()) &#123;          ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();          int size = queue.size();            // 遍历当前层所有节点          while (size &gt; 0) &#123;              TreeNode node = queue.poll();              list.add(node.val);                // 把这层所有的左节点加入              if (node.left != null) &#123;                  queue.offer(node.left);              &#125;              // 把这层所有的右节点加入              if (node.right != null) &#123;                  queue.offer(node.right);              &#125;              size--;          &#125;          resultList.add(list);      &#125;  &#125;    /**   * 递归方式实现层序遍历(深度优先)   * @param root 根节点   * @param i 层数   * @param resultList 遍历结果   */  private void levelOrderDFS(TreeNode root, int i, ArrayList&lt;List&lt;Integer&gt;&gt; resultList) &#123;      if (root == null) &#123;          return;      &#125;        i++;        // 如果小于，说明第一次进这层，需要初始化这个位置的list      if (resultList.size() &lt; i) &#123;          ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();          resultList.add(list);      &#125;      resultList.get(i - 1).add(root.val);        levelOrderDFS(root.left, i, resultList);      levelOrderDFS(root.right, i, resultList);  &#125;\n226翻转二叉树\n题目链接：(https://leetcode.cn/problems/invert-binary-tree/description/)\n看了一部分的题目解析，突然反应过来tree不用自己构建，直接用方法简单很多。\n/**   * DFS递归   * @param root 根节点   * @return 翻转结果   */  public TreeNode invertTree(TreeNode root) &#123;      invertTreePreorder(root);      return root;  &#125;    private void invertTreePreorder(TreeNode root) &#123;      if (root == null) &#123;          return;      &#125;      TreeNode temp = new TreeNode();      // 指针交换      temp = root.left;      root.left = root.right;      root.right = temp;        if (root.left != null) &#123;          invertTreePreorder(root.left);      &#125;      if (root.right != null) &#123;          invertTreePreorder(root.right);      &#125;  &#125;\n101对称二叉树\n题目链接：(https://leetcode.cn/problems/symmetric-tree/description/)\n/**   * 这题和翻转放在一起   * 第一思路就是翻转之后比较是否相等(但是是指针引用，翻转之后是不能进行比较的)   * 看了部分讲解，说是把左子，右子拆分成两棵树来看.   * 可以拆分之后翻转一棵树，然后比较是否相等。   *   * @param root 根节点   * @return 结果   */  public static boolean isSymmetric(TreeNode root) &#123;      if (root == null) &#123;          return true;      &#125;      TreeNode right = root.right;      TreeNode left = root.left;        // 左子树翻转      invertTreePreorder(left);      return isEqual(right, left);  &#125;    private static boolean isEqual(TreeNode right, TreeNode left) &#123;      if (right == null &amp;&amp; left == null) &#123;          return true;      &#125;      if ((right == null &amp;&amp; left != null) || (right != null &amp;&amp; left == null)) &#123;          return false;      &#125;      if (right.val != left.val) &#123;          return false;      &#125;        return isEqual(right.right, left.right) &amp;&amp; isEqual(right.left, left.left);  &#125;    private static void invertTreePreorder(TreeNode root) &#123;      if (root == null) &#123;          return;      &#125;      TreeNode temp;      // 指针交换      temp = root.left;      root.left = root.right;      root.right = temp;        if (root.left != null) &#123;          invertTreePreorder(root.left);      &#125;      if (root.right != null) &#123;          invertTreePreorder(root.right);      &#125;  &#125;\n看解析\n102二叉树的层序遍历\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0102.二叉树的层序遍历.html)\n层序遍历一个二叉树。需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。\n而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。\n226翻转二叉树\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0226.翻转二叉树.html)\n递归的中序遍历是不行的，因为使用递归的中序遍历，某些节点的左右孩子会翻转两次。\n101对称二叉树\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0101.对称二叉树.html)\n本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。\n正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。\n/**    * 看完解析后的思路，不用翻转直接比较是否相等   *   * @param root 根节点   * @return 结果   */public static boolean isSymmetric(TreeNode root) &#123;      if (root == null) &#123;          return true;      &#125;      TreeNode right = root.right;      TreeNode left = root.left;        return compare(right, left);  &#125;    private static boolean compare(TreeNode right, TreeNode left) &#123;      if (right == null &amp;&amp; left == null) &#123;          return true;      &#125;      if ((right == null &amp;&amp; left != null) || (right != null &amp;&amp; left == null)) &#123;          return false;      &#125;      if (right.val != left.val) &#123;          return false;      &#125;        return compare(right.right, left.left) &amp;&amp; compare(right.left, left.right);  &#125;\n    /**     * 迭代法     * 使用双端队列，相当于两个栈     */    public boolean isSymmetric2(TreeNode root) &#123;        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();        deque.offerFirst(root.left);        deque.offerLast(root.right);        while (!deque.isEmpty()) &#123;            TreeNode leftNode = deque.pollFirst();            TreeNode rightNode = deque.pollLast();            if (leftNode == null &amp;&amp; rightNode == null) &#123;                continue;            &#125;//            if (leftNode == null &amp;&amp; rightNode != null) &#123;//                return false;//            &#125;//            if (leftNode != null &amp;&amp; rightNode == null) &#123;//                return false;//            &#125;//            if (leftNode.val != rightNode.val) &#123;//                return false;//            &#125;            // 以上三个判断条件合并            if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) &#123;                return false;            &#125;            deque.offerFirst(leftNode.left);            deque.offerFirst(leftNode.right);            deque.offerLast(rightNode.right);            deque.offerLast(rightNode.left);        &#125;        return true;    &#125;    /**     * 迭代法     * 使用普通队列     */    public boolean isSymmetric3(TreeNode root) &#123;        Queue&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();        deque.offer(root.left);        deque.offer(root.right);        while (!deque.isEmpty()) &#123;            TreeNode leftNode = deque.poll();            TreeNode rightNode = deque.poll();            if (leftNode == null &amp;&amp; rightNode == null) &#123;                continue;            &#125;//            if (leftNode == null &amp;&amp; rightNode != null) &#123;//                return false;//            &#125;//            if (leftNode != null &amp;&amp; rightNode == null) &#123;//                return false;//            &#125;//            if (leftNode.val != rightNode.val) &#123;//                return false;//            &#125;            // 以上三个判断条件合并            if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) &#123;                return false;            &#125;            // 这里顺序与使用Deque不同            deque.offer(leftNode.left);            deque.offer(rightNode.right);            deque.offer(leftNode.right);            deque.offer(rightNode.left);        &#125;        return true;    &#125;\n","categories":["面试","代码随想录"],"tags":["二叉树"]},{"title":"代码随想录算法训练营第二十一天-理论基础、77组合","url":"/2024/06/10/100000039/","content":"\n\n前言\n状态：理论基础总结在[[面试-数据结构和算法]]中。\n\n\n更新\n\n\n24-05-10 初始记录\n\n初步题解\n77组合\n题目链接：(https://leetcode.cn/problems/combinations/)\npublic List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;      List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      List&lt;Integer&gt; list = new ArrayList&lt;&gt;();      combineBFS(1, n, k, list, result);      return result;  &#125;    /**   * * @param start 当前开始节点   * @param n n   * @param k k   * @param list 每个list   * @param result 最后的结果   */  private void combineBFS(int start, int n, int k, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; result) &#123;      if (list.size() == k) &#123;          List&lt;Integer&gt; resultOne = new ArrayList&lt;&gt;(k);          resultOne.addAll(list);          result.add(resultOne);          return;      &#125;        for (int j = start; j &lt;= n; j++) &#123;          list.add(j);          combineBFS(j + 1, n, k, list, result);          list.remove(list.size() - 1);      &#125;  &#125;\n看解析\n77组合\n题目链接/文章讲解：https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html\n视频讲解：https://www.bilibili.com/video/BV1ti4y1L7cv\n剪枝操作：https://www.bilibili.com/video/BV1wi4y157er\npublic List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;      List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      List&lt;Integer&gt; list = new ArrayList&lt;&gt;();      combineBFS(1, n, k, list, result);      return result;  &#125;    /**   * * @param start 当前开始节点   * @param n n   * @param k k   * @param list 每个list   * @param result 最后的结果   */  private void combineBFS(int start, int n, int k, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; result) &#123;      if (list.size() == k) &#123;          List&lt;Integer&gt; resultOne = new ArrayList&lt;&gt;(k);          resultOne.addAll(list);          result.add(resultOne);          return;      &#125;  \t// 附带剪枝操作    for (int j = start; j &lt;= (n - (k - list.size())) + 1; j++) &#123;          list.add(j);          combineBFS(j + 1, n, k, list, result);          list.remove(list.size() - 1);      &#125;  &#125;\n","categories":["面试","代码随想录"],"tags":["回溯算法"]},{"title":"代码随想录算法训练营第二十二天-216组合总和III、17电话号码的字母组合","url":"/2024/06/10/100000040/","content":"\n\n前言\n状态：216可以AC。17看了部分解析写出来的。\n\n\n更新\n\n\n24-06-10 初始记录\n\n初步题解\n216组合总和III\n题目链接：(https://leetcode.cn/problems/combination-sum-iii)\npublic class LE22 &#123;      public static void main(String[] args) &#123;          List&lt;List&lt;Integer&gt;&gt; combinationSum3 = combinationSum3(9, 45);          for (List&lt;Integer&gt; integerList : combinationSum3) &#123;              System.out.println(Arrays.toString(integerList.stream().mapToInt(n -&gt; n).toArray()));          &#125;      &#125;        public static List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123;          // 结果集          List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();          // 单个结果          List&lt;Integer&gt; list = new ArrayList&lt;&gt;();            combinationSum(1, k, n, 0, list, result);          return result;      &#125;        private static void combinationSum(int start, int k, int n, int sum, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; result) &#123;          // 剪枝操作          if (sum &gt; n) &#123;              return;          &#125;            if (list.size() == k) &#123;              if (sum == n) &#123;                  List&lt;Integer&gt; resultOne = new ArrayList&lt;&gt;(list);                  result.add(resultOne);              &#125;              return;          &#125;            for (int j = start; j &lt;= 9 - (k - list.size()) + 1; j++) &#123;              list.add(j);              combinationSum(j + 1, k, n, sum + j, list, result);              list.remove(list.size() - 1);          &#125;      &#125;  &#125;\n17电话号码的字母组合\n题目链接：(https://leetcode.cn/problems/letter-combinations-of-a-phone-number)\n/**   * @param digits 按键数组   * @return 结果   */  public static List&lt;String&gt; letterCombinations(String digits) &#123;      List&lt;String&gt; list = new ArrayList&lt;&gt;();      String[] buttonList = &#123;&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;;        if (digits == null || &quot;&quot;.equals(digits)) &#123;          return list;      &#125;        combinations(0, digits, buttonList, &quot;&quot;, list);      return list;  &#125;    /**   * * @param i 遍历的层数   */  private static void combinations(int i, String digits, String[] buttonList, String str, List&lt;String&gt; list) &#123;      if (i == digits.length()) &#123;          list.add(str);          return;      &#125;        int digit = Integer.parseInt(digits.charAt(i) + &quot;&quot;);      String letter = buttonList[digit];      for (int j = 0; j &lt; letter.length(); j++) &#123;          str+=letter.charAt(j);          combinations(i + 1, digits, buttonList, str, list);          str = str.substring(0, str.length() - 1);      &#125;  &#125;\n看解析\n216组合总和III\n题目链接/文章讲解：https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html\n视频讲解：https://www.bilibili.com/video/BV1wg411873x\n17电话号码的字母组合\n题目链接/文章讲解：https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html\n视频讲解：https://www.bilibili.com/video/BV1yV4y1V7Ug\n","categories":["面试","代码随想录"],"tags":["回溯算法"]},{"title":"面试-04 Spring","url":"/2024/06/10/100000041/","content":"\n\n前言\n❗表示必掌握，❔表示基本不会问\n\n\n更新\n\n\n24-06-10 初始记录\n\n说说Spring常用的几个注解？\n\n\n\n\n\n\n\n\n\n@Component\n取代.xml中的；用于三层架构类之外。\n\n\n@Controller\n衍生注解；用于Controller层\n\n\n@Service\n衍生注解；用于Service层\n\n\n@Repository\n衍生注解；用于Dao层\n\n\n@Bean\n取代.xml中工厂创建bean对象,方法的返回值成为bean对象。\n\n\n@Autowired\n取代.xml中中的ref注入，底层是CGLIB动态代理。这个是本地注入。\n\n\n@Aspect\n定义在类上；设置当前类为切面类\n\n\n@Before\n定义在方法上；标注当前方法作为前置通知\n\n\n\n谈谈你对Spring的理解？\nSpring是一个完整的生态，不单单是一个技术框架。\nSpring两大核心思想是什么？\nIOC：解耦，使代码复用，可维护性大幅提升。\nAOP：提供切面编程，同样增强生产力。\n说一说你对IOC的理解？\n❗大白话：最原始的tomcat+servlet的编码原理。使用的时候Myservice myservie = new MyserviceImpl()。耦合度很高，修改一个类要修改很多文件。然后我们引入Spring这个框架。会去由框架Spring容器创建实例Bean，对象间就会直接引用（依赖注入）。然后Spring MVC(核心Servlet Filter 去处理请求)。IOC底层就是反射（+工厂模式）、通过类去创建对象。\nIoC（Inversion Of Control）控制反转，其实是一种思想，用于解决程序间的耦合问题。【解耦】\n原本我们创建对象是直接在类中，通过new的方式创建，控制权在于程序员自己，现在我们把new对象的工作交给spring完成，我们只需要通过配置文件进行配置即可。反转的是对象的创建权力。【便捷】\nioc容器，可以简单理解为一个工厂，但是他的功能比普通工厂要强大很多，内部帮助我们完成了对象的创建和效果的整个过程管理，同时提供了很多扩展机会。【可扩展】\n说一说你对AOP的理解？\nSpring\n","categories":["面试","八股文"],"tags":["面试","八股文"]},{"title":"代码随想录算法训练营第二十三天-39组合总和、40组合总和II、131分割回文串","url":"/2024/06/11/100000042/","content":"\n\n前言\n状态：39AC但是可以继续优化剪枝。40AC。131分割没有做过，直接看解析了（动态规划求回文这个没有看，后面刷到动态规划再研究）。\n\n\n更新\n\n\n24-06-11 初始记录\n\n初步题解\n39组合总和\n题目链接：(https://leetcode.cn/problems/combination-sum)\npublic static List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;      List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      List&lt;Integer&gt; resultOne = new ArrayList&lt;&gt;();        combinationSumBFS(0, 0, target, candidates, resultOne, result);      return result;  &#125;      private static void combinationSumBFS(int startIndex, int sum, int target, int[] candidates, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result) &#123;      if (sum &gt;= target) &#123;          if (target == sum) &#123;              result.add(new ArrayList&lt;&gt;(resultOne));          &#125;          return;      &#125;        for (int i = startIndex; i &lt; candidates.length; i++) &#123;          resultOne.add(candidates[i]);          combinationSumBFS(i, sum + candidates[i], target, candidates, resultOne, result);          resultOne.remove(resultOne.size() - 1);      &#125;  &#125;\n40组合总和II\n题目链接：(https://leetcode.cn/problems/combination-sum-ii)\npublic static List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;      Arrays.sort(candidates);        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      List&lt;Integer&gt; resultOne = new ArrayList&lt;&gt;();        combinationSum2BFS(0, 0, target, candidates, resultOne, result);      return result;  &#125;    /**   * 思路：   * 1. 和上题差不多。但是数组变成有重复元素的了。   * 2. 想法是每层遍历的时候，去重   */  private static void combinationSum2BFS(int startIndex, int sum, int target, int[] candidates, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result) &#123;      if (sum == target) &#123;          result.add(new ArrayList&lt;&gt;(resultOne));          return;      &#125;        for (int i = startIndex; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;\t\t// 在单层的数组内去重        if (i - 1 &gt;= startIndex &amp;&amp; candidates[i] == candidates[i - 1]) &#123;              continue;          &#125;          resultOne.add(candidates[i]);          combinationSum2BFS(i + 1, sum + candidates[i], target, candidates, resultOne, result);          resultOne.remove(resultOne.size() - 1);      &#125;  &#125;\n131分割回文串\n题目链接：(https://leetcode.cn/problems/palindrome-partitioning)\n看解析\n39组合总和\n题目链接/文章讲解：(https://programmercarl.com/0039.组合总和.html)\n视频讲解：(https://www.bilibili.com/video/BV1KT4y1M7HJ/)\n本来以为只要return就不用优化了（好像没有什么关系，还是会继续往下走），但是题解中说可以减少一次进入递归。\npublic static List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;      // 要剪枝必须要排序      Arrays.sort(candidates);        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      List&lt;Integer&gt; resultOne = new ArrayList&lt;&gt;();        combinationSumBFS(0, 0, target, candidates, resultOne, result);      return result;  &#125;      private static void combinationSumBFS(int startIndex, int sum, int target, int[] candidates, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result) &#123;      if (target == sum) &#123;          result.add(new ArrayList&lt;&gt;(resultOne));          return;      &#125;        // for循环的判断做了剪枝优化处理      for (int i = startIndex; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;          resultOne.add(candidates[i]);          combinationSumBFS(i, sum + candidates[i], target, candidates, resultOne, result);          resultOne.remove(resultOne.size() - 1);      &#125;  &#125;\n40组合总和II\n题目链接/文章讲解：(https://programmercarl.com/0040.组合总和II.html)\n视频讲解：(https://www.bilibili.com/video/BV12V4y1V73A/)\n131分割回文串\n题目链接/文章讲解：(https://programmercarl.com/0131.分割回文串.html)\n视频讲解：(https://www.bilibili.com/video/BV1c54y1e7k6/)\npublic static List&lt;List&lt;String&gt;&gt; partition(String s) &#123;      List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;();      List&lt;String&gt; string = new ArrayList&lt;&gt;();      partitionBFS(0, s, string, result);      return result;  &#125;    private static void partitionBFS(int startIndex, String s, List&lt;String&gt; string, List&lt;List&lt;String&gt;&gt; result) &#123;      if (startIndex &gt;= s.length()) &#123;          result.add(new ArrayList&lt;&gt;(string));      &#125;        for (int i = startIndex; i &lt; s.length(); i++) &#123;          String substring = s.substring(startIndex, i + 1);          if (!isPartition(substring)) &#123;              continue;          &#125;          string.add(substring);          partitionBFS(i + 1, s, string, result);          string.remove(string.size() - 1);      &#125;  &#125;    /**   * 判断传入字符串是否为回文字符串   * @param substring 截取的字符串   * @return 结果   */  private static boolean isPartition(String substring) &#123;      for (int i = 0, j= substring.length() - 1; i &lt; j; i++, j--) &#123;          if (substring.charAt(i) != substring.charAt(j)) &#123;              return false;          &#125;      &#125;      return true;  &#125;\n// 优化版 动态规划法class Solution &#123;    List&lt;List&lt;String&gt;&gt; result;    LinkedList&lt;String&gt; path;    boolean[][] dp;    public List&lt;List&lt;String&gt;&gt; partition(String s) &#123;        result = new ArrayList&lt;&gt;();        char[] str = s.toCharArray();        path = new LinkedList&lt;&gt;();        dp = new boolean[str.length + 1][str.length + 1];        isPalindrome(str);        backtracking(s, 0);        return result;    &#125;    public void backtracking(String str, int startIndex) &#123;        if (startIndex &gt;= str.length()) &#123;            //如果起始位置大于s的大小，说明找到了一组分割方案            result.add(new ArrayList&lt;&gt;(path));        &#125; else &#123;            for (int i = startIndex; i &lt; str.length(); ++i) &#123;                if (dp[startIndex][i]) &#123;                    //是回文子串，进入下一步递归                    //先将当前子串保存入path                    path.addLast(str.substring(startIndex, i + 1));                    //起始位置后移，保证不重复                    backtracking(str, i + 1);                    path.pollLast();                &#125; else &#123;                    //不是回文子串，跳过                    continue;                &#125;            &#125;        &#125;    &#125;    //通过动态规划判断是否是回文串,参考动态规划篇 52 回文子串    public void isPalindrome(char[] str) &#123;        for (int i = 0; i &lt;= str.length; ++i) &#123;            dp[i][i] = true;        &#125;        for (int i = 1; i &lt; str.length; ++i) &#123;            for (int j = i; j &gt;= 0; --j) &#123;                if (str[j] == str[i]) &#123;                    if (i - j &lt;= 1) &#123;                        dp[j][i] = true;                    &#125; else if (dp[j + 1][i - 1]) &#123;                        dp[j][i] = true;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;","categories":["面试","代码随想录"],"tags":["回溯算法"]},{"title":"代码随想录算法训练营第二十五天-491递增子序列 、46全排列 、47全排列 II","url":"/2024/06/11/100000043/","content":"\n\n前言\n状态：491超时。46AC。47不是很对，要看解析，主要是去重那一步。\n\n\n更新\n\n\n24-06-11 初始记录\n\n初步题解\n491递增子序列\n题目链接：(https://leetcode.cn/problems/non-decreasing-subsequences)\n超时了，主要是去重那一步应该。\npublic static List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123;      List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      List&lt;Integer&gt; resultOne = new ArrayList&lt;&gt;();        findSubsequencesBFS(0 , nums, resultOne, result);      return result;  &#125;    private static void findSubsequencesBFS(int startIndex, int[] nums, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result) &#123;      // 先这样判断是否重复      if (resultOne.size() &gt;= 2 &amp;&amp; !result.contains(resultOne)) &#123;          result.add(new ArrayList&lt;&gt;(resultOne));      &#125;        for (int i = startIndex; i &lt; nums.length; i++) &#123;          if (resultOne.size() != 0 &amp;&amp; resultOne.get(resultOne.size() - 1) &gt; nums[i]) &#123;              continue;          &#125;          resultOne.add(nums[i]);           findSubsequencesBFS(i + 1, nums, resultOne, result);          resultOne.remove(resultOne.size() - 1);      &#125;  &#125;\n46全排列\n题目链接：(https://leetcode.cn/problems/permutations/description/)\n// 排列每个变量都要统计，所以不需要startIndexpublic static List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;      List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      List&lt;Integer&gt; resultOne = new ArrayList&lt;&gt;();        if (nums == null || nums.length == 0) &#123;          return result;      &#125;        permuteBFS(nums, resultOne, result);      return result;  &#125;    private static void permuteBFS(int[] nums, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result) &#123;      if (resultOne.size() == nums.length) &#123;          result.add(new ArrayList&lt;&gt;(resultOne));          return;      &#125;        for (int i = 0; i &lt; nums.length; i++) &#123;          if (resultOne.contains(nums[i])) &#123;              continue;          &#125;          resultOne.add(nums[i]);          permuteBFS(nums, resultOne, result);          resultOne.remove(resultOne.size() - 1);      &#125;  &#125;\n47全排列 II\n题目链接：(leetcode.cn/problems/permutations-ii/)\n/**   * 和上一题唯一的区别就是数组元素重复。   * 所以不能用数组直接统计，得用index记录这个是否被记过   * 还有点缺陷。重复元素会按不同下标被重复计入.   * 和之前一样，单层元素不能重复。   * @param nums nums   * @return 结果   */  public static List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;      List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      List&lt;Integer&gt; resultOne = new ArrayList&lt;&gt;();          if (nums == null || nums.length == 0) &#123;          return result;      &#125;        Arrays.sort(nums);      permuteUniqueBFS(nums, new ArrayList&lt;&gt;(), resultOne, result);      return result;  &#125;    private static void permuteUniqueBFS(int[] nums, List&lt;Integer&gt; resultIndex, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result) &#123;      if (resultOne.size() == nums.length) &#123;          result.add(new ArrayList&lt;&gt;(resultOne));          return;      &#125;        // 判断这层有没有使用过这个数字，和LE491一样      HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();      // set记录下标      for (int i = 0; i &lt; nums.length; i++) &#123;          if (resultIndex.contains(i)) &#123;              continue;          &#125;          if (set.contains(nums[i])) &#123;              continue;          &#125;          resultIndex.add(i);          resultOne.add(nums[i]);          set.add(nums[i]);          permuteUniqueBFS(nums, resultIndex, resultOne, result);          resultOne.remove(resultOne.size() - 1);          resultIndex.remove(resultIndex.size() - 1);      &#125;  &#125;\n看题解\n491递增子序列\nhttps://programmercarl.com/0491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html\n视频讲解：https://www.bilibili.com/video/BV1EG4y1h78v\n加了剪枝操作的优化。\npublic static List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123;      List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      List&lt;Integer&gt; resultOne = new ArrayList&lt;&gt;();        findSubsequencesBFS(0 , nums, resultOne, result);      return result;  &#125;    private static void findSubsequencesBFS(int startIndex, int[] nums, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result) &#123;       if (resultOne.size() &gt;= 2) &#123;          result.add(new ArrayList&lt;&gt;(resultOne));      &#125;        HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();      for (int i = startIndex; i &lt; nums.length; i++) &#123;          if (resultOne.size() != 0 &amp;&amp; resultOne.get(resultOne.size() - 1) &gt; nums[i]) &#123;              continue;          &#125;          // 判断这层是否使用          if (map.getOrDefault(nums[i], 0) &gt;= 1) &#123;              continue;          &#125;          map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);          resultOne.add(nums[i]);          findSubsequencesBFS(i + 1, nums, resultOne, result);          resultOne.remove(resultOne.size() - 1);      &#125;  &#125;\n46全排列\nhttps://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html\n视频讲解：https://www.bilibili.com/video/BV19v4y1S79W\n47全排列 II\nhttps://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html\n视频讲解：https://www.bilibili.com/video/BV1R84y1i7Tm\npublic static List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;      List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      List&lt;Integer&gt; resultOne = new ArrayList&lt;&gt;();          if (nums == null || nums.length == 0) &#123;          return result;      &#125;        Arrays.sort(nums);      permuteUniqueBFS(nums, new boolean[]&#123;&#125;, resultOne, result);      return result;  &#125;    /**   * 用数组标记因为这个树更像一个矩阵   * 数组可以标记nums又可以标记层数   */  private static void permuteUniqueBFS(int[] nums, boolean[] used, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result) &#123;      if (resultOne.size() == nums.length) &#123;          result.add(new ArrayList&lt;&gt;(resultOne));          return;      &#125;        // set记录下标      for (int i = 0; i &lt; nums.length; i++) &#123;          // 记录了index值，即这index被使用了（这里可以理解）          if (used[i]) &#123;              continue;          &#125;            // 如果这个数值和前面的数值相同          // 首先一定要排序，这样nums数组中的前面一个节点，就一定是被用过了          // 然后现在到这个节点，前面一个节点的状态是false(这里横向看)，说明已经回溯了。节点已经被添加，跳过这层          if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) &#123;              continue;          &#125;          // 这层是否使用过          used[i] = true;          resultOne.add(nums[i]);          permuteUniqueBFS(nums, used, resultOne, result);          resultOne.remove(resultOne.size() - 1);          used[i] = false;      &#125;  &#125;","categories":["面试","代码随想录"],"tags":["回溯算法"]},{"title":"代码随想录算法训练营第二十四天-93复原IP地址、78子集、90子集II","url":"/2024/06/11/100000044/","content":"\n\n前言\n状态：93可以AC。78、90AC。\n\n\n更新\n\n\n24-06-11 初始记录\n\n初步题解\n93复原IP地址\n题目链接：(https://leetcode.cn/problems/restore-ip-addresses)\n解的时候不知道单字符串怎么操作了，加了一个数组。慢了很多。\npublic static List&lt;String&gt; restoreIpAddresses(String s) &#123;      List&lt;String&gt; result = new ArrayList&lt;&gt;();      List&lt;String&gt; temp = new ArrayList&lt;&gt;();          if (s.length() &lt; 4 || s.length() &gt; 12)&#123;          return result;      &#125;        restoreIpAddressesBFS(0, temp, s, result);      return result;  &#125;    /**   * * @param startIndex 开始Index   * @param s 输入的s   * @param result 切割的字符串集   */  private static void restoreIpAddressesBFS(int startIndex, List&lt;String&gt; temp, String s, List&lt;String&gt; result) &#123;      if (startIndex &gt;= s.length() &amp;&amp; temp.size() == 4) &#123;          String resultOne = String.join(&quot;.&quot;, temp);          result.add(resultOne);      &#125;        for (int i = startIndex; i &lt; s.length() &amp;&amp; Integer.parseInt(s.substring(startIndex, i + 1)) &lt; 256; i++) &#123;          // 8 为 substring 的取值就在 1 - 3之间          String substring = s.substring(startIndex, i + 1);          if (substring.length() &lt; 1 || substring.length() &gt; 3) &#123;              continue;          &#125;          if (substring.length() &gt; 1 &amp;&amp; substring.startsWith(&quot;0&quot;)) &#123;              continue;          &#125;          temp.add(substring);          restoreIpAddressesBFS(i + 1, temp, s, result);          temp.remove(temp.size() - 1);      &#125;  &#125;\n78子集\n题目链接：(https://leetcode.cn/problems/subsets)\npublic static List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;      List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      List&lt;Integer&gt; resultOne = new ArrayList&lt;&gt;();        // 排序      Arrays.sort(nums);          subsetsBFS(0, nums, resultOne, result);      return result;  &#125;    /**   * 这个和之前的区别在于，如果转化成一颗树。之前只要求叶子节点。这个全部都要   * 而且还要不重复（😗写错了，看成90的题了。这题还要更简单一点。） * @param startIndex 起始index   */private static void subsetsBFS(int startIndex, int[] nums, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result) &#123;        result.add(new ArrayList&lt;&gt;(resultOne));      for (int i = startIndex; i &lt; nums.length; i++) &#123;          resultOne.add(nums[i]);          subsetsBFS(i + 1, nums, resultOne, result);          resultOne.remove(resultOne.size() - 1);      &#125;  &#125;\n90子集II\n题目链接：(https://leetcode.cn/problems/subsets-ii)\npublic static List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;      List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      List&lt;Integer&gt; resultOne = new ArrayList&lt;&gt;();        // 排序      Arrays.sort(nums);        subsetsBFS(0, nums, resultOne, result);      return result;  &#125;    /**   * @param startIndex 起始index   */private static void subsetsBFS(int startIndex, int[] nums, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result) &#123;      result.add(new ArrayList&lt;&gt;(resultOne));        for (int i = startIndex; i &lt; nums.length; i++) &#123;          if (i - 1 &gt;= startIndex &amp;&amp; nums[i] == nums[i - 1]) &#123;              continue;          &#125;          resultOne.add(nums[i]);          subsetsBFS(i + 1, nums, resultOne, result);          resultOne.remove(resultOne.size() - 1);      &#125;  &#125;\n看解析\n93复原IP地址\n题目链接/文章讲解：https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html\n视频讲解：https://www.bilibili.com/video/BV1XP4y1U73i/\nclass Solution &#123;    List&lt;String&gt; result = new ArrayList&lt;String&gt;();\tStringBuilder stringBuilder = new StringBuilder();\tpublic List&lt;String&gt; restoreIpAddresses(String s) &#123;\t\trestoreIpAddressesHandler(s, 0, 0);\t\treturn result;\t&#125;\t// number表示stringbuilder中ip段的数量\tpublic void restoreIpAddressesHandler(String s, int start, int number) &#123;\t\t// 如果start等于s的长度并且ip段的数量是4，则加入结果集，并返回\t\tif (start == s.length() &amp;&amp; number == 4) &#123;\t\t\tresult.add(stringBuilder.toString());\t\t\treturn;\t\t&#125;\t\t// 如果start等于s的长度但是ip段的数量不为4，或者ip段的数量为4但是start小于s的长度，则直接返回\t\tif (start == s.length() || number == 4) &#123;\t\t\treturn;\t\t&#125;\t\t// 剪枝：ip段的长度最大是3，并且ip段处于[0,255]\t\tfor (int i = start; i &lt; s.length() &amp;&amp; i - start &lt; 3 &amp;&amp; Integer.parseInt(s.substring(start, i + 1)) &gt;= 0\t\t\t\t&amp;&amp; Integer.parseInt(s.substring(start, i + 1)) &lt;= 255; i++) &#123;\t\t\t// 如果ip段的长度大于1，并且第一位为0的话，continue\t\t\tif (i + 1 - start &gt; 1 &amp;&amp; s.charAt(start) - &#x27;0&#x27; == 0) &#123;\t\t\t\tcontinue;\t\t\t&#125;\t\t\tstringBuilder.append(s.substring(start, i + 1));\t\t\t// 当stringBuilder里的网段数量小于3时，才会加点；如果等于3，说明已经有3段了，最后一段不需要再加点\t\t\tif (number &lt; 3) &#123;\t\t\t\tstringBuilder.append(&quot;.&quot;);\t\t\t&#125;\t\t\tnumber++;\t\t\trestoreIpAddressesHandler(s, i + 1, number);\t\t\tnumber--;\t\t\t// 删除当前stringBuilder最后一个网段，注意考虑点的数量的问题\t\t\t// 主要这里没有写出来❗\t\t\tstringBuilder.delete(start + number, i + number + 2);\t\t&#125;\t&#125;&#125;\n78子集\n题目链接/文章讲解：https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html\n视频讲解：https://www.bilibili.com/video/BV1U84y1q7Ci\n90子集II\n题目链接/文章讲解：https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html\n视频讲解：https://www.bilibili.com/video/BV1vm4y1F71J\n","categories":["面试","代码随想录"],"tags":["回溯算法"]}]