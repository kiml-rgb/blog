[{"title":"Obsidian + Git + Hexo + 图床 = Blog + 个人笔记体系","url":"/blog/2023/02/6870bf8bd223.html","content":"\n\n前言\n之前有过基于 Hexo 的博客搭建经历，但是由于时间繁忙，加上后续学习了解到的笔记软件，拥有我想要的全局搜索功能，而且比博客的格式、排版更加吸引人，就放弃了之前搭建的博客。但是出来找工作感觉拥有一个自己的技术博客会比较占优势，因此打算在笔记的基础上，加上原来的 Hexo 快速生成，转成技术博客输出。\n\n\n参考文章\n\n\n\n【保姆级】利用Github搭建自己的个人博客，看完就会\nHexo + Obsidian + Git 完美的博客部署与编辑方案\n\n\n更新\n\n22.12.11 初始记录(修改预计开始日期为元旦)23.02.24 环境部署，个人博客绑定到 Gitee Pages23.02.27 Obsidian 整合 等待Gitee Pages审核ing\n\n环境部署\n安装git\n\n\n访问 git 官方地址，下载对应的安装包，进行安装（简单的点击下一步）。\n\n\n安装好之后，鼠标右键可以看到：Git Bash Here，点击后打开了。\n\n\n输入：git --version\n出现版本号说明安装成功。\n\n\n安装node.js\n\n\n访问 node.js 官方地址，下载对应的安装包，进行安装（简单的点击下一步）。\n\n\n安装好之后，配置环境变量，并在终端里面输入：node -v\n出现版本号说明安装成功。\n\n\n安装 Hexo\n\n\n安装命令：\n\n\nnpm install hexo -g\n测试是否安装成功，命令：hexo -v\n出现版本号说明安装成功。\n\n\n安装 hexo 推送 git 拓展依赖，安装命令：\n\n\nnpm install hexo-deployer-git --save\ngit配置 SSH key\n\n\n先看本地是否配置好SSH key（命令：cd ~/.ssh）\nSSH key的保存位置在本地的C:\\Users\\&#123;你的用户名&#125;\\.ssh文件下，如果本地已存在SSH，此步不会有提示，否则出现No such file or directory。如果保存文件下没有文件id_rsa.pub 或 id_dsa.pub则也需要重新生成\n\n\n生成SSH key\n如果没有配置输入生成命令，然后连续回车三次即可：\n\n\nssh-keygen -t rsa -C &quot;邮件地址&quot; #该邮箱地址是绑定github账号的地址\ngithub\n\n\n打开SSH key的保存位置，复制id_rsa.pub文件里全部内容，接着打开github主页，点击个人设置，点击左侧的SSH and GPG keys，点击New SSH key\n\n\n\n将id_rsa.pub复制的内容粘贴到key中，title随便起一个就行。\n\n\n\n测试是否成功，输入命令：\n\n\nssh -T git@github.com\n出现 You've successfully authenticated, but GitHub does not provide shell access.说明成功\n\n\n配置账号和密码\n\n\n$ git config --global user.name &quot;liyunchen&quot; #你的github用户名 $ git config --global user.email &quot;xxx@163.com&quot; #填写你的github注册邮箱\ngitee\n\n除了Github Pages，也可以把博客搭建在Gitee Pages上，不翻墙的情况下，连接github经常会出现连接不上的情况，所以这次就直接改到Gitee上了。又换回来了（24.02.02）\n\n\n\n同样的配置SSH key，在Gitee的个人设置界面添加公钥\n\n\n\n测试是否成功，输入命令：\n\n\nssh -T git@gitee.com\n出现 You've successfully authenticated, but GITEE.COM does not provide shell access.说明成功\n搭建个人博客\n\n\n新建一个保存博客的存放目录，进入到本地博客存放目录，初始化个人博客，命令：\n\n\nhexo init\n出现不可获取错误说明github连接失败，再重新执行一遍命令就可以了\n\n\n\n生成静态网页，命令：\n\n\nhexo g\n\n\n本地预览，命令：\n\n\nhexo s\n\n访问localhost:4000\ngithub\n\n\n新建一个github仓库，给仓库起个名称，可以为用户名.github.io，这样这个名称就可以作为你github博客的访问地址\n\n\n编辑_config.yml，此文件在你博客存放目录下，需要编辑的github地址填写在最后deploy处\n\n\ndeploy: \ttype: git \trepository: #仓库地址\tbranch: main #查看自己仓库是master还是main\n\n\n发布到 github，命令：\n\n\nhexo d\n这样就已经把生成的静态文件推送到github仓库去了。\ngitee\n\n\n新建一个 gitee 仓库，给仓库起个名称，这里我直接用 blog 作为名称，这样博客的访问地址就是用户名.gitee.io/blog\n\n\n编辑_config.yml，此文件在你博客存放目录下，文件需要\n\n\ndeploy: \ttype: git \trepository: #仓库地址\tbranch: master #查看自己仓库是master还是main\n\n\n发布到 gitee，命令：\n\n\nhexo d\n\n\n在个人仓库界面，开启 Gitee Pages 服务（第一次使用还要手持身份证拍照的实名认证，蛮无语的，终于知道为什么用的人少了。。。）\n\n\n\n博客主题（Keep）\n\n在配置文件里可以看见 Hexo 主题商店的地址，配置文件中默认的主题为 landscape，不太喜欢打算换掉。原先博客使用的是Next主题，也是使用 Hexo 搭建博客用到最多的主题，但是也用腻了。现在发现一个新的主题 Keep，感觉蛮简洁舒适的，所以这次重新搭建也打算直接换上。\n\nKeep 主题的官方配置文档很详细，在演示博客中有一个使用指南，直接照着配置就行。\nObsidian整合\nObsidian知识库创建\n\n\n新建一个仓库或将之前的博客文件作为仓库打开\n\n\n\n忽略多余的文件。我们主要是编辑和管理Markdown文件，所以一些多余的文件要忽略掉，这样在知识库里搜索文件、关键字时才不会搜索到多余的，也能有效提高检索效率。打开：设置&gt;文件与链接&gt;Exclude Files\n\n\n\n设置新建笔记的存放位置，内部链接类型~~（关闭Wiki链接的使用，因为hexo的解析要求为markdown格式的文件）~~以及附件默认的存放路径\n\n\n\n在 hexo 项目的 .gitignore 文件中加入如下内容：\n\n\n.obsidian/workspace\n博客文章的管理\n\n新建文件在 hexo 的默认配置中放在 source/_post 目录下，随着文章数量的增多，文章也会变得难以寻找。因此采用以文件夹来分目录的方式，存放写好的文件。但是这样分类后，还需要手动维护文章开始前的定义文字，去修改文件所在的目录，较为麻烦。\n\n为了省去手动维护 categorys 字段的这个问题，我们可以使用 hexo-auto-category 这个插件。这个插件在 Hexo 进行 build 的时候会去自动根据文章目录情况来自动修改文章的 categories 信息，更详细的部分可以看作者的文章。除此之外最好修改一下 _config.yml 中的默认配置：\npermalink: :year/:month/:hash.html\n但是这里有一个问题，就是只有 hexo 在执行 hexo generate 或者 hexo server 时候才会去触发 categories 的生成，那么每次我们创建文章都要重新 hexo generate 以触发插件的自动校正功能，并再次把更新后的变更提交推送git。\n参考博客使用Husky完成git hook的操作：\n\n\n安装 huksy：npm install husky --save-dev\n\n\n执行 huksy 初始化指令：npx husky install\n\n\n在 package.json 中的 scripts 中写入：&quot;prepare&quot;: &quot;husky install&quot;\n\n\n在生成的 .husky 目录创建 pre-commit 文件（有的话就不用创建），并写入以下内容：\n\n\n#!/usr/bin/env sh. &quot;$(dirname -- &quot;$0&quot;)/_/husky.sh&quot;npx hexo generate &amp;&amp; git add .\n如果提交代码的时候，终端出现类似的构建过程，就说明由 husky 创建的 git hook 生效了。\n\nhexo 博客默认携带的两个文件夹为 categories 和 tags ，这两个标签可以在文章开始前定义，然后 hexo 会自动解析该文章所属的目录和标签。\n\n上面已经通过插件解决了目录的问题，还剩下文章的标题和 tags。Obsidian 是支持创建新文件时插入模板的，这就意味着我们可以不用重复写 Hexo 博客文的 Front-matter 部分。\n\n\n在 source 目录下创建 _obsidian 文件夹，并创建一篇 Post Template 的文章（md文件），内容为：\n\n\n---title: &#123;&#123;title&#125;&#125;date: &#123;&#123;date&#125;&#125;tags: []---\n\n\n然后进入到 Obsidian 的设置面板，选择核心插件，并启用模板功能。同时点击旁边的配置按钮，进入到模板配置的设置中，设置配置信息\n\n\n\n之后，我们再创建新文章的时候，只需要点击侧边栏的插入模板按钮就可以快速生成 Front-matter 信息：\n\n\n\n博客图片的管理\n\n在 Obsidian 中，可以直接粘贴截图，并设置默认保存位置。相对路径保存的格式如下：![](attachments/xxx.png)，但是这样部署到 hexo 中的图片会显示404加载不成功的错误。\n\n原先的办法是将 _config.yml 配置文件中的 post_asset_folder 选项设置为 true 来打开。该功能打开后，Hexo 将会在你每一次通过 hexo new [layout] &lt;title&gt; 命令创建新文章时自动创建一个文件夹。这个资源文件夹名与文章文件名相同。将所有与你的文章有关的资源（如图片）放在这个关联文件夹中之后，通过相对路径来引用它们。但是由于本次需要将 Obsidian 与 Hexo 结合，希望生成新文章不依靠于命令行。因此本次直接加入图床保存图片。使用的图床为Keep主题推荐的图床PicX。建议本地依旧备份一份图片，以防万一。\nGit 同步\n\nObsidian内存在插件Obsidian Git 插件使我们可以在 Obsidian 内就可以实现 git commit 以及 push 的操作。\n\n\n\n在右侧命令面板处输入open source control view，可以打开Git面板，右侧会自动生成commit信息，commit信息可以在配置文件内自行配置\n\n\n\nFile Tree 定位\n\n用 Obsidian 控制文件有一个弊端在于左侧目录为全部文件，而我们编写 hexo 博客，一般只会在_posts文件下操作，可以使用Obsidian插件 File Tree Alternative Plugin\n\n安装插件后可以看到文件列变为了以下格式\n\n打开选中_post，右键Focus on Folder，则菜单栏只显示_post文件夹\n\n其他拓展\n更高级的 Markdown 渲染器\n\nHexo 默认的 Markdown 渲染器是hexo-renderer-marked，但其支持的渲染格式有限，比如重点符号的渲染就是不成功的，因此更换更好用的渲染器hexo-renderer-markdown-it\n\n\n\n卸载hexo-renderer-marked\n\n\nnpm un hexo-renderer-marked --save\n\n\n安装 hexo-renderer-markdown-it\n\n\nnpm i hexo-renderer-markdown-it --save\n\n\n将如下文本复制粘贴到 Hexo 的配置文件 _config.yml 的尾部\n\n\nmarkdown:  preset: &quot;default&quot;  render:    html: true    xhtmlOut: false    langPrefix: &quot;language-&quot;    breaks: true    linkify: true    typographer: true    quotes: &quot;“”‘’&quot;  enable_rules:  disable_rules:  plugins:    - markdown-it-abbr    - markdown-it-cjk-breaks    - markdown-it-deflist    - markdown-it-emoji    - markdown-it-footnote    - markdown-it-ins    - markdown-it-mark    - markdown-it-sub    - markdown-it-sup    - markdown-it-checkbox    - markdown-it-imsize    - markdown-it-expandable    - name: markdown-it-container      options: success    - name: markdown-it-container      options: tips    - name: markdown-it-container      options: warning    - name: markdown-it-container      options: danger  anchors:    level: 2    collisionSuffix: &quot;&quot;    permalink: false    permalinkClass: &quot;header-anchor&quot;    permalinkSide: &quot;left&quot;    permalinkSymbol: &quot;¶&quot;    case: 0    separator: &quot;-&quot;\n\n\n分别使用 npm 命令安装以下三个插件，其它插件 hexo-renderer-markdown-it 渲染器已有\n\n\nnpm i markdown-it-checkboxnpm i markdown-it-imsizenpm i markdown-it-expandable\n","categories":["博客"]},{"title":"Git及常用命令","url":"/blog/2023/07/4a9f7c37553f.html","content":"\n\n前言\nGit部分知识以及常用命令\n\n\n更新\n\n\n23.07.11 初始记录\n\n安装\n之前在写 [[Obsidian + Git + Hexo + 图床 = Blog + 个人笔记体系]]这篇笔记的时候有提到过Git的安装。这里就直接把步骤贴过来，具体安装地址(https://git-scm.com/)\n\n\n访问 git 官方地址，下载对应的安装包，进行安装（简单的点击下一步）。\n\n\n安装好之后，鼠标右键可以看到：Git Bash Here，点击后打开了。\n\n\n输入：git --version\n出现版本号说明安装成功。\n\n\n\n\nlinux安装使用以下命令\n\n\nsudo apt-get install git\ngit配置 SSH key\nGit是分布式的代码管理工具，远程的代码管理是基于SSH的，所以要使用远程的Git则需要SSH的配置。一、设置Git的user name和email：\n$ git config --global user.name &quot;kiml&quot;  $ git config --global user.email &quot;1162278448@qq.com&quot;\n二、生成SSH密钥内链：[[Obsidian + Git + Hexo + 图床 = Blog + 个人笔记体系#git配置 SSH key]]\n外链：Obsidian + Git + Hexo + 图床 = Blog + 个人笔记体系\ngit工具\nGitHub Desktop\n\n平时更多使用IntelliJ IDEA自带的git工具，偶然发现这个工具，近期打算使用官方文档：[https://docs.github.com/zh/desktop/installing-and-configuring-github-desktop/overview/getting-started-with-github-desktop]\n\n常用命令\nclone到本地\ngit clone git@gitee.com:kiml_rgb/blog.git\n提交代码\n# 进入项目工程目录cd hello/# 将当前修改的文件添加到暂存区git add .# 提交代码git commit -m &quot;first commit&quot;\n推送代码\ngit push\n拉取代码\ngit pull\n创建并提交分支\n# 切换并从当前分支创建一个dev分支git checkout -b dev# 将新创建的dev分支推送到远程仓库git push origin dev\n其他常用命令\n# 切换到dev分支git checkout dev# 查看本地仓库文件状况git status# 查看本地所有分支git branch# 查看提交记录git log","categories":["环境搭建"],"tags":["Git"]},{"title":"装机-软件安装","url":"/blog/2023/11/4640726c232e.html","content":"\n\n前言\n找到工作之后每天就是躺平，好久没有更新技术上的内容了，之前学的好多东西也忘了……甚至md语法都忘了好多（每天CRUD，但是也很消耗精力。必须要不断学习，好痛苦，什么时候能退休😢）趁着618配了一台新电脑，顺便用半个多月的时间用新电脑打游戏。。。正好最近在装软件，整理一下装机要注意的事，以及一些必备软件，便于后面再次装机使用。\n\n\n更新\n\n\n23.06.24 初始记录23.07.02 IDEA常用插件 + 基本设置23.07.09 编程环境Java + MySQL23.07.11 Git23.08.28 Maven\n\n初始装机\n这部分都是照着b站上的视频完成的。总之时间就分两大块，把零件装上去，理线。具体可参照以下视频：B站 赵德柱装机\n系统安装\n系统安装需要准备一个U盘装系统。具体步骤可以参照以下视频：B站 赵德柱装系统安装系统完毕第一件事就是去对应官网安装对应驱动，这个依据配置不同，需要下载的东西也不一样。可以检查以下项目的驱动是否安装，每项都需要到对应的官网去下载对应的驱动包：\n\n\ncpu驱动\n\n\n主板驱动（涉及较多）\n\n\n显卡驱动\n\n\n鼠标驱动（调光需要）\n\n\n键盘驱动（调光需要）\n\n\n软件安装\n常用软件\nOffice全家桶\n这个直接登录原来的微软账户就可以安装了，之前买笔记本有配有家庭版可以直接使用。有的笔记本没有送，这个需要注意原来的不要卸载，不然重新下载比较麻烦（这是个付费软件）。直接去买个激活码就行\nSteam\n装机第一件事\nUU加速器\n用了这么多，最常用的还是这个，加速商店是足够用了，想要加速游戏可以进一步去贴吧下载\nChrome\n插件就不提供了，自己后续需要再搜，最好还是能整个账号，不然每次装机都要重新把收藏夹的导出来有点麻烦。\nSnipaste\n很好用的截屏软件，U盘里带有安装包，直接解压缩，开启后就可以F1截图了\nScreenToGif\n制作Gif的软件，以前下载过但是没有用到的机会\nToDesk\n远程连接工具，不想背电脑回家就带这个\nObsidian\n目前在用的All in One笔记软件，好用但是太繁琐了，一开始大半时间都浪费在插件和布局上面，目前用着还行，希望后面能完全用起来。当个md编辑器还是不错的。部分常用的基本用法如下：内链：Obsidian基本用法外链：\nTypora\n一款 Markdown 编辑器和阅读器。更便捷的浏览工具。\n网盘\n百度网盘\n之前参加活动，容量已经到5T了，但是不充会员完全没法使用，现在就是一个吉祥物的存在，有时候网上购买资源会发网盘链接，还是需要下载一个软件。\n阿里云盘\n需要备用一个\n编程专用\n开发环境\nJava\n目前用的还是1.8版本，在U盘内存了常用的几版JDK。有安装包双击下载就行，下载之后需要配置一下环境变量\nMySQL\n目前使用的是5.7.20版本，官网下载就行。同样也需要配置环境变量。\nRedis\n安装与SpringBoot下的使用方法如下：内链：Spring Data Redis\n外链：Spring Data Redis\nMaven\n一个Java项目管理工具，window需要官网下载可用的.zip包，之后解压到一个没有中文没有空格的路径下，同时也需要配置相应的环境变量。（可能出现IDEA不适配需要降低maven版本，当前IDEA 2020.3.2，可以安装Maven 3.6.3）打开安装目录conf/settings.xml文件，进行以下两项配置。\n\n\n开发工具\nIntelliJ IDEA\n这个不用多说，U盘里存了一个可用的破解版，从大学用到现在了。安装后还需要进行一些常用的设置。具体可以参考以下内链：[[IntelliJ IDEA常用设置]]\n外链：IntelliJ IDEA常用设置\nTabby\n一款终端工具，之前用的一直是FinalShell，后来想转成XSHELL，才知道 XSHELL &amp; XFTP的家庭版是免费的，后来是看博客，知道了一款22年的终端Tabby（不过这么多具体哪个好用确实也是不太了解，换成这个的原因主要是他可以结合远程连接和远程传输两块的内容。也看到把数据库连接，服务器监控，终端都结合在一起的工具，但是数据库工具还是比较习惯用navicat，所以暂时决定是先把终端工具换成Tabby）具体使用步骤参考（后面有时间再整理到自己的笔记里面吧）：(https://www.macrozheng.com/tool/tabby_start.html)\nNavicat\n一款好用的数据库管理工具，提供14天免费试用。但是这种一般都是有破解的，网盘里存了一个（会被杀毒软件杀掉）\nGit\n版本控制工具。（目前使用的博客工具Hexo也是依靠Git部署）具体使用介绍如下内链：[[Git及常用命令]]\n外链：Git及常用命令\n其他\n翻墙\n","categories":["环境搭建"],"tags":["工具"]},{"title":"IntelliJ IDEA常用设置","url":"/blog/2023/07/82fdef6c011a.html","content":"\n\n前言\nIntelliJ IDEA常用设置\n\n\n更新\n\n\n23.07.02 初始记录23.07.09 基本设置（初始）23.07.16 基本设置完成 推荐插件（初始）23.08.28 三个插件的添加\n\n基本设置\n基本风格及UI字体大小\n\n设置打开IDEA不直接打开项目\n\n这样默认打开IDEA时就是如下画面：\n点击Customize里的All settings，就可以为所有新项目设置配置。\n设置项目文件编码格式（很重要）\n建议将所有都设置成UTF-8格式\n\n设置代码提示的匹配格式\n\n设置新建类文件的注释模板\n/** * @author $&#123;USER&#125; * @date: $&#123;DATE&#125; $&#123;TIME&#125; * @description:*/\n\n设置多个类同时打开并不重叠隐藏\n\n设置maven配置\n\n设置SQL自动补全\n\n\n启用IDEA的database插件\n\n\n针对项目进行SQL Dialects配置\n\n\n\n基本设置导出\n为了更方便的迁移IDEA，可以将基本设置导出。\n\n推荐插件\nLombok\n\n通过注解不再需要编写getter、setter、equals等方法，可以在编译时自动生成，开发时常用的插件。IDEA在目前使用的版本中已经内置，SpringBoot 2.1.x之后的版本也在Starter中内置了Lombok依赖。\n\n集成\n在项目的pom.xml文件中可以添加Lombok依赖，SpringBoot 2.1.x版本后无需指定Lombok版本，SpringBoot在spring-boot-dependencies中已经内置。\n&lt;!--lombok依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;\nMyBatisX\n\nMybatisX 是一款基于 IDEA 的快速开发插件，为效率而生。\n\nMaven Helper\n\n可以右键项目快速完成项目maven的各个阶段。\npom.xml文件点击后，显示右边多了Dependency Analyzer的Tab选项，可以查看依赖冲突。同时也可以快速排除冲突的文件。\n\nGit Commit Template\n\n为git的提交提供模板。例子：fix(DAO):用户查询缺少username属性 feat(Controller):用户查询接口开发\n\n参数详解：\n\n\n\n参数\n类型\nshuoming\n\n\n\n\ntype(必须)\n\n用于说明git commit的类别，只允许使用下面的标识。\n\n\n\nfeat\n新功能（feature）\n\n\n\nfix/to\n修复bug，可以是QA发现的BUG，也可以是研发自己发现的BUG。\n\n\n\nfix\n产生diff并自动修复此问题。适合于一次提交直接修复问题\n\n\n\nto\n只产生diff不自动修复此问题。适合于多次提交。最终修复问题提交时使用fix。\n\n\n\ndocs\n文档（documentation）\n\n\n\nstyle\n格式（不影响代码运行的变动）。\n\n\n\nrefactor\n重构（即不是新增功能，也不是修改bug的代码变动）。\n\n\n\nperf\n优化相关，比如提升性能、体验。\n\n\n\ntest\n增加测试。\n\n\n\nchore\n构建过程或辅助工具的变动。\n\n\n\nrevert\n回滚到上一个版本。\n\n\n\nmerge\n代码合并。\n\n\n\nsync\n同步主线或分支的Bug。\n\n\nscope(可选)\n\nscope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。\n\n\nsubject(必须)\n\nsubject是commit目的的简短描述，不超过50个字符\n\n\n\nStatistic\n\n代码统计器\n\n","categories":["环境搭建"],"tags":["IDEA"]},{"title":"Spring Data Redis","url":"/blog/2023/08/a52deee36df0.html","content":"\n\n前言\nSpring Data Redis 是Spring 框架提供的用于操作Redis的方式。涵盖Redis的安装、Spring Cache结合Redis的使用、Redis连接池的使用和RedisTemplate的使用等内容。\n\n\n参考文章\nSpring Data Redis 最佳实践！\n\n\n更新\n\n\n23.08.29 初始记录\n\nRedis安装\nLinux\n\n\n下载Redis5.0的Docker镜像\n\n\ndocker pull redis:5.0\n\n\n使用Docker命令启动Redis容器\n\n\ndocker run -p 6379:6379 --name redis \\-v /mydata/redis/data:/data \\-d redis:5.0 redis-server --appendonly yes\nWindows\n\n\n下载Windows版本的Redis\n\n\n\n下载后直接解压\n\n\n在当前地址栏输入cmd命令，执行对应的redis启动命令\n\n\n# 注册服务redis-server --service-install redis.windows.conf# 启动服务redis-server --service-start# 停止服务redis-server --service-stop# 删除服务redis-server --service-uninstall\nSpring Cache 操作Redis\nSpring Cache 简介\n\n当Spring Boot 结合Redis来作为缓存使用时，最简单的方式就是使用Spring Cache了，使用它我们无需知道Spring中对Redis的各种操作，仅仅通过它提供的@Cacheable 、@CachePut 、@CacheEvict 、@EnableCaching等注解就可以实现缓存功能。\n\n常用注解\n@EnableCaching\n开启缓存功能，一般放在启动类上。\n@Cacheable\n使用该注解的方法当缓存存在时，会从缓存中获取数据而不执行方法，当缓存不存在时，会执行方法并把返回结果存入缓存中。一般使用在查询方法上，可以设置如下属性：\n\n\nvalue：缓存名称（必填），指定缓存的命名空间；\n\n\nkey：用于设置在命名空间中的缓存key值，可以使用SpEL表达式定义；\n\n\nunless：条件符合则不缓存；\n\n\ncondition：条件符合则缓存。\n\n\n@CachePut\n使用该注解的方法每次执行时都会把返回结果存入缓存中。一般使用在新增方法上，可以设置如下属性：\n\n\nvalue：缓存名称（必填），指定缓存的命名空间；\n\n\nkey：用于设置在命名空间中的缓存key值，可以使用SpEL表达式定义；\n\n\nunless：条件符合则不缓存；\n\n\ncondition：条件符合则缓存。\n\n\n@CacheEvict\n使用该注解的方法执行时会清空指定的缓存。一般使用在更新或删除方法上，可以设置如下属性：\n\n\nvalue：缓存名称（必填），指定缓存的命名空间；\n\n\nkey：用于设置在命名空间中的缓存key值，可以使用SpEL表达式定义；\n\n\ncondition：条件符合则缓存。\n\n\n使用步骤\n基础步骤\n\n\n在pom.xml中添加项目依赖：\n\n\n&lt;!--redis依赖配置--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n修改配置文件application.yml，添加Redis的连接配置\n\n\nspring:  redis:    host: 192.168.6.139 # Redis服务器地址    database: 0 # Redis数据库索引（默认为0）    port: 6379 # Redis服务器连接端口    password: # Redis服务器连接密码（默认为空）    timeout: 1000ms # 连接超时时间\n\n\n在启动类上添加@EnableCaching注解启动缓存功能\n\n\n@EnableCaching@SpringBootApplicationpublic class Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Application.class, args);    &#125;&#125;\n\n\n类中实现缓存功能\n\n\n/** * PmsBrandService实现类 * Created by macro on 2019/4/19. */@Servicepublic class PmsBrandServiceImpl implements PmsBrandService &#123;    @Autowired    private PmsBrandMapper brandMapper;    @CacheEvict(value = RedisConfig.REDIS_KEY_DATABASE, key = &quot;&#x27;pms:brand:&#x27;+#id&quot;)    @Override    public int update(Long id, PmsBrand brand) &#123;        brand.setId(id);        return brandMapper.updateByPrimaryKeySelective(brand);    &#125;    @CacheEvict(value = RedisConfig.REDIS_KEY_DATABASE, key = &quot;&#x27;pms:brand:&#x27;+#id&quot;)    @Override    public int delete(Long id) &#123;        return brandMapper.deleteByPrimaryKey(id);    &#125;    @Cacheable(value = RedisConfig.REDIS_KEY_DATABASE, key = &quot;&#x27;pms:brand:&#x27;+#id&quot;, unless = &quot;#result==null&quot;)    @Override    public PmsBrand getItem(Long id) &#123;        return brandMapper.selectByPrimaryKey(id);    &#125;&#125;\n存储JSON格式数据\n\n给RedisTemplate设置JSON格式的序列化器，并通过配置RedisCacheConfiguration设置超时时间来实现以上需求，此时还需要去除启动类上的@EnableCaching注解，具体配置类RedisConfig代码如下\n\n/** * Redis配置类 * Created by macro on 2020/3/2. */@EnableCaching@Configurationpublic class RedisConfig extends CachingConfigurerSupport &#123;    /**     * redis数据库自定义key     */    public  static final String REDIS_KEY_DATABASE=&quot;mall&quot;;    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;        RedisSerializer&lt;Object&gt; serializer = redisSerializer();        RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();        redisTemplate.setConnectionFactory(redisConnectionFactory);        redisTemplate.setKeySerializer(new StringRedisSerializer());        redisTemplate.setValueSerializer(serializer);        redisTemplate.setHashKeySerializer(new StringRedisSerializer());        redisTemplate.setHashValueSerializer(serializer);        redisTemplate.afterPropertiesSet();        return redisTemplate;    &#125;    @Bean    public RedisSerializer&lt;Object&gt; redisSerializer() &#123;        //创建JSON序列化器        Jackson2JsonRedisSerializer&lt;Object&gt; serializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class);        ObjectMapper objectMapper = new ObjectMapper();        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        serializer.setObjectMapper(objectMapper);        return serializer;    &#125;    @Bean    public RedisCacheManager redisCacheManager(RedisConnectionFactory redisConnectionFactory) &#123;        RedisCacheWriter redisCacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory);        //设置Redis缓存有效期为1天        RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig()                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer())).entryTtl(Duration.ofDays(1));        return new RedisCacheManager(redisCacheWriter, redisCacheConfiguration);    &#125;&#125;\n使用Redis连接池\n\nSpringBoot 1.5.x版本Redis客户端默认是Jedis实现的，SpringBoot 2.x版本中默认客户端是用Lettuce实现的，我们先来了解下Jedis和Lettuce客户端。\n\nJedis vs Lettuce\nJedis在实现上是直连Redis服务，多线程环境下非线程安全，除非使用连接池，为每个 RedisConnection 实例增加物理连接。\nLettuce是一种可伸缩，线程安全，完全非阻塞的Redis客户端，多个线程可以共享一个RedisConnection，它利用Netty NIO框架来高效地管理多个连接，从而提供了异步和同步数据访问方式，用于构建非阻塞的反应性应用程序。\n使用步骤\n\n\n修改application.yml添加Lettuce连接池配置，用于配置线程数量和阻塞等待时间\n\n\nspring:  redis:    lettuce:      pool:        max-active: 8 # 连接池最大连接数        max-idle: 8 # 连接池最大空闲连接数        min-idle: 0 # 连接池最小空闲连接数        max-wait: -1ms # 连接池最大阻塞等待时间，负值表示没有限制\n\n\n由于SpringBoot 2.x中默认并没有使用Redis连接池，所以需要在pom.xml中添加commons-pool2的依赖\n\n\n&lt;dependency&gt;    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n不添加依赖则报错\n\n\nCaused by: java.lang.NoClassDefFoundError: org/apache/commons/pool2/impl/GenericObjectPoolConfig\tat org.springframework.data.redis.connection.lettuce.LettucePoolingClientConfiguration$LettucePoolingClientConfiguYrRUIQWOPrationBuilder.&lt;init&gt;(LettucePoolingClientConfiguration.java:84) ~[spring-data-redis-2.1.5.RELEASE.jar:2.1.5.RELEASE]\tat org.springframework.data.redis.connection.lettuce.LettucePoolingClientConfiguration.builder(LettucePoolingClientConfiguration.java:48) ~[spring-data-redis-2.1.5.RELEASE.jar:2.1.5.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration$PoolBuilderFactory.createBuilder(LettuceConnectionConfiguration.java:149) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration.createBuilder(LettuceConnectionConfiguration.java:107) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration.getLettuceClientConfiguration(LettuceConnectionConfiguration.java:93) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration.redisConnectionFactory(LettuceConnectionConfiguration.java:74) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration$$EnhancerBySpringCGLIB$$5caa7e47.CGLIB$redisConnectionFactory$0(&lt;generated&gt;) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration$$EnhancerBySpringCGLIB$$5caa7e47$$FastClassBySpringCGLIB$$b8ae2813.invoke(&lt;generated&gt;) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:244) ~[spring-core-5.1.5.RELEASE.jar:5.1.5.RELEASE]\tat org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:363) ~[spring-context-5.1.5.RELEASE.jar:5.1.5.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration$$EnhancerBySpringCGLIB$$5caa7e47.redisConnectionFactory(&lt;generated&gt;) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_91]\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_91]\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_91]\tat java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_91]\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\t... 111 common frames omitted\n自由操作Redis\n\n使用RedisTemplate自由缓存方法中产生的中间值\n\nRedisService\n/** * redis操作Service * Created by macro on 2020/3/3. */public interface RedisService &#123;    /**     * 保存属性     */    void set(String key, Object value, long time);    /**     * 保存属性     */    void set(String key, Object value);    /**     * 获取属性     */    Object get(String key);    /**     * 删除属性     */    Boolean del(String key);    /**     * 批量删除属性     */    Long del(List&lt;String&gt; keys);    /**     * 设置过期时间     */    Boolean expire(String key, long time);    /**     * 获取过期时间     */    Long getExpire(String key);    /**     * 判断是否有该属性     */    Boolean hasKey(String key);    /**     * 按delta递增     */    Long incr(String key, long delta);    /**     * 按delta递减     */    Long decr(String key, long delta);    /**     * 获取Hash结构中的属性     */    Object hGet(String key, String hashKey);    /**     * 向Hash结构中放入一个属性     */    Boolean hSet(String key, String hashKey, Object value, long time);    /**     * 向Hash结构中放入一个属性     */    void hSet(String key, String hashKey, Object value);    /**     * 直接获取整个Hash结构     */    Map&lt;Object, Object&gt; hGetAll(String key);    /**     * 直接设置整个Hash结构     */    Boolean hSetAll(String key, Map&lt;String, Object&gt; map, long time);    /**     * 直接设置整个Hash结构     */    void hSetAll(String key, Map&lt;String, Object&gt; map);    /**     * 删除Hash结构中的属性     */    void hDel(String key, Object... hashKey);    /**     * 判断Hash结构中是否有该属性     */    Boolean hHasKey(String key, String hashKey);    /**     * Hash结构中属性递增     */    Long hIncr(String key, String hashKey, Long delta);    /**     * Hash结构中属性递减     */    Long hDecr(String key, String hashKey, Long delta);    /**     * 获取Set结构     */    Set&lt;Object&gt; sMembers(String key);    /**     * 向Set结构中添加属性     */    Long sAdd(String key, Object... values);    /**     * 向Set结构中添加属性     */    Long sAdd(String key, long time, Object... values);    /**     * 是否为Set中的属性     */    Boolean sIsMember(String key, Object value);    /**     * 获取Set结构的长度     */    Long sSize(String key);    /**     * 删除Set结构中的属性     */    Long sRemove(String key, Object... values);    /**     * 获取List结构中的属性     */    List&lt;Object&gt; lRange(String key, long start, long end);    /**     * 获取List结构的长度     */    Long lSize(String key);    /**     * 根据索引获取List中的属性     */    Object lIndex(String key, long index);    /**     * 向List结构中添加属性     */    Long lPush(String key, Object value);    /**     * 向List结构中添加属性     */    Long lPush(String key, Object value, long time);    /**     * 向List结构中批量添加属性     */    Long lPushAll(String key, Object... values);    /**     * 向List结构中批量添加属性     */    Long lPushAll(String key, Long time, Object... values);    /**     * 从List结构中移除属性     */    Long lRemove(String key, long count, Object value);&#125;\nRedisServiceImpl\n/** * redis操作实现类 * Created by macro on 2020/3/3. */@Servicepublic class RedisServiceImpl implements RedisService &#123;    @Autowired    private RedisTemplate&lt;String, Object&gt; redisTemplate;    @Override    public void set(String key, Object value, long time) &#123;        redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);    &#125;    @Override    public void set(String key, Object value) &#123;        redisTemplate.opsForValue().set(key, value);    &#125;    @Override    public Object get(String key) &#123;        return redisTemplate.opsForValue().get(key);    &#125;    @Override    public Boolean del(String key) &#123;        return redisTemplate.delete(key);    &#125;    @Override    public Long del(List&lt;String&gt; keys) &#123;        return redisTemplate.delete(keys);    &#125;    @Override    public Boolean expire(String key, long time) &#123;        return redisTemplate.expire(key, time, TimeUnit.SECONDS);    &#125;    @Override    public Long getExpire(String key) &#123;        return redisTemplate.getExpire(key, TimeUnit.SECONDS);    &#125;    @Override    public Boolean hasKey(String key) &#123;        return redisTemplate.hasKey(key);    &#125;    @Override    public Long incr(String key, long delta) &#123;        return redisTemplate.opsForValue().increment(key, delta);    &#125;    @Override    public Long decr(String key, long delta) &#123;        return redisTemplate.opsForValue().increment(key, -delta);    &#125;    @Override    public Object hGet(String key, String hashKey) &#123;        return redisTemplate.opsForHash().get(key, hashKey);    &#125;    @Override    public Boolean hSet(String key, String hashKey, Object value, long time) &#123;        redisTemplate.opsForHash().put(key, hashKey, value);        return expire(key, time);    &#125;    @Override    public void hSet(String key, String hashKey, Object value) &#123;        redisTemplate.opsForHash().put(key, hashKey, value);    &#125;    @Override    public Map&lt;Object, Object&gt; hGetAll(String key) &#123;        return redisTemplate.opsForHash().entries(key);    &#125;    @Override    public Boolean hSetAll(String key, Map&lt;String, Object&gt; map, long time) &#123;        redisTemplate.opsForHash().putAll(key, map);        return expire(key, time);    &#125;    @Override    public void hSetAll(String key, Map&lt;String, Object&gt; map) &#123;        redisTemplate.opsForHash().putAll(key, map);    &#125;    @Override    public void hDel(String key, Object... hashKey) &#123;        redisTemplate.opsForHash().delete(key, hashKey);    &#125;    @Override    public Boolean hHasKey(String key, String hashKey) &#123;        return redisTemplate.opsForHash().hasKey(key, hashKey);    &#125;    @Override    public Long hIncr(String key, String hashKey, Long delta) &#123;        return redisTemplate.opsForHash().increment(key, hashKey, delta);    &#125;    @Override    public Long hDecr(String key, String hashKey, Long delta) &#123;        return redisTemplate.opsForHash().increment(key, hashKey, -delta);    &#125;    @Override    public Set&lt;Object&gt; sMembers(String key) &#123;        return redisTemplate.opsForSet().members(key);    &#125;    @Override    public Long sAdd(String key, Object... values) &#123;        return redisTemplate.opsForSet().add(key, values);    &#125;    @Override    public Long sAdd(String key, long time, Object... values) &#123;        Long count = redisTemplate.opsForSet().add(key, values);        expire(key, time);        return count;    &#125;    @Override    public Boolean sIsMember(String key, Object value) &#123;        return redisTemplate.opsForSet().isMember(key, value);    &#125;    @Override    public Long sSize(String key) &#123;        return redisTemplate.opsForSet().size(key);    &#125;    @Override    public Long sRemove(String key, Object... values) &#123;        return redisTemplate.opsForSet().remove(key, values);    &#125;    @Override    public List&lt;Object&gt; lRange(String key, long start, long end) &#123;        return redisTemplate.opsForList().range(key, start, end);    &#125;    @Override    public Long lSize(String key) &#123;        return redisTemplate.opsForList().size(key);    &#125;    @Override    public Object lIndex(String key, long index) &#123;        return redisTemplate.opsForList().index(key, index);    &#125;    @Override    public Long lPush(String key, Object value) &#123;        return redisTemplate.opsForList().rightPush(key, value);    &#125;    @Override    public Long lPush(String key, Object value, long time) &#123;        Long index = redisTemplate.opsForList().rightPush(key, value);        expire(key, time);        return index;    &#125;    @Override    public Long lPushAll(String key, Object... values) &#123;        return redisTemplate.opsForList().rightPushAll(key, values);    &#125;    @Override    public Long lPushAll(String key, Long time, Object... values) &#123;        Long count = redisTemplate.opsForList().rightPushAll(key, values);        expire(key, time);        return count;    &#125;    @Override    public Long lRemove(String key, long count, Object value) &#123;        return redisTemplate.opsForList().remove(key, count, value);    &#125;&#125;\nRedisController\n\n简单测试在Controller中进行操作\n\n/** * Redis测试Controller * Created by macro on 2020/3/3. */@Api(tags = &quot;RedisController&quot;, description = &quot;Redis测试&quot;)@Controller@RequestMapping(&quot;/redis&quot;)public class RedisController &#123;    @Autowired    private RedisService redisService;    @Autowired    private PmsBrandService brandService;    @ApiOperation(&quot;测试简单缓存&quot;)    @RequestMapping(value = &quot;/simpleTest&quot;, method = RequestMethod.GET)    @ResponseBody    public CommonResult&lt;PmsBrand&gt; simpleTest() &#123;        List&lt;PmsBrand&gt; brandList = brandService.list(1, 5);        PmsBrand brand = brandList.get(0);        String key = &quot;redis:simple:&quot; + brand.getId();        redisService.set(key, brand);        PmsBrand cacheBrand = (PmsBrand) redisService.get(key);        return CommonResult.success(cacheBrand);    &#125;    @ApiOperation(&quot;测试Hash结构的缓存&quot;)    @RequestMapping(value = &quot;/hashTest&quot;, method = RequestMethod.GET)    @ResponseBody    public CommonResult&lt;PmsBrand&gt; hashTest() &#123;        List&lt;PmsBrand&gt; brandList = brandService.list(1, 5);        PmsBrand brand = brandList.get(0);        String key = &quot;redis:hash:&quot; + brand.getId();        Map&lt;String, Object&gt; value = BeanUtil.beanToMap(brand);        redisService.hSetAll(key, value);        Map&lt;Object, Object&gt; cacheValue = redisService.hGetAll(key);        PmsBrand cacheBrand = BeanUtil.mapToBean(cacheValue, PmsBrand.class, true);        return CommonResult.success(cacheBrand);    &#125;    @ApiOperation(&quot;测试Set结构的缓存&quot;)    @RequestMapping(value = &quot;/setTest&quot;, method = RequestMethod.GET)    @ResponseBody    public CommonResult&lt;Set&lt;Object&gt;&gt; setTest() &#123;        List&lt;PmsBrand&gt; brandList = brandService.list(1, 5);        String key = &quot;redis:set:all&quot;;        redisService.sAdd(key, (Object[]) ArrayUtil.toArray(brandList, PmsBrand.class));        redisService.sRemove(key, brandList.get(0));        Set&lt;Object&gt; cachedBrandList = redisService.sMembers(key);        return CommonResult.success(cachedBrandList);    &#125;    @ApiOperation(&quot;测试List结构的缓存&quot;)    @RequestMapping(value = &quot;/listTest&quot;, method = RequestMethod.GET)    @ResponseBody    public CommonResult&lt;List&lt;Object&gt;&gt; listTest() &#123;        List&lt;PmsBrand&gt; brandList = brandService.list(1, 5);        String key = &quot;redis:list:all&quot;;        redisService.lPushAll(key, (Object[]) ArrayUtil.toArray(brandList, PmsBrand.class));        redisService.lRemove(key, 1, brandList.get(0));        List&lt;Object&gt; cachedBrandList = redisService.lRange(key, 0, 3);        return CommonResult.success(cachedBrandList);    &#125;&#125;","categories":["后端项目","准备工作"],"tags":["Redis"]}]