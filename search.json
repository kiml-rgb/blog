[{"title":"Obsidian + Git + Hexo + 图床 = Blog + 个人笔记体系","url":"/2023/02/27/100000002/","content":"\n\n前言\n之前有过基于 Hexo 的博客搭建经历，但是由于时间繁忙，加上后续学习了解到的笔记软件，拥有我想要的全局搜索功能，而且比博客的格式、排版更加吸引人，就放弃了之前搭建的博客。但是出来找工作感觉拥有一个自己的技术博客会比较占优势，因此打算在笔记的基础上，加上原来的 Hexo 快速生成，转成技术博客输出。\n\n\n参考文章\n\n\n\n【保姆级】利用Github搭建自己的个人博客，看完就会\nHexo + Obsidian + Git 完美的博客部署与编辑方案\n\n\n更新\n\n22.12.11 初始记录(修改预计开始日期为元旦)23.02.24 环境部署，个人博客绑定到 Gitee Pages23.02.27 Obsidian 整合 等待Gitee Pages审核ing24.03.28 更新域名绑定等相关问题\n\n环境部署\n安装git\n\n\n访问 git 官方地址，下载对应的安装包，进行安装（简单的点击下一步）。\n\n\n安装好之后，鼠标右键可以看到：Git Bash Here，点击后打开了。\n\n\n输入：git --version\n出现版本号说明安装成功。\n\n\n安装node.js\n\n\n访问 node.js 官方地址，下载对应的安装包，进行安装（简单的点击下一步）。\n\n\n安装好之后，配置环境变量，并在终端里面输入：node -v\n出现版本号说明安装成功。\n\n\n安装 Hexo\n\n\n安装命令：\n\n\nnpm install hexo -g\n测试是否安装成功，命令：hexo -v\n出现版本号说明安装成功。\n\n\n安装 hexo 推送 git 拓展依赖，安装命令：\n\n\nnpm install hexo-deployer-git --save\ngit配置 SSH key\n\n\n先看本地是否配置好SSH key（命令：cd ~/.ssh）\nSSH key的保存位置在本地的C:\\Users\\&#123;你的用户名&#125;\\.ssh文件下，如果本地已存在SSH，此步不会有提示，否则出现No such file or directory。如果保存文件下没有文件id_rsa.pub 或 id_dsa.pub则也需要重新生成\n\n\n生成SSH key\n如果没有配置输入生成命令，然后连续回车三次即可：\n\n\nssh-keygen -t rsa -C &quot;邮件地址&quot; #该邮箱地址是绑定github账号的地址\ngithub\n\n\n打开SSH key的保存位置，复制id_rsa.pub文件里全部内容，接着打开github主页，点击个人设置，点击左侧的SSH and GPG keys，点击New SSH key\n\n\n\n将id_rsa.pub复制的内容粘贴到key中，title随便起一个就行。\n\n\n\n测试是否成功，输入命令：\n\n\nssh -T git@github.com\n出现 You've successfully authenticated, but GitHub does not provide shell access.说明成功\n\n\n配置账号和密码\n\n\n$ git config --global user.name &quot;liyunchen&quot; #你的github用户名 $ git config --global user.email &quot;xxx@163.com&quot; #填写你的github注册邮箱\ngitee\n\n除了Github Pages，也可以把博客搭建在Gitee Pages上，不翻墙的情况下，连接github经常会出现连接不上的情况，所以这次就直接改到Gitee上了。又换回来了（24.02.02）\n\n\n\n同样的配置SSH key，在Gitee的个人设置界面添加公钥\n\n\n\n测试是否成功，输入命令：\n\n\nssh -T git@gitee.com\n出现 You've successfully authenticated, but GITEE.COM does not provide shell access.说明成功\n搭建个人博客\n\n\n新建一个保存博客的存放目录，进入到本地博客存放目录，初始化个人博客，命令：\n\n\nhexo init\n出现不可获取错误说明github连接失败，再重新执行一遍命令就可以了\n\n\n\n生成静态网页，命令：\n\n\nhexo g\n\n\n本地预览，命令：\n\n\nhexo s\n访问localhost:4000\ngithub\n\n\n新建一个github仓库，给仓库起个名称，可以为用户名.github.io，这样这个名称就可以作为你github博客的访问地址\n\n\n编辑_config.yml，此文件在你博客存放目录下，需要编辑的github地址填写在最后deploy处\n\n\ndeploy: \ttype: git \trepository: #仓库地址\tbranch: main #查看自己仓库是master还是main\n\n\n发布到 github，命令：\n\n\nhexo d\n这样就已经把生成的静态文件推送到github仓库去了。\ngitee\n\n\n新建一个 gitee 仓库，给仓库起个名称，这里我直接用 blog 作为名称，这样博客的访问地址就是用户名.gitee.io/blog\n\n\n编辑_config.yml，此文件在你博客存放目录下，文件需要\n\n\ndeploy: \ttype: git \trepository: #仓库地址\tbranch: master #查看自己仓库是master还是main\n\n\n发布到 gitee，命令：\n\n\nhexo d\n\n\n在个人仓库界面，开启 Gitee Pages 服务（第一次使用还要手持身份证拍照的实名认证，蛮无语的，终于知道为什么用的人少了。。。）\n\n\n\n博客主题（Keep）\n\n在配置文件里可以看见 Hexo 主题商店的地址，配置文件中默认的主题为 landscape，不太喜欢打算换掉。原先博客使用的是Next主题，也是使用 Hexo 搭建博客用到最多的主题，但是也用腻了。现在发现一个新的主题 Keep，感觉蛮简洁舒适的，所以这次重新搭建也打算直接换上。\n\nKeep 主题的官方配置文档很详细，在演示博客中有一个使用指南，直接照着配置就行。\nObsidian整合\nObsidian知识库创建\n\n\n新建一个仓库或将之前的博客文件作为仓库打开\n\n\n\n忽略多余的文件。我们主要是编辑和管理Markdown文件，所以一些多余的文件要忽略掉，这样在知识库里搜索文件、关键字时才不会搜索到多余的，也能有效提高检索效率。打开：设置&gt;文件与链接&gt;Exclude Files\n\n\n\n设置新建笔记的存放位置，内部链接类型~~（关闭Wiki链接的使用，因为hexo的解析要求为markdown格式的文件）~~以及附件默认的存放路径\n\n\n\n在 hexo 项目的 .gitignore 文件中加入如下内容：\n\n\n.obsidian/workspace\n博客文章的管理\n\n新建文件在 hexo 的默认配置中放在 source/_post 目录下，随着文章数量的增多，文章也会变得难以寻找。因此采用以文件夹来分目录的方式，存放写好的文件。但是这样分类后，还需要手动维护文章开始前的定义文字，去修改文件所在的目录，较为麻烦。\n\n为了省去手动维护 categorys 字段的这个问题，我们可以使用 hexo-auto-category 这个插件。这个插件在 Hexo 进行 build 的时候会去自动根据文章目录情况来自动修改文章的 categories 信息，更详细的部分可以看作者的文章。除此之外最好修改一下 _config.yml 中的默认配置：\npermalink: :year/:month/:hash.html\n但是这里有一个问题，就是只有 hexo 在执行 hexo generate 或者 hexo server 时候才会去触发 categories 的生成，那么每次我们创建文章都要重新 hexo generate 以触发插件的自动校正功能，并再次把更新后的变更提交推送git。\n参考博客使用Husky完成git hook的操作：\n\n\n安装 huksy：npm install husky --save-dev\n\n\n执行 huksy 初始化指令：npx husky install\n\n\n在 package.json 中的 scripts 中写入：&quot;prepare&quot;: &quot;husky install&quot;\n\n\n在生成的 .husky 目录创建 pre-commit 文件（有的话就不用创建），并写入以下内容：\n\n\n#!/usr/bin/env sh. &quot;$(dirname -- &quot;$0&quot;)/_/husky.sh&quot;npx hexo generate &amp;&amp; git add .\n如果提交代码的时候，终端出现类似的构建过程，就说明由 husky 创建的 git hook 生效了。\n\nhexo 博客默认携带的两个文件夹为 categories 和 tags ，这两个标签可以在文章开始前定义，然后 hexo 会自动解析该文章所属的目录和标签。\n\n上面已经通过插件解决了目录的问题，还剩下文章的标题和 tags。Obsidian 是支持创建新文件时插入模板的，这就意味着我们可以不用重复写 Hexo 博客文的 Front-matter 部分。\n\n\n在 source 目录下创建 _obsidian 文件夹，并创建一篇 Post Template 的文章（md文件），内容为：\n\n\n---title: &#123;&#123;title&#125;&#125;date: &#123;&#123;date&#125;&#125;tags: []---\n\n\n然后进入到 Obsidian 的设置面板，选择核心插件，并启用模板功能。同时点击旁边的配置按钮，进入到模板配置的设置中，设置配置信息\n\n\n\n之后，我们再创建新文章的时候，只需要点击侧边栏的插入模板按钮就可以快速生成 Front-matter 信息：\n\n\n\n博客图片的管理\n\n在 Obsidian 中，可以直接粘贴截图，并设置默认保存位置。相对路径保存的格式如下：![](attachments/xxx.png)，但是这样部署到 hexo 中的图片会显示404加载不成功的错误。\n\n原先的办法是将 _config.yml 配置文件中的 post_asset_folder 选项设置为 true 来打开。该功能打开后，Hexo 将会在你每一次通过 hexo new [layout] &lt;title&gt; 命令创建新文章时自动创建一个文件夹。这个资源文件夹名与文章文件名相同。将所有与你的文章有关的资源（如图片）放在这个关联文件夹中之后，通过相对路径来引用它们。但是由于本次需要将 Obsidian 与 Hexo 结合，希望生成新文章不依靠于命令行。因此本次直接加入图床保存图片。使用的图床为Keep主题推荐的图床PicX。建议本地依旧备份一份图片，以防万一。\nGit 同步（后续弃用）\n\nObsidian内存在插件Obsidian Git 插件使我们可以在 Obsidian 内就可以实现 git commit 以及 push 的操作。\n\n\n\n在右侧命令面板处输入open source control view，可以打开Git面板，右侧会自动生成commit信息，commit信息可以在配置文件内自行配置\n\n\n\nFile Tree 定位\n\n用 Obsidian 控制文件有一个弊端在于左侧目录为全部文件，而我们编写 hexo 博客，一般只会在_posts文件下操作，可以使用Obsidian插件 File Tree Alternative Plugin\n\n安装插件后可以看到文件列变为了以下格式\n\n打开选中_post，右键Focus on Folder，则菜单栏只显示_post文件夹\n\n其他拓展\n更高级的 Markdown 渲染器\n\nHexo 默认的 Markdown 渲染器是hexo-renderer-marked，但其支持的渲染格式有限，比如重点符号的渲染就是不成功的，因此更换更好用的渲染器hexo-renderer-markdown-it\n\n\n\n卸载hexo-renderer-marked\n\n\nnpm un hexo-renderer-marked --save\n\n\n安装 hexo-renderer-markdown-it\n\n\nnpm i hexo-renderer-markdown-it --save\n\n\n将如下文本复制粘贴到 Hexo 的配置文件 _config.yml 的尾部\n\n\nmarkdown:  preset: &quot;default&quot;  render:    html: true    xhtmlOut: false    langPrefix: &quot;language-&quot;    breaks: true    linkify: true    typographer: true    quotes: &quot;“”‘’&quot;  enable_rules:  disable_rules:  plugins:    - markdown-it-abbr    - markdown-it-cjk-breaks    - markdown-it-deflist    - markdown-it-emoji    - markdown-it-footnote    - markdown-it-ins    - markdown-it-mark    - markdown-it-sub    - markdown-it-sup    - markdown-it-checkbox    - markdown-it-imsize    - markdown-it-expandable    - name: markdown-it-container      options: success    - name: markdown-it-container      options: tips    - name: markdown-it-container      options: warning    - name: markdown-it-container      options: danger  anchors:    level: 2    collisionSuffix: &quot;&quot;    permalink: false    permalinkClass: &quot;header-anchor&quot;    permalinkSide: &quot;left&quot;    permalinkSymbol: &quot;¶&quot;    case: 0    separator: &quot;-&quot;\n\n\n分别使用 npm 命令安装以下三个插件，其它插件 hexo-renderer-markdown-it 渲染器已有\n\n\nnpm i markdown-it-checkboxnpm i markdown-it-imsizenpm i markdown-it-expandable\n域名绑定\n\n\n域名的购买\n\n\n在仓库里添加CNAME文件并在文件中填写绑定的域名\n\n\n\nping 你的github域名得到IP地址\n\n\n\n解析域名到对应的地址\n\n\n\n问题\nHexo在部署到Github后CNAME文件会消失或改变\n问题详述：之前已经在github上对域名进行了绑定，但是hexo -d之后绑定生成的CNAME文件被删除。解决方式：参考网上博客的说法，把对应的CNAME文件放入source文件夹下，这样hexo -g重新生成public文件夹下的内容时，CNAME文件也会同步生成。再执行hexo -d操作后，CNAME文件被同步发布，页面刷新域名正常不会出现404问题。\nHexo链接地址改变\n处理如下：内链：[[优化 Hexo 网站的永久链接格式]]\n外链：优化 Hexo 网站的永久链接格式\n","categories":["博客"]},{"title":"优化 Hexo 网站的永久链接格式","url":"/2024/05/22/100000002/","content":"\n\n前言\n浏览之前引用的文章地址，突然发现，地址全部变成了404。后来发现每次发布，地址链接都会改变。所以记录一下，怎么处理这个问题。\n\n\n参考文章\n\n\n\n优化 Hexo 网站的永久链接格式\n\n\n更新\n\n24.05.22 初始记录\n\n打开Hexo配置文件可以看到原先的配置处为：\nurl: https://kiml.github.iopermalink: :year/:month/:hash.htmlpermalink_defaults:pretty_urls:  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks\n照理说这样配置也是没有问题的，由于hash值的计算与文章标题有关，可能是因为这样，重新发布后，有部分页面会直接变成404的状态。\n优化\n安装插件\n在 Hexo 根目录打开终端安装插件\n# 使用npm安装插件npm install hexo-abbrlink2 --save# 使用yarn安装插件yarn add hexo-abbrlink2\n修改配置\n修改 Hexo 的配置文件的 permalink 字段。好像abbrlink的值月份内是有可能重复的？不加day有部分文章生成的链接是相同的不知道怎么回事\npermalink: :year/:month/:day/:abbrlink/\n插件配置默认为0，这里设置成100000000，添加到配置文件处\nabbrlink:  start: 100 # 启起始文章id，默认为0 ，可以自定义，比如100\n","categories":["博客"]},{"title":"IntelliJ IDEA常用设置","url":"/2023/07/02/100000003/","content":"\n\n前言\nIntelliJ IDEA常用设置\n\n\n更新\n\n\n23.07.02 初始记录23.07.09 基本设置（初始）23.07.16 基本设置完成 推荐插件（初始）23.08.28 三个插件的添加\n\n基本设置\n基本风格及UI字体大小\n\n设置打开IDEA不直接打开项目\n\n这样默认打开IDEA时就是如下画面：\n点击Customize里的All settings，就可以为所有新项目设置配置。\n设置项目文件编码格式（很重要）\n建议将所有都设置成UTF-8格式，Maven下载不成功有时候和这个有关\n\n设置代码提示的匹配格式\n\n设置新建类文件的注释模板\n/** * @author $&#123;USER&#125; * @date: $&#123;DATE&#125; $&#123;TIME&#125; * @description:*/\n\n设置多个类同时打开并不重叠隐藏\n\n设置maven配置\n\n设置SQL自动补全\n\n\n启用IDEA的database插件\n\n\n针对项目进行SQL Dialects配置\n\n\n基本设置导出\n为了更方便的迁移IDEA，可以将基本设置导出。\n\n推荐插件\nLombok\n\n通过注解不再需要编写getter、setter、equals等方法，可以在编译时自动生成，开发时常用的插件。IDEA在目前使用的版本中已经内置，SpringBoot 2.1.x之后的版本也在Starter中内置了Lombok依赖。\n\n集成\n在项目的pom.xml文件中可以添加Lombok依赖，SpringBoot 2.1.x版本后无需指定Lombok版本，SpringBoot在spring-boot-dependencies中已经内置。\n&lt;!--lombok依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;\nMyBatisX\n\nMybatisX 是一款基于 IDEA 的快速开发插件，为效率而生。\n\nMaven Helper\n\n可以右键项目快速完成项目maven的各个阶段。\npom.xml文件点击后，显示右边多了Dependency Analyzer的Tab选项，可以查看依赖冲突。同时也可以快速排除冲突的文件。\n\nGit Commit Template\n\n为git的提交提供模板。例子：fix(DAO):用户查询缺少username属性 feat(Controller):用户查询接口开发\n\n参数详解：\n\n\n\n参数\n类型\nshuoming\n\n\n\n\ntype(必须)\n\n用于说明git commit的类别，只允许使用下面的标识。\n\n\n\nfeat\n新功能（feature）\n\n\n\nfix/to\n修复bug，可以是QA发现的BUG，也可以是研发自己发现的BUG。\n\n\n\nfix\n产生diff并自动修复此问题。适合于一次提交直接修复问题\n\n\n\nto\n只产生diff不自动修复此问题。适合于多次提交。最终修复问题提交时使用fix。\n\n\n\ndocs\n文档（documentation）\n\n\n\nstyle\n格式（不影响代码运行的变动）。\n\n\n\nrefactor\n重构（即不是新增功能，也不是修改bug的代码变动）。\n\n\n\nperf\n优化相关，比如提升性能、体验。\n\n\n\ntest\n增加测试。\n\n\n\nchore\n构建过程或辅助工具的变动。\n\n\n\nrevert\n回滚到上一个版本。\n\n\n\nmerge\n代码合并。\n\n\n\nsync\n同步主线或分支的Bug。\n\n\nscope(可选)\n\nscope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。\n\n\nsubject(必须)\n\nsubject是commit目的的简短描述，不超过50个字符\n\n\n\nStatistic\n\n代码统计器\n\n","categories":["环境搭建"],"tags":["IDEA"]},{"title":"Git及常用命令","url":"/2023/07/11/100000003/","content":"\n\n前言\nGit部分知识以及常用命令\n\n\n更新\n\n\n23.07.11 初始记录\n\n安装\n之前在写 [[Obsidian + Git + Hexo + 图床 = Blog + 个人笔记体系]]这篇笔记的时候有提到过Git的安装。这里就直接把步骤贴过来，具体安装地址(https://git-scm.com/)\n\n\n访问 git 官方地址，下载对应的安装包，进行安装（简单的点击下一步）。\n\n\n安装好之后，鼠标右键可以看到：Git Bash Here，点击后打开了。\n\n\n输入：git --version\n出现版本号说明安装成功。\n\n\n\n\nlinux安装使用以下命令\n\n\nsudo apt-get install git\ngit配置 SSH key\nGit是分布式的代码管理工具，远程的代码管理是基于SSH的，所以要使用远程的Git则需要SSH的配置。一、设置Git的user name和email：\n$ git config --global user.name &quot;kiml&quot;  $ git config --global user.email &quot;1162278448@qq.com&quot;\n二、生成SSH密钥内链：[[Obsidian + Git + Hexo + 图床 = Blog + 个人笔记体系#git配置 SSH key]]\n外链：[Obsidian + Git + Hexo + 图床 = Blog + 个人笔记体系](https://kiml.site/2023/02/27/100000002/#git配置 SSH key)\ngit工具\nGitHub Desktop\n\n平时更多使用IntelliJ IDEA自带的git工具，偶然发现这个工具，近期打算使用官方文档：[https://docs.github.com/zh/desktop/installing-and-configuring-github-desktop/overview/getting-started-with-github-desktop]\n\n常用命令\nclone到本地\ngit clone git@gitee.com:kiml_rgb/blog.git\n提交代码\n# 进入项目工程目录cd hello/# 将当前修改的文件添加到暂存区git add .# 提交代码git commit -m &quot;first commit&quot;\n推送代码\ngit push\n拉取代码\ngit pull\n创建并提交分支\n# 切换并从当前分支创建一个dev分支git checkout -b dev# 将新创建的dev分支推送到远程仓库git push origin dev\n其他常用命令\n# 切换到dev分支git checkout dev# 查看本地仓库文件状况git status# 查看本地所有分支git branch# 查看提交记录git log","categories":["环境搭建"],"tags":["Git"]},{"title":"装机-软件安装","url":"/2023/11/02/100000003/","content":"\n\n前言\n找到工作之后每天就是躺平，好久没有更新技术上的内容了，之前学的好多东西也忘了……甚至md语法都忘了好多（每天CRUD，但是也很消耗精力。必须要不断学习，好痛苦，什么时候能退休😢）趁着618配了一台新电脑，顺便用半个多月的时间用新电脑打游戏。。。正好最近在装软件，整理一下装机要注意的事，以及一些必备软件，便于后面再次装机使用。\n\n\n更新\n\n\n23.06.24 初始记录23.07.02 IDEA常用插件 + 基本设置23.07.09 编程环境Java + MySQL23.07.11 Git23.08.28 Maven\n\n初始装机\n这部分都是照着b站上的视频完成的。总之时间就分两大块，把零件装上去，理线。具体可参照以下视频：B站 赵德柱装机\n系统安装\n系统安装需要准备一个U盘装系统。具体步骤可以参照以下视频：B站 赵德柱装系统安装系统完毕第一件事就是去对应官网安装对应驱动，这个依据配置不同，需要下载的东西也不一样。可以检查以下项目的驱动是否安装，每项都需要到对应的官网去下载对应的驱动包：\n\n\ncpu驱动\n\n\n主板驱动（涉及较多）\n\n\n显卡驱动\n\n\n鼠标驱动（调光需要）\n\n\n键盘驱动（调光需要）\n\n\n软件安装\n常用软件\nOffice全家桶\n这个直接登录原来的微软账户就可以安装了，之前买笔记本有配有家庭版可以直接使用。有的笔记本没有送，这个需要注意原来的不要卸载，不然重新下载比较麻烦（这是个付费软件）。直接去买个激活码就行\nSteam\n装机第一件事\nUU加速器\n用了这么多，最常用的还是这个，加速商店是足够用了，想要加速游戏可以进一步去贴吧下载\nChrome\n插件就不提供了，自己后续需要再搜，最好还是能整个账号，不然每次装机都要重新把收藏夹的导出来有点麻烦。\nSnipaste\n很好用的截屏软件，U盘里带有安装包，直接解压缩，开启后就可以F1截图了\nScreenToGif\n制作Gif的软件，以前下载过但是没有用到的机会\nToDesk\n远程连接工具，不想背电脑回家就带这个\nObsidian\n目前在用的All in One笔记软件，好用但是太繁琐了，一开始大半时间都浪费在插件和布局上面，目前用着还行，希望后面能完全用起来。当个md编辑器还是不错的。\nTypora\n一款 Markdown 编辑器和阅读器。更便捷的浏览工具。\n网盘\n百度网盘\n之前参加活动，容量已经到5T了，但是不充会员完全没法使用，现在就是一个吉祥物的存在，有时候网上购买资源会发网盘链接，还是需要下载一个软件。\n阿里云盘\n需要备用一个\n编程专用\n开发环境\nJava\n目前用的还是1.8版本，在U盘内存了常用的几版JDK。有安装包双击下载就行，下载之后需要配置一下环境变量\nMySQL\n目前使用的是5.7.20版本，官网下载就行。同样也需要配置环境变量。\nRedis\n安装与SpringBoot下的使用方法如下：内链：[[Spring Data Redis]]\n外链：Spring Data Redis\nMaven\n一个Java项目管理工具，window需要官网下载可用的.zip包，之后解压到一个没有中文没有空格的路径下，同时也需要配置相应的环境变量。（可能出现IDEA不适配需要降低maven版本，当前IDEA 2020.3.2，可以安装Maven 3.6.3）打开安装目录conf/settings.xml文件，进行以下两项配置。\n\n\n其他\n还有很多其他环境配置，包括开发用的其他中间件。听说Windows也能配置Docker了，这部分应该会单独写文章。\n开发工具\nIntelliJ IDEA\n这个不用多说，U盘里存了一个可用的破解版，从大学用到现在了。安装后还需要进行一些常用的设置。具体可以参考以下内链：[[IntelliJ IDEA常用设置]]\n外链：IntelliJ IDEA常用设置\nWebStorm\n前端的IDEA，打算抛弃Vs Code用这个了。看了很多对比测评。用JetBrains的产品习惯了。\nPycharm\nPython的IDEA，也是JetBrains家的。\nTabby\n一款终端工具，之前用的一直是FinalShell，后来想转成XSHELL，才知道 XSHELL &amp; XFTP的家庭版是免费的，后来是看博客，知道了一款22年的终端Tabby（不过这么多具体哪个好用确实也是不太了解，换成这个的原因主要是他可以结合远程连接和远程传输两块的内容。也看到把数据库连接，服务器监控，终端都结合在一起的工具，但是数据库工具还是比较习惯用navicat，所以暂时决定是先把终端工具换成Tabby）具体使用步骤参考（后面有时间再整理到自己的笔记里面吧）：(https://www.macrozheng.com/tool/tabby_start.html)\nNavicat\n一款好用的数据库管理工具，提供14天免费试用。但是这种一般都是有破解的，网盘里存了一个（会被杀毒软件杀掉）\nGit\n版本控制工具。（目前使用的博客工具Hexo也是依靠Git部署）具体使用介绍如下内链：[[Git及常用命令]]\n外链：Git及常用命令\n其他\n翻墙\n目前使用的教程是(https://github.com/Alvin9999/new-pac/blob/master/自建v2ray服务器教程.md)\n","categories":["环境搭建"],"tags":["工具"]},{"title":"华为OD","url":"/2024/03/28/100000003/","content":"\n\n前言\n为块术（不是），其实一直觉得二本毕业去这边也蛮好的，但是一直没有动力刷题。今天去面试，啥也没准备，就看了一天早已忘记的八股文，果然挂了。但是Boss上收到华为OD的Hr的消息（好像是最近突然加了岗位？），总之约了两周后机考（怎么敢的，真的一点都没准备过）\n\n\n更新\n\n\n24.03.28 初始记录-day1刷题记录\n\n刷题记录\n240328（牛客华为机试题库——https://www.nowcoder.com/ta/huawei）\n\n\nHJ1 字符串最后一个单词的长度\n\n\n思路居然是遍历，遇0清空计数，真的没想到。显得我的方法很笨。\n\n\nHJ2 计算某字符出现次数\n\n\nHJ3 明明的随机数\n\n\n语法糖就语法糖吧，我放弃了\n\n\nHJ4 字符串分隔\n\n\nHJ5 进制转换\n\n\n240330（牛客华为机试题库——https://www.nowcoder.com/ta/huawei）\n\n\nHJ6 质数因子\n\n\n240402（牛客华为机试题库——https://www.nowcoder.com/ta/huawei）\n\n\nHJ7 取近似值\n\n\n用了API\n\n\nHJ8 取近似值\n\n\nHJ9 提取不重复的整数\n\n\nHJ10 字符个数统计\n\n\nHJ11 数字颠倒\n\n\n240404（牛客华为机试题库——https://www.nowcoder.com/ta/huawei）\n\n\nHJ12 字符串反转\n\n\nHJ13 句子逆序\n\n\n// 忘了这个APIString.join(&quot; &quot;, strings)\n\n\nHJ14 字符串排序\n\n\nHJ15 求int型正整数在内存中存储时1的个数\n\n\n华为OD机试真题-寻找身高相近的小朋友（C卷）\n\n\n240406（华为OD机试2024年最新题库-C卷）\n\n\n华为OD机试真题-围棋的气（C卷）\n\n\n华为OD机试真题-用连续自然数之和来表达整数（C卷）\n\n\n本题用滑动窗口进行求解。之前都不会这个。标记一下需要二刷。\n\n\n华为OD机试真题-开源项目热榜（C卷）\n\n\n华为OD机试真题-API集群负载统计（C卷）\n\n\n华为OD机试真题-整数对最小和（C卷）\n\n\n华为OD机试真题-素数之积（C卷）\n\n\n华为OD机试真题-CPU算力分配（C卷）\n\n\n华为OD机试真题-最大坐标值（C卷）\n\n\n华为OD机试真题-寻找最富裕的小家庭（C卷）\n\n\n240407（华为OD机试2024年最新题库-C卷）\n\n\n华为OD机试真题-分月饼（C卷）\n\n\n不会，没有思路，先跳过。\n240408（华为OD机试2024年最新题库-C卷）\n\n\n华为OD机试真题-找城市（C卷）\n\n\n没有思路，200分题打算周末再刷了，先看看有没有类似的题解。\n\n\n华为OD机试真题-查找接口成功率最优时间段（C卷）\n\n\n严重超时，不知道是不是因为一边上班一边做的原因思路都是乱的\n240409（华为OD机试2024年最新题库-C卷）\n\n\n华为OD机试真题-分割均衡字符串（C卷）\n\n\n华为OD机试真题-虚拟游戏理财（C卷）\n\n\n华为OD机试真题-靠谱的车（C卷）\n\n\n华为OD机试真题-执行时长（C卷）\n\n\n华为OD机试真题-万能字符单词拼写（C卷）\n\n\n240410（华为OD机试2024年最新题库-C卷）\n\n\n华为OD机试真题-来自异国的客人（C卷）\n\n\n华为OD机试真题-求最多可以派出多少支团队（C卷）\n\n\n华为OD机试真题-最长子字符串的长度（C卷）\n\n\n华为OD机试真题-机场航班调度程序（C卷）\n\n\n华为OD机试真题-数的分解（C卷）\n\n\n240411（华为OD机试2024年最新题库-C卷）\n\n\n华为OD机试真题-智能成绩表（C卷）\n\n\n华为OD机试真题-提取字符串中的最长数学表达式并计算（C卷）\n\n\n不希望考到这题。怎么还有正则正则实在不太熟，这题硬记((+-)?(\\\\d+[+-*])*\\\\d)判断出最长正则式子之后的思路为：1、记录初始加减号2、如果是+，记录数乘1；如果是-，记录数乘-1；如果是乘，获取前一个数并乘并记录乘积\n机试（240417）\n没过。。。293但是要300分。算了。本来也没报多大希望。还是多刷点题再投简历。现阶段，辞不辞职都无所谓了（最好明天就把我裁了！！！大晚上10点群里@人是不是有病啊，又不是bug？？？？谁tm理你？？？！！！）\n1年多的Java现在真的狗都嫌，打算实在没有去处，6个月之后再考一次，反正本次刷题感觉还行，不是特别难。\n后续\n打算先刷点算法+八股了。实在不行啃点存款，反正还没辞职。。。\n","categories":["面试"],"tags":["面试","Java"]},{"title":"面试-数据结构和算法","url":"/2024/04/22/100000004/","content":"\n\n前言\n根据刷题记录，整理各个类型的特点\n\n\n更新\n\n\n24.04.22 初始记录 数组的总结24.05.23 链表的总结24.05.24 哈希表的总结24.05.29 字符串的总结（KMP）\n\n数据结构\n数组\n基础理论\n1、数组是存放在连续内存空间上的相同类型数据的集合。\n\n\n数组下标从0开始\n\n\n数组的内存空间地址连续\n\n\n2、因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。\n3、数组的元素是不能删的，只能覆盖。\n4、二维数组在内存的空间地址不连续\n经典题目\n二分法\n需要遵循循环不变量原则。这里的循环不变量原则在二分法中的表现就是，循环过程中左闭右开，这个规则是不变的。\n双指针法\n快慢指针法：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。\n双向指针法：一个指针从左向右一个指针从右向左。从左向右的找等于目标值的位置，从右向左找不等于目标的位置，每次找到一个用不等于覆盖等于。（就是自己第一次题解时的做法）\n滑动窗口\n动态更新窗口的大小，找到最优解。\n滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。\n模拟行为\n目前遇到的题型是螺旋矩阵。这类题目只要模拟数组需要执行的操作就行，需要注意边界值，遵循循环不变量原则。\n链表\n基础理论\n分类\n\n\n单链表\n指针域只能指向节点的下一个节点。\n\n\n双链表\n每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。\n\n\n循环链表\n链表首尾相连。\n\n\n存储方式\n数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。链表是通过指针域的指针链接在内存中各个节点。\n所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。\n链表的定义\npublic class ListNode &#123;      public int val;      public ListNode next;        public ListNode() &#123;      &#125;        public ListNode(int val) &#123;          this.val = val;      &#125;  &#125;\n链表操作\n删除节点\n将该节点跳过，前一节点指向后一节点。\n添加节点\n前一节点指向该节点，该节点指向后一节点。\n性能分析\n\n\n\n\n插入/删除（时间复杂度）\n查询（时间复杂度）\n适用场景\n\n\n\n\n数组\nO(n)\nO(1)\n数据量固定，频繁查询，较少增删\n\n\n链表\nO(1)\nO(n)\n数据量不固定，频繁增删，较少查询\n\n\n\n经典题目\n虚拟头节点\n链表中的增删操作，都是需要操作前一个节点进行指向。但是对于头节点的操作，由于没有前一个节点，每次都需要单独处理。因此使用虚拟头结点的技巧。（基本上做题都是加上虚拟节点比较方便）\n链表的基本操作\n\n\n获取链表第index个节点的数值\n\n\n在链表的最前面插入一个节点\n\n\n在链表的最后面插入一个节点\n\n\n在链表第index个节点前面插入一个节点\n\n\n删除链表的第index个节点的数值\n\n\n反转链表\n\n\n迭代法用双指针，改变两个节点之间的指针方向\n\n\n递归法和迭代法的思路基本一样，把移动下一步的操作放到递归里进行。\n\n\n两两交换链表中的节点\n这题也用到了虚拟头节点的方法。\n\n\n需要交换的两个节点的前一个节点，指向需要交换的第二个节点\n\n\n节点交换\n\n\n删除倒数第N个节点\n运用虚拟头节点+双指针。思路是，一个指针先走N步，然后两个指针一起向后。当快指针指向末尾时，慢指针的位置正好是倒数第N个节点。然后完成删除操作。\n链表相交\n这里的相交指的是引用完全相同，即：内存地址完全相同的交点\n环形链表\n\n\n判断是否有环\n\n\n判断交点位置这是一道数学题，具体解析在对应的文章中给出。\n\n\n哈希表\n基础理论\n定义\n哈希表是根据关键码的值而直接进行访问的数据结构。\n\n一般使用\n一般哈希表都是用来快速判断一个元素是否出现集合里。\n哈希函数/哈希碰撞\n哈希函数是把传入的key映射到符号表的索引上。\n哈希碰撞处理有多个key映射到相同索引上时的情景，处理碰撞的普遍方式是拉链法和线性探测法。\n常见的三种哈希结构\n\n\n数组\n\n\nset（集合）\n\n\nmap（映射）\n\n\n哈希表经典题目\n数组作为哈希表\n一般题目中出现规定map大小（比如明说都是小写字母），就可以使用数组。这些题用map确实可以，但使用map的空间消耗要比数组大一些，因为map要维护红黑树或者符号表，而且还要做哈希函数的运算。所以数组更加简单直接有效！\n关联题目：有效的字母异位词赎金信\nset作为哈希表\n如果题目没有限制大小，就无法使用数组。主要因为：\n\n\n数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。\n\n\n如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。关联题目：两个数组的交集快乐数\n\n\nmap作为哈希表\nset是一个集合，里面放的元素只能是一个key，但是遇到key与value都要保存时，就需要使用map。\n字符串\n基础理论\n定义\n字符串是若干字符组成的有限序列，也可以理解为是一个字符数组。\n字符串经典题目\n双指针\n双指针法在数组，链表和字符串中很常用。\n关联题目：反转字符串：只是简单使用temp作为中间变量。替换字符：数组填充类的问题，可以先预先给数组扩容带填充后的大小，然后再从后向前进行操作。\n与移除操作有关的双指针操作：翻转字符串内的单词中的移除空格部分。之前数组部分中移除数组元素\n反转系列\n反转就是双指针（头尾指针一起向中间移动，然后交换数组元素）关联题目：反转字符串II\n翻转字符串内的单词：这题的反转用了两次，先整体反转，再分段反转。右旋转字符串：和上题一样需要先局部反转再整体反转。（这种题笔试遇到直接API快一点）\nKMP\nKMP算法是字符串查找最重要的算法。\nKMP的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。\n关联题目：实现 strStr() 、重复的子字符串\n前缀表\n作用：前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。\n常见的基础题目是在文本串中查找一个模式串，例：在aabaabaafa中查找aabaaf。这个查找是文本串指针顺序后移（不变），活动模式串进行匹配。前缀表用于记录查找失败后，模式串下一次返回查找的点。例：文本串指针到第二个b时，查找失败，这时模式串从b这个位置重新查询。\n什么是前缀表？\n记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。\n最长公共前后缀\n前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。\n后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。这个部分暂时是比较好理解的。\n为什么使用前缀表可以告诉我们匹配失败之后跳到哪里重新匹配？\n\n这张图是教程内的图，下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。\n如何找到一张前缀表\n不是很能理解，但是背下来了\n// 需要找到前缀表的字符串String s;// 初始化int j = 0;int[] next = new int[s.length];for(int i = 1; i &lt; s.length, i++) &#123;\t// 不相同的情况\twhile(j != 0 &amp;&amp; s.charAt[i] != s.charAt[j]) &#123;\t\tj = next[j - 1];\t&#125;\tif(s.charAt[i] == s.charAt[j]) &#123;\t\tj++;\t&#125;\tnext[i] = j;&#125;\n","categories":["面试"],"tags":["面试","数组","双指针","滑动窗口","链表","#字符串","KMP","#哈希表"]},{"title":"MybatisPlus多表联查分页，Total计数异常","url":"/2024/04/19/100000004/","content":"\n\n更新\n\n\n24.04.19 初始记录\n\n问题\n使用MP的分表联查，出现了查询出10条数据，但是Total数量显示4的问题。一开始以为是SQL书写错误，但是看了同样一张表的另一个SQL，只是加上了GROUP BY，就可以显示正确的Total数。\nDEBUG\n控制台输出SQL语句，发现count()语句的记录只到了left join前，所以计数异常。\n解决\n使用page方法时：加上以下语句\n// 需要手动把sql的优化关闭。不然计数的时候只会查主表的记录数page.setOptimizeCountSql(false);  \n这里在源码中默认是开启的\n如果不关闭将会导致计算总记录数据的时候，sql语句会丢弃后面的子查询，造成记录数结果不正确。\n","categories":["bug记录","2024"],"tags":["Java","MybatisPlus","BUG"]},{"title":"RestTemplate使用GET请求，返回中文乱码","url":"/2024/05/23/100000004/","content":"\n\n更新\n\n\n24.05.23 初始记录\n\n问题\n测试 RestTemplate 的 Get 请求，返回中文乱码。\n原因\n当 RestTemplate 默认使用 String 存储 body 内容时默认使用 ISO_8859_1 字符集。\n解决\n配置 StringHttpMessageConverter 消息转换器，使用 utf-8 字符集。\n@Bean  public RestTemplate restTemplate() &#123;      RestTemplate restTemplate = new RestTemplate(new OkHttp3ClientHttpRequestFactory());      //消息转换器列表      List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = restTemplate.getMessageConverters();      //配置消息转换器StringHttpMessageConverter，并设置utf‐8      messageConverters.set(1, new StringHttpMessageConverter(StandardCharsets.UTF_8));      return restTemplate;  &#125;","categories":["bug记录","2024"],"tags":["Java","BUG","RestTemplate"]},{"title":"Spring Data Redis","url":"/2023/08/29/100000004/","content":"\n\n前言\nSpring Data Redis 是Spring 框架提供的用于操作Redis的方式。涵盖Redis的安装、Spring Cache结合Redis的使用、Redis连接池的使用和RedisTemplate的使用等内容。\n\n\n参考文章\nSpring Data Redis 最佳实践！\n\n\n更新\n\n\n23.08.29 初始记录\n\nRedis安装\nLinux\n\n\n下载Redis5.0的Docker镜像\n\n\ndocker pull redis:5.0\n\n\n使用Docker命令启动Redis容器\n\n\ndocker run -p 6379:6379 --name redis \\-v /mydata/redis/data:/data \\-d redis:5.0 redis-server --appendonly yes\nWindows\n\n\n下载Windows版本的Redis\n\n\n\n下载后直接解压\n\n\n在当前地址栏输入cmd命令，执行对应的redis启动命令\n\n\n# 注册服务redis-server --service-install redis.windows.conf# 启动服务redis-server --service-start# 停止服务redis-server --service-stop# 删除服务redis-server --service-uninstall\nSpring Cache 操作Redis\nSpring Cache 简介\n\n当Spring Boot 结合Redis来作为缓存使用时，最简单的方式就是使用Spring Cache了，使用它我们无需知道Spring中对Redis的各种操作，仅仅通过它提供的@Cacheable 、@CachePut 、@CacheEvict 、@EnableCaching等注解就可以实现缓存功能。\n\n常用注解\n@EnableCaching\n开启缓存功能，一般放在启动类上。\n@Cacheable\n使用该注解的方法当缓存存在时，会从缓存中获取数据而不执行方法，当缓存不存在时，会执行方法并把返回结果存入缓存中。一般使用在查询方法上，可以设置如下属性：\n\n\nvalue：缓存名称（必填），指定缓存的命名空间；\n\n\nkey：用于设置在命名空间中的缓存key值，可以使用SpEL表达式定义；\n\n\nunless：条件符合则不缓存；\n\n\ncondition：条件符合则缓存。\n\n\n@CachePut\n使用该注解的方法每次执行时都会把返回结果存入缓存中。一般使用在新增方法上，可以设置如下属性：\n\n\nvalue：缓存名称（必填），指定缓存的命名空间；\n\n\nkey：用于设置在命名空间中的缓存key值，可以使用SpEL表达式定义；\n\n\nunless：条件符合则不缓存；\n\n\ncondition：条件符合则缓存。\n\n\n@CacheEvict\n使用该注解的方法执行时会清空指定的缓存。一般使用在更新或删除方法上，可以设置如下属性：\n\n\nvalue：缓存名称（必填），指定缓存的命名空间；\n\n\nkey：用于设置在命名空间中的缓存key值，可以使用SpEL表达式定义；\n\n\ncondition：条件符合则缓存。\n\n\n使用步骤\n基础步骤\n\n\n在pom.xml中添加项目依赖：\n\n\n&lt;!--redis依赖配置--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n修改配置文件application.yml，添加Redis的连接配置\n\n\nspring:  redis:    host: 192.168.6.139 # Redis服务器地址    database: 0 # Redis数据库索引（默认为0）    port: 6379 # Redis服务器连接端口    password: # Redis服务器连接密码（默认为空）    timeout: 1000ms # 连接超时时间\n\n\n在启动类上添加@EnableCaching注解启动缓存功能\n\n\n@EnableCaching@SpringBootApplicationpublic class Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Application.class, args);    &#125;&#125;\n\n\n类中实现缓存功能\n\n\n/** * PmsBrandService实现类 * Created by macro on 2019/4/19. */@Servicepublic class PmsBrandServiceImpl implements PmsBrandService &#123;    @Autowired    private PmsBrandMapper brandMapper;    @CacheEvict(value = RedisConfig.REDIS_KEY_DATABASE, key = &quot;&#x27;pms:brand:&#x27;+#id&quot;)    @Override    public int update(Long id, PmsBrand brand) &#123;        brand.setId(id);        return brandMapper.updateByPrimaryKeySelective(brand);    &#125;    @CacheEvict(value = RedisConfig.REDIS_KEY_DATABASE, key = &quot;&#x27;pms:brand:&#x27;+#id&quot;)    @Override    public int delete(Long id) &#123;        return brandMapper.deleteByPrimaryKey(id);    &#125;    @Cacheable(value = RedisConfig.REDIS_KEY_DATABASE, key = &quot;&#x27;pms:brand:&#x27;+#id&quot;, unless = &quot;#result==null&quot;)    @Override    public PmsBrand getItem(Long id) &#123;        return brandMapper.selectByPrimaryKey(id);    &#125;&#125;\n存储JSON格式数据\n\n给RedisTemplate设置JSON格式的序列化器，并通过配置RedisCacheConfiguration设置超时时间来实现以上需求，此时还需要去除启动类上的@EnableCaching注解，具体配置类RedisConfig代码如下\n\n/** * Redis配置类 * Created by macro on 2020/3/2. */@EnableCaching@Configurationpublic class RedisConfig extends CachingConfigurerSupport &#123;    /**     * redis数据库自定义key     */    public  static final String REDIS_KEY_DATABASE=&quot;mall&quot;;    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;        RedisSerializer&lt;Object&gt; serializer = redisSerializer();        RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();        redisTemplate.setConnectionFactory(redisConnectionFactory);        redisTemplate.setKeySerializer(new StringRedisSerializer());        redisTemplate.setValueSerializer(serializer);        redisTemplate.setHashKeySerializer(new StringRedisSerializer());        redisTemplate.setHashValueSerializer(serializer);        redisTemplate.afterPropertiesSet();        return redisTemplate;    &#125;    @Bean    public RedisSerializer&lt;Object&gt; redisSerializer() &#123;        //创建JSON序列化器        Jackson2JsonRedisSerializer&lt;Object&gt; serializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class);        ObjectMapper objectMapper = new ObjectMapper();        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        serializer.setObjectMapper(objectMapper);        return serializer;    &#125;    @Bean    public RedisCacheManager redisCacheManager(RedisConnectionFactory redisConnectionFactory) &#123;        RedisCacheWriter redisCacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory);        //设置Redis缓存有效期为1天        RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig()                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer())).entryTtl(Duration.ofDays(1));        return new RedisCacheManager(redisCacheWriter, redisCacheConfiguration);    &#125;&#125;\n使用Redis连接池\n\nSpringBoot 1.5.x版本Redis客户端默认是Jedis实现的，SpringBoot 2.x版本中默认客户端是用Lettuce实现的，我们先来了解下Jedis和Lettuce客户端。\n\nJedis vs Lettuce\nJedis在实现上是直连Redis服务，多线程环境下非线程安全，除非使用连接池，为每个 RedisConnection 实例增加物理连接。\nLettuce是一种可伸缩，线程安全，完全非阻塞的Redis客户端，多个线程可以共享一个RedisConnection，它利用Netty NIO框架来高效地管理多个连接，从而提供了异步和同步数据访问方式，用于构建非阻塞的反应性应用程序。\n使用步骤\n\n\n修改application.yml添加Lettuce连接池配置，用于配置线程数量和阻塞等待时间\n\n\nspring:  redis:    lettuce:      pool:        max-active: 8 # 连接池最大连接数        max-idle: 8 # 连接池最大空闲连接数        min-idle: 0 # 连接池最小空闲连接数        max-wait: -1ms # 连接池最大阻塞等待时间，负值表示没有限制\n\n\n由于SpringBoot 2.x中默认并没有使用Redis连接池，所以需要在pom.xml中添加commons-pool2的依赖\n\n\n&lt;dependency&gt;    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n不添加依赖则报错\n\n\nCaused by: java.lang.NoClassDefFoundError: org/apache/commons/pool2/impl/GenericObjectPoolConfig\tat org.springframework.data.redis.connection.lettuce.LettucePoolingClientConfiguration$LettucePoolingClientConfiguYrRUIQWOPrationBuilder.&lt;init&gt;(LettucePoolingClientConfiguration.java:84) ~[spring-data-redis-2.1.5.RELEASE.jar:2.1.5.RELEASE]\tat org.springframework.data.redis.connection.lettuce.LettucePoolingClientConfiguration.builder(LettucePoolingClientConfiguration.java:48) ~[spring-data-redis-2.1.5.RELEASE.jar:2.1.5.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration$PoolBuilderFactory.createBuilder(LettuceConnectionConfiguration.java:149) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration.createBuilder(LettuceConnectionConfiguration.java:107) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration.getLettuceClientConfiguration(LettuceConnectionConfiguration.java:93) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration.redisConnectionFactory(LettuceConnectionConfiguration.java:74) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration$$EnhancerBySpringCGLIB$$5caa7e47.CGLIB$redisConnectionFactory$0(&lt;generated&gt;) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration$$EnhancerBySpringCGLIB$$5caa7e47$$FastClassBySpringCGLIB$$b8ae2813.invoke(&lt;generated&gt;) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:244) ~[spring-core-5.1.5.RELEASE.jar:5.1.5.RELEASE]\tat org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:363) ~[spring-context-5.1.5.RELEASE.jar:5.1.5.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration$$EnhancerBySpringCGLIB$$5caa7e47.redisConnectionFactory(&lt;generated&gt;) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_91]\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_91]\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_91]\tat java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_91]\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\t... 111 common frames omitted\n自由操作Redis\n\n使用RedisTemplate自由缓存方法中产生的中间值\n\nRedisService\n/** * redis操作Service * Created by macro on 2020/3/3. */public interface RedisService &#123;    /**     * 保存属性     */    void set(String key, Object value, long time);    /**     * 保存属性     */    void set(String key, Object value);    /**     * 获取属性     */    Object get(String key);    /**     * 删除属性     */    Boolean del(String key);    /**     * 批量删除属性     */    Long del(List&lt;String&gt; keys);    /**     * 设置过期时间     */    Boolean expire(String key, long time);    /**     * 获取过期时间     */    Long getExpire(String key);    /**     * 判断是否有该属性     */    Boolean hasKey(String key);    /**     * 按delta递增     */    Long incr(String key, long delta);    /**     * 按delta递减     */    Long decr(String key, long delta);    /**     * 获取Hash结构中的属性     */    Object hGet(String key, String hashKey);    /**     * 向Hash结构中放入一个属性     */    Boolean hSet(String key, String hashKey, Object value, long time);    /**     * 向Hash结构中放入一个属性     */    void hSet(String key, String hashKey, Object value);    /**     * 直接获取整个Hash结构     */    Map&lt;Object, Object&gt; hGetAll(String key);    /**     * 直接设置整个Hash结构     */    Boolean hSetAll(String key, Map&lt;String, Object&gt; map, long time);    /**     * 直接设置整个Hash结构     */    void hSetAll(String key, Map&lt;String, Object&gt; map);    /**     * 删除Hash结构中的属性     */    void hDel(String key, Object... hashKey);    /**     * 判断Hash结构中是否有该属性     */    Boolean hHasKey(String key, String hashKey);    /**     * Hash结构中属性递增     */    Long hIncr(String key, String hashKey, Long delta);    /**     * Hash结构中属性递减     */    Long hDecr(String key, String hashKey, Long delta);    /**     * 获取Set结构     */    Set&lt;Object&gt; sMembers(String key);    /**     * 向Set结构中添加属性     */    Long sAdd(String key, Object... values);    /**     * 向Set结构中添加属性     */    Long sAdd(String key, long time, Object... values);    /**     * 是否为Set中的属性     */    Boolean sIsMember(String key, Object value);    /**     * 获取Set结构的长度     */    Long sSize(String key);    /**     * 删除Set结构中的属性     */    Long sRemove(String key, Object... values);    /**     * 获取List结构中的属性     */    List&lt;Object&gt; lRange(String key, long start, long end);    /**     * 获取List结构的长度     */    Long lSize(String key);    /**     * 根据索引获取List中的属性     */    Object lIndex(String key, long index);    /**     * 向List结构中添加属性     */    Long lPush(String key, Object value);    /**     * 向List结构中添加属性     */    Long lPush(String key, Object value, long time);    /**     * 向List结构中批量添加属性     */    Long lPushAll(String key, Object... values);    /**     * 向List结构中批量添加属性     */    Long lPushAll(String key, Long time, Object... values);    /**     * 从List结构中移除属性     */    Long lRemove(String key, long count, Object value);&#125;\nRedisServiceImpl\n/** * redis操作实现类 * Created by macro on 2020/3/3. */@Servicepublic class RedisServiceImpl implements RedisService &#123;    @Autowired    private RedisTemplate&lt;String, Object&gt; redisTemplate;    @Override    public void set(String key, Object value, long time) &#123;        redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);    &#125;    @Override    public void set(String key, Object value) &#123;        redisTemplate.opsForValue().set(key, value);    &#125;    @Override    public Object get(String key) &#123;        return redisTemplate.opsForValue().get(key);    &#125;    @Override    public Boolean del(String key) &#123;        return redisTemplate.delete(key);    &#125;    @Override    public Long del(List&lt;String&gt; keys) &#123;        return redisTemplate.delete(keys);    &#125;    @Override    public Boolean expire(String key, long time) &#123;        return redisTemplate.expire(key, time, TimeUnit.SECONDS);    &#125;    @Override    public Long getExpire(String key) &#123;        return redisTemplate.getExpire(key, TimeUnit.SECONDS);    &#125;    @Override    public Boolean hasKey(String key) &#123;        return redisTemplate.hasKey(key);    &#125;    @Override    public Long incr(String key, long delta) &#123;        return redisTemplate.opsForValue().increment(key, delta);    &#125;    @Override    public Long decr(String key, long delta) &#123;        return redisTemplate.opsForValue().increment(key, -delta);    &#125;    @Override    public Object hGet(String key, String hashKey) &#123;        return redisTemplate.opsForHash().get(key, hashKey);    &#125;    @Override    public Boolean hSet(String key, String hashKey, Object value, long time) &#123;        redisTemplate.opsForHash().put(key, hashKey, value);        return expire(key, time);    &#125;    @Override    public void hSet(String key, String hashKey, Object value) &#123;        redisTemplate.opsForHash().put(key, hashKey, value);    &#125;    @Override    public Map&lt;Object, Object&gt; hGetAll(String key) &#123;        return redisTemplate.opsForHash().entries(key);    &#125;    @Override    public Boolean hSetAll(String key, Map&lt;String, Object&gt; map, long time) &#123;        redisTemplate.opsForHash().putAll(key, map);        return expire(key, time);    &#125;    @Override    public void hSetAll(String key, Map&lt;String, Object&gt; map) &#123;        redisTemplate.opsForHash().putAll(key, map);    &#125;    @Override    public void hDel(String key, Object... hashKey) &#123;        redisTemplate.opsForHash().delete(key, hashKey);    &#125;    @Override    public Boolean hHasKey(String key, String hashKey) &#123;        return redisTemplate.opsForHash().hasKey(key, hashKey);    &#125;    @Override    public Long hIncr(String key, String hashKey, Long delta) &#123;        return redisTemplate.opsForHash().increment(key, hashKey, delta);    &#125;    @Override    public Long hDecr(String key, String hashKey, Long delta) &#123;        return redisTemplate.opsForHash().increment(key, hashKey, -delta);    &#125;    @Override    public Set&lt;Object&gt; sMembers(String key) &#123;        return redisTemplate.opsForSet().members(key);    &#125;    @Override    public Long sAdd(String key, Object... values) &#123;        return redisTemplate.opsForSet().add(key, values);    &#125;    @Override    public Long sAdd(String key, long time, Object... values) &#123;        Long count = redisTemplate.opsForSet().add(key, values);        expire(key, time);        return count;    &#125;    @Override    public Boolean sIsMember(String key, Object value) &#123;        return redisTemplate.opsForSet().isMember(key, value);    &#125;    @Override    public Long sSize(String key) &#123;        return redisTemplate.opsForSet().size(key);    &#125;    @Override    public Long sRemove(String key, Object... values) &#123;        return redisTemplate.opsForSet().remove(key, values);    &#125;    @Override    public List&lt;Object&gt; lRange(String key, long start, long end) &#123;        return redisTemplate.opsForList().range(key, start, end);    &#125;    @Override    public Long lSize(String key) &#123;        return redisTemplate.opsForList().size(key);    &#125;    @Override    public Object lIndex(String key, long index) &#123;        return redisTemplate.opsForList().index(key, index);    &#125;    @Override    public Long lPush(String key, Object value) &#123;        return redisTemplate.opsForList().rightPush(key, value);    &#125;    @Override    public Long lPush(String key, Object value, long time) &#123;        Long index = redisTemplate.opsForList().rightPush(key, value);        expire(key, time);        return index;    &#125;    @Override    public Long lPushAll(String key, Object... values) &#123;        return redisTemplate.opsForList().rightPushAll(key, values);    &#125;    @Override    public Long lPushAll(String key, Long time, Object... values) &#123;        Long count = redisTemplate.opsForList().rightPushAll(key, values);        expire(key, time);        return count;    &#125;    @Override    public Long lRemove(String key, long count, Object value) &#123;        return redisTemplate.opsForList().remove(key, count, value);    &#125;&#125;\nRedisController\n\n简单测试在Controller中进行操作\n\n/** * Redis测试Controller * Created by macro on 2020/3/3. */@Api(tags = &quot;RedisController&quot;, description = &quot;Redis测试&quot;)@Controller@RequestMapping(&quot;/redis&quot;)public class RedisController &#123;    @Autowired    private RedisService redisService;    @Autowired    private PmsBrandService brandService;    @ApiOperation(&quot;测试简单缓存&quot;)    @RequestMapping(value = &quot;/simpleTest&quot;, method = RequestMethod.GET)    @ResponseBody    public CommonResult&lt;PmsBrand&gt; simpleTest() &#123;        List&lt;PmsBrand&gt; brandList = brandService.list(1, 5);        PmsBrand brand = brandList.get(0);        String key = &quot;redis:simple:&quot; + brand.getId();        redisService.set(key, brand);        PmsBrand cacheBrand = (PmsBrand) redisService.get(key);        return CommonResult.success(cacheBrand);    &#125;    @ApiOperation(&quot;测试Hash结构的缓存&quot;)    @RequestMapping(value = &quot;/hashTest&quot;, method = RequestMethod.GET)    @ResponseBody    public CommonResult&lt;PmsBrand&gt; hashTest() &#123;        List&lt;PmsBrand&gt; brandList = brandService.list(1, 5);        PmsBrand brand = brandList.get(0);        String key = &quot;redis:hash:&quot; + brand.getId();        Map&lt;String, Object&gt; value = BeanUtil.beanToMap(brand);        redisService.hSetAll(key, value);        Map&lt;Object, Object&gt; cacheValue = redisService.hGetAll(key);        PmsBrand cacheBrand = BeanUtil.mapToBean(cacheValue, PmsBrand.class, true);        return CommonResult.success(cacheBrand);    &#125;    @ApiOperation(&quot;测试Set结构的缓存&quot;)    @RequestMapping(value = &quot;/setTest&quot;, method = RequestMethod.GET)    @ResponseBody    public CommonResult&lt;Set&lt;Object&gt;&gt; setTest() &#123;        List&lt;PmsBrand&gt; brandList = brandService.list(1, 5);        String key = &quot;redis:set:all&quot;;        redisService.sAdd(key, (Object[]) ArrayUtil.toArray(brandList, PmsBrand.class));        redisService.sRemove(key, brandList.get(0));        Set&lt;Object&gt; cachedBrandList = redisService.sMembers(key);        return CommonResult.success(cachedBrandList);    &#125;    @ApiOperation(&quot;测试List结构的缓存&quot;)    @RequestMapping(value = &quot;/listTest&quot;, method = RequestMethod.GET)    @ResponseBody    public CommonResult&lt;List&lt;Object&gt;&gt; listTest() &#123;        List&lt;PmsBrand&gt; brandList = brandService.list(1, 5);        String key = &quot;redis:list:all&quot;;        redisService.lPushAll(key, (Object[]) ArrayUtil.toArray(brandList, PmsBrand.class));        redisService.lRemove(key, 1, brandList.get(0));        List&lt;Object&gt; cachedBrandList = redisService.lRange(key, 0, 3);        return CommonResult.success(cachedBrandList);    &#125;&#125;","categories":["后端项目","准备工作"],"tags":["Redis","Spring"]},{"title":"聚合支付-项目介绍","url":"/2024/05/15/100000004/","content":"\n\n前言\n之前的项目已经接触了支付宝、微信、银联三种支付方式了。正好辞职把这个项目写一遍，看了技术栈有一些是没有接触过的，应该能学到很多。\n项目git地址：https://gitee.com/kiml_rgb/shanjupay.git\n前端项目地址：https://gitee.com/kiml_rgb/shanjupay_web\n\n\n更新\n\n\n24.05.16 初始记录（抄了一些项目描述）\n\n项目概述\n聚合支付目前主要的做法就是线上聚合收银台(开放API)，线下C2B一码多付、线下B2C商家扫码。平台应以SaaS服务形式提供给各商户订单管理、门店管理、财务数据统计等基础服务，闪聚支付还以支付为入口，通过广告、营销、金融等服务，构建一个移动支付的全生态系统。\n功能模块\n平台主要包括三个模块：官网&amp;开放平台、商户平台、运营平台，详细功能如下：\n\n\n\n\n功能模块名称\n功能说明\n\n\n\n\n官网&amp;开放平台\n产品展示、功能介绍、帮助中心和开发者中心\n\n\n商户平台-首页\n提供商户注册、登录、基本信息查看、数据看板\n\n\n商户平台-账户管理\n提供商户企业资质认证、企业信息查看和套餐购买\n\n\n商户平台-支付管理\n为商户提供应用创建、渠道参数配置、交易总览和开启支付(生成二维码)等\n\n\n商户平台-门店管理\n为商户提供新增门店、店长分配、门店导入等\n\n\n商户平台-员工管理\n为商户提供新增员工、定义角色、分配角色等\n\n\n商户平台-优惠管理\n为商户提供优惠券管理、活动统计等\n\n\n运营平台-商户管理\n对商户进行检索、审核和订单统计\n\n\n运营平台-优惠管理\n为商户设置优惠策略和优惠券发送\n\n\n运营平台-管理员管理\n运营平台-管理员管理\n\n\n\n业务主体流程\n\n项目技术架构\n技术架构\n\n技术栈\n\n重点了解微服务技术栈：服务端基于Spring Boot构建，采用Spring Cloud Alibaba微服务架构。\n\n\n基础设施业务数据持久化采用MySQL，数据缓存采用Redis，采用RocketMQ的事务消息机制完成部分场景下的分布式事务控制，采用第三方云平台完成文件上传与分布式存储。\n\n\n组件系统微服务基于SpringBoot开发，数据库连接池采用Druid，POJO构建采用Lombok，日志系统采用Log4j2， Guava工具类库，Mybatis Plus持久层接口实现，Sharding-jdbc分库分表组件，Swagger接口规范组件，XXL-job 分布式任务调度组件，Sentinel限流组件等。\n\n\n接入 Zuul网关完成客户端认证、路由转发等功能，Dubbo RPC完成微服务远程调用，JWT提供前后端令牌管理方案。\n\n\n视图平台支持H5、PC等各种前端。\n\n\n","categories":["后端项目","聚合支付"],"tags":["Java"]},{"title":"聚合支付-环境搭建","url":"/2024/05/16/100000004/","content":"\n\n前言\n环境搭建先是在windows本机上，后面听说在windows上可以下载docker，所以会补充windows上的docker内的环境安装。\n\n\n更新\n\n\n24.05.16 初始记录（windows系统的环境安装）\n\n服务端搭建\n开发环境\nJava 1.8 这个网上教程很多，就不赘述了。\nMaven 使用本地仓库，可配置下载镜像路径。\nNacos服务发现与配置中心\n微服务开发需要构建服务发现中心、配置中心，本项目采用Nacos来实现。可以直接导入项目nacos文件夹下面的配置文件。注意需要新建命名空间，并修改配置文件中的命名空间变量。\nMybatis Plus\n本项目数据库使用 mysql-community-5.7，请自行安装MySQL数据库。本项目持久层采用Mybatis Plus作为技术构架，Mybatis Plus是在Mybatis基础上作了很好的封装，方便系统开 发。\n导入项目SQL\n使用客户端连接MySQL，执行项目sql文件夹下面的shanjupay-init.sql文件。数据库清单如下：\n\n\n\n数据库名称\n数据内容\n\n\n\n\nshanjupay_merchant_service\n用户中心数据\n\n\nshanjupay_transaction\n交易服务数据库\n\n\n\n\n\n\n\n搭建项目服务\n\n\n\n服务名\n职责\n\n\n\n\n\n商户平台应用(shanjupay-merchant-application)\n为前端提供商户管理功能\n\n\n\n商户服务API(shanjupay-merchant-api)\n实现商户服务提供的接口\n\n\n\n商户服务(shanjupay-merchant-service)\n实现商户服务的所有接口\n\n\n\n工程在架构中的位置如下：\n\n\n\n\n\n\n\n\n\n\n","categories":["后端项目","聚合支付"],"tags":["Java"]},{"title":"代码随想录算法训练营第一天-704二分查找、27移除元素","url":"/2024/04/17/100000004/","content":"\n\n前言\n状态：可以通过\n\n\n更新\n\n\n24.04.17 初始记录\n\n初步题解\n704二分查找\n题目链接：https://leetcode.cn/problems/binary-search/\npublic class LE704 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          int[] nums = Arrays.stream(scanner.nextLine().split(&quot;,&quot;))                  .mapToInt(Integer::parseInt)                  .toArray();          int target = Integer.parseInt(scanner.nextLine());          System.out.println(search(nums, target));      &#125;        public static int search(int[] nums, int target) &#123;          for (int i = 0, j = nums.length - 1; i &lt;= j; ) &#123;              int k = (i + j) / 2;              if (nums[k] == target) &#123;                  return k;              &#125;              if (nums[k] &gt; target) &#123;                  j = k - 1;              &#125; else &#123;                  i = k + 1;              &#125;          &#125;            return -1;      &#125;  &#125;\n27移除元素\n题目链接：https://leetcode.cn/problems/remove-element/\npublic class LE27 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          int[] nums = Arrays.stream(scanner.nextLine().split(&quot;,&quot;))                  .mapToInt(Integer::parseInt)                  .toArray();          int val = Integer.parseInt(scanner.nextLine());          System.out.println(removeElement(nums, val));      &#125;        public static int removeElement(int[] nums, int val) &#123;          int i, j;          for (i = 0, j = nums.length - 1; i &lt;= j ; ) &#123;              // 第一次修改 -&gt; if改为while              // 第三次修改 -&gt; 加上j的边界值限制, 不然会数组越界              while (j &gt;= 0 &amp;&amp; nums[j] == val) &#123;                  j--;              &#125;              while (i &lt;= nums.length - 1 &amp;&amp; nums[i] != val) &#123;                  i++;              &#125;              // 第二次修改 -&gt; 加上i &lt; j的判断, 否则最后一次交换会把数组换乱              if (i &lt; j) &#123;                  int temp = nums[j];                  nums[j] = nums[i];                  nums[i] = temp;              &#125;          &#125;          return i;      &#125;  &#125;\n看讲解\n704二分查找\n文章讲解：https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html\n视频讲解：https://www.bilibili.com/video/BV1fA4y1o715\npublic static int search(int[] nums, int target) &#123;      for (int i = 0, j = nums.length - 1; i &lt;= j; ) &#123; \t    // 这里需要写成这种方式防止整数溢出\t    // 或者也可以写成 int k = i + ((j - i) &gt;&gt; 1);\t    int k = i + (j - i) / 2;        // int k = (i + j) / 2;          if (nums[k] == target) &#123;              return k;          &#125;          if (nums[k] &gt; target) &#123;              j = k - 1;          &#125; else &#123;              i = k + 1;          &#125;      &#125;      return -1;  &#125;\n27移除元素\n文章讲解：https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html\n视频讲解：https://www.bilibili.com/video/BV12A4y1Z7LP\n其实。。一开始看题目我没有反应过来暴力解法是什么。第一时间当然是想到iterator().remove()，但是不行。老实说，那个题目里的O(1)额外空间我也不知道怎么算的。暴力解法是双层循环，删除之后的所有都前移。双指针和我想的也完全不一样，我也不知道我写的这个叫什么。。\npublic static int removeElement(int[] nums, int val) &#123;      int i = 0;      for (int j = 0; j &lt; nums.length; j++) &#123;\t    // 当 val == nums[j]时，只有j++\t    // 下一次不相等时，前一个指针的后一位直接指向当前的j，相当于中间的元素都被删除了。        if (val != nums[j]) &#123;              nums[i++]= nums[j];          &#125;      &#125;      return i;  &#125;\n总结\n其实都属于已经知道题解方式再去看题，加上是简单算法，所以感觉难度不是很大。（也可能我只是为了找工作，对我来说解出来就OK）\n二分查找\n前提：\n1、有序数组\n2、数组中无重复元素注意：整数数值越界的问题\n","categories":["面试","代码随想录"],"tags":["数组","二分查找","双指针"]},{"title":"代码随想录算法训练营第二天-977有序数组的平方、209长度最小的子数组、59螺旋矩阵II","url":"/2024/04/18/100000005/","content":"\n\n前言\n状态：977、209通过。59没有思路\n\n\n更新\n\n\n24.04.18 初始记录24.04.21 补充螺旋矩阵的题解\n\n初步题解\n977有序数组的平方\n题目链接：https://leetcode.cn/problems/squares-of-a-sorted-array/\npublic class LE977 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          String s = scanner.nextLine();          int[] nums = Arrays.stream(s.substring(1, s.length() - 1).split(&quot;,&quot;))                  .mapToInt(Integer::parseInt)                  .toArray();          System.out.println(Arrays.toString(sortedSquares(nums)));      &#125;  \t// 关键在于非递增顺序，获取平方数，组成新的非递增序列\t// 新数组的最大数一定来自于旧数组的两端。平方的大小一定从两边向中间递减\t// 用双指针，依次将最大值添加到新数组，并向内移动    public static int[] sortedSquares(int[] nums) &#123;          int i = 0;          int j = nums.length - 1;          int k = nums.length - 1;          int[] ints = new int[nums.length];            while (i &lt;= j) &#123;              int i2 = nums[i] * nums[i];              int j2 = nums[j] * nums[j];              ints[k] = Math.max(i2, j2);              k--;              if (i2 &gt;= j2) &#123;                  i++;              &#125; else &#123;                  j--;              &#125;          &#125;        return ints;      &#125;  &#125;\n209长度最小的子数组\n题目链接：https://leetcode.cn/problems/minimum-size-subarray-sum/\npublic class LE209 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          int target = Integer.parseInt(scanner.nextLine());          String s = scanner.nextLine();          int[] nums = Arrays.stream(s.substring(1, s.length() - 1).split(&quot;,&quot;))                  .mapToInt(Integer::parseInt)                  .toArray();          System.out.println(minSubArrayLen(target, nums));      &#125;  \t// 看题就知道是滑动窗口，前几天刚好做过    public static int minSubArrayLen(int target, int[] nums) &#123;          int min = 0;          for (int i = 0, j = 0; i &lt; nums.length &amp;&amp; j &lt; nums.length; ) &#123;              int subArraySum = getSum(nums, i, j);              if (target == subArraySum) &#123;                  min = Math.min(min, j - i + 1);                  i++;                  j = i;                  if (min == 1) &#123;                      break;                  &#125;              &#125; else if (target &lt; subArraySum) &#123;                  i++;                  j = i;              &#125; else &#123;                  j++;              &#125;          &#125;          return min;      &#125;        private static int getSum(int[] nums, int i, int j) &#123;          int sum = 0;          for (int k = i; k &lt;= j; k++) &#123;              sum += nums[k];          &#125;          return sum;      &#125;  &#125;\n59螺旋矩阵II\n题目链接：https://leetcode.cn/problems/spiral-matrix-ii/\n// 看了题目没有什么算法上的思路，打算直接看题解\n看讲解\n977有序数组的平方\n文章讲解：https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html\n视频讲解： https://www.bilibili.com/video/BV1QB4y1D7ep\n// 这里的题解和我的想法差不多，就不多写了\n209长度最小的子数组\n文章讲解：https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html\n视频讲解：https://www.bilibili.com/video/BV1tZ4y1q7XE\n还有一个进阶的解法，打算明天再看看，不能再熬夜了。\n// 这里的题解和我的想法差不多，就不多写了// 进阶部分等之后有时间了补充\n59螺旋矩阵II\n文章讲解：https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html\n视频讲解：https://www.bilibili.com/video/BV1SL4y1N7mV/\n// 大致看了文章讲解，就是把四条边按规律读出。// 没有看答案，按讲解写了一个版本，但是很奇怪，输出的xy和我想象中的不一样// 打了断点才发现，二维数组的表现和坐标不一样。public class LE59 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          int n = Integer.parseInt(scanner.nextLine());          System.out.println(Arrays.deepToString(generateMatrix(n)));      &#125;        public static int[][] generateMatrix(int n) &#123;          int[][] ints = new int[n][n];          int startX = 0;          int startY = 0;          int k = 1;          int loop = 1;          int i, j;          // 这边需要加上边界条件        while (k &lt;= n * n &amp;&amp; loop &lt;= n / 2) &#123;              for (i = startX; i &lt; n - loop; i++) &#123;                  ints[i][startY] = k++;              &#125;              for (j = startY; j &lt; n - loop; j++) &#123;                  ints[i][j] = k++;              &#125;              for (; i &gt; startX; i--) &#123;                  ints[i][j] = k++;              &#125;              for (; j &gt; startY ; j--) &#123;                  ints[i][j] = k++;              &#125;              startX++;              startY++;              loop++;          &#125;          // 奇数矩阵需要特殊处理        if (n % 2 == 1) &#123;              ints[startX][startY] = k;          &#125;          return ints;      &#125;  &#125;// 重新按二维数组的写法写了一遍。这个需要加到总结中// 二位数组中：j才是横坐标，i是纵坐标public static int[][] generateMatrix(int n) &#123;      int[][] ints = new int[n][n];      int startX = 0;      int startY = 0;      int k = 1;      int loop = 1;      int i, j;        while (k &lt;= n * n &amp;&amp; loop &lt;= n / 2) &#123;          for (j = startY; j &lt; n - loop; j++) &#123;              ints[startX][j] = k++;          &#125;          for (i = startX; i &lt; n - loop; i++) &#123;              ints[i][j] = k++;          &#125;          for (; j &gt; startY ; j--) &#123;              ints[i][j] = k++;          &#125;          for (; i &gt; startX; i--) &#123;              ints[i][j] = k++;          &#125;          startX++;          startY++;          loop++;      &#125;      if (n % 2 == 1) &#123;          ints[startX][startY] = k;      &#125;      return ints;  &#125;\n","categories":["面试","代码随想录"],"tags":["数组","双指针","滑动窗口","螺旋数组"]},{"title":"代码随想录算法训练营第三天-203移除链表元素、707设计链表、206反转链表","url":"/2024/04/24/100000005/","content":"\n\n前言\n状态：链表定义有点不会，基本上是都是看了一半图解后写出来的，而且耗时比较长，可能二刷会好一点吧。\n\n\n更新\n\n\n24.04.24 初始记录24.05.15 完成题目\n\n初步题解\n203移除链表元素\n题目链接：https://leetcode.cn/problems/remove-linked-list-elements/description/\n刚开始看到有点懵，习惯了写输入输出，这里不知道怎么输入了。链表这块需要先初始化链表。没有写出来后面是查看了解析。在具体方法那里，一直尝试只用一个链表做操作，但是运行总是得不到想要的结果。\npublic class LE203 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          String s = scanner.nextLine();          if (&quot;&quot;.equals(s.trim())) &#123;              System.out.println(new LinkedList());              return;          &#125;          List&lt;Integer&gt; head = Arrays.stream(s.split(&quot;,&quot;)).map(Integer::parseInt).collect(Collectors.toList());          int val = Integer.parseInt(scanner.nextLine());            // 初始化链表          LinkedList linkedList = new LinkedList();          for (Integer integer : head) &#123;              linkedList.add(integer);          &#125;              ListNode listNode = removeElements(linkedList.head, val);          System.out.println(listNode);      &#125;  \t// 一开始只能写成这个样子    public static ListNode removeElements(ListNode head, int val) &#123;  \t\twhile (head != null &amp;&amp; head.val == val) &#123;  \t\t    head = head.next;  \t\t&#125;  \t\t  \t\tif (head == null) &#123;  \t\t    return head;  \t\t&#125;    &#125;        /**       * 链表的定义       */      public static class ListNode &#123;          int val;          ListNode next;            ListNode() &#123;          &#125;            ListNode(int val) &#123;              this.val = val;          &#125;            ListNode(int val, ListNode next) &#123;              this.val = val;              this.next = next;          &#125;      &#125;        public static class LinkedList &#123;          private ListNode head;            public ListNode getHead() &#123;              return head;          &#125;            public void setHead(ListNode head) &#123;              this.head = head;          &#125;            public ListNode getCurrent() &#123;              return current;          &#125;            public void setCurrent(ListNode current) &#123;              this.current = current;          &#125;            private ListNode current;            public void add(int val) &#123;              if (head == null) &#123;                  head = new ListNode(val);                  current = head;              &#125; else &#123;                  current.next = new ListNode(val);                  current = current.next;              &#125;          &#125;      &#125;  &#125;\n707设计链表\n题目链接：https://leetcode.cn/problems/design-linked-list/description/\n修修改改了很久才通过，要考虑头节点，尾节点。\npublic class LE707 &#123;      public static void main(String[] args) &#123;          MyLinkedList myLinkedList = new MyLinkedList();          myLinkedList.addAtHead(1);          myLinkedList.addAtTail(3);          // 链表变为 1-&gt;2-&gt;3        myLinkedList.addAtIndex(1, 2);          // 返回 2        myLinkedList.get(1);          // 现在，链表变为 1-&gt;3        myLinkedList.deleteAtIndex(1);          // 返回 3        myLinkedList.get(1);      &#125;        public static class ListNode &#123;          private int val;          private ListNode next;            public ListNode() &#123;          &#125;            public ListNode(int val) &#123;              this.val = val;          &#125;      &#125;        public static class MyLinkedList &#123;          private int size;          private ListNode head;            public MyLinkedList() &#123;              size = 0;              head = new ListNode(0);          &#125;            public int get(int index) &#123;              if (index &lt;= -1 || index &gt;= size) &#123;                  return -1;              &#125;                ListNode indexNode = head;              for (int i = 0; i &lt; index; i++) &#123;                  indexNode = indexNode.next;              &#125;                return indexNode.val;          &#125;            public void addAtHead(int val) &#123;              if (size == 0) &#123;                  size++;                  head = new ListNode(val);                  return;              &#125;              addAtIndex(0, val);          &#125;            public void addAtTail(int val) &#123;              addAtIndex(size, val);          &#125;            public void addAtIndex(int index, int val) &#123;              if (index &gt; size) &#123;                  return;              &#125;                if (index &lt; 0) &#123;                  index = 0;              &#125;                ListNode pre = head;              // 找到前一个节点的位置              for (int i = 0; i &lt; index - 1; i++) &#123;                  pre = pre.next;              &#125;                ListNode listNode = new ListNode(val);              // 如果插入节点为头节点              if (index == 0) &#123;                  listNode.next = pre;                  head = listNode;                  // 长度++                  size++;                  return;              &#125;              // 如果插入位置正好是尾节点 直接前节点指向这个节点 然后return              if (index == size) &#123;                  pre.next = listNode;                  // 长度++                  size++;                  return;              &#125;                // 否则              // 先把当前节点的后指针指向前节点的next              listNode.next = pre.next;              // 再把前节点的后指针指向当前节点              pre.next = listNode;              // 长度++              size++;          &#125;            public void deleteAtIndex(int index) &#123;              if (index &gt;= size || index &lt; 0) &#123;                  return;              &#125;                ListNode pre = head;              for (int i = 0; i &lt; index - 1; i++) &#123;                  pre = pre.next;              &#125;              // 如果删除节点为头节点              if (index == 0) &#123;                  head = head.next;                  size--;                  return;              &#125;              // 如果删除位置正好是尾节点 直接前节点指向null 然后return              if (index + 1 == size) &#123;                  pre.next = null;                  // 长度++                  size--;                  return;              &#125;              // 改变当前节点的前节点的后指针，指向下一个节点              pre.next = pre.next.next;              // 长度--              size--;          &#125;      &#125;  &#125;\n206反转链表\n题目链接：https://leetcode.cn/problems/reverse-linked-list/description/\n偷偷看了下视频图解，按这个思路写的代码：还是比较简单的\n\npublic static LE707.ListNode reverseList(LE707.ListNode head) &#123;      LE707.ListNode pre = null;      LE707.ListNode cur = head;      while (cur != null) &#123;          LE707.ListNode temp = cur.next;          cur.next = pre;          pre = cur;          cur = temp;      &#125;        return pre;  &#125;\n看讲解\n203移除链表元素\n题目链接/文章讲解/视频讲解：：https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html\n// 一开始没有搞懂，前面一个循环是用来干什么的。// 但是去除前面一步，执行[7,7,7,7] 7 这个用例会多出一个7public static ListNode removeElements(ListNode head, int val) &#123;      while (head != null &amp;&amp; head.val == val) &#123;          head = head.next;      &#125;        if (head == null) &#123;          return head;      &#125;        ListNode pre = head;      ListNode cur = head.next;      while (cur != null) &#123;          if (cur.val == val) &#123;              pre.next = cur.next;          &#125; else &#123;              pre = cur;          &#125;          cur = cur.next;      &#125;      return head;  &#125;\n这个题共有三种题解法：\n\n\n第一种：添加虚节点。在原先的链表前，添加一个虚拟节点，用于处理可能被删除的头节点。因为删除可能涉及到头节点，所以在方法二中，第一个循环把头节点可能需要删除的情况直接处理掉。\n\n\n第二种：不添加虚节点。用一个循环处理可能会被删除的头节点。\n\n\n第三种：不加虚节点，同时不添加pre节点。加上判断删除节点是否是尾节点。\n\n\n707设计链表\n题目链接/文章讲解/视频讲解：https://programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html\n//单链表class ListNode &#123;    int val;    ListNode next;    ListNode()&#123;&#125;    ListNode(int val) &#123;        this.val=val;    &#125;&#125;class MyLinkedList &#123;    //size存储链表元素的个数    int size;    //虚拟头结点    ListNode head;    //初始化链表    public MyLinkedList() &#123;        size = 0;        head = new ListNode(0);    &#125;    //获取第index个节点的数值，注意index是从0开始的，第0个节点就是头结点    public int get(int index) &#123;        //如果index非法，返回-1        if (index &lt; 0 || index &gt;= size) &#123;            return -1;        &#125;        ListNode currentNode = head;        //包含一个虚拟头节点，所以查找第 index+1 个节点        for (int i = 0; i &lt;= index; i++) &#123;            currentNode = currentNode.next;        &#125;        return currentNode.val;    &#125;    //在链表最前面插入一个节点，等价于在第0个元素前添加    public void addAtHead(int val) &#123;        addAtIndex(0, val);    &#125;    //在链表的最后插入一个节点，等价于在(末尾+1)个元素前添加    public void addAtTail(int val) &#123;        addAtIndex(size, val);    &#125;    // 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。    // 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点    // 如果 index 大于链表的长度，则返回空    public void addAtIndex(int index, int val) &#123;        if (index &gt; size) &#123;            return;        &#125;        if (index &lt; 0) &#123;            index = 0;        &#125;        size++;        //找到要插入节点的前驱        ListNode pred = head;        for (int i = 0; i &lt; index; i++) &#123;            pred = pred.next;        &#125;        ListNode toAdd = new ListNode(val);        toAdd.next = pred.next;        pred.next = toAdd;    &#125;    //删除第index个节点    public void deleteAtIndex(int index) &#123;        if (index &lt; 0 || index &gt;= size) &#123;            return;        &#125;        size--;        if (index == 0) &#123;            head = head.next;\t    return;        &#125;        ListNode pred = head;        for (int i = 0; i &lt; index ; i++) &#123;            pred = pred.next;        &#125;        pred.next = pred.next.next;    &#125;&#125;\n参考中是直接设置了虚拟头节点解决的，代码会更加简洁。还有一种双向链表的方法，没有仔细研究。\n206反转链表\n题目链接/文章讲解/视频讲解：https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html\n// 递归 class Solution &#123;    public ListNode reverseList(ListNode head) &#123;        return reverse(null, head);    &#125;    private ListNode reverse(ListNode prev, ListNode cur) &#123;        if (cur == null) &#123;            return prev;        &#125;        ListNode temp = null;        temp = cur.next;// 先保存下一个节点        cur.next = prev;// 反转        // 更新prev、cur位置        // prev = cur;        // cur = temp;        // 此时cur为前一个节点，temp为后一个节点。两个节点位置交换，做递归。        return reverse(cur, temp);    &#125;&#125;\n按照讲解，一开始写的是双指针方法。\nLeetCode进阶处写了还可以使用递归解决。解法在解析中给出。\n","categories":["面试","代码随想录"],"tags":["链表","虚拟头节点","#双指针"]},{"title":"代码随想录算法训练营第四天-24两两交换链表中的节点、19删除链表的倒数第N个节点、面试题02.07.链表相交、142环形链表II","url":"/2024/05/16/100000005/","content":"\n\n前言\n状态：24需要看部分题解才能AC，19直接看的题解解题，面试题02.07可以AC（但是还有一种解法，完全想不到），142不会（第一次做真的有人能有思路吗🥲）\n\n\n更新\n\n\n24.05.16 初始记录24.05.22 后两题的完成\n\n初步题解\n24两两交换链表中的节点\n题目链接：(https://leetcode.cn/problems/swap-nodes-in-pairs/description/)\n// 第一遍完全没有看题解的写法，不能通过public static LE707.ListNode swapPairs(LE707.ListNode head) &#123;      while (head.next != null) &#123;          LE707.ListNode temp = head.next.next;          head.next.next = head;          head.next = temp;          head = head.next.next;      &#125;      return head;  &#125;// 第二遍看了部分文字题解// 发现少了头节点，即前一个节点的后节点的指向那一步public static LE707.ListNode swapPairs(LE707.ListNode head) &#123;      LE707.ListNode dumyHead = new LE707.ListNode(-1);      dumyHead.next = head;        // 记录当前节点的位置，便于循环      LE707.ListNode cur = dumyHead;      while (cur.next != null &amp;&amp; cur.next.next != null) &#123;          // 记录原来，后一个节点需要指向的节点          LE707.ListNode temp = cur.next.next.next;          LE707.ListNode node2 = cur.next.next;          LE707.ListNode node1 = cur.next;          cur.next = node2;          cur.next.next = node1;          cur.next.next.next = temp;          cur = node1;      &#125;      return dumyHead.next;  &#125;\n19删除链表的倒数第N个节点\n题目链接：https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/\n这道题直接看的解析。\n面试题02.07链表相交\n题目链接：https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/\n提交是可以的，但是本地跑不行，看了一下可能是本地测试的add方法，每次都是新建一个对象，两个链表中的对象地址是不一致的，导致tempA == tempB这一步始终判断失败。\n/**   * 思路：最后都会合成到一个链   * 可以把两个链按末尾对其，即较长链的指针起始与短链对齐   * @param headA headA   * @param headB headB   * @return 相交部分   */  public static LE707.ListNode getIntersectionNode(LE707.ListNode headA, LE707.ListNode headB) &#123;      int intersectVal = 0;      int skipA = 0;      int skipB = 0;        LE707.ListNode tempA = headA;      LE707.ListNode tempB = headB;        int sizeA = 0;      while (tempA != null) &#123;          sizeA++;          tempA = tempA.next;      &#125;        int sizeB = 0;      while (tempB != null) &#123;          sizeB++;          tempB = tempB.next;      &#125;        if (sizeA == 0 || sizeB == 0) &#123;          return null;      &#125;        tempA = headA;      tempB = headB;      // 尾端对其      if (sizeA &gt;= sizeB) &#123;          for (int i = 0; i &lt; (sizeA - sizeB); i++) &#123;              tempA = tempA.next;              skipA++;          &#125;      &#125; else &#123;          for (int i = 0; i &lt; (sizeB - sizeA); i++) &#123;              tempB = tempB.next;              skipB++;          &#125;      &#125;        // 不相同，指针后移      while (tempA != null) &#123;          if (tempA == tempB) &#123;              intersectVal = tempA.val;              return tempA;          &#125;          tempA = tempA.next;          tempB = tempB.next;          skipA++;          skipB++;      &#125;        return null;  &#125;\n142环形链表II\n题目链接：https://leetcode.cn/problems/linked-list-cycle-ii/description/\n不会，直接看的解析。\n看讲解\n24两两交换链表中的节点\n题目链接/文章讲解/视频讲解：：https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html\n这题看题解图会比较容易：\n看完根据这个图，总算是写出来了。也还有别的方法（递归）：\npublic ListNode swapPairs(ListNode head) &#123;        // base case 退出提交        if(head == null || head.next == null) return head;        // 获取当前节点的下一个节点        ListNode next = head.next;        // 进行递归        ListNode newNode = swapPairs(next.next);        // 这里进行交换        next.next = head;        head.next = newNode;        return next;    &#125;\n注：将步骤二三互换，可以不定义temp节点。\n19删除链表的倒数第N个节点\n题目链接/文章讲解/视频讲解：https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html\n/**   * 第一想法是获取长度，然后长度-n得到节点位置。因为节点这个初始化操作之前是写了size的   * 但是题目中是没有这个初始化操作的。   * 直接看的解析，说是用快慢双指针的方式。   */  public static LE707.ListNode removeNthFromEnd(LE707.ListNode head, int n) &#123;      // 添加一个虚拟头节点      LE707.ListNode dumyHead = new LE707.ListNode(-1);      dumyHead.next = head;        LE707.ListNode fast = dumyHead;      for (int i = 0; i &lt; n; i++) &#123;          fast = fast.next;      &#125;      LE707.ListNode slow = dumyHead;      while (fast != null &amp;&amp; fast.next != null) &#123;          fast = fast.next;          slow = slow.next;      &#125;        // 此时慢指针指向的为要删除节点的前一个节点      slow.next = slow.next.next;        return dumyHead.next;  &#125;\n步骤一：先移动快指针，快指针移动的位置与n相同。步骤二：同时移动快慢指针，当快指针下一节点的位置为0时，此时慢指针指向的位置为要删除的节点的前一节点。步骤三：删除指定节点。注：为了避免多处理头节点的情况，添加虚拟头节点。\n面试题02.07链表相交\n题目链接/文章讲解：https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html\n除了初步题解那种解法，还有一种，但是不是很能看懂理解，可以说第一次完全想不到，下面是解法和图解：\nhttps://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/solutions/1190240/mian-shi-ti-0207-lian-biao-xiang-jiao-sh-b8hn/\n// 合并链表实现移动public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;\t// p1 指向 A 链表头结点，p2 指向 B 链表头结点\tListNode p1 = headA, p2 = headB;\twhile (p1 != p2) &#123;\t\t// p1 走一步，如果走到 A 链表末尾，转到 B 链表\t\tif (p1 == null) p1 = headB;\t\telse            p1 = p1.next;\t\t// p2 走一步，如果走到 B 链表末尾，转到 A 链表\t\tif (p2 == null) p2 = headA;\t\telse            p2 = p2.next;\t&#125;\treturn p1;&#125;\n142环形链表II\n题目链接/文章讲解/视频讲解：https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html\n\n题解思路：\n\n\n如何判断链表是否有环：首先这题使用快慢指针解法。如果无环，那么快指针到最后也不会与慢指针相遇；如果可以相遇，则说明有环。\n\n\n快指针一定先进入环形，慢指针后进入环形。当慢指针进入环形时，就变成了追击问题，由快追击慢。因为指定快指针速度为2个节点，慢指针为1个节点，相对速度为1个节点，因此快慢一定会在环内相遇。\n\n\n如图所示：假设相遇在点P，入口在start，三段路径分别如图所示，则此时A的行走路径为：x + n(y + z) + y，B的行走路径为x + y\n\n\n又因为快指针速度为满指针的两倍，所以x + n(y + z) + y = 2(x + y)，得出x = n(y + z) - y，等式变形为x = (n - 1)(y + z) + z，又n &gt;= 1。可以简化为，在相遇处，出发处各设一个指针，一起移动，两个指针一定会相遇。相遇处即为start。\n\n\n疑难点：\nQ：为什么B的路径一定在一圈以内？\nA：关键在当慢指针进入环形时，就变成了追击问题。也就是说，快指针的追击路线一定小于一圈，即追击时间一定不够慢指针跑满一圈。\nQ：快慢指针一定会在环内相遇？\nA：因为指定快指针速度为2个节点，慢指针为1个节点，相对速度为1个节点，因此快慢一定会在环内相遇。（如果快指针的速度为3，那就可能会跳过了）\npublic LE707.ListNode detectCycle(LE707.ListNode head) &#123;      LE707.ListNode fast = head;      LE707.ListNode slow = head;        while (fast!= null  &amp;&amp; fast.next != null) &#123;          fast = fast.next.next;          slow = slow.next;          // 找到相遇点          if (slow == fast) &#123;              LE707.ListNode index1 = head;              LE707.ListNode index2 = fast;              while (index1 != index2) &#123;                  index1 = index1.next;                  index2 = index2.next;              &#125;              return index1;          &#125;      &#125;      return null;  &#125;","categories":["面试","代码随想录"],"tags":["链表","虚拟头节点","#双指针","环形链表"]},{"title":"代码随想录算法训练营第五天-242有效的字母异位词、349两个数组的交集、202快乐数、1两数之和","url":"/2024/05/23/100000006/","content":"\n\n前言\n状态：全部可以AC。看了解析之后，242、202可再优化。\n\n\n更新\n\n\n24.05.23 初始记录\n\n初步题解\n242有效的字母异位词\n题目链接：(https://leetcode.cn/problems/valid-anagram/description/)\npublic class LE242 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          String s = scanner.nextLine();          String t = scanner.nextLine();          System.out.println(isAnagram(s, t));      &#125;        /**       * 思路：       * 1.用map接收每个字符出现的次数       * 2.比较次数是否相同       */      public static boolean isAnagram(String s, String t) &#123;          char[] charsS = s.toCharArray();          char[] charsT = t.toCharArray();            HashMap&lt;String, Integer&gt; numMapS = getNumMap(charsS);          HashMap&lt;String, Integer&gt; numMapT = getNumMap(charsT);            if (numMapS.size() != numMapT.size()) &#123;              return false;          &#125;          for (String key : numMapS.keySet()) &#123;              if (!numMapS.get(key).equals(numMapT.get(key))) &#123;                  return false;              &#125;          &#125;          return true;      &#125;        /**       * 获取每个字符的数量       * @param charsS 字符串       * @return 每个字符的数量       */      private static HashMap&lt;String, Integer&gt; getNumMap(char[] charsS) &#123;          HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();          for (char c : charsS) &#123;              if (map.containsKey(String.valueOf(c))) &#123;                  map.put(String.valueOf(c) , map.get(String.valueOf(c)) + 1);              &#125; else &#123;                  map.put(String.valueOf(c), 1);              &#125;          &#125;          return map;      &#125;  &#125;\n349两个数组的交集\n题目链接：(https://leetcode.cn/problems/intersection-of-two-arrays/description/)\npublic class LE349 &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int[] nums1 = Arrays.stream(scanner.nextLine().split(&quot;,&quot;)).filter(Objects::nonNull).mapToInt(Integer::parseInt).toArray();        int[] nums2 = Arrays.stream(scanner.nextLine().split(&quot;,&quot;)).filter(Objects::nonNull).mapToInt(Integer::parseInt).toArray();        int[] intersection = intersection(nums1, nums2);    &#125;    public static int[] intersection(int[] nums1, int[] nums2) &#123;        HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();        HashSet&lt;Integer&gt; intersection = new HashSet&lt;&gt;();        for (int i : nums1) &#123;            set.add(i);        &#125;        for (int i : nums2) &#123;            if (set.contains(i)) &#123;                intersection.add(i);            &#125;        &#125;        return intersection.stream().filter(Objects::nonNull).mapToInt(i -&gt; i).toArray();    &#125;&#125;\n202快乐数\n题目链接：(https://leetcode.cn/problems/happy-number/description/)\npublic class LE202 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          String s = scanner.nextLine();          System.out.println(isHappy(Integer.parseInt(s)));      &#125;        /**       * 思路：放到set中，重复或者为1，跳出循环       * @param n 数       * @return 是否是快乐数       */      public static boolean isHappy(int n) &#123;          HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();          String num = n + &quot;&quot;;          set.add(n);          while (true) &#123;              int sum = 0;              for (int i = 0; i &lt; num.length(); i++) &#123;                  sum += Math.pow(Integer.parseInt(num.charAt(i) + &quot;&quot;), 2);              &#125;                if (sum == 1) &#123;                  return true;              &#125;                if (set.contains(sum)) &#123;                  return false;              &#125;              num = sum + &quot;&quot;;              set.add(sum);          &#125;      &#125;  &#125;\n1两数之和\n题目链接：(https://leetcode.cn/problems/two-sum/)\npublic class LE1 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          int[] nums = Arrays.stream(scanner.nextLine().split(&quot;,&quot;)).filter(Objects::nonNull).mapToInt(Integer::parseInt).toArray();          int target = Integer.parseInt(scanner.next());          twoSum(nums, target);      &#125;        /**       * 暴力解法肯定是循环两遍       * 但是这题放在哈希表专题里，就应该哈希表也能解决       * 用值为key，下标为value放入map       */    public static int[] twoSum(int[] nums, int target) &#123;          HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();          for (int i = 0; i &lt; nums.length; i++) &#123;              if (map.containsKey(target - nums[i])) &#123;                  return new int[]&#123;map.get(target - nums[i]), i&#125;;              &#125;              map.put(nums[i], i);          &#125;            return null;      &#125;  &#125;\n看讲解\n242有效的字母异位词\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0242.有效的字母异位词.html)\n/**   * 优化：   * 改为定义数组去接收数值（其实和map是一样的思想，但是这样代码量更少）   * 改为第二次遍历，在原数组上直接--（空间用得更少了）   */  public static boolean isAnagram1(String s, String t) &#123;      int[] record = new int[26];        for (int i = 0; i &lt; s.length(); i++) &#123;          record[s.charAt(i) - &#x27;a&#x27;]++;      &#125;        for (int i = 0; i &lt; t.length(); i++) &#123;          record[t.charAt(i) - &#x27;a&#x27;]--;      &#125;        for (int count : record) &#123;          if (count != 0) &#123;              return false;          &#125;      &#125;      return true;  &#125;\n349两个数组的交集\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0349.两个数组的交集.html)\n202快乐数\n题目链接/文章讲解：(https://programmercarl.com/0202.快乐数.html)\n// 可以再优化，一个数各个位数平方求和while (n &gt; 0) &#123;      int temp = n % 10;      sum += temp * temp;      n = n / 10;  &#125;\n1两数之和\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0001.两数之和.html)\n","categories":["面试","代码随想录"],"tags":["哈希表"]},{"title":"【代码模板】阿里云接口实现短信发送","url":"/2024/05/24/100000007/","content":"\n\n前言\n阿里云接口实现短信发送。\n\n\n更新\n\n\n24.05.24 初始记录\n\n依赖\n&lt;!--sms验证服务--&gt;  &lt;dependency&gt;      &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;      &lt;artifactId&gt;spring-cloud-alicloud-sms&lt;/artifactId&gt;      &lt;version&gt;2.2.0.RELEASE&lt;/version&gt;  &lt;/dependency&gt;\n代码\n\n\nService中要添加的代码\n\n\n@Override  public Boolean sendCode(String phone) &#123;      //非空校验      if (Strings.isNullOrEmpty(phone)) &#123;          throw new LogicException(&quot;手机号为空&quot;);      &#125;        StringBuilder sbCode = new StringBuilder();      // 6位随机密码    Stream.generate(() -&gt; new Random().nextInt(10))              .limit(6)              .forEach(sbCode::append);      //将验证码放入redis, 5分钟过期      redisTemplate.opsForValue().set(phone, sbCode.toString(), Duration.ofMinutes(5));      log.info(&quot;短信验证码：&quot; + sbCode.toString());      return smsSender.sendMsg(phone, sbCode.toString());  &#125;   \n\n\nSmsConfig.java\n\n\n@Configuration  @RefreshScope  public class SmsConfig &#123;      @Value(&quot;$&#123;sms.operator.signName&#125;&quot;)      private String signName;      @Value(&quot;$&#123;sms.operator.templateCode&#125;&quot;)      private String templateCode;        public String getSignName() &#123;          return signName;      &#125;        public String getTemplateCode() &#123;          return templateCode;      &#125;  &#125;\n\n\n配置文件中添加\n\n\nsms:  operator:    signName: 你的signName    templateCode: 你的templateCode  \n\n\nSmsSender.java\n\n\n@Component  @Slf4j  public class SmsSender &#123;      @Autowired      private SmsConfig smsConfig;      @Autowired      private ISmsService smsService;        /**       * 发送验证码短信       *       * @param telephone 手机号       * @param code     手机验证码       */      public boolean sendMsg(String telephone, String code) &#123;          SendSmsRequest request = new SendSmsRequest();            request.setPhoneNumbers(telephone);          request.setSignName(smsConfig.getSignName());          request.setTemplateCode(smsConfig.getTemplateCode());          ObjectMapper mapper = new ObjectMapper();          JsonNode rootNode = mapper.createObjectNode();          // 存入验证码          ((ObjectNode) rootNode).put(&quot;code&quot;, code);            try &#123;              request.setTemplateParam(mapper.writeValueAsString(rootNode));              val sendSmsResponse = smsService.sendSmsRequest(request);              log.info(&quot;短信发送接收：&quot; + JSONUtil.toJsonPrettyStr(sendSmsResponse));              if (sendSmsResponse.getCode() != null &amp;&amp; &quot;OK&quot;.equals(sendSmsResponse.getCode())) &#123;                  return true;              &#125; else &#123;                  throw new LogicException(&quot;验证码发送失败：&quot; + sendSmsResponse.getMessage());              &#125;          &#125; catch (Exception e) &#123;              log.error(&quot;send sms error.&quot; + e.getMessage());              val operLog = OperLog.builder().title(&quot;发送验证码&quot;)                      .businessType(BusinessType.OTHER.ordinal())                      .operParam(JSONUtil.toJsonPrettyStr(request))                      .status(BusinessStatus.FAIL.ordinal())                      .errorMsg(e.getMessage())                      .build();              AsyncManager.me().execute(AsyncFactory.recordOper(operLog));              throw new LogicException(&quot;验证码发送失败&quot;);          &#125;      &#125;  &#125;","categories":["后端项目","准备工作"],"tags":["代码模板","#Java"]},{"title":"聚合支付-功能实现","url":"/2024/05/23/100000008/","content":"\n\n前言\n第一部分-商户注册和资质申请\n\n\n更新\n\n\n24.05.23 初始记录（商户注册&amp;资质申请）\n\n商户注册&amp;资质申请\n系统交互流程\n\n商户注册的流程由商户平台应用、商户服务、SaaS平台、验证码服务四个微服务之间进行交互完成，各微服务的职责介绍如下：\n1）商户平台应用：此应用主要为商户提供业务功能，包括：商户资质申请、员工管理、门店管理等功能。\n2）商户服务： 提供商户管理的相关服务接口，供其它微服务调用，主要为商户平台应用提供接口服务，功能包括：商户基本信息管理、资质申请、商户应用管理、渠道参数配置、商户员工信息管理、商户门店管理等。\n3）SaaS平台：闪聚支付项目是一个SaaS平台 ，所谓SaaS平台即多个用户租用平台的业务功能，这样用户即可省去软件系统开发的成本，每个商户就是一个租户，所以又称为多租户系统。 SaaS平台提供租户管理、账号管理、权限管理、资源管理、套餐管理、系统认证授权等功业务功能。在上图商户注册的流程中，商户注册的账号等信息需要写入SaaS平台，由SaaS平台统一管理账号，分配权限，商户统一通过SaaS平台登录闪聚支付。\n4）验证码服务：提供获取短信验证码、校验验证码的接口。 商户使用手机号进行注册，平台通过校验手机验证码来确认是否本人在注册。\n\n获取短信验证码\n短信验证码为一个开源的服务，可单独开启使用。开源git地址：(https://github.com/fightingape/sailing)\n大致看了一下这个开源项目是根据传入的业务名称，获取配置好的code长度和Service实现。后续应该还可以加入别的实现（比如阿里云的短信服务等）其中生成验证信息这个方法。1.根据业务名称+随机UUID生成key存入redis。这个key会返回给服务请求方。2.根据配置好的Map获取名称对应的len即code码长度，如果传入不存在的name，会直接报错。3.验证服务就是根据返回给服务请求方的key，查询Redis缓存是否存在，不存在返回false，即验证码错误。\n本项目中没有使用，只是简单控制台打印了一下。也可以直接在这个服务里存入redis（因为要申请开通阿里云短信服务有点麻烦，又要多部署一个服务，而且这个功能比较简单不打算花时间开通了）。\n之前有写过阿里云的短信，关联文章：内链：[[【代码模板】阿里云接口实现短信发送]]\n外链：【代码模板】阿里云接口实现短信发送\n文件上传\n资质申请的流程中涉及到了文件上传的功能。之前已经写过使用Minio作为文件服务器和用阿里云OSS作为文件存储两种方式。这里的上传直接把七牛云换成了Minio。顺便整理了一下之前写过的两种方式。文件上传：内链：【代码模板】文件存储外链：【代码模板】文件存储\nBUG记录\nRestTemplate使用GET请求，返回中文乱码\n内链：RestTemplate使用GET请求，返回中文乱码外链：RestTemplate使用GET请求，返回中文乱码\n","categories":["后端项目","聚合支付"],"tags":["Java"]},{"title":"代码随想录算法训练营第六天-454四数相加II、383赎金信、15三数之和、18四数之和","url":"/2024/05/24/100000009/","content":"\n\n前言\n状态：454和383可以AC，15超时，18根据15做出，还可以进一步优化\n\n\n更新\n\n\n24.05.24 初始记录\n\n初步题解\n454四数相加II\n题目链接：(https://leetcode.cn/problems/4sum-ii/)\npublic class LE454 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          int[] nums1 = Arrays.stream(scanner.nextLine().split(&quot;,&quot;)).filter(Objects::nonNull).mapToInt(Integer::parseInt).toArray();          int[] nums2 = Arrays.stream(scanner.nextLine().split(&quot;,&quot;)).filter(Objects::nonNull).mapToInt(Integer::parseInt).toArray();          int[] nums3 = Arrays.stream(scanner.nextLine().split(&quot;,&quot;)).filter(Objects::nonNull).mapToInt(Integer::parseInt).toArray();          int[] nums4 = Arrays.stream(scanner.nextLine().split(&quot;,&quot;)).filter(Objects::nonNull).mapToInt(Integer::parseInt).toArray();          System.out.println(fourSumCount(nums1, nums2, nums3, nums4));      &#125;  \t// 和昨天的最后一题差不多    public static int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) &#123;          int res = 0;          HashMap&lt;Integer, Integer&gt; map = new HashMap();          for (int k : nums1) &#123;              for (int i : nums2) &#123;                  int sum = k + i;                  map.put(sum, map.getOrDefault(sum, 0) + 1);              &#125;          &#125;            for (int i : nums3) &#123;              for (int j : nums4) &#123;                  res += map.getOrDefault(-i - j, 0);              &#125;          &#125;            return res;      &#125;  &#125;\n383赎金信\n题目链接：(https://leetcode.cn/problems/ransom-note/submissions/534463469/)\npublic class LE383 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          String ransomNote = scanner.nextLine();          String magazine = scanner.nextLine();          System.out.println(canConstruct(ransomNote, magazine));      &#125;  \t// 和242一样的思路    public static boolean canConstruct(String ransomNote, String magazine) &#123;          int[] ints = new int[26];          // 遍历存储数量          for (int i = 0; i &lt; magazine.length(); i++) &#123;              ints[magazine.charAt(i) - 97]++;          &#125;          // 遍历扣除数量          for (int i = 0; i &lt; ransomNote.length(); i++) &#123;              ints[ransomNote.charAt(i) - 97]--;          &#125;          for (int i : ints) &#123;              if (i &lt; 0) &#123;                  return false;              &#125;          &#125;          return true;      &#125;  &#125;\n15三数之和\n题目链接：(https://leetcode.cn/problems/3sum/description/)\n暴力解法，但是这样超时了。\npublic static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;      // 判断是否重复      HashMap&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();        for (int i = 0; i &lt; nums.length; i++) &#123;          for (int j = i + 1; j &lt; nums.length; j++) &#123;              for (int k = j + 1; k &lt; nums.length; k++) &#123;                  if (nums[i] + nums[j] + nums[k] == 0) &#123;                      List&lt;Integer&gt; list = new ArrayList&lt;&gt;();                      list.add(nums[i]);                      list.add(nums[j]);                      list.add(nums[k]);                      list.sort(Integer::compareTo);                      map.put(list.stream().map(integer -&gt; integer + &quot;&quot;).collect(Collectors.joining(&quot;,&quot;)), list);                  &#125;              &#125;          &#125;      &#125;      List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();      for (Map.Entry&lt;String, List&lt;Integer&gt;&gt; stringListEntry : map.entrySet()) &#123;          list.add(stringListEntry.getValue());      &#125;      return list;  &#125;\n看了部分解析改用双指针，可以通过，但是比较慢。而且费时\npublic static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;      nums = Arrays.stream(nums).sorted().toArray();      ArrayList&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();      // 递增序列，前三位和大于0，直接返回      if (nums[0] + nums[1] + nums[2] &gt; 0) &#123;          return list;      &#125;        int i = 0;      int j = i + 1;      int k = nums.length - 1;      while (i &lt; j &amp;&amp; j &lt; k) &#123;          System.out.println(i + &quot; &quot; + j + &quot; &quot; + k);          int sum = nums[i] + nums[j] + nums[k];          if (sum == 0) &#123;              list.add(Arrays.asList(nums[i], nums[j], nums[k]));              j++;          &#125; else if (sum &lt; 0) &#123;              j++;          &#125; else &#123;              k--;          &#125;          while (j &gt; i + 1 &amp;&amp; j &lt;= nums.length - 1 &amp;&amp; nums[j] == nums[j - 1]) &#123;              j++;          &#125;          while (k &gt; j &amp;&amp; k != nums.length - 1 &amp;&amp; nums[k] == nums[k + 1]) &#123;              k--;          &#125;          if (j &gt;= k) &#123;              i = i + 1;              while (i != 0 &amp;&amp; i &lt;= nums.length - 1 &amp;&amp; nums[i] == nums[i - 1]) &#123;                  i++;              &#125;              j = i + 1;              k = nums.length - 1;          &#125;      &#125;      return list;  &#125;\n18四数之和\n题目链接：(https://leetcode.cn/problems/4sum/description/)\n看到题目，就觉得是15的进阶版，按照上一题的思路写了一下\npublic static List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;      Arrays.sort(nums);        ArrayList&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();      for (int i = 0; i &lt; nums.length; i++) &#123;          if (i != 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;              continue;          &#125;            for (int j = i + 1; j &lt; nums.length; j++) &#123;              if (j != i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123;                  continue;              &#125;                int left = j + 1;              int right = nums.length - 1;              while (left &lt; right) &#123;                  long sum = (long) nums[i] + (long) nums[j] + (long) nums[left] + (long) nums[right];                  if (sum &lt; target) &#123;                      left++;                  &#125; else if (sum &gt; target) &#123;                      right--;                  &#125; else &#123;                      list.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));                      while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) &#123;                          left++;                      &#125;                      while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) &#123;                          right--;                      &#125;                      left++;                      right--;                  &#125;              &#125;          &#125;      &#125;      return list;  &#125;\n看讲解\n454四数相加II\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0454.四数相加II.html)\n383赎金信\n题目链接/文章讲解：(https://programmercarl.com/0383.赎金信.html)\n15三数之和\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0015.三数之和.html)\n确实用for循环更好理解。题解的思路更加清晰，而且更快。\npublic static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;      List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      Arrays.sort(nums);      for (int i = 0; i &lt; nums.length; i++) &#123;          // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了          if (nums[i] &gt; 0) &#123;              return result;          &#125;            /**           * 只能是与前一个比较进行去重           */          if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;              continue;          &#125;            int left = i + 1;          int right = nums.length - 1;          while (right &gt; left) &#123;              int sum = nums[i] + nums[left] + nums[right];              if (sum &gt; 0) &#123;                  right--;              &#125; else if (sum &lt; 0) &#123;                  left++;              &#125; else &#123;                  result.add(Arrays.asList(nums[i], nums[left], nums[right]));                  /**                   * 去重逻辑应该放在找到一个三元组之后                   * 否则获取不到结果集                   */                  while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) &#123;                      right--;                  &#125;                  while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) &#123;                      left++;                  &#125;                    right--;                  left++;              &#125;          &#125;      &#125;      return result;  &#125;\n18四数之和\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0018.四数之和.html)\n看了解析。加上剪枝操作。\npublic static List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;      Arrays.sort(nums);        ArrayList&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();      for (int i = 0; i &lt; nums.length; i++) &#123;          // nums[i] &gt; target 直接返回, 剪枝操作          if (nums[i] &gt; 0 &amp;&amp; nums[i] &gt; target) &#123;              return list;          &#125;            for (int j = i + 1; j &lt; nums.length; j++) &#123; \t        // 二级剪枝            if (nums[i] + nums[j] &gt; 0 &amp;&amp; nums[i] + nums[j] &gt; target) &#123;                  break;              &#125;                if (j != i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123;                  continue;              &#125;                int left = j + 1;              int right = nums.length - 1;              while (left &lt; right) &#123;                  long sum = (long) nums[i] + (long) nums[j] + (long) nums[left] + (long) nums[right];                  if (sum &lt; target) &#123;                      left++;                  &#125; else if (sum &gt; target) &#123;                      right--;                  &#125; else &#123;                      list.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));                      while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) &#123;                          left++;                      &#125;                      while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) &#123;                          right--;                      &#125;                      left++;                      right--;                  &#125;              &#125;          &#125;      &#125;      return list;  &#125;","categories":["面试","代码随想录"],"tags":["双指针","哈希表"]},{"title":"代码随想录算法训练营第七天-344反转字符串、541反转字符串II、卡码网54替换数字、151翻转字符串里的单词、卡码网55右旋转字符串","url":"/2024/05/27/100000010/","content":"\n\n前言\n状态：都是可以写出来的。但是有些与参考种给出的解析思路不同。\n\n\n更新\n\n\n24.05.27 初始记录\n\n初步题解\n344反转字符串\n题目链接：(https://leetcode.cn/problems/reverse-string/description/)\npublic class LE344 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          reverseString(scanner.nextLine().toCharArray());      &#125;        public static void reverseString(char[] s) &#123;          for (int i = 0, j = s.length - 1; i &lt;= j; i++, j--) &#123;              char temp = s[i];              s[i] = s[j];              s[j] = temp;          &#125;          System.out.println(Arrays.toString(s));      &#125;  &#125;\n541反转字符串II\n题目链接：(https://leetcode.cn/problems/reverse-string-ii/description/)\npublic class LE541 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          System.out.println(reverseStr(scanner.nextLine(), Integer.parseInt(scanner.nextLine())));      &#125;        /**       * 画图翻译了一下       * 大概意思就是奇数段反转       */      public static String reverseStr(String s, int k) &#123;          // 判断能拆分成几段          int size = s.length() / k;          if (s.length() % k != 0) &#123;              size = size + 1;          &#125;            StringBuilder reverseStr = new StringBuilder();          for (int i = 1; i &lt;= size; i++) &#123;              String substring = s.substring((i - 1) * k, Math.min(i * k, s.length()));              if (i % 2 != 0) &#123;                  char[] chars = substring.toCharArray();                  for (int n = 0, m = chars.length - 1; n &lt;= m; n++, m--) &#123;                      char temp = chars[n];                      chars[n] = chars[m];                      chars[m] = temp;                  &#125;                  reverseStr.append(chars);              &#125; else &#123;                  reverseStr.append(substring);              &#125;          &#125;            return reverseStr.toString();      &#125;  &#125;\n卡码网54替换数字\n题目链接：(https://kamacoder.com/problempage.php?pid=1064)\npublic class CM54 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          System.out.println(replaceNumber(scanner.nextLine()));      &#125;        public static String replaceNumber(String s) &#123;          StringBuilder stringBuilder = new StringBuilder();          char[] chars = s.toCharArray();          for (char c : chars) &#123;              if (&#x27;0&#x27; &lt;= c &amp;&amp; &#x27;9&#x27; &gt;= c) &#123;                  stringBuilder.append(&quot;number&quot;);              &#125; else &#123;                  stringBuilder.append(c);              &#125;          &#125;          return stringBuilder.toString();      &#125;  &#125;\n151翻转字符串里的单词\n题目链接：(https://leetcode.cn/problems/reverse-words-in-a-string/description/)\npublic static void main(String[] args) &#123;      Scanner scanner = new Scanner(System.in);      System.out.println(reverseWords(scanner.nextLine()));  &#125;    private static String reverseWords(String s) &#123;      String[] split = s.trim().split(&quot; &quot;);      StringBuilder stringBuilder = new StringBuilder();      for (int i = split.length - 1; i &gt;= 0; i--) &#123;          String trim = split[i].trim();          if (&quot;&quot;.equals(trim)) &#123;              continue;          &#125;          stringBuilder.append(trim).append(&quot; &quot;);      &#125;        return stringBuilder.toString().trim();  &#125;\n卡码网55右旋转字符串\n题目链接：(https://kamacoder.com/problempage.php?pid=1065)\npublic class CM55 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          int k = Integer.parseInt(scanner.nextLine());          String s = scanner.nextLine();          System.out.println(rightString(k, s));      &#125;        private static String rightString(int k, String s) &#123;          // 过界判断          if (k &gt;= s.length() || k &lt;= 0) &#123;              return s;          &#125;            return s.substring(s.length() - k) + s.substring(0, s.length() - k);      &#125;  &#125;\n看讲解\n344反转字符串\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0344.反转字符串.html)\n541反转字符串II\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0541.反转字符串II.html)\n卡码网54替换数字\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/kamacoder/0054.替换数字.html)\n根据讲解，这题本意是先扩充再分配。要用到双指针的方法。\npublic class Main &#123;    public static String replaceNumber(String s) &#123;        int count = 0; // 统计数字的个数        int sOldSize = s.length();        for (int i = 0; i &lt; s.length(); i++) &#123;            if(Character.isDigit(s.charAt(i)))&#123;                count++;            &#125;        &#125;        // 扩充字符串s的大小，也就是每个空格替换成&quot;number&quot;之后的大小        char[] newS = new char[s.length() + count * 5];        int sNewSize = newS.length;        // 将旧字符串的内容填入新数组        System.arraycopy(s.toCharArray(), 0, newS, 0, sOldSize);        // 从后先前将空格替换为&quot;number&quot;        for (int i = sNewSize - 1, j = sOldSize - 1; j &lt; i; j--, i--) &#123;            if (!Character.isDigit(newS[j])) &#123;                newS[i] = newS[j];            &#125; else &#123;                newS[i] = &#x27;r&#x27;;                newS[i - 1] = &#x27;e&#x27;;                newS[i - 2] = &#x27;b&#x27;;                newS[i - 3] = &#x27;m&#x27;;                newS[i - 4] = &#x27;u&#x27;;                newS[i - 5] = &#x27;n&#x27;;                i -= 5;            &#125;        &#125;        return new String(newS);    &#125;;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        String s = scanner.next();        System.out.println(replaceNumber(s));        scanner.close();    &#125;&#125;\n151翻转字符串里的单词\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0151.翻转字符串里的单词.html)\n这题。。。Java不好像没有办法空间复杂度为O(n)。（面试的话，不太清楚会不会这么细，平时可能就直接API搞定了。。。一般机考也不会考这个吧😶‍🌫️）只能说思路很重要：\n\n\n移除多余空格（）\n\n\n将整个字符串反转\n\n\n将每个单词反转\n\n\npublic class LE151 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          System.out.println(reverseWords(scanner.nextLine()));      &#125;        /**       * 本题考察点应该和上一题一样       * 步骤如下:       * 1.移除字符串中的空格       * 2.倒序       * 3.每个单词再反转       * 要求：不使用任何内置API       */    public static String reverseWords(String s) &#123;          String removeSpace = removeSpace(s);          System.out.println(removeSpace);          return reverseWord(removeSpace);      &#125;        /**       * 单个单词倒置       */      private static String reverseWord(String s) &#123;          String[] list = s.split(&quot; &quot;);          if (list.length &lt;= 0) &#123;              return &quot;&quot;;          &#125;          StringBuilder stringBuilder = new StringBuilder();          for (String s1 : list) &#123;              char[] chars = s1.toCharArray();              for (int i = 0, j = chars.length - 1; i &lt;= j; i++, j--) &#123;                  char temp = chars[i];                  chars[i] = chars[j];                  chars[j] = temp;              &#125;              stringBuilder.append(chars).append(&quot; &quot;);          &#125;          return stringBuilder.substring(0, stringBuilder.length() - 1);      &#125;        /**       * 去除字符串中的多余空格       * 并进行倒序       */      private static String removeSpace(String s) &#123;          char[] chars = s.toCharArray();          int start = 0;          int end = s.length() - 1;          while (s.charAt(start) == &#x27; &#x27;) &#123;              start++;          &#125;          while (s.charAt(end) == &#x27; &#x27;) &#123;              end--;          &#125;          if (start &gt; end) &#123;              return &quot;&quot;;          &#125;          StringBuilder stringBuilder = new StringBuilder();          for (int i = end; i &gt;= start; i--) &#123;              if (chars[i] == &#x27; &#x27; &amp;&amp; chars[i - 1] == &#x27; &#x27;) &#123;                  continue;              &#125;              stringBuilder.append(chars[i]);          &#125;          return stringBuilder.toString();      &#125;    &#125;\n卡码网55右旋转字符串\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/kama55.右旋字符串.html)\n这题也是。。。反正直接用API了，看了说《剑指Offer》有差不多的题目。没有再写一遍，直接抄了解析中的写法。\npublic class Main &#123;    public static void main(String[] args) &#123;        Scanner in = new Scanner(System.in);        int n = Integer.parseInt(in.nextLine());        String s = in.nextLine();        int len = s.length();  //获取字符串长度        char[] chars = s.toCharArray();        reverseString(chars, 0, len - 1);  //反转整个字符串        reverseString(chars, 0, n - 1);  //反转前一段字符串，此时的字符串首尾尾是0,n - 1        reverseString(chars, n, len - 1);  //反转后一段字符串，此时的字符串首尾尾是n,len - 1                System.out.println(chars);    &#125;    public static void reverseString(char[] ch, int start, int end) &#123;        //异或法反转字符串，参照题目 344.反转字符串的解释        while (start &lt; end) &#123;            ch[start] ^= ch[end];            ch[end] ^= ch[start];            ch[start] ^= ch[end];            start++;            end--;        &#125;    &#125;&#125;","categories":["面试","代码随想录"],"tags":["双指针","字符串","反转"]},{"title":"代码随想录算法训练营第八天-28实现 strStr() 、459重复的子字符串","url":"/2024/05/29/100000011/","content":"\n\n前言\n状态：28暴力（应为KMP）、459暴力（KMP不会）\n\n\n更新\n\n\n24-05-29 初始记录\n\n初步题解\n28实现 strStr()\n题目链接：(https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)\npublic class LE28 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          String haystack = scanner.nextLine();          String needle = scanner.nextLine();          System.out.println(strStr(haystack, needle));      &#125;        /**       * 思路：一个指针针对haystack遍历，一个指针针对needle遍历       * 当指针指过的路径相等，输出两者的差（即初始相等的指针位置）       * 当指向元素不同，haystack指针指向初始对比的下一个，needle指针重置       */      public static int strStr(String haystack, String needle) &#123;          int j = 0;          for (int i = 0; i &lt; haystack.length(); i++) &#123;              if (haystack.charAt(i) == needle.charAt(j)) &#123;                  if (j == needle.length() - 1) &#123;                      return i - j;                  &#125;                  j++;              &#125; else &#123;                  i = i - j;                  j = 0;              &#125;          &#125;          return  -1;      &#125;  &#125;\n459重复的子字符串\n题目链接：(https://leetcode.cn/problems/repeated-substring-pattern/description/)\n（虽然讲了KMP应该就用KMP，但是不会）\n// 暴力求解public class LE459 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          String nextLine = scanner.nextLine();          System.out.println(repeatedSubstringPattern(nextLine));      &#125;        public static boolean repeatedSubstringPattern(String s) &#123;          int n = s.length();          for (int i = 1; i * 2 &lt;= n; i++) &#123;              if (n % i == 0) &#123;                  boolean match = true;                  for (int j = i; j &lt; n; j++) &#123;                      if (s.charAt(j) != s.charAt(j - i)) &#123;                          match = false;                          break;                      &#125;                  &#125;                  if (match) &#123;                      return true;                  &#125;              &#125;          &#125;            return false;      &#125;  &#125;\n看讲解\n28实现 strStr()\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0028.实现strStr.html)\n本题应该用KMP思路，这个算法主要用在字符串匹配上。KMP的经典思想就是:当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。\n/**   * 思路：使用KMP算法。   * 之前双指针移动，不相等haystack的指针返回到初始匹配位置的下一位（暴力求解）   * 现在使用KMP算法，不相等移动到next表中标记的位置。   * 所以现在的关键就在于next表的计算：   * 1.初始化   * 2.当前后缀不相等时的思路（回退）   * 3.当前后缀相等时的思路（继续后移）   * 内部相当于也进行了KMP */  public static int strStr1(String haystack, String needle) &#123;      // 获取Next表      int[] ints = new int[needle.length()];      int[] next = getNext(ints, needle);        int j = 0;      if (needle.length() == 0) &#123;          return -1;      &#125;      for (int i = 0; i &lt; haystack.length(); i++) &#123;          // 不相等, j回退          while (j != 0 &amp;&amp; haystack.charAt(i) != needle.charAt(j)) &#123;              j = next[j - 1];          &#125;          // 相等          if (haystack.charAt(i) == needle.charAt(j)) &#123;              // 完全匹配，返回下标              if (j == needle.length() - 1) &#123;                  return i - j;              &#125;              j++;          &#125;        &#125;      return  -1;  &#125;    /**   * 获取next表，例：   * a a b a a f   * 0 1 0 1 2 0 * * 1.初始化   * 2.当前后缀不相等时的思路（回退）   * 3.当前后缀相等时的思路（继续后移）   *   * @param next 返回的next数组   * @param s 要求的字符串   * @return next数组   */  private static int[] getNext(int[] next, String s) &#123;      // 初始化 两个指针i和j，j指向前缀末尾位置(同时也是之前最长相等的前后缀长度)，i指向后缀末尾位置(随着字符串长度递增，递增)。      // 刚刚初始化时，字符串为a，所以j = 0      int j = 0;      next[0] = j;        // 这里i从1开始，没有搞懂(因为初始位置一定为0吗)      for (int i = 1; i &lt; s.length(); i++) &#123;          while (j != 0 &amp;&amp; s.charAt(i) != s.charAt(j)) &#123;              j = next[j - 1];          &#125;          if (s.charAt(i) == s.charAt(j)) &#123;              j++;          &#125;          next[i] = j;      &#125;      return next;  &#125;\n459重复的子字符串\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0459.重复的子字符串.html)\n/**   * KMP思路   * 如果这个字符串是由重复子串组成的，那么字符串长度-最长相等前后缀就为重复子串的长度   * 反过来说，如果一个字符串的最长相等前后缀与长度的差值（即可能是重复子串长度的这个值）能被字符串长度整除，那么就说明这个字符串是由重复子串组成的   * 但是这个反过来说。需要证明。（虽然画了几种情况都是这样）   *   * KMP复习：   * 1.初始化   * 2.不相等的情况   * 3.相等的情况   */  public static boolean repeatedSubstringPattern1(String s) &#123;      int[] next = getNext(s);      // 这里除了上面说的条件之外，还需要加上next[len - 1] != -1, 这说明字符串有最长相同的前后缀（就是字符串里的前缀子串和后缀子串相同的最长长度）      return next[s.length() - 1] != 0 &amp;&amp; s.length() % (s.length() - next[s.length() - 1]) == 0;  &#125;    private static int[] getNext(String s) &#123;      int j = 0;      int[] next = new int[s.length()];      next[j] = 0;        for (int i = 1; i &lt; s.length(); i++) &#123;          while (j != 0 &amp;&amp; s.charAt(i) != s.charAt(j)) &#123;              j = next[j - 1];          &#125;          if (s.charAt(i) == s.charAt(j)) &#123;              j++;          &#125;          next[i] = j;      &#125;        return next;  &#125;","categories":["面试","代码随想录"],"tags":["双指针","#字符串","KMP"]},{"title":"代码随想录算法训练营第九天-232用栈实现队列、225用队列实现栈","url":"/2024/05/30/100000012/","content":"\n\n前言\n状态：都是直接看的解析，不是很难。\n\n\n更新\n\n\n24.05.30 初始记录\n\n初步题解\n232用栈实现队列\n题目链接：(https://leetcode.cn/problems/implement-queue-using-stacks/description/)\npublic class LE232 &#123;      public static void main(String[] args) &#123;          MyQueue queue = new MyQueue();          queue.push(1);          queue.push(2);          System.out.println(&quot;queue.peek() = &quot; + queue.peek());          System.out.println(&quot;queue.pop() = &quot; + queue.pop());          System.out.println(&quot;queue.empty() = &quot; + queue.empty());      &#125;        static class MyQueue &#123;          Stack&lt;Integer&gt; stackIn;          Stack&lt;Integer&gt; stackOut;            public MyQueue() &#123;              stackIn = new Stack&lt;&gt;();              stackOut = new Stack&lt;&gt;();          &#125;            public void push(int x) &#123;              stackIn.push(x);          &#125;            public int pop() &#123;              // 把in的内容复制到out              in2out();              return stackOut.pop();          &#125;            private void in2out() &#123;              if (stackOut.isEmpty()) &#123;                  while (!stackIn.isEmpty()) &#123;                      stackOut.push(stackIn.pop());                  &#125;              &#125;          &#125;            /**           * 返回列表开头的数据           * @return 结果           */          public int peek() &#123;              // 把in的内容复制到out              in2out();              return stackOut.peek();          &#125;            public boolean empty() &#123;              return stackIn.empty() &amp;&amp; stackOut.empty();          &#125;      &#125;  &#125;\n225用队列实现栈\n题目链接：(https://leetcode.cn/problems/implement-queue-using-stacks/description/)\npublic class LE225 &#123;      public static void main(String[] args) &#123;          MyStack myStack = new MyStack();          myStack.push(1);          myStack.push(2);          System.out.println(&quot;myStack.top() = &quot; + myStack.top());          System.out.println(&quot;myStack.pop() = &quot; + myStack.pop());          System.out.println(&quot;myStack.empty() = &quot; + myStack.empty());      &#125;        static class MyStack &#123;          Queue&lt;Integer&gt; queue;            public MyStack() &#123;              queue = new LinkedList&lt;&gt;();          &#125;            public void push(int x) &#123;              queue.offer(x);              int size = queue.size() - 1;              while (size != 0) &#123;                  size--;                  queue.offer(queue.poll());              &#125;          &#125;            public int pop() &#123;              return queue.poll();          &#125;            public int top() &#123;              return queue.peek();          &#125;            /**           * 判断是否为空           */          public boolean empty() &#123;              return queue.isEmpty();          &#125;      &#125;  &#125;\n看讲解\n232用栈实现队列\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0232.用栈实现队列.html)\n思路：用栈模拟队列需要两个栈。一个栈作为入栈，一个栈作为出栈。如果出栈为空，将入栈中的元素压入出栈。\n\n225用队列实现栈\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0225.用队列实现栈.html)\n思路：用队列模拟栈，可以只用一个队列。每当有新元素入队列，将原有的旧元素重新入队列，这样新元素就变成栈顶元素。（一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了。）\n\n","categories":["面试","代码随想录"],"tags":["栈","队列"]},{"title":"代码随想录算法训练营第十天-20有效的括号、1047删除字符串中的所有相邻重复项、150逆波兰表达式求值","url":"/2024/05/30/100000013/","content":"\n\n前言\n状态：20AC，1047AC，150AC\n\n\n更新\n\n\n24.05.30 初始记录\n\n初步题解\n20有效的括号\n题目链接：(https://leetcode.cn/problems/valid-parentheses/description/)\npublic class LE20 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          System.out.println(isValid(scanner.nextLine()));      &#125;        public static boolean isValid(String s) &#123;          Stack&lt;Character&gt; stack = new Stack&lt;&gt;();          for (char c : s.toCharArray()) &#123;              if (c == &#x27;(&#x27; || c == &#x27;[&#x27; || c == &#x27;&#123;&#x27;) &#123;                  stack.push(c);                  continue;              &#125;              if (stack.isEmpty()) &#123;                  return false;              &#125;              Character pop = stack.pop();              if ((c == &#x27;)&#x27; &amp;&amp; pop != &#x27;(&#x27; ) || (c == &#x27;]&#x27; &amp;&amp; pop != &#x27;[&#x27; ) || (c == &#x27;&#125;&#x27; &amp;&amp; pop != &#x27;&#123;&#x27; )) &#123;                  return false;              &#125;          &#125;          return stack.isEmpty();      &#125;  &#125;\n1047删除字符串中的所有相邻重复项\n题目链接：(https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/)\npublic static void main(String[] args) &#123;      Scanner scanner = new Scanner(System.in);      System.out.println(removeDuplicates(scanner.nextLine()));  &#125;    public static String removeDuplicates(String s) &#123;      Stack&lt;Character&gt; stack = new Stack&lt;&gt;();      for (char c : s.toCharArray()) &#123;          if (stack.isEmpty()) &#123;              stack.push(c);              continue;          &#125;          if (c == stack.peek()) &#123;              stack.pop();          &#125; else &#123;              stack.push(c);          &#125;      &#125;        StringBuilder str = new StringBuilder();      int size = stack.size();      for (int i = 0; i &lt; size; i++) &#123;          str.insert(0, stack.pop());      &#125;      return str.toString();  &#125;\n150逆波兰表达式求值\n题目链接：(https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/)\n可以直接根据题目中给的链接查看逆波兰表示法的意思\npublic int evalRPN(String[] tokens) &#123;      Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();      int num = Integer.parseInt(tokens[0]);      for (String token : tokens) &#123;          switch (token) &#123;              case &quot;+&quot;: &#123;                  num = stack.pop() + stack.pop();                  stack.push(num);                  break;              &#125;              case &quot;-&quot;: &#123;                  Integer num2 = stack.pop();                  Integer num1 = stack.pop();                  num = num1 - num2;                  stack.push(num);                  break;              &#125;              case &quot;*&quot;: &#123;                  num = stack.pop() * stack.pop();                  stack.push(num);                  break;              &#125;              case &quot;/&quot;: &#123;                  Integer num2 = stack.pop();                  Integer num1 = stack.pop();                  num = num1 / num2;                  stack.push(num);                  break;              &#125;              default: &#123;                  stack.push(Integer.parseInt(token));              &#125;          &#125;      &#125;      return num;  &#125;\n看解析\n20有效的括号\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0020.有效的括号.html)\n1047删除字符串中的所有相邻重复项\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/1047.删除字符串中的所有相邻重复项.html)\n150逆波兰表达式求值\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0150.逆波兰表达式求值.html)\n","categories":["面试","代码随想录"],"tags":["栈"]},{"title":"【代码模板】文件存储","url":"/2024/05/30/100000014/","content":"\n\n前言\n项目中常用到文件上传的功能。\n\n\n更新\n\n\n24.05.30 初始记录（Minio，阿里云OSS）\n\n文件上传\n\n\n校验\n\n文件是否为空\n文件的格式\n文件的大小\n\n\n\n文件重命名\n\n\n文件目录分离\n\n使用目录分离算法(Hash把hash值作为目录名称)\n按照日期分目录(每天创建一个新的目录)\n按照用户名分目录\n\n\n\n图片保存地点\n\nweb服务器（项目所运行在的电脑）\n云存储服务商\n自己搭建文件服务器（FastDFS Minio）\n\n\n\n通用部分代码\n/**   * 文件上传   *   * @param file 文件   * @return Boolean   */@RestController@RequestMapping(&quot;common&quot;)public class CommonController &#123;    @PostMapping(&quot;upload&quot;)    public R uploadPic(MultipartFile file) throws IOException &#123;        // 校验        // 校验文件是否为空        if (ObjectUtil.isNull(file)) return R.error(&quot;上传文件不能为空&quot;);        // 校验文件的格式        if (!StrUtil.containsAnyIgnoreCase(FileUtil.getSuffix(file.getOriginalFilename()), &quot;jpg&quot;, &quot;png&quot;)) &#123;            return R.error(&quot;上传文件格式错误&quot;);        &#125;        // 校验文件的大小        if (file.getSize() / 1024 / 1024 &gt; 2) return R.error(&quot;文件过大，限制在2MB以内&quot;);                // 给文件进行重命名        String fileName = UUID.fastUUID().toString() + &quot;.&quot; + FileUtil.getSuffix(file.getOriginalFilename());        // 给文件目录分离                // 图片保存地点（不同保存地点实现方式不同）        .....        return R.success(fileName);    &#125;&#125;\n不同的保存地点\nweb服务器（项目所运行在的电脑）\n\n\n文件上传部分代码\n\n\n// 这种情况下，文件存储路径为服务器上的路径名称file.transferTo(new File(&quot;D:\\\\images\\\\&quot; + fileName));\n\n\n下载\n\n\n\n\n前端直接访问服务器域名+存储地址\n\n\n// 这种情况下，代码中需要添加访问资源映射地址// 在拦截器中配置@Configuration  public class WebMvcConfig implements WebMvcConfigurer &#123;      @Autowired      private AuthInterceptor authInterceptor;          private static final String DWG = &quot;file:&quot; + &quot;D:/images/&quot;;      @Override      public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;    // 添加访问资源的地址        registry.addResourceHandler(&quot;/virtual/**&quot;).addResourceLocations(DWG);      &#125;        @Override      public void addInterceptors(InterceptorRegistry registry) &#123;          registry.addInterceptor(authInterceptor)                  .addPathPatterns(&quot;/**&quot;)                  .excludePathPatterns(&quot;/**/login/**&quot;, &quot;/**/*.html&quot;, &quot;/**/*.js&quot;, &quot;/**/*.css&quot;, &quot;/doc.*&quot;,                          &quot;/swagger-ui.*&quot;,                          &quot;/swagger-resources&quot;,                          &quot;/webjars/**&quot;,                          &quot;/v2/api-docs/**&quot;,                          &quot;/virtual/**&quot;                  );      &#125;  &#125;\n\n\n前端通过接口下载文件\n\n\n@GetMapping(&quot;download&quot;)public void downloadPic(String name, HttpServletResponse response) throws IOException &#123;    FileInputStream fileInputStream = new FileInputStream(&quot;D:\\\\images\\\\&quot; + name);    ServletOutputStream outputStream = response.getOutputStream();    byte[] bytes = new byte[1024];    int len = 0;    while ((len = fileInputStream.read(bytes)) != -1) &#123;        outputStream.write(bytes, 0, len);    &#125;    fileInputStream.close();    outputStream.close();&#125;\n云存储服务商\n通过开通云存储服务商的OSS服务，调用提供的API，实现文件存储。一般后面两种情况会直接编写Util类方便多处调用。\n阿里云\nMaven依赖\n&lt;dependency&gt;      &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;      &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;      &lt;version&gt;3.4.2&lt;/version&gt;  &lt;/dependency&gt;\n配置文件\naliyun:    oss:      endpoint: oss-cn-hangzhou.aliyuncs.com      accessKeyId: xxxxxxxxxxxxxxxx      accessKeySecret: xxxxxxxxxxxxxxxx      bucket:  xxxxxxxxxxxxxxxx    userFolder: user/      managerFolder: manager/\n代码\n\n\nOssAutoConfiguration.java\n\n\n@Configuration  @ConditionalOnClass(&#123;OSSClient.class&#125;)  @EnableConfigurationProperties(OssProperties.class)  public class OssAutoConfiguration &#123;        private final OssProperties ossProperties;        public OssAutoConfiguration(final OssProperties ossProperties) &#123;          this.ossProperties = ossProperties;      &#125;        @Bean      public OssClientFactoryBean ossClientFactoryBean() &#123;          final OssClientFactoryBean factoryBean = new OssClientFactoryBean();          factoryBean.setEndpoint(this.ossProperties.getEndpoint());          factoryBean.setAccessKeyId(this.ossProperties.getAccessKeyId());          factoryBean.setAccessKeySecret(this.ossProperties.getAccessKeySecret());          return factoryBean;      &#125;  &#125;\n\n\nOssClientFactoryBean.class\n\n\npublic class OssClientFactoryBean implements FactoryBean&lt;OSSClient&gt;, InitializingBean, DisposableBean &#123;        private OSSClient ossClient;      private String endpoint;      private String accessKeyId;      private String accessKeySecret;        @Override      public OSSClient getObject() throws Exception &#123;          return this.ossClient;      &#125;        @Override      public Class&lt;?&gt; getObjectType() &#123;          return OSSClient.class;      &#125;        @Override      public boolean isSingleton() &#123;          return true;      &#125;        @Override      public void destroy() throws Exception &#123;          if (this.ossClient != null) &#123;              this.ossClient.shutdown();          &#125;      &#125;        @Override      public void afterPropertiesSet() throws Exception &#123;          Assert.notNull(this.endpoint, &quot;&#x27;aliyun.oss.endpoint&#x27; must be not null&quot;);          Assert.notNull(this.accessKeyId, &quot;&#x27;aliyun.oss.accessKeyId&#x27; must be not null&quot;);          Assert.notNull(this.accessKeySecret, &quot;&#x27;aliyun.oss.accessKeySecret&#x27; must be not null&quot;);          this.ossClient = new OSSClient(this.endpoint, this.accessKeyId, this.accessKeySecret);      &#125;        public void setEndpoint(final String endpoint) &#123;          this.endpoint = endpoint;      &#125;        public void setAccessKeyId(final String accessKeyId) &#123;          this.accessKeyId = accessKeyId;      &#125;        public void setAccessKeySecret(final String accessKeySecret) &#123;          this.accessKeySecret = accessKeySecret;      &#125;  &#125;\n\n\nOssProperties.java\n\n\n@Getter  @Setter  @ConfigurationProperties(prefix = &quot;aliyun.oss&quot;)  public class OssProperties &#123;      private String endpoint;      private String accessKeyId;      private String accessKeySecret;      private String bucket;      private String userFolder;      private String managerFolder;  &#125;\n\n\nOssUtil.class\n\n\n@Slf4j  @Component  public class OssUtil &#123;      @Autowired      private OSSClient ossClient;        @Autowired      private OssProperties ossProperties;        /**       * 上传文件       * @param folder &quot;需要加/ 如&quot;xxx/&quot;&quot;       * @return 文件地址       */      public String upload(MultipartFile file, String folder) &#123;          String bucketName = ossProperties.getBucket();            // 判断Bucket的存在          if (!ossClient.doesBucketExist(bucketName)) &#123;              // 创建存储空间              Bucket bucket = ossClient.createBucket(bucketName);              bucketName = bucket.getName();          &#125;            String objectName = &quot;&quot;;          try &#123;              // 以输入流的形式上传文件              InputStream is = file.getInputStream();              // 文件名              String originalFilename = file.getOriginalFilename();              if (ObjectUtil.isNull(originalFilename)) &#123;                  throw new LogicException(&quot;文件名称获取失败&quot;);              &#125;              val suffix = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));              String fileName = UUID.fastUUID().toString() + suffix.toLowerCase();              objectName = folder + DateUtil.format(new Date(), &quot;yy-MM/dd&quot;) + &quot;/&quot; + fileName;                // 文件大小              long fileSize = file.getSize();                // 创建上传Object的Metadata              ObjectMetadata metadata = new ObjectMetadata();              // 上传的文件的长度              metadata.setContentLength(is.available());              // 指定该Object被下载时的网页的缓存行为              metadata.setCacheControl(&quot;no-cache&quot;);              // 指定该Object下设置Header              metadata.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);              // 指定该Object被下载时的内容编码格式              metadata.setContentEncoding(&quot;utf-8&quot;);              // 文件的MIME，定义文件的类型及网页编码，决定浏览器将以什么形式、什么编码读取文件。如果用户没有指定则根据Key或文件名的扩展名生成，              // 如果没有扩展名则填默认值application/octet-stream              metadata.setContentType(AliyunOssFileTypeEnum.getText(suffix.toLowerCase()));              // 指定该Object被下载时的名称（指示MINME用户代理如何显示附加的文件，打开或下载，及文件名称）              metadata.setContentDisposition(&quot;filename/filesize=&quot; + originalFilename + &quot;/&quot; + fileSize + &quot;Byte.&quot;);              // 上传文件 (上传文件流的形式)              PutObjectResult putResult = ossClient.putObject(bucketName, objectName, is, metadata);              // 解析结果              String resultStr = putResult.getETag();              log.info(&quot;唯一MD5数字签名:&quot; + resultStr);          &#125; catch (OSSException oe) &#123;              // oe.printStackTrace();              log.error(&quot;上传阿里云OSS服务器异常.&quot; + oe.getMessage(), oe);          &#125; catch (ClientException ce) &#123;              // ce.printStackTrace();              log.error(&quot;阿里云OSS服务连接异常.&quot; + ce.getMessage(), ce);          &#125; catch (IOException e) &#123;              // e.printStackTrace();              log.error(&quot;文件流异常.&quot; + e.getMessage(), e);          &#125;          return &quot;https://&quot; + ossProperties.getBucket() + &quot;.&quot; + ossProperties.getEndpoint() + &quot;/&quot; + objectName;      &#125;        /**       * 上传文件 byte ()       * @param folder &quot;需要加/ 如&quot;xxx/&quot;&quot;       * @return 文件地址       */      public String imgUploadByByte(byte[] bytes, String folder) &#123;          String bucketName = ossProperties.getBucket();            // 判断Bucket的存在          if (!ossClient.doesBucketExist(bucketName)) &#123;              // 创建存储空间              Bucket bucket = ossClient.createBucket(bucketName);              bucketName = bucket.getName();          &#125;            String objectName = &quot;&quot;;          try &#123;              InputStream inputStream = new ByteArrayInputStream(bytes);                val suffix = &quot;jpg&quot;;              String fileName = UUID.fastUUID().toString() +suffix;              objectName = folder + DateUtil.format(new Date(), &quot;yy-MM/dd&quot;) + &quot;/&quot; + fileName;                // 创建上传Object的Metadata              ObjectMetadata metadata = new ObjectMetadata();              // 上传的文件的长度              metadata.setContentLength(inputStream.available());              // 指定该Object被下载时的网页的缓存行为              metadata.setCacheControl(&quot;no-cache&quot;);              // 指定该Object下设置Header              metadata.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);              // 指定该Object被下载时的内容编码格式              metadata.setContentEncoding(&quot;utf-8&quot;);              // 文件的MIME，定义文件的类型及网页编码，决定浏览器将以什么形式、什么编码读取文件。如果用户没有指定则根据Key或文件名的扩展名生成，              // 如果没有扩展名则填默认值application/octet-stream              metadata.setContentType(AliyunOssFileTypeEnum.getText(suffix));              // 上传文件 (上传文件流的形式)              PutObjectResult putResult = ossClient.putObject(bucketName, objectName, inputStream, metadata);              // 解析结果              String resultStr = putResult.getETag();              log.info(&quot;唯一MD5数字签名:&quot; + resultStr);          &#125; catch (OSSException oe) &#123;              // oe.printStackTrace();              log.error(&quot;上传阿里云OSS服务器异常.&quot; + oe.getMessage(), oe);          &#125; catch (ClientException ce) &#123;              // ce.printStackTrace();              log.error(&quot;阿里云OSS服务连接异常.&quot; + ce.getMessage(), ce);          &#125; catch (IOException e) &#123;              // e.printStackTrace();              log.error(&quot;文件流异常.&quot; + e.getMessage(), e);          &#125;          return &quot;https://&quot; + ossProperties.getBucket() + &quot;.&quot; + ossProperties.getEndpoint() + &quot;/&quot; + objectName;      &#125;        /**       * 根据objectName删除OSS服务器上的文件       *       * @param objectName     模拟文件夹名 如&quot;qj_nanjing/&quot; + Bucket下的文件的路径名+文件名 如：&quot;upload/cake.jpg&quot;       */       public Boolean deleteFile(String objectName) &#123;          String bucketName = ossProperties.getBucket();          ossClient.deleteObject(bucketName, objectName);          log.info(&quot;删除&quot; + bucketName + &quot;下的文件&quot; + objectName + &quot;成功&quot;);          return true;      &#125;        /**       * 根据url获取objectName       *     * @param url url       */    public String getObjectNameByUrl(String url) &#123;  //        url = url.replace(&quot;https://&quot; + ossProperties.getBucket() + &quot;.&quot; + ossProperties.getEndpoint() + &quot;/&quot;, &quot;&quot;);          int firstIndex = url.indexOf(&quot;/&quot;);          int secondIndex = url.indexOf(&quot;/&quot;, firstIndex + 1);          int thirdIndex = url.indexOf(&quot;/&quot;, secondIndex + 1);          int suffix = url.lastIndexOf(&quot;?&quot;) &gt; 0 ? url.lastIndexOf(&quot;?&quot;) : url.length();          url = url.substring(thirdIndex + 1, suffix);          return url;      &#125;        /**       * 获取上传文件url (非公共读写时)       *     * @param objectName 模拟文件夹名 如&quot;qj_nanjing/&quot; + Bucket下的文件的路径名+文件名 如：&quot;upload/cake.jpg&quot;       * @return url       */    public String getUrl(String objectName) &#123;          //设置URl过期时间为99年：3600L*1000*24*365*99          Date expiration = new Date(new Date().getTime() + 3600L * 1000 * 24 * 365 * 99);          GeneratePresignedUrlRequest generatePresignedUrlRequest = new GeneratePresignedUrlRequest(ossProperties.getBucket(), objectName);          generatePresignedUrlRequest.setExpiration(expiration);          URL url = ossClient.generatePresignedUrl(generatePresignedUrlRequest);          return url.toString();      &#125;&#125;\nMinio\nMaven依赖\n&lt;dependencies&gt;      &lt;dependency&gt;          &lt;groupId&gt;io.minio&lt;/groupId&gt;          &lt;artifactId&gt;minio&lt;/artifactId&gt;          &lt;version&gt;7.1.0&lt;/version&gt;      &lt;/dependency&gt;\t&lt;!--SPI--&gt;    &lt;dependency&gt;          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;          &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;          &lt;optional&gt;true&lt;/optional&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;          &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;      &lt;/dependency&gt;  &lt;/dependencies&gt;\n配置文件\nminio:    endpoint: xxxxxxxxxxxxxxxxxxxxxx #MinIO服务所在地址    bucketName: xxxxxxxxxxx #存储桶名称    accessKey: xxxxxxxxxxxxxxxx #访问的key    secretKey: xxxxxxxxxxxxxxxxxxx #访问的秘钥\n代码\n\n\nMinioProp.java\n\n\n@ConfigurationProperties(prefix = &quot;minio&quot;)  public class MinioProp &#123;      private String endpoint;      private String accessKey;      private String secretKey;      private String bucketName;        public String getEndpoint() &#123;          return endpoint;      &#125;        public void setEndpoint(String endpoint) &#123;          this.endpoint = endpoint;      &#125;        public String getAccessKey() &#123;          return accessKey;      &#125;        public void setAccessKey(String accessKey) &#123;          this.accessKey = accessKey;      &#125;        public String getSecretKey() &#123;          return secretKey;      &#125;        public void setSecretKey(String secretKey) &#123;          this.secretKey = secretKey;      &#125;        public String getBucketName() &#123;          return bucketName;      &#125;        public void setBucketName(String bucket) &#123;          this.bucketName = bucket;      &#125;  &#125;\n\n\nOSSFile.java\n\n\n@Data  public class OSSFile &#123;      /**       * 文件名       */      private String fileName;      /**       * 文件存储地址       */      private String url;      /**       * 文件ObjectName       */        private String objectName;  &#125;\n\n\nMinioUtil.java\n\n\n@Component  @Slf4j  @EnableConfigurationProperties(MinioProp.class)  public class MinioUtil &#123;      @Resource      private MinioProp prop;        private MinioClient minioClient;        /**       * 创建minioClient       */    @PostConstruct      public void createMinioClient() &#123;          try &#123;              if (null == minioClient) &#123;                  log.info(&quot;minioClient create start&quot;);                  minioClient = MinioClient.builder().endpoint(prop.getEndpoint())                          .credentials(prop.getAccessKey(), prop.getSecretKey())                          .build();                  createBucket();                  log.info(&quot;minioClient create end&quot;);              &#125;          &#125; catch (Exception e) &#123;              log.error(&quot;连接MinIO服务器异常：&quot; + e);          &#125;      &#125;        /**       * 初始化Bucket       *     * @throws Exception 异常       */      private void createBucket()              throws IOException, InvalidKeyException, InvalidResponseException, InsufficientDataException, NoSuchAlgorithmException, ServerException, InternalException, XmlParserException, InvalidBucketNameException, ErrorResponseException, RegionConflictException &#123;          if (!minioClient.bucketExists(BucketExistsArgs.builder().bucket(prop.getBucketName()).build())) &#123;              minioClient.makeBucket(MakeBucketArgs.builder().bucket(prop.getBucketName()).build());          &#125;      &#125;        /**       * 查看存储bucket是否存在       * @return boolean       */    public Boolean bucketExists(String bucketName) &#123;          Boolean found;          try &#123;              found = minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());          &#125; catch (Exception e) &#123;              e.printStackTrace();              return false;          &#125;          return found;      &#125;        /**       * 创建存储bucket       * @return Boolean       */        public Boolean makeBucket(String bucketName) &#123;          try &#123;              if (!bucketExists(bucketName)) &#123;                  minioClient.makeBucket(MakeBucketArgs.builder()                          .bucket(bucketName)                          .build());                  String policyJson = &quot;&#123;\\n&quot; +                          &quot;\\t\\&quot;Version\\&quot;: \\&quot;&quot;+new SimpleDateFormat(&quot;yyyy-mm-dd&quot;).format(System.currentTimeMillis())+&quot;\\&quot;,\\n&quot; +                          &quot;\\t\\&quot;Statement\\&quot;: [&#123;\\n&quot; +                          &quot;\\t\\t\\&quot;Effect\\&quot;: \\&quot;Allow\\&quot;,\\n&quot; +                          &quot;\\t\\t\\&quot;Principal\\&quot;: &#123;\\n&quot; +                          &quot;\\t\\t\\t\\&quot;AWS\\&quot;: [\\&quot;*\\&quot;]\\n&quot; +                          &quot;\\t\\t&#125;,\\n&quot; +                          &quot;\\t\\t\\&quot;Action\\&quot;: [\\&quot;s3:GetBucketLocation\\&quot;, \\&quot;s3:ListBucket\\&quot;, \\&quot;s3:ListBucketMultipartUploads\\&quot;],\\n&quot; +                          &quot;\\t\\t\\&quot;Resource\\&quot;: [\\&quot;arn:aws:s3:::&quot; + bucketName + &quot;\\&quot;]\\n&quot; +                          &quot;\\t&#125;, &#123;\\n&quot; +                          &quot;\\t\\t\\&quot;Effect\\&quot;: \\&quot;Allow\\&quot;,\\n&quot; +                          &quot;\\t\\t\\&quot;Principal\\&quot;: &#123;\\n&quot; +                          &quot;\\t\\t\\t\\&quot;AWS\\&quot;: [\\&quot;*\\&quot;]\\n&quot; +                          &quot;\\t\\t&#125;,\\n&quot; +                          &quot;\\t\\t\\&quot;Action\\&quot;: [\\&quot;s3:AbortMultipartUpload\\&quot;, \\&quot;s3:DeleteObject\\&quot;, \\&quot;s3:GetObject\\&quot;, \\&quot;s3:ListMultipartUploadParts\\&quot;, \\&quot;s3:PutObject\\&quot;],\\n&quot; +                          &quot;\\t\\t\\&quot;Resource\\&quot;: [\\&quot;arn:aws:s3:::&quot; + bucketName + &quot;/*\\&quot;]\\n&quot; +                          &quot;\\t&#125;]\\n&quot; +                          &quot;&#125;\\n&quot;;                  minioClient.setBucketPolicy(SetBucketPolicyArgs.builder().bucket(bucketName).config(policyJson).build());                  log.info(&quot;buckets：【&#123;&#125;】,创建[readwrite]策略成功！&quot;, bucketName);              &#125; else &#123;                  log.info(&quot;minio bucket-&gt;&gt;&gt;【&#123;&#125;】already exists&quot;, bucketName);              &#125;          &#125; catch (Exception e) &#123;              e.printStackTrace();              return false;          &#125;          return true;      &#125;      /**       * 删除存储bucket       * @return Boolean       */        public Boolean removeBucket(String bucketName) &#123;          try &#123;              minioClient.removeBucket(RemoveBucketArgs.builder()                      .bucket(bucketName)                      .build());          &#125; catch (Exception e) &#123;              e.printStackTrace();              return false;          &#125;          return true;      &#125;      /**       * 获取全部bucket       */        public List&lt;Bucket&gt; getAllBuckets() &#123;          try &#123;              List&lt;Bucket&gt; buckets = minioClient.listBuckets();              return buckets;          &#125; catch (Exception e) &#123;              e.printStackTrace();          &#125;          return null;      &#125;      /**       * 文件上传       *       * @param file 文件       * @return Boolean       */        public OSSFile upload(MultipartFile file) &#123;          String originalFilename = file.getOriginalFilename();          if (StrUtil.isBlank(originalFilename))&#123;              throw new RuntimeException();          &#125;          // 重命名          String fileName = UUID.fastUUID() + originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));          String objectName = DateUtil.format(new Date(), &quot;yy-MM/dd&quot;) + &quot;/&quot; + fileName;          try &#123;              PutObjectArgs objectArgs = PutObjectArgs.builder().bucket(prop.getBucketName()).object(objectName)                      .stream(file.getInputStream(), file.getSize(), -1).contentType(file.getContentType()).build();              //文件名称相同会覆盖              minioClient.putObject(objectArgs);          &#125; catch (Exception e) &#123;              e.printStackTrace();              return null;          &#125;            OSSFile ossFile = new OSSFile();          ossFile.setFileName(originalFilename);          ossFile.setObjectName(objectName);          ossFile.setUrl(prop.getEndpoint() + &quot;/&quot; + prop.getBucketName() + &quot;/&quot; + objectName);          return ossFile;      &#125;        /**       * 预览图片       * @param fileName       * @return       */      public String preview(String fileName)&#123;          // 查看文件地址          GetPresignedObjectUrlArgs build = new GetPresignedObjectUrlArgs().builder().bucket(prop.getBucketName()).object(fileName).method(Method.GET).build();          try &#123;              String url = minioClient.getPresignedObjectUrl(build);              return url;          &#125; catch (Exception e) &#123;              e.printStackTrace();          &#125;          return null;      &#125;        /**       * 文件下载       * @param fileName 文件名称       * @param res response       * @return Boolean       */        public void download(String fileName, HttpServletResponse res) &#123;          GetObjectArgs objectArgs = GetObjectArgs.builder().bucket(prop.getBucketName())                  .object(fileName).build();          try (InputStream response = minioClient.getObject(objectArgs))&#123;              byte[] buf = new byte[1024];              int len;              try (FastByteArrayOutputStream os = new FastByteArrayOutputStream())&#123;                  while ((len=response.read(buf))!=-1)&#123;                      os.write(buf,0,len);                  &#125;                  os.flush();                  byte[] bytes = os.toByteArray();                  res.setCharacterEncoding(&quot;utf-8&quot;);                  // 设置强制下载不打开                  // res.setContentType(&quot;application/force-download&quot;);                  res.addHeader(&quot;Content-Disposition&quot;, &quot;attachment;fileName=&quot; + fileName);                  try (ServletOutputStream stream = res.getOutputStream())&#123;                      stream.write(bytes);                      stream.flush();                  &#125;              &#125;          &#125; catch (Exception e) &#123;              e.printStackTrace();          &#125;      &#125;        /**       * 查看文件对象       * @return 存储bucket内文件对象信息       */      public List&lt;Item&gt; listObjects() &#123;          Iterable&lt;Result&lt;Item&gt;&gt; results = minioClient.listObjects(                  ListObjectsArgs.builder().bucket(prop.getBucketName()).build());          List&lt;Item&gt; items = new ArrayList&lt;&gt;();          try &#123;              for (Result&lt;Item&gt; result : results) &#123;                  items.add(result.get());              &#125;          &#125; catch (Exception e) &#123;              e.printStackTrace();              return null;          &#125;          return items;      &#125;        /**       * 删除       * @param fileName       * @return       * @throws Exception       */      public boolean remove(String fileName)&#123;          try &#123;              minioClient.removeObject( RemoveObjectArgs.builder().bucket(prop.getBucketName()).object(fileName).build());          &#125;catch (Exception e)&#123;              return false;          &#125;          return true;      &#125;  &#125;\n拓展\nMinio这个被写成了SPI加载到别的服务中，这边再加一下关于SPI的知识。\n如图resources文件夹下的META-INF文件夹下的spring.factories文件。如果要把MinioUtil这个方法加载到别的项目中，可以这么写。\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=com.hzjzxx.minio.utils.MinioUtil\n关于SPI的知识：内链：SPI相关外链：SPI相关\n","tags":["Minio","Oss"]},{"title":"SPI相关","url":"/2024/05/30/100000015/","content":"\n\n前言\nSPI相关的面试问题及用法\n\n\n更新\n\n\n24.05.30 初始记录\n\nSPI介绍\n​SPI全称Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。\nJava的SPI机制就是将一些==类信息写在约定的文件中==，然后由特定的类加载器ServiceLoader加载解析文件获取资源。\nJava SPI 基于 “接口编程＋策略模式＋配置文件(约定)”组合实现的动态加载机制。它提供了一种服务发现机制，允许在程序外部动态指定具体实现。一般情况下是调用方调用实现好的接口，但是当接口存在于调用方这边时，就是 SPI ，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。​以下是SPI的一些运用场景:\n\n\n\n场景\n说明\n\n\n\n\n数据库驱动\n数据库驱动加载接口实现类的加载 JDBC加载不同类型数据库的驱动\n\n\n日志门面SLF4J接口实现类加载\nSLF4J加载不同提供商的日志实现类\n\n\nSpring\nSpring中大量使用了SPI,比如：对servlet3.0规范对ServletContainerInitializer的实现、自动类型转换Type Conversion SPI(Converter SPI、Formatter SPI)等\n\n\nDubbo\nDubbo中也大量使用SPI的方式实现框架的扩展, 不过它对Java提供的原生SPI做了封装，允许用户扩展实现Filter接口\n\n\nSpringBoot\nSpringBoot基于SPI思想实现自动装配\n\n\n插件扩展\n开源框架，想使用别人的插件，扩展某个功能。\n\n\n\nServiceLoader\n面试大白话\nJava中的SPI就是你提供一个接口，然后让别人提供实现类。然后将这个实现放在resources/META-INF/services/中。这样Java启动的时候就会去扫描这个下面的jar包，并把他加载进来。一般来说用在开源框架中的插件扩展，然后比较常见的思想提现就是Java的JDBC实现，可以根据自己使用的数据库，将对应的jar包引用进来。（Dubbo中可能问到的问题）Dubbo中也使用了这个思想，；比如说有一行代码是：\nProtocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();\n然后在使用Protocol接口时，dubbo他会去找一个你配置的Protocol，他就会将你配置的Protocol实现类，加载到jvm中来，然后实例化对象，就用你的那个Protocol实现类就可以了。这个Protocol就是用来配置他的网络协议的，然后在源码中可以看到，默认使用的是dubbo协议，就是DubboProtocol。dubbo里面提供了大量的类似上面的扩展点，就是说，你如果要扩展一个东西，只要自己写个jar，让你的consumer或者是provider工程，依赖你的那个jar，在你的jar里指定目录下配置好接口名称对应的文件，里面通过key=实现类（这些都可以在官网的文档里找到）。\n","tags":["SPI","面试题","Java基础"]}]