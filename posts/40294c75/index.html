<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Kiml">
    
    <title>
        
            面试-并发🤕 |
        
        Kiml&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/sword.png">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.3/font/css/fontawesome.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.3/font/css/regular.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.3/font/css/solid.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.3/font/css/brands.min.css">
    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"kiml.github.io","root":"/","language":"zh-CN","path":"search.json"}
    KEEP.theme_config = {"base_info":{"title":"Kiml's Blog","author":"Kiml","avatar":null,"font_size":null,"font_family":null,"primary_color":"#0066cc","logo":null,"favicon":"/images/sword.png"},"menu":{"Home":"/","Archives":"/archives","Tags":"/tags","Categories":"/categories","tools":"/tools/","About":"/about"},"first_screen":{"enable":true,"header_transparent":true,"background_img":"https://blog-resources.oss-cn-hangzhou.aliyuncs.com/240414/%E8%83%8C%E6%99%AF.webp","description":"我生来就是高山而非溪流 || 我欲于群峰之巅俯视平庸的沟壑","font_color":null,"hitokoto":false},"social_contact":{"enable":true,"links":{"github":"https://github.com/kiml-rgb","email":"1162278448@qq.com"}},"scroll":{"progress_bar":true,"percent":true},"home":{"announcement":null,"category":false,"tag":false,"post_datetime":"updated"},"post":{"author_badge":{"enable":true,"level_badge":true},"word_count":{"enable":true,"wordcount":true,"min2read":true},"img_align":"left","copyright_info":true},"code_block":{"tools":{"enable":true,"style":"mac"},"highlight_theme":"obsidian"},"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"website_count":{"busuanzi_count":{"enable":true,"site_uv":true,"site_pv":true,"page_pv":true}},"local_search":{"enable":true,"preload":true},"comment":{"enable":true,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.8"},"waline":{"server_url":null,"reaction":false,"version":2}},"rss":{"enable":true},"lazyload":{"enable":true},"cdn":{"enable":true,"provider":"cdnjs"},"pjax":{"enable":true},"footer":{"since":2022,"icp":null,"site_deploy":{"enable":false,"provider":"github","url":null}},"inject":{"enable":false,"css":[null],"js":[null]},"root":"","home_article":{"category":{"enable":true,"limit":3},"tag":{"enable":true,"limit":5}},"source_data":{"tools":[{"category":"聊天 AI"},{"name":"ChatGPT","link":"https://chat.openai.com/","description":"OpenAI 旗下 AI 聊天对话工具","image":"/images/tools/chatgpt.ico"},{"name":"智谱清言","link":"https://chatglm.cn/","description":"智谱 AI 旗下的 AI 聊天对话工具","image":"/images/tools/Chat GLM.png"},{"name":"Kimi Chat","link":"https://kimi.moonshot.cn","description":"擅长长文本对话","image":"/images/tools/kimi.png"},{"category":"部署托管"},{"name":"Vercel","link":"https://vercel.com/","description":"Vercel","image":"/images/tools/Vercel.png"}]},"version":"4.1.3"}
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"}
    KEEP.language_code_block = {"copy":"复制代码","copied":"已复制","fold":"折叠代码块","folded":"已折叠"}
    KEEP.language_copy_copyright = {"copy":"复制版权信息","copied":"已复制","title":"原文标题","author":"原文作者","link":"原文链接"}
  </script>
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Keep Theme" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>



<main class="page-container border-box">
    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left border-box">
            
            <a class="site-name border-box" href="/">
               Kiml&#39;s Blog
            </a>
        </div>

        <div class="right border-box">
            <div class="pc">
                <ul class="menu-list">
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                
                                首页
                            </a>
                        </li>
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                
                                归档
                            </a>
                        </li>
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                
                                标签
                            </a>
                        </li>
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                
                                分类
                            </a>
                        </li>
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/tools/"
                            >
                                
                                工具
                            </a>
                        </li>
                    
                        
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas search fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/"
                    >首页</a>
                </li>
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives"
                    >归档</a>
                </li>
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags"
                    >标签</a>
                </li>
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories"
                    >分类</a>
                </li>
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tools/"
                    >工具</a>
                </li>
            
                
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about"
                    >关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            

            <div class="post-content-bottom border-box">
                
                    <div class="post-title">
                        面试-并发🤕
                    </div>
                

                
                    <div class="post-header border-box">
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">Kiml</span>
                                
                                    <span class="author-badge">Lv5</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-calendar-plus"></i>&nbsp;
                <span class="datetime">2024-06-03 21:42:40</span>
            </span>

            <span class="meta-info-item post-update-date">
                <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                <span class="datetime" data-updated="Thu Jun 20 2024 17:42:10 GMT+0800">2024-06-20 17:42:10</span>
            </span>
        

        
            <span class="meta-info-item post-category border-box"><i class="icon fas fa-folder"></i>&nbsp;
                <ul class="post-category-ul">
                    
                            <li class="category-item"><a href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></li>
                        
                    
                            <li class="category-item">&nbsp;<i class="icon fas fa-angle-right"></i>&nbsp;<a href="/categories/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a></li>
                        
                    
                </ul>
            </span>
        

        
            <span class="post-tag meta-info-item border-box">
                <ul class="post-tag-ul">
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></li>
                        
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a></li>
                        
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></li>
                        
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池</a></li>
                        
                    
                </ul>
            </span>
        

        
        
            <span class="meta-info-item post-wordcount">
                <i class="icon fas fa-file-word"></i>&nbsp;<span>9.5k 字</span>
            </span>
        
        
            <span class="meta-info-item post-min2read">
                <i class="icon fas fa-clock"></i>&nbsp;<span>33 分钟</span>
            </span>
        
        
            <span class="meta-info-item post-pv">
                <i class="icon fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
            </span>
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body ">
                    

                    <ul class="lvl-0">
<li class="lvl-2">
<p>前言<br>
❗表示必掌握，❔表示基本不会问</p>
</li>
<li class="lvl-2">
<p>更新</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">24.06.03 初始记录</span><br><span class="line">24.06.04 AQS</span><br><span class="line">24.06.05 线程池</span><br><span class="line">24.06.06 高并发</span><br><span class="line">24.06.10 总结</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="高并发（锁）">高并发（锁）</h2>
<h3 id="❗Java-内存模型的理解">❗Java 内存模型的理解</h3>
<p>大白话：Java 的对象都是处于主内存之中，而线程拥有自己的工作内存（CPU 级别的缓存）。操作过程，1) 线程把主内存中的数据读出 read，2) 线程把值加载到工作内存中 load，3) 线程使用这个值 use，4) 线程把算好的值设置到工作内存 assign，5) 把值存入 store，6) 写入主内存 write。如果有两个线程，会同时操作，即并发（操作结果可能只有一次的结果）。</p>
<blockquote>
<p>首先，JAVA 内存模型是指 JMM，而不是指内存结构，内存结构是在物理上的区域划分，而 JMM 则是抽象概念上的划分。</p>
<p>JMM（内存模型）主要包括两块：<strong>主内存</strong>+<strong>工作内存</strong>。</p>
<p>主内存：多个线程间通信的共享内存称之为主内存，即，数据是多个线程工共享的，在物理内存结构上通常对应“堆”中的线程共享数据。</p>
<p>工作内存：多个线程各自对应自己的本地内存，即，数据只属于该线程自己的，在物理内存结构上通常对应“本地方法栈”中的线程私有数据。</p>
<p>Java 内存模型规定了所有的变量都存储在主内存 (Main Memory) 中，每条线程还有自己的工作内存 (Working Memory)，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作 (读取、赋值等) 都必须在工作内存中进行，而不能直接读写主内存中的变量，不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值得传递均需要通过主内存来实现。</p>
</blockquote>
<h4 id="❗Java-内存模型中的原子性、有序性、可见性">❗Java 内存模型中的原子性、有序性、可见性</h4>
<p>可见性：一个线程操作完，另一个线程必须读取操作后的数据。</p>
<p>原子性：同时只有一个线程能操作。（不加操作默认情况下就是没有原子性的）</p>
<p>有序性：编译之后，可能会指令重排。如果具备有序性，就不会发生指令重排。</p>
<h4 id="❗从-Java-底层角度聊聊-volatile-关键字的原理">❗从 Java 底层角度聊聊 volatile 关键字的原理</h4>
<blockquote>
<p>volatile 关键字与可见性的关系</p>
</blockquote>
<p>volatile 关键字是用来解决可见性和有序性。给数据加上 volatile 关键字，在线程更新数据时，会把其他线程内缓存的数据值失效，这时其他线程会强制重新从主内存加载数据值（变成新的缓存）。</p>
<p>在很多开源中间件系统中，大量使用 volatile。例子：在 main 方法中，会有一段逻辑，如果主线程在执行，不可以后台退出（这里的执行状态用一个值表示，根据值判断系统是否在运行）。如果提供了一个方法，需要关闭主线程，如果不加 volatile 关键字，其他线程更新状态，主线程没有同步，就会出问题。（<strong>这个类似的用法会在多处使用</strong>）</p>
<h4 id="❗指令重排以及-happens-before-原则">❗指令重排以及 happens-before 原则</h4>
<blockquote>
<p>volatile 关键字与有序性的关系、连带问题</p>
</blockquote>
<p>❔<strong>happens-before 原则</strong>：</p>
<ol>
<li class="lvl-3">
<p>程序次序规则：一个线程内，代码按写的顺序执行</p>
</li>
<li class="lvl-3">
<p>锁定规则：一个 unLock 操作先行与后一个 Lock 的操作（先解锁，后加锁）</p>
</li>
<li class="lvl-3">
<p>volatile 变量规则：加了 volatile 关键字，写操作先，读操作后</p>
</li>
<li class="lvl-3">
<p>传递规则：如果 A 先于 B，B 先于 C，那么 A 一定先于 C</p>
</li>
<li class="lvl-3">
<p>线程启动规则：线程的启动 <code>start()</code> 方法先于此线程的每个操作</p>
</li>
<li class="lvl-3">
<p>线程中断规则：对线程的 <code>interrupt()</code> 调用，先于检测到终端的发生</p>
</li>
<li class="lvl-3">
<p>线程终结规则：线程的所有操作都先于线程的终止检测操作</p>
</li>
<li class="lvl-3">
<p>对象终结规则：对象的初始化在 <code>finalize()</code> 之前</p>
</li>
</ol>
<p>这个规则制定了在特殊情况下，不允许指令重排。而因为这个规则，volatile 关键字有一定的防止指令重排的效果（只能先写后读）。</p>
<p>同时，volatile 关键字本身，就有其他避免指令重排的规则（就是底层。。。最好不要问这个，谁记得住啊）。</p>
<h4 id="❗volatile-底层是如何基于内存屏障保证可见性和有序性的">❗volatile 底层是如何基于内存屏障保证可见性和有序性的</h4>
<p>volatile 不能保证原子性。（只能加锁 synchronized、lock）。</p>
<p>volatile 保证可见性：对于 volatile 修饰的变量，执行写操作，JVM 会发送一条 lock 前缀指令给 CPU，CPU 在计算完之后将值强制刷回主内存。其他线程有一个嗅探机制（<strong>MESI 缓存一致性协议</strong>），会去失效线程内的缓存。</p>
<p>volatile 保证有序性：加入内存屏障，可以禁止指令重排。</p>
<blockquote>
<p>对于 volatile 修改变量的读写操作，都会加入内存屏障。每个 volatile 写操作前面，加 StoreStore 屏障，禁止上面的普通写和他重排；每个 volatile 写操作后面，加 StoreLoad 屏障，禁止跟下面的 volatile 读/写重排。每个 volatile 读操作后面，加 LoadLoad 屏障，禁止下面的普通读和 voaltile 读重排；每个 volatile 读操作后面，加 LoadStore 屏障，禁止下面的普通写和 volatile 读重排。</p>
</blockquote>
<h3 id="synchronized-为什么又叫内置锁？">synchronized 为什么又叫内置锁？</h3>
<p>synchronized 是内置于 JDK 中的，底层实现是 native，由 C/C++ 语言实现；同时，加锁、解锁都是 JDK 自动完成，不需要用户显示控制，非常方便。</p>
<h4 id="❗说说-synchronized-关键字的底层原理">❗说说 synchronized 关键字的底层原理</h4>
<p><strong>因为 synchronized 可以同时保证原子性、可见性和有序性，所以在并发编程中经常会用到他，synchronized 主要有三种用法</strong>：修饰实例方法、修饰静态方法、修饰代码块。</p>
<p>synchronized 修饰代码块时，JVM 采用 monitorenter 、monitorexit 两个指令来实现同步，monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指向同步代码块的结束位置。</p>
<p>synchronized 修饰同步方法时，JVM 采用 ACC_SYNCHRONIZED 标记符来实现同步，这个标了该方法是一个同步方法。</p>
<p>❗大白话（修饰代码块）：每个对象实例都会关联一个 monitor，一个类的 class 对象也会关联一个 monitor。一个线程过来，把 monitor 置 1（可以重复加锁，二次加 monitor 变成 2、3…）。当线程走出 synchronized，执行 monitorexit，底层获取对应的 monitor 进行释放。线程 2 加锁失败，陷入一个阻塞等待的状态。</p>
<h5 id="Syncrhronized-怎么保证可见性？">Syncrhronized 怎么保证可见性？</h5>
<p>JMM 中使用 happens-before 语义：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>线程解锁前，必须把共享变量的最新值刷新到主内存中。</p>
</li>
<li class="lvl-2">
<p>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新获取最新的值。（注意：加锁与解锁需要是同一把锁）</p>
</li>
</ul>
<h5 id="Synchronized-怎么保证原子性？">Synchronized 怎么保证原子性？</h5>
<h6 id="为什么会有两个-monitorexit-呢？">为什么会有两个 monitorexit 呢？</h6>
<p>这个主要是防止在同步代码块中线程因异常退出，而锁没有得到释放，这必然会造成死锁（等待的线程永远获取不到锁）。因此最后一个 monitorexit 是保证在异常情况下，锁也可以得到释放，避免死锁，它由编译器自动产生的一个异常处理器来执行。</p>
<h6 id="synchronized-可重入的原理">synchronized 可重入的原理</h6>
<p>重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁，且不再被阻塞。底层原理维护一个计数器，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为 0 时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。</p>
<h4 id="Synchronized-怎么保证有序性？">Synchronized 怎么保证有序性？</h4>
<p>首先，Synchronized 保证有序性，但不表示他能禁止指令重排。</p>
<p>而之所以会有序性问题，是因为硬件层面做了很多优化，比如处理器做强化和指令重排等，这些技术引入会导致有序性问题。这有序性问题主要出在多线程中，因为单线程中是遵循 JMM 的 as-if-serial 语义的，能保证数据间的依赖关系的，比如 A 依赖于 B，B 依赖于 C，那 A 的实现之前，必须会先执行 C。as-if-serial 语义的意思是：不管怎么重排序，单线程程序的执行结果不能被改变。编译器、runtime 和处理器都必须遵守 as-if-serial 语义。</p>
<p>但是多线程就可能因为指令重排导致在另一个线程中先执行到了 C，多线程程序的语义就被重排序破坏了！Synchronized 同步代码块可以锁住当前线程，这样每个线程单独执行，就可以保证有序性了。</p>
<h4 id="Synchronized-和监视器（monitor）有什么关系？为什么-Synchronized-可以使用任意对象？">Synchronized 和监视器（monitor）有什么关系？为什么 Synchronized 可以使用任意对象？</h4>
<p>首先，每个对象都可以被认为是一个“监视器 monitor”，这个监视器由三部分组成：<strong>独占锁、入口队列，等待队列</strong>。</p>
<p>注意：一个对象只能有一个独占锁，但是任意线程都可以拥有这个独占锁（说白了，锁占锁就是一个标记）。</p>
<p>Synchronized 需要获取对象锁，实际上就是获取的是对象中的独占锁，通过这个标记来判断是否已有线程进入占用（所以 synchronized 无论使用什么对象都可以，每个对象在堆中都有独占锁）。</p>
<p>而入口队列中放的则是要竞争锁资源的其他线程，如果线程使用了 wait 方法，则进入对象的等待列队中。</p>
<h4 id="Synchronized-中的锁中什么是重量锁（对象锁），自旋锁，自适应自旋锁，轻量锁，偏向锁，锁消除，锁粗化？">Synchronized 中的锁中什么是重量锁（对象锁），自旋锁，自适应自旋锁，轻量锁，偏向锁，锁消除，锁粗化？</h4>
<p>线程的阻塞和唤醒需要 CPU 从用户态转为核心态，频繁的阻塞和唤醒对 CPU 来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的，所以引入自旋锁。</p>
<p>就是等待锁的线程并不进入阻塞状态，而是执行一个无意义的循环。在循环结束后查看锁是否已经被释放，若已经释放则直接进入执行状态。因为长时间无意义循环也会大量浪费系统资源，因此自旋锁适用于间隔时间短的加锁场景。</p>
<p><strong>自适应自旋锁：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>自适应就意味着<strong>自旋的次数不再是固定</strong>的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</p>
</li>
</ul>
<p><strong>偏向锁：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>偏向于第一个获得它的线程。当线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID，以后该线程在进入和退出同步块时不需要花进行 CAS 加锁和解锁操作。适用于只有 1 个线程的情况。无法代替重量锁。</p>
</li>
</ul>
<p><strong>轻量锁：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果有第二线程过来竞争，则从偏向锁升级为轻量锁，线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败。适用于只有 2 个线程情况。无法代替重量锁。</p>
</li>
</ul>
<p><strong>重量锁：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>当有 3 个及以上的线程竞争时，升级为重量锁，获得锁的执行，没获得锁的阻塞挂起，直到持有锁的线程执行完同步块唤醒它们。重量级锁通过对象内部的监视器（monitor）实现，其中 monitor 的本质是依赖于底层操作系统的实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</p>
</li>
</ul>
<p><strong>锁消除：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>JVM 检测到不可能存在共享数据竞争，这时 JVM 会对这些同步锁进行锁消除。比如一个方法中使用变量是属于自己方法中的，那么这个变量是只属于该线程自己的，其他线程抢不走，这时候这个方法中的变量就没必要加锁了。锁消除的依据是逃逸分析（底层判断该数据是否有被全局引用或者程序指向无法被访问到的地方等）的数据支持。</p>
</li>
</ul>
<p><strong>锁粗化：</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>锁粗化就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如上面实例：vector 每次 add 的时候都需要加锁操作，JVM 检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到 for 循环之外。</p>
</li>
</ul>
<h5 id="多线程中-synchronized-锁升级的原理是什么？">多线程中 synchronized 锁升级的原理是什么？</h5>
<p>偏向所锁，轻量级锁都是乐观锁，重量级锁是悲观锁。</p>
<p>一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁。偏向第一个线程，这个线程在修改对象头成为偏向锁的时候使用 CAS 操作，并将对象头中的 ThreadID 改成自己的 ID，之后再次访问这个对象时，只需要对比 ID，不需要再使用 CAS 在进行操作。</p>
<p>一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象时偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，（偏向锁就是这个时候升级为轻量级锁的）。如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。</p>
<p>轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止 CPU 空转。</p>
<p><strong>Synchronized 锁只会自动升级，不会降级（ReentrantReadWriteLock 读写锁可以降级）。</strong></p>
<h3 id="synchronized-和-volatile-的区别是什么？">synchronized 和 volatile 的区别是什么？</h3>
<p>synchronized 表示只有一个线程可以获取作用对象的锁，执行代码，阻塞其他线程。</p>
<p>volatile 表示变量在 CPU 的寄存器中是不确定的，必须从主存中读取。保证多线程环境下变量的可见性；禁止指令重排序。</p>
<p>区别：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>volatile 是变量修饰符；synchronized 可以修饰类、方法、变量。</p>
</li>
<li class="lvl-2">
<p>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</p>
</li>
<li class="lvl-2">
<p>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</p>
</li>
<li class="lvl-2">
<p>volatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</p>
</li>
</ul>
<h3 id="❗对-CAS-的理解及其底层实现原理">❗对 CAS 的理解及其底层实现原理</h3>
<p>CAS 叫做比较并交换，CAS 指令包含 3 个参数：新值，旧值，内存值（内存位置），线程会先获取内存值，然后复制到变量副本，生成旧值，旧值在一系列操作后生成新值。</p>
<p>若旧值=内存值，说明没有被其他线程抢先占有，则修改内存值为新值；</p>
<p>若旧值≠内存值，说明内存值已经被其他线程修改，则自旋获取新的内存值，然后重新操作。</p>
<p>大白话：比如说使用 synchronized 对于代码块进行加锁，这个时候多个线程的执行是串行的。比如一个累加的计数器，优化可以把 int 类型的累加字段改成<strong>AtomicInteger</strong>类型（<strong>原子类</strong>），方法改为 incrementAndGet，此时不用 synchronized 也是线程安全的。这个原子类底层就是 CAS（Compare and Set）。在线程执行 incrementAndGet 时，会先读取，再尝试设置：当一个线程成功执行 CAS 操作（就是对比旧值是否是原来的值），另一个就会失败，失败就会重新读取，再次设置。</p>
<h4 id="❗CAS-会出现经典的-ABA-问题">❗CAS 会出现经典的 ABA 问题</h4>
<p>原因：第一个线程刚获得 A，第二个线程就抢走也获得 A，然后改成 B 后又改成 A，这时候第一个线程发现变量是 A，就继续执行。但是这样会出现潜藏的问题，比如修改的是金额，存一笔和存两笔是两个概念。</p>
<p>解决：加入版本号解决。</p>
<h3 id="❗对-JDK-中的-AQS-的理解，AQS-的实现原理">❗对 JDK 中的 AQS 的理解，AQS 的实现原理</h3>
<p>多线程访问数据除了 synchronized，CAS，ConcurrentHashMap，还有 Lock。ReentrantLock 的底层就是 AQS（Abstract Queue Synchronizer）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">// 默认使用非公平锁</span></span><br><span class="line"><span class="comment">// 传入参数true，就使用公平锁</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">lock.lock();</span><br><span class="line"></span><br><span class="line">look.unlock();</span><br></pre></td></tr></table></figure>
<p>大白话：AQS 底层有个 state，多个线程执行 CAS 更新 state；还有一个变量记录加锁线程。AQS 中会有一个等待队列的概念。当前一个线程释放了锁，会去唤醒等待队列中的队首元素。</p>
<p>非公平锁：在唤醒等待队列的过程中，如果有另一个线程抢占锁，是可以成功的。</p>
<p>公平锁：在唤醒等待队列的过程中，如果需要抢占锁，需要加入到等待队列内，进行等待。</p>
<h4 id="ReetrantReadWriteLock-读写锁和-RenntrantLock-有什么区别？">ReetrantReadWriteLock 读写锁和 RenntrantLock 有什么区别？</h4>
<p>ReentrantLock 有一定的局限性，它的读锁与读锁间也会互斥，但读数据并不会改动数据，没有必要加锁保护，这就降低了程序的性能。</p>
<p>因以上问题，诞生了读写锁，读写锁一种读写分离技术，它的读锁是共享的，写锁是独占的，也就是说，多个线程是可以一起读数据的，只有写数据的时候，才会同步线程。</p>
<h4 id="读写锁-ReentrantReadWriteLock-有什么特点？">读写锁 ReentrantReadWriteLock 有什么特点？</h4>
<ol>
<li class="lvl-3">
<p>公平性可以选择：支持非公平 (默认) 和公平的锁获取，吞吐量非公平优于公平。</p>
</li>
<li class="lvl-3">
<p>重进入：读锁和写锁都支持线程重进入。</p>
</li>
<li class="lvl-3">
<p>锁降级：获取写锁，再获取读锁，然后释放写锁，这样写锁就降级为了读锁。（注：Synchronized 是不能进行锁降级的，意义不一样）。</p>
</li>
</ol>
<h3 id="ReentrantLock-与-Synchronized-的区别">ReentrantLock 与 Synchronized 的区别</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>二者的本质区别：synchronized 是关键字，ReentrantLock 是一个类 相同点：这两个都是可重入锁。</p>
</li>
<li class="lvl-2">
<p>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁</p>
</li>
<li class="lvl-2">
<p>ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等。</p>
</li>
</ul>
<h3 id="什么是死锁？">什么是死锁？</h3>
<p>A 需要 B 解锁，B 需要 A 解锁，两个都在中间互相等待，却谁也无法满足条件，从而发生阻塞，就是死锁。</p>
<p><strong>怎么防止死锁？</strong></p>
<ol>
<li class="lvl-3">
<p>不要写嵌套锁，容易死锁；</p>
</li>
<li class="lvl-3">
<p>尽量少用同步代码块 (Synchronized);</p>
</li>
<li class="lvl-3">
<p>尽量使用 ReentrantLock 的 tryLock 方法设置超时时间，超时可以退出，防止死锁；</p>
</li>
<li class="lvl-3">
<p>尽量降低锁粒度，尽量不要几个功能一把锁；</p>
</li>
<li class="lvl-3">
<p>尽量使用 JUC 包；</p>
</li>
</ol>
<h3 id="❗ConcurrentHashMap-实现线程安全的底层原理">❗ConcurrentHashMap 实现线程安全的底层原理</h3>
<p>JDK1.8 以前，多个数组，分段加锁，一个数组一个锁。他将一个大的 ConcurrentHashMap 分成 16 个小的 Segment。也就是说可以同时承受 16 个线程的并发。</p>
<p>JDK1.8 以后，数组里每个元素进行 put 操作，都是有一个不同的锁，对当个位置进行 put 操作时，采取的是 CAS 的策略。如果 CAS 操作失败，就使用 synchronized 对这个位置的对象进行锁定，然后基于链表或红黑树，对数组元素进行写入。</p>
<h2 id="多线程">多线程</h2>
<h3 id="❗创建线程的-4-种方法">❗创建线程的 4 种方法</h3>
<ol>
<li class="lvl-3">
<p>继承 Thread 类通过继承 Thread 类，并重写它的 run 方法，我们就可以创建一个线程。</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>首先定义一个类来继承 Thread 类，重写 run 方法。</p>
</li>
<li class="lvl-2">
<p>然后创建这个子类对象，并调用 start 方法启动线程。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">5</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 重写父类中的run()， 执行具体的业务逻辑  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">        count--;  </span><br><span class="line">        System.out.println(count);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="comment">//1. 创建线程对象的实例， 该对象必须继承Thread类及重写了run()  </span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">my</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//2. 创建多个线程的实例， 进入线程的初始化状态  </span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(my);  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(my);  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(my);  </span><br><span class="line">  </span><br><span class="line">      <span class="comment">/*3. 启动线程， 线程只有执行start()之后才算是真正的启动, 才会执行run()方法里面的具体逻辑  </span></span><br><span class="line"><span class="comment">         线程启动后会进入线程的就绪状态，等待CPU的调用*/</span>  </span><br><span class="line">        t1.start();  </span><br><span class="line">        t2.start();  </span><br><span class="line">        t3.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li class="lvl-3">
<p>实现 Runnable 接口通过实现 Runnable ，并实现 run 方法，也可以创建一个线程。</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>首先定义一个类实现 Runnable 接口，并实现 run 方法。</p>
</li>
<li class="lvl-2">
<p>然后创建 Runnable 实现类对象，并把它作为 target 传入 Thread 的构造函数中</p>
</li>
<li class="lvl-2">
<p>最后调用 start 方法启动线程。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;thread run ......&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableThread</span>()).run();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li class="lvl-3">
<p>实现 Callable 接口，并结合 Future 实现</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>首先定义一个 Callable 的实现类，并实现 call 方法。call 方法是带返回值的。</p>
</li>
<li class="lvl-2">
<p>然后通过 FutureTask 的构造方法，把这个 Callable 实现类传进去。</p>
</li>
<li class="lvl-2">
<p>把 FutureTask 作为 Thread 类的 target ，创建 Thread 线程对象。</p>
</li>
<li class="lvl-2">
<p>通过 FutureTask 的 get 方法获取线程的执行结果。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFuture</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123; </span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">CallableThread</span>());  </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();  </span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> futureTask.get();  </span><br><span class="line">        System.out.println(o);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallableThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;call一下&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li class="lvl-3">
<p>通过线程池创建线程此处用 JDK 自带的 Executors 来创建线程池对象。</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-2">
<p>首先，定一个 Runnable 的实现类，重写 run 方法。</p>
</li>
<li class="lvl-2">
<p>然后创建一个拥有固定线程数的线程池。</p>
</li>
<li class="lvl-2">
<p>最后通过 ExecutorService 对象的 execute 方法传入线程对象。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;run一下&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);  </span><br><span class="line">        executorService.execute(<span class="keyword">new</span> <span class="title class_">ExecutorThread</span>());  </span><br><span class="line">        executorService.shutdown();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="说一下-runnable-和-callable-有什么区别？">说一下 runnable 和 callable 有什么区别？</h4>
<p>相同点：</p>
<ol>
<li class="lvl-3">
<p>都是接口</p>
</li>
<li class="lvl-3">
<p>都可以编写多线程程序</p>
</li>
<li class="lvl-3">
<p>都采用 Thread.start() 启动线程</p>
</li>
</ol>
<p>主要区别：</p>
<ol>
<li class="lvl-3">
<p>Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，是个泛型，和 Future、FutureTask 配合可以用来获取异步执行的结果。</p>
</li>
<li class="lvl-3">
<p>Runnable 接口 run 方法只能抛出运行时异常，且无法捕获处理；Callable 接口 call 方法允许抛出异常，可以获取异常信息。</p>
</li>
</ol>
<p><strong>注：Callalbe 接口支持返回执行结果，需要调用 FutureTask.get() 得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</strong></p>
<h4 id="线程的-run-和-start-有什么区别？">线程的 run() 和 start() 有什么区别？</h4>
<p>每个线程都是通过某个特定 Thread 对象所对应的方法 run() 来完成其操作的，run() 方法称为线程体。通过调用 Thread 类的 start() 方法来启动一个线程。</p>
<p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p>
<p>start() 方法来启动一个线程，真正实现了多线程运行。调用 start() 方法无需等待 run 方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此 Thread 类调用方法 run() 来完成其运行状态， run() 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。</p>
<p>run() 方法是在本线程里的，只是线程里的一个函数，而不是多线程的。 如果直接调用 run()，其实就相当于是调用了一个普通函数而已，直接待用 run() 方法必须等待 run() 方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用 start() 方法而不是 run() 方法。</p>
<h4 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？">为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h4>
<p>new 一个 Thread，线程进入了新建状态。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。</p>
<p>而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</p>
<h5 id="start-方法为什么能开启多线程？">start() 方法为什么能开启多线程？</h5>
<p>真正实现开启多线程的是 start() 方法中的 start0() 方法。</p>
<p>调用 start0() 方法后，该线程并不一定会立马执行，只是将线程变成了可运行状态（NEW —&gt; RUNNABLE）；具体什么时候执行，取决于 CPU ，由 CPU 统一调度；我们又知道 Java 是跨平台的，可以在不同系统上运行，每个系统的 CPU 调度算法不一样，所以就需要做不同的处理，这件事情就只能交给 JVM 来实现了，start0() 方法自然就表标记成了 native。</p>
<h3 id="如何避免线程死锁">如何避免线程死锁</h3>
<p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p>
<p><strong>破坏互斥条件</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p>
</li>
</ul>
<p><strong>破坏请求与保持条件</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>一次性申请所有的资源。</p>
</li>
</ul>
<p><strong>破坏不剥夺条件</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p>
</li>
</ul>
<p><strong>破坏循环等待条件</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p>
</li>
</ul>
<h3 id="线程的-6-种状态是什么？">线程的 6 种状态是什么？</h3>
<ol>
<li class="lvl-3">
<p>新建状态（new）：创建线程对象。</p>
</li>
<li class="lvl-3">
<p>就绪状态（runnable）：start 方法。</p>
</li>
<li class="lvl-3">
<p>阻塞状态（blocked）：无法获得锁对象（线程没抢到）。</p>
</li>
<li class="lvl-3">
<p>等待状态（waiting）：wait 方法。</p>
</li>
<li class="lvl-3">
<p>计时状态（timed_waiting）：sleep 方法。</p>
</li>
<li class="lvl-3">
<p>死亡状态（terminated）：全部代码运行完毕。</p>
</li>
</ol>
<h3 id="线程的调度模式是什么？">线程的调度模式是什么？</h3>
<p>分时调度：轮流获取 CPU 使用权。</p>
<p>抢占式调度：优先级高的线程占用 CPU。</p>
<h3 id="请说出与线程同步以及线程调度相关的方法">请说出与线程同步以及线程调度相关的方法</h3>
<ol>
<li class="lvl-3">
<p>wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</p>
</li>
<li class="lvl-3">
<p>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常；</p>
</li>
<li class="lvl-3">
<p>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；</p>
</li>
<li class="lvl-3">
<p>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</p>
</li>
</ol>
<h3 id="sleep-和-wait-有什么区别？">sleep() 和 wait() 有什么区别？</h3>
<p>相同点：两者都可以暂停线程的执行。</p>
<p>不同点：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>sleep 方法，不会释放资源（本质是占用线程），如果占具锁资源，则其他线程不可进；wait 方法会释放锁资源，即其他线程可进来。</p>
</li>
<li class="lvl-2">
<p>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout) 超时后线程会自动苏醒。</p>
</li>
</ul>
<h3 id="Java-中你怎样唤醒一个阻塞的线程？">Java 中你怎样唤醒一个阻塞的线程？</h3>
<p>首先 ，wait()、notify() 方法是针对对象的，调用任意对象的 wait() 方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的 notify() 方法则将随机解除该对象阻塞的线程，但它需要重新获取该对象的锁，直到获取成功才能往下执行；</p>
<p>其次，wait、notify 方法必须在 synchronized 块或方法中被调用，并且要保证同步块或方法的锁对象与调用 wait、notify 方法的对象是同一个，如此一来在调用 wait 之前当前线程就已经成功获取某对象的锁，执行 wait 阻塞后当前线程就将之前获取的对象锁释放。</p>
<h3 id="notify-和-notifyAll-有什么区别？">notify() 和 notifyAll() 有什么区别？</h3>
<p>如果线程调用了对象的 wait() 方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</p>
<p>notifyAll() 会唤醒所有的线程，notify() 只会唤醒一个线程。</p>
<p>notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify() 只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p>
<h3 id="为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？">为什么 wait(), notify() 和 notifyAll() 必须在同步方法或者同步块中被调用？</h3>
<p>这是 JDK 强制的，wait() 方法和 notify()/notifyAll() 方法在调用前都必须先获得对象的锁，也就是 synchronized 对象锁。</p>
<h3 id="Java-线程数过多会造成什么异常？">Java 线程数过多会造成什么异常？</h3>
<ol>
<li class="lvl-3">
<p>线程的生命周期开销非常高</p>
</li>
<li class="lvl-3">
<p>消耗过多的 CPU 资源如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争 CPU 资源时还将产生其他性能的开销。</p>
</li>
<li class="lvl-3">
<p>降低稳定性.JVM 在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出 OutOfMemoryError 异常。</p>
</li>
</ol>
<h3 id="ThreadLocal">ThreadLocal</h3>
<p>Threadlocal 是一个线程内部的存储类，提供了线程内存储变量的能力,可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据。这些变量不同之处在于每一个线程读取的变量是对应的互相独立的。</p>
<p>其内部维护了一个 ThreadLocalMap，该 Map 用于存储每一个线程的变量副本。并且 key 为线程对象，value 为对应线程的变量副本。</p>
<h2 id="线程池">线程池</h2>
<h3 id="Executors-类有哪几种常见的线程池？">Executors 类有哪几种常见的线程池？</h3>
<p>4 种：单例线程池、固定大小线程池、可缓存线程池、大小无限线程池。</p>
<p>（1）newSingleThreadExecutor：创建一个单例线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p>
<p>（2）newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。如果希望在服务器上使用线程池，建议使用 newFixedThreadPool 方法来创建线程池，这样能获得更好的性能。</p>
<p>（3） newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。</p>
<p>（4）newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
<h3 id="❗说说线程池的底层工作原理">❗说说线程池的底层工作原理</h3>
<p>避免频繁的创建线程，销毁线程……</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>) <span class="comment">// corePoolSize</span></span><br></pre></td></tr></table></figure>
<p>如果线程池内数量小于 corePoolSize，就会创建一个线程执行任务。线程池一般会带一个队列，当线程执行任务完成，会等待阻塞在队列上（队首），尝试从队列继续获取任务。如果任务多于 corePoolSize，会进入阻塞队列。如果阻塞队列满了，可以根据 maximumPoolSize 创建额外的线程。额外线程的空闲时间根据 keepAliveTime 进行自行销毁。</p>
<p>如果额外的线程都创建完了，队列还是满的，还有新来的任务。会 reject 掉，有几种 reject 策略，可以传入 RejectedExecutionHandler。</p>
<ol>
<li class="lvl-3">
<p>AbortPolicy：抛异常</p>
</li>
<li class="lvl-3">
<p>DiscardPolicy：扔掉</p>
</li>
<li class="lvl-3">
<p>DiscardOldestPolicy：删除最旧的任务</p>
</li>
<li class="lvl-3">
<p>CallerRunsPolicy</p>
</li>
<li class="lvl-3">
<p>自定义</p>
</li>
</ol>
<p>（常用）FixedThreadPool 的队列是 LinkedBlockingQueue，无界阻塞队列，即队列长度无线大。corePoolSize 与 maximumPoolSize 一样大。</p>
<h4 id="❗线程池的核心配置参数">❗线程池的核心配置参数</h4>
<p>代表线程池的类是 ThreadPoolExecutor。corePoolSize（核心线程数），maximumPoolSize（线程池），keepAliveTime（多余的空闲线程在终止之前等待新任务的最长时间），workQueue（阻塞队列）。</p>
<p>七个核心参数：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>参数一：核心线程数（不能小于 0）</p>
</li>
<li class="lvl-2">
<p>参数二：最大线程数（&gt;=核心线程数）</p>
</li>
<li class="lvl-2">
<p>参数三：临时线程最大存活时间（不能小于 0）</p>
</li>
<li class="lvl-2">
<p>参数四：时间单位（参数三的单位）</p>
</li>
<li class="lvl-2">
<p>参数五：等待列队（不能为 null）</p>
</li>
<li class="lvl-2">
<p>参数六：创建线程工厂（不能为 null，一般用默认线程工厂）</p>
</li>
<li class="lvl-2">
<p>参数七：任务的拒绝策略（不能为 null）</p>
</li>
</ul>
<h5 id="拒绝策略有哪些">拒绝策略有哪些</h5>
<ol>
<li class="lvl-3">
<p>ThreadPoolExecutor.AbortPolicy：丢弃任务并抛出异常（默认）；</p>
</li>
<li class="lvl-3">
<p>ThreadPoolExecutor.DiscardPolicy：丢弃任务，不抛异常（不推荐）；</p>
</li>
<li class="lvl-3">
<p>ThreadPoolExecutor.DiscardOldestPolicy：丢弃等待最久的线程；</p>
</li>
<li class="lvl-3">
<p>ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程（main）运行 run 方法。</p>
</li>
</ol>
<h4 id="❗如果在线程池中使用无界阻塞队列会发生什么问题？">❗如果在线程池中使用无界阻塞队列会发生什么问题？</h4>
<blockquote>
<p>面试题：在远程服务异常的情况下，使用无界阻塞队列，是否会导致内存异常飙升？</p>
<p>调用超时，队列变得越来越大，会导致内存飙升，可能还会导致 OOM</p>
</blockquote>
<h4 id="❗线程池队列满了之后，会发生什么事情">❗线程池队列满了之后，会发生什么事情</h4>
<p>无界队列，内存溢出。</p>
<p>有界队列，但是如果 maximumPoolSize 数量很大，可以无限制创建线程，但是每个线程占用栈内存，可能会导致内存资源耗尽，或者线程太多，CPU 负载太高。</p>
<p>有界队列，maximumPoolSize 数量固定，多余的任务会被拒绝。</p>
<p>建议：自定义一个 reject 策略，如果线程池无法执行更多任务，可以把任务信息持久化写入磁盘。等负载降低重新执行这些任务。</p>
<h4 id="❗如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？">❗如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？</h4>
<p>线程池内积压的任务丢失。</p>
<p>解决：在提交任务前，在数据库内插入任务信息，并更新他的状态：已提交、未提交、已完成……。系统重启后把任务状态重新提交。</p>

                </div>
                
                        
<div class="post-copyright-info-container border-box">
    <div class="copyright-info-content border-box">
        <div class="copyright-info-top border-box">
            <div class="copyright-post-title border-box text-ellipsis">
                面试-并发🤕
            </div>

            <div class="copyright-post-link border-box text-ellipsis">
                posts/40294c75/
            </div>
        </div>

        <div class="copyright-info-bottom border-box">
            <div class="copyright-post-author bottom-item">
                <div class="type">
                    作者
                </div>
                <div class="content">Kiml</div>
            </div>

            <div class="post-time bottom-item">
                <div class="type">
                    发布于
                </div>
                <div class="content">2024-06-03 21:42</div>
            </div>


            <div class="post-license bottom-item">
                <div class="type">
                    许可
                </div>
                <div class="content tooltip" data-tooltip-content="CC BY-NC-SA 4.0">
                    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans" target="_blank">
                        
                            <i class="fa-brands fa-creative-commons"></i>
                            <i class="fa-brands fa-creative-commons-by"></i>
                            <i class="fa-brands fa-creative-commons-nc"></i>
                            <i class="fa-brands fa-creative-commons-sa"></i>
                        
                    </a>
                </div>
            </div>
        </div>

        <i class="copyright-bg fa-solid fa-copyright"></i>
    </div>
    <div class="copy-copyright-info flex-center tooltip" data-tooltip-content="复制版权信息" data-tooltip-offset-y="-2px">
        <i class="fa-solid fa-copy"></i>
    </div>
</div>

                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                            <ul class="post-tags-box border-box">
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/%E9%9D%A2%E8%AF%95/">面试</a>
                                    </li>
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/">八股文</a>
                                    </li>
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
                                    </li>
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池</a>
                                    </li>
                                
                            </ul>
                        
                    </div>
                    <div>
                        
                    </div>
                </div>

                

                
                    <div class="post-nav border-box">
                        
                            <div class="prev-post">
                                <a class="prev"
                                   rel="prev"
                                   href="/posts/39075b30/"
                                   title="代码随想录算法训练营第十四天-104二叉树的最大深度、111二叉树的最小深度、222完全二叉树的节点个数"
                                >
                                    <span class="left arrow-icon flex-center">
                                        <i class="fas fa-chevron-left"></i>
                                    </span>
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">代码随想录算法训练营第十四天-104二叉树的最大深度、111二叉树的最小深度、222完全二叉树的节点个数</span>
                                        <span class="post-nav-item">上一篇</span>
                                    </span>
                                </a>
                            </div>
                        
                        
                            <div class="next-post">
                                <a class="next"
                                   rel="next"
                                   href="/posts/3a228d8a/"
                                   title="面试-基础"
                                >
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">面试-基础</span>
                                        <span class="post-nav-item">下一篇</span>
                                    </span>
                                    <span class="right arrow-icon flex-center">
                                        <i class="fas fa-chevron-right"></i>
                                    </span>
                                </a>
                            </div>
                        
                    </div>
                

                
                    


    <div class="comments-container border-box">
        <div id="comments-anchor" class="comment-area-title border-box">
            <i class="fas fa-comments"></i>&nbsp;评论
        </div>
        <div class="comment-plugin-fail border-box">
    <span class="fail-tip">评论插件加载失败</span>
    <button class="reload keep-button">点击重新加载</button>
</div>
<div class="comment-plugin-loading flex-center border-box">
    <i class="loading-icon fa-solid fa-spinner fa-spin"></i>
    <span class="load-tip">正在加载评论插件</span>
</div>
<script data-pjax>
  window.KeepCommentPlugin = {}
  window.KeepCommentPlugin.hideLoading = () => {
    const cplDom = document.querySelector('.comments-container .comment-plugin-loading')
    cplDom.style.display = 'none'
  }
  window.KeepCommentPlugin.loadFailHandle = () => {
    window.KeepCommentPlugin.hideLoading()
    const cpfDom = document.querySelector('.comments-container .comment-plugin-fail')
    cpfDom.style.display = 'flex'
    cpfDom.querySelector('.reload').addEventListener('click', () => {
      window.location.reload()
    })
  }
</script>

        
            

    <div class="configuration-items-error-tip border-box">
    <i class="fa-solid fa-circle-exclamation"></i>
    请完整填写 Valine 评论插件必需的配置项
</div>



        
    </div>





                
            </div>
        </div>

        
            <div class="pc-post-toc right-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <!-- use hexo-blog-encrypt -->
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%88%E9%94%81%EF%BC%89"><span class="nav-text">高并发（锁）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%97Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-text">❗Java 内存模型的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%97Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-text">❗Java 内存模型中的原子性、有序性、可见性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%97%E4%BB%8E-Java-%E5%BA%95%E5%B1%82%E8%A7%92%E5%BA%A6%E8%81%8A%E8%81%8A-volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-text">❗从 Java 底层角度聊聊 volatile 关键字的原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%97%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E4%BB%A5%E5%8F%8A-happens-before-%E5%8E%9F%E5%88%99"><span class="nav-text">❗指令重排以及 happens-before 原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%97volatile-%E5%BA%95%E5%B1%82%E6%98%AF%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E7%9A%84"><span class="nav-text">❗volatile 底层是如何基于内存屏障保证可见性和有序性的</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%88%E5%8F%AB%E5%86%85%E7%BD%AE%E9%94%81%EF%BC%9F"><span class="nav-text">synchronized 为什么又叫内置锁？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%97%E8%AF%B4%E8%AF%B4-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-text">❗说说 synchronized 关键字的底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Syncrhronized-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%9F"><span class="nav-text">Syncrhronized 怎么保证可见性？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Synchronized-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9F"><span class="nav-text">Synchronized 怎么保证原子性？</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E4%B8%A4%E4%B8%AA-monitorexit-%E5%91%A2%EF%BC%9F"><span class="nav-text">为什么会有两个 monitorexit 呢？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#synchronized-%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-text">synchronized 可重入的原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Synchronized-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%9F"><span class="nav-text">Synchronized 怎么保证有序性？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Synchronized-%E5%92%8C%E7%9B%91%E8%A7%86%E5%99%A8%EF%BC%88monitor%EF%BC%89%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88-Synchronized-%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E4%BB%BB%E6%84%8F%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="nav-text">Synchronized 和监视器（monitor）有什么关系？为什么 Synchronized 可以使用任意对象？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Synchronized-%E4%B8%AD%E7%9A%84%E9%94%81%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E9%87%8F%E9%94%81%EF%BC%88%E5%AF%B9%E8%B1%A1%E9%94%81%EF%BC%89%EF%BC%8C%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%8C%E8%87%AA%E9%80%82%E5%BA%94%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%8C%E8%BD%BB%E9%87%8F%E9%94%81%EF%BC%8C%E5%81%8F%E5%90%91%E9%94%81%EF%BC%8C%E9%94%81%E6%B6%88%E9%99%A4%EF%BC%8C%E9%94%81%E7%B2%97%E5%8C%96%EF%BC%9F"><span class="nav-text">Synchronized 中的锁中什么是重量锁（对象锁），自旋锁，自适应自旋锁，轻量锁，偏向锁，锁消除，锁粗化？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD-synchronized-%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">多线程中 synchronized 锁升级的原理是什么？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-%E5%92%8C-volatile-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">synchronized 和 volatile 的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%97%E5%AF%B9-CAS-%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">❗对 CAS 的理解及其底层实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%97CAS-%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%BB%8F%E5%85%B8%E7%9A%84-ABA-%E9%97%AE%E9%A2%98"><span class="nav-text">❗CAS 会出现经典的 ABA 问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%97%E5%AF%B9-JDK-%E4%B8%AD%E7%9A%84-AQS-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8CAQS-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">❗对 JDK 中的 AQS 的理解，AQS 的实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ReetrantReadWriteLock-%E8%AF%BB%E5%86%99%E9%94%81%E5%92%8C-RenntrantLock-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">ReetrantReadWriteLock 读写锁和 RenntrantLock 有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81-ReentrantReadWriteLock-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="nav-text">读写锁 ReentrantReadWriteLock 有什么特点？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock-%E4%B8%8E-Synchronized-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">ReentrantLock 与 Synchronized 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="nav-text">什么是死锁？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%97ConcurrentHashMap-%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-text">❗ConcurrentHashMap 实现线程安全的底层原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%97%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84-4-%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-text">❗创建线程的 4 种方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-runnable-%E5%92%8C-callable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">说一下 runnable 和 callable 有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84-run-%E5%92%8C-start-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">线程的 run() 和 start() 有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%B0%83%E7%94%A8-start-%E6%96%B9%E6%B3%95%E6%97%B6%E4%BC%9A%E6%89%A7%E8%A1%8C-run-%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8-run-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-text">为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#start-%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E5%BC%80%E5%90%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-text">start() 方法为什么能开启多线程？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="nav-text">如何避免线程死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84-6-%E7%A7%8D%E7%8A%B6%E6%80%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">线程的 6 种状态是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">线程的调度模式是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E8%AF%B4%E5%87%BA%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">请说出与线程同步以及线程调度相关的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep-%E5%92%8C-wait-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">sleep() 和 wait() 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E4%B8%AD%E4%BD%A0%E6%80%8E%E6%A0%B7%E5%94%A4%E9%86%92%E4%B8%80%E4%B8%AA%E9%98%BB%E5%A1%9E%E7%9A%84%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-text">Java 中你怎样唤醒一个阻塞的线程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#notify-%E5%92%8C-notifyAll-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">notify() 和 notifyAll() 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-wait-notify-%E5%92%8C-notifyAll-%E5%BF%85%E9%A1%BB%E5%9C%A8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E6%88%96%E8%80%85%E5%90%8C%E6%AD%A5%E5%9D%97%E4%B8%AD%E8%A2%AB%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="nav-text">为什么 wait(), notify() 和 notifyAll() 必须在同步方法或者同步块中被调用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E7%BA%BF%E7%A8%8B%E6%95%B0%E8%BF%87%E5%A4%9A%E4%BC%9A%E9%80%A0%E6%88%90%E4%BB%80%E4%B9%88%E5%BC%82%E5%B8%B8%EF%BC%9F"><span class="nav-text">Java 线程数过多会造成什么异常？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal"><span class="nav-text">ThreadLocal</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Executors-%E7%B1%BB%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="nav-text">Executors 类有哪几种常见的线程池？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%97%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">❗说说线程池的底层工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%97%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="nav-text">❗线程池的核心配置参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-text">拒绝策略有哪些</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%97%E5%A6%82%E6%9E%9C%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%97%A0%E7%95%8C%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">❗如果在线程池中使用无界阻塞队列会发生什么问题？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%97%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%98%9F%E5%88%97%E6%BB%A1%E4%BA%86%E4%B9%8B%E5%90%8E%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85"><span class="nav-text">❗线程池队列满了之后，会发生什么事情</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%97%E5%A6%82%E6%9E%9C%E7%BA%BF%E4%B8%8A%E6%9C%BA%E5%99%A8%E7%AA%81%E7%84%B6%E5%AE%95%E6%9C%BA%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E8%AF%B7%E6%B1%82%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-text">❗如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？</span></a></li></ol></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>
        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="copyright-info info-item">
        &copy;&nbsp;<span>2022</span>&nbsp;-&nbsp;2024
        
            &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">Kiml</a>
        
    </div>

    <div class="theme-info info-item">
        由&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;驱动&nbsp;&&nbsp;主题&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
    </div>

    

    
        <div class="count-info info-item">
            

            
                <span class="count-item border-box uv">
                    <span class="item-type border-box">访客数</span>
                    <span class="item-value border-box uv" id="busuanzi_value_site_uv"></span>
                </span>
            

            
                <span class="count-item border-box pv">
                    <span class="item-type border-box">访问量</span>
                    <span class="item-value border-box pv" id="busuanzi_value_site_pv"></span>
                </span>
            
        </div>
    

    
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="tools-list border-box">
        <!-- PC TOC show toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- PC go comment -->
        
            <li class="tools-item flex-center go-to-comments">
                <i class="fas fa-comment"></i>
                <span class="post-comments-count"></span>
            </li>
        

        <!-- PC full screen -->
        <li class="tools-item flex-center full-screen">
            <i class="fa-solid fa-expand"></i>
        </li>
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-toggle-theme-mode flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        
            <li class="tools-item toggle-show-toc-tablet flex-center">
                <i class="fas fa-list"></i>
            </li>
        

        
            <li class="tools-item go-to-comments-tablet flex-center">
                <i class="fas fa-comment"></i>
            </li>
        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

    <!-- tablet toc -->
    
        <div class="tablet-post-toc-mask">
            <div class="tablet-post-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <!-- use hexo-blog-encrypt -->
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E5%B9%B6%E5%8F%91%EF%BC%88%E9%94%81%EF%BC%89"><span class="nav-text">高并发（锁）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%97Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-text">❗Java 内存模型的理解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%97Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-text">❗Java 内存模型中的原子性、有序性、可见性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%97%E4%BB%8E-Java-%E5%BA%95%E5%B1%82%E8%A7%92%E5%BA%A6%E8%81%8A%E8%81%8A-volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-text">❗从 Java 底层角度聊聊 volatile 关键字的原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%97%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E4%BB%A5%E5%8F%8A-happens-before-%E5%8E%9F%E5%88%99"><span class="nav-text">❗指令重排以及 happens-before 原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%97volatile-%E5%BA%95%E5%B1%82%E6%98%AF%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E7%9A%84"><span class="nav-text">❗volatile 底层是如何基于内存屏障保证可见性和有序性的</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%88%E5%8F%AB%E5%86%85%E7%BD%AE%E9%94%81%EF%BC%9F"><span class="nav-text">synchronized 为什么又叫内置锁？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%97%E8%AF%B4%E8%AF%B4-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-text">❗说说 synchronized 关键字的底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Syncrhronized-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7%EF%BC%9F"><span class="nav-text">Syncrhronized 怎么保证可见性？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Synchronized-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9F"><span class="nav-text">Synchronized 怎么保证原子性？</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E4%B8%A4%E4%B8%AA-monitorexit-%E5%91%A2%EF%BC%9F"><span class="nav-text">为什么会有两个 monitorexit 呢？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#synchronized-%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-text">synchronized 可重入的原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Synchronized-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7%EF%BC%9F"><span class="nav-text">Synchronized 怎么保证有序性？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Synchronized-%E5%92%8C%E7%9B%91%E8%A7%86%E5%99%A8%EF%BC%88monitor%EF%BC%89%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88-Synchronized-%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E4%BB%BB%E6%84%8F%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="nav-text">Synchronized 和监视器（monitor）有什么关系？为什么 Synchronized 可以使用任意对象？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Synchronized-%E4%B8%AD%E7%9A%84%E9%94%81%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8D%E9%87%8F%E9%94%81%EF%BC%88%E5%AF%B9%E8%B1%A1%E9%94%81%EF%BC%89%EF%BC%8C%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%8C%E8%87%AA%E9%80%82%E5%BA%94%E8%87%AA%E6%97%8B%E9%94%81%EF%BC%8C%E8%BD%BB%E9%87%8F%E9%94%81%EF%BC%8C%E5%81%8F%E5%90%91%E9%94%81%EF%BC%8C%E9%94%81%E6%B6%88%E9%99%A4%EF%BC%8C%E9%94%81%E7%B2%97%E5%8C%96%EF%BC%9F"><span class="nav-text">Synchronized 中的锁中什么是重量锁（对象锁），自旋锁，自适应自旋锁，轻量锁，偏向锁，锁消除，锁粗化？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD-synchronized-%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">多线程中 synchronized 锁升级的原理是什么？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-%E5%92%8C-volatile-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">synchronized 和 volatile 的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%97%E5%AF%B9-CAS-%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">❗对 CAS 的理解及其底层实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%97CAS-%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%BB%8F%E5%85%B8%E7%9A%84-ABA-%E9%97%AE%E9%A2%98"><span class="nav-text">❗CAS 会出现经典的 ABA 问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%97%E5%AF%B9-JDK-%E4%B8%AD%E7%9A%84-AQS-%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8CAQS-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">❗对 JDK 中的 AQS 的理解，AQS 的实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ReetrantReadWriteLock-%E8%AF%BB%E5%86%99%E9%94%81%E5%92%8C-RenntrantLock-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">ReetrantReadWriteLock 读写锁和 RenntrantLock 有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E9%94%81-ReentrantReadWriteLock-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="nav-text">读写锁 ReentrantReadWriteLock 有什么特点？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReentrantLock-%E4%B8%8E-Synchronized-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">ReentrantLock 与 Synchronized 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="nav-text">什么是死锁？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%97ConcurrentHashMap-%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-text">❗ConcurrentHashMap 实现线程安全的底层原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%97%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84-4-%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-text">❗创建线程的 4 种方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B-runnable-%E5%92%8C-callable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">说一下 runnable 和 callable 有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84-run-%E5%92%8C-start-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">线程的 run() 和 start() 有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%B0%83%E7%94%A8-start-%E6%96%B9%E6%B3%95%E6%97%B6%E4%BC%9A%E6%89%A7%E8%A1%8C-run-%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8-run-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="nav-text">为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#start-%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E5%BC%80%E5%90%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-text">start() 方法为什么能开启多线程？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="nav-text">如何避免线程死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84-6-%E7%A7%8D%E7%8A%B6%E6%80%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">线程的 6 种状态是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">线程的调度模式是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E8%AF%B4%E5%87%BA%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%BB%A5%E5%8F%8A%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-text">请说出与线程同步以及线程调度相关的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep-%E5%92%8C-wait-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">sleep() 和 wait() 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E4%B8%AD%E4%BD%A0%E6%80%8E%E6%A0%B7%E5%94%A4%E9%86%92%E4%B8%80%E4%B8%AA%E9%98%BB%E5%A1%9E%E7%9A%84%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-text">Java 中你怎样唤醒一个阻塞的线程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#notify-%E5%92%8C-notifyAll-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">notify() 和 notifyAll() 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-wait-notify-%E5%92%8C-notifyAll-%E5%BF%85%E9%A1%BB%E5%9C%A8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E6%88%96%E8%80%85%E5%90%8C%E6%AD%A5%E5%9D%97%E4%B8%AD%E8%A2%AB%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="nav-text">为什么 wait(), notify() 和 notifyAll() 必须在同步方法或者同步块中被调用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-%E7%BA%BF%E7%A8%8B%E6%95%B0%E8%BF%87%E5%A4%9A%E4%BC%9A%E9%80%A0%E6%88%90%E4%BB%80%E4%B9%88%E5%BC%82%E5%B8%B8%EF%BC%9F"><span class="nav-text">Java 线程数过多会造成什么异常？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal"><span class="nav-text">ThreadLocal</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Executors-%E7%B1%BB%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="nav-text">Executors 类有哪几种常见的线程池？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%9D%97%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-text">❗说说线程池的底层工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%97%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="nav-text">❗线程池的核心配置参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-text">拒绝策略有哪些</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%97%E5%A6%82%E6%9E%9C%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%97%A0%E7%95%8C%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-text">❗如果在线程池中使用无界阻塞队列会发生什么问题？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%97%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%98%9F%E5%88%97%E6%BB%A1%E4%BA%86%E4%B9%8B%E5%90%8E%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85"><span class="nav-text">❗线程池队列满了之后，会发生什么事情</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%9D%97%E5%A6%82%E6%9E%9C%E7%BA%BF%E4%B8%8A%E6%9C%BA%E5%99%A8%E7%AA%81%E7%84%B6%E5%AE%95%E6%9C%BA%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E8%AF%B7%E6%B1%82%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-text">❗如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？</span></a></li></ol></li></ol></li></ol>
    </div>
</div>

            </div>
        </div>
    
</main>



<!-- common -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.3/js/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.3/js/header-shrink.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.3/js/back2top.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.3/js/toggle-theme.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.3/js/code-block.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.3/js/main.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.3/js/libs/anime.min.js"></script>

<!-- local-search -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.3/js/local-search.min.js"></script>


<!-- lazyload -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.3/js/lazyload.min.js"></script>


<div class="pjax">
    
        <!-- post-helper -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.3/js/post/post-helper.min.js"></script>

        <!-- toc -->
        
            <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.3/js/post/toc.min.js"></script>
        

        <!-- copyright-info -->
        
            <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.3/js/post/copyright-info.min.js"></script>
        

        <!-- share -->
        
    

    <!-- categories page -->
    

    <!-- links page -->
    

    <!-- photos page -->
    

    <!-- tools page -->
    
</div>

<!-- mermaid -->


<!-- pjax -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.1.3/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart()
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd()
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'))
            KEEP.initExecute()
        });
    });
</script>




</body>
</html>
