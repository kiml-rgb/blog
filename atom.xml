<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Keep Theme</title>
  
  <subtitle>Keep theme quick starter</subtitle>
  <link href="https://kiml.github.io/atom.xml" rel="self"/>
  
  <link href="https://kiml.github.io/"/>
  <updated>2024-07-21T13:43:26.342Z</updated>
  <id>https://kiml.github.io/</id>
  
  <author>
    <name>Keep Team</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 git 提交报错：error RPC failed; HTTP 413 curl 22 The requested URL returned error 413</title>
    <link href="https://kiml.github.io/posts/5a672f0a/"/>
    <id>https://kiml.github.io/posts/5a672f0a/</id>
    <published>2024-07-19T11:28:07.000Z</published>
    <updated>2024-07-21T13:43:26.342Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言参考文章：<a class="link"   href="https://blog.csdn.net/m0_55868614/article/details/120597702" >使用git提交时报错：error: RPC failed； HTTP 413 curl 22 The requested URL returned error: 413 Request Entity<i class="fas fa-external-link-alt"></i></a></p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-07-19 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="问题">问题</h2><p>使用 git push 时报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Total 254 (delta 50), reused 0 (delta 0), pack-reused 0</span><br><span class="line">error: RPC failed; HTTP 413 curl 22 The requested URL returned error: 413</span><br><span class="line">send-pack: unexpected disconnect while reading sideband packet</span><br><span class="line">fatal: the remote end hung up unexpectedly</span><br></pre></td></tr></table></figure><h2 id="原因">原因</h2><blockquote><p>413 Request Entity Too Large 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。</p></blockquote><h2 id="解决">解决</h2><ol><li class="lvl-3"><p>修改上传的数据限制<mark>好像没用</mark></p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.postBuffer 52428800</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>使用 ssh 方式上传（1）查看当前 git 的提交地址</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>（2）查看 ssh 仓库地址</p><p>（3）设置更换远程仓库地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin 复制过来的ssh地址</span><br></pre></td></tr></table></figure><p>（4）再次提交</p><h2 id="其他原因">其他原因</h2><p>在提交目录下加了一个 1G 多的 doc 目录，后面直接删除提交成功了。</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言参考文章：&lt;a class=&quot;link&quot;   href=&quot;https://blog.csdn.net/m0_55868614/article/details/120597702&quot; &gt;使用git提交时报错：error: RPC failed； HTTP 413 curl 22 The requested URL returned error: 413 Request Entity&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-07-19 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="bug记录" scheme="https://kiml.github.io/categories/bug%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Git" scheme="https://kiml.github.io/tags/Git/"/>
    
    <category term="BUG" scheme="https://kiml.github.io/tags/BUG/"/>
    
  </entry>
  
  <entry>
    <title>04 聚合支付-【代码模板】支付宝接入</title>
    <link href="https://kiml.github.io/posts/fc17a9b8/"/>
    <id>https://kiml.github.io/posts/fc17a9b8/</id>
    <published>2024-07-19T10:15:31.000Z</published>
    <updated>2024-07-19T13:42:58.725Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="c82f841b257ec2aad906d932224b734da03dc9d5069055b44378fa4182cfed23">4630436162ade97ba2718b7d0c4b3b6338208f8942f2ce54753d8fd7f949e1b7593fdd8285c0b6262fba257620164d4d5bb90f4a8b75c9f75788c768a438a1f4bf08bead474a0eec7cb2a7e9492d2732c01797eb38e7b8d3859ab37dfc4a93422bc9b899c25b4bb76e1fff8fc6923388352f75f8e2f38bc049fa119110b1797da28ecef92d0aadebf7e95ca7610489324bba9c9658f81f985a7bd3f7a795eb5b4db347cfca60b31dc8273b54a0b7a722b43ba4e117be4c5a340a949aec898a0634288822be2823e315eb02bea85b5a93180081cc79f754978c4c8a3f684820b4ac78489dfef514afe36b5571bce4ff32b06f7c57d05594dbce4504175acde882d8b8115f394001ca5ddf81d9d079e772a8e893459cfed24956a6461906b915c13e32573885b53b68165e3bb12ab2d3e751724d871c0791ec8210309c894685936b0bd53aa97dbd958f4448b8a8a1befeb9a9cdb4b154966af39d6dbae1f8456252c8781efefc72ba6c4f27e23bc388ae3220649cd78aedade4d4df5322453c9c30410635bcb5647b58f30d4fe027122cd867c868efa3d616022c11acba26019e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="后端项目" scheme="https://kiml.github.io/categories/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="聚合支付" scheme="https://kiml.github.io/categories/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98/"/>
    
    
    <category term="Java" scheme="https://kiml.github.io/tags/Java/"/>
    
    <category term="代码模板" scheme="https://kiml.github.io/tags/%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第四十六天-42接雨水、84柱状图中最大的矩形</title>
    <link href="https://kiml.github.io/posts/82b551fe/"/>
    <id>https://kiml.github.io/posts/82b551fe/</id>
    <published>2024-07-13T01:06:09.000Z</published>
    <updated>2024-07-16T09:49:11.804Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：42 看解析。84 看解析。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">24-07-13 初始记录</span><br><span class="line">24-07-16 完成</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="初步题解">初步题解</h2><h3 id="42-接雨水">42 接雨水</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/trapping-rain-water/" >https://leetcode.cn/problems/trapping-rain-water/<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="84-柱状图中最大的矩形">84 柱状图中最大的矩形</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/largest-rectangle-in-histogram" >https://leetcode.cn/problems/largest-rectangle-in-histogram<i class="fas fa-external-link-alt"></i></a>)</p><h2 id="看解析">看解析</h2><h3 id="42-接雨水-2">42 接雨水</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0042.%E6%8E%A5%E9%9B%A8%E6%B0%B4.html" >https://programmercarl.com/0042.接雨水.html<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>当前高度小于等于栈顶高度，入栈，指针后移。</p></li><li class="lvl-3"><p>当前高度大于栈顶高度，出栈，计算出当前墙和栈顶的墙之间水的多少，然后计算当前的高度和新栈的高度的关系，重复第 2 步。直到当前墙的高度不大于栈顶高度或者栈空，然后把当前墙入栈，指针后移。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;  </span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    stack.push(<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; height.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (height[i] &lt;= height[stack.peek()]) &#123;  </span><br><span class="line">            stack.push(i);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// 当前元素小于栈顶元素  </span></span><br><span class="line">            <span class="keyword">if</span> (height[stack.peek()] &gt;= height[i]) &#123;  </span><br><span class="line">                stack.push(i);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) &#123;  </span><br><span class="line">                    <span class="comment">// 当前的栈顶  </span></span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">mid</span> <span class="operator">=</span> stack.pop();  </span><br><span class="line">                    <span class="keyword">if</span> (!stack.isEmpty()) &#123;  </span><br><span class="line">                        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> Math.min(height[stack.peek()], height[i]) - height[mid];  </span><br><span class="line">                        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> i - stack.peek() - <span class="number">1</span>;  </span><br><span class="line">                        area += h * w;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                stack.push(i);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> area;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="84-柱状图中最大的矩形-2">84 柱状图中最大的矩形</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0084.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.html" >https://programmercarl.com/0084.柱状图中最大的矩形.html<i class="fas fa-external-link-alt"></i></a>)</p><p><em>本题是要找每个柱子左右两边第一个小于该柱子的柱子，所以从栈头（元素从栈头弹出）到栈底的顺序应该是从大到小的顺序</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;  </span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  </span><br><span class="line">    <span class="comment">// 首末尾加零防止无法进入循环  </span></span><br><span class="line">    <span class="type">int</span>[] newHeights = <span class="keyword">new</span> <span class="title class_">int</span>[heights.length + <span class="number">2</span>];  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; newHeights.length - <span class="number">1</span>; i++) &#123;  </span><br><span class="line">        newHeights[i] = heights[i - <span class="number">1</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">    newHeights[heights.length + <span class="number">1</span>] = <span class="number">0</span>;  </span><br><span class="line">    newHeights[<span class="number">0</span>] = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    stack.push(<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; newHeights.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; newHeights[i] &lt; newHeights[stack.peek()]) &#123;  </span><br><span class="line">            <span class="comment">// 当前元素的前一个元素  </span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">mid</span> <span class="operator">=</span> stack.pop();  </span><br><span class="line">            <span class="comment">// 右侧数据与左侧数据的差值  </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> i - stack.peek() - <span class="number">1</span>;  </span><br><span class="line">            area = Math.max(area, w * newHeights[mid]);  </span><br><span class="line">        &#125;  </span><br><span class="line">        stack.push(i);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> area;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：42 看解析。84 看解析。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-07-13 初始记录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24-07-16 完成&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="单调栈" scheme="https://kiml.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第四十五天-739每日温度、496下一个更大元素 I、503下一个更大元素II</title>
    <link href="https://kiml.github.io/posts/d0198d2/"/>
    <id>https://kiml.github.io/posts/d0198d2/</id>
    <published>2024-07-11T02:53:32.000Z</published>
    <updated>2024-07-16T09:44:58.106Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：739 看解析。496 看解析。503 根据 739 写出。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-07-11 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="初步题解">初步题解</h2><h3 id="739-每日温度">739 每日温度</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/daily-temperatures" >https://leetcode.cn/problems/daily-temperatures<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="496-下一个更大元素-I">496 下一个更大元素 I</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/next-greater-element-i" >https://leetcode.cn/problems/next-greater-element-i<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="503-下一个更大元素-II">503 下一个更大元素 II</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/next-greater-element-ii" >https://leetcode.cn/problems/next-greater-element-ii<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] nextGreaterElements(<span class="type">int</span>[] nums) &#123;  </span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];  </span><br><span class="line">    Arrays.fill(result, -<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  </span><br><span class="line">    stack.push(<span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length * <span class="number">2</span>; i++) &#123;  </span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[i % nums.length] &gt; nums[stack.peek()]) &#123;  </span><br><span class="line">            result[stack.peek()] = nums[i % nums.length];  </span><br><span class="line">            stack.pop();  </span><br><span class="line">        &#125;  </span><br><span class="line">        stack.push(i % nums.length);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="看解析">看解析</h2><h3 id="739-每日温度-2">739 每日温度</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html" >https://programmercarl.com/0739.每日温度.html<i class="fas fa-external-link-alt"></i></a>)</p><ul class="lvl-0"><li class="lvl-2"><p>情况一：当前遍历的元素 <code>T[i]</code> 小于栈顶元素 <code>T[st.top()]</code> 的情况</p></li><li class="lvl-2"><p>情况二：当前遍历的元素 <code>T[i]</code> 等于栈顶元素 <code>T[st.top()]</code> 的情况</p></li><li class="lvl-2"><p>情况三：当前遍历的元素 <code>T[i]</code> 大于栈顶元素 <code>T[st.top()]</code> 的情况</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;  </span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();  </span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[temperatures.length];  </span><br><span class="line">  </span><br><span class="line">    stack.push(<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; temperatures.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 当前元素小于等于栈顶元素，直接继续放入  </span></span><br><span class="line">        <span class="keyword">if</span> (temperatures[i] &lt;= temperatures[stack.peek()]) &#123;  </span><br><span class="line">            stack.push(i);  </span><br><span class="line">        <span class="comment">// 当前元素大于栈顶元素，弹出元素，计算result，（直到当前元素不大于栈顶元素），将当前元素加入栈</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;  </span><br><span class="line">                result[stack.peek()] = i - stack.peek();  </span><br><span class="line">                stack.pop();  </span><br><span class="line">            &#125;  </span><br><span class="line">            stack.push(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;  </span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();  </span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[temperatures.length];  </span><br><span class="line">  </span><br><span class="line">    stack.push(<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; temperatures.length; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;  </span><br><span class="line">                result[stack.peek()] = i - stack.peek();  </span><br><span class="line">                stack.pop();  </span><br><span class="line">            &#125;  </span><br><span class="line">        stack.push(i);    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="496-下一个更大元素-I-2">496 下一个更大元素 I</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0496.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I.html" >https://programmercarl.com/0496.下一个更大元素I.html<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;  </span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];  </span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    Arrays.fill(result, -<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;  </span><br><span class="line">        map.put(nums1[i], i);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    stack.push(<span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums2.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (nums2[i] &lt;= nums2[stack.peek()]) &#123;  </span><br><span class="line">            stack.push(i);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">// 栈中保存了上个需要比较的对象</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums2[i] &gt; nums2[stack.peek()]) &#123;  </span><br><span class="line">                <span class="comment">// num1中包含整这个元素  </span></span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(nums2[stack.peek()])) &#123;  </span><br><span class="line">                    <span class="comment">// result中的对应下标为这个元素的后一位  </span></span><br><span class="line">                    result[map.get(nums2[stack.peek()])] = nums2[i];  </span><br><span class="line">                &#125;  </span><br><span class="line">                stack.pop();  </span><br><span class="line">            &#125;  </span><br><span class="line">            stack.push(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="503-下一个更大元素-II-2">503 下一个更大元素 II</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0503.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0II.html" >https://programmercarl.com/0503.下一个更大元素II.html<i class="fas fa-external-link-alt"></i></a>)</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：739 看解析。496 看解析。503 根据 739 写出。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-07-11 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="单调栈" scheme="https://kiml.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第四十四天-647回文子串、516最长回文子序列</title>
    <link href="https://kiml.github.io/posts/aa7c5f5/"/>
    <id>https://kiml.github.io/posts/aa7c5f5/</id>
    <published>2024-07-09T09:13:45.000Z</published>
    <updated>2024-07-10T14:19:12.457Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：647 看解析，516 看解析</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">24-07-09 初始记录</span><br><span class="line">24-07-10 完成</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="初步题解">初步题解</h2><h3 id="647-回文子串">647 回文子串</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/palindromic-substrings" >https://leetcode.cn/problems/palindromic-substrings<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="516-最长回文子序列">516 最长回文子序列</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/longest-palindromic-subsequence" >https://leetcode.cn/problems/longest-palindromic-subsequence<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i][j]</code> 的含义：表示区间范围 <code>[i,j]</code> （注意是左闭右闭）的子串的最长回文子串的长度。</p></li><li class="lvl-3"><p>递推公式：<code>s[i]</code> 与 <code>s[j]</code> 相等，<code>s[i]</code> 与 <code>s[j]</code> 不相等这两种情况：不相等取左右指针向内移动的最大值；相等 <code>dp[i][j] = dp[i + 1][j - 1] + 2;  </code></p></li><li class="lvl-3"><p>dp 数组的初始化：相等时，取 1。</p></li><li class="lvl-3"><p>遍历顺序：<strong>从下到上，从左到右遍历</strong></p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()][s.length()];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;  </span><br><span class="line">        dp[i][i] = <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> max= <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; s.length(); j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;  </span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                dp[i][j] = Math.max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);  </span><br><span class="line">            &#125;  </span><br><span class="line">            max = Math.max(dp[i][j], max);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> max;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="看解析">看解析</h2><h3 id="647-回文子串-2">647 回文子串</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html" >https://programmercarl.com/0647.回文子串.html<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i][j]</code> 的含义：表示区间范围 <code>[i,j]</code> （注意是左闭右闭）的子串是否是回文子串，如果是 <code>dp[i][j]</code> 为 true，否则为 false。</p></li><li class="lvl-3"><p>递推公式：<code>s[i]</code> 与 <code>s[j]</code> 相等，<code>s[i]</code> 与 <code>s[j]</code> 不相等这两种情况：不相等即为 false；相等分为三种情况：下标 i 与 j 相同，同一个字符返回 true；下标 i 与 j 相差为 1，返回 true；i 与 j 相差大于 1 的时候，判断 <code>dp[i + 1][j - 1]</code> 是否为 true</p></li><li class="lvl-3"><p>dp 数组的初始化：全为 false</p></li><li class="lvl-3"><p>遍历顺序：<strong>从下到上，从左到右遍历</strong></p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;  </span><br><span class="line">    <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()][s.length()];  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; s.length(); j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(j)) &#123;  </span><br><span class="line">                dp[i][j] = <span class="literal">false</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123;  </span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (dp[i][j]) &#123;  </span><br><span class="line">                num++;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> num;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="516-最长回文子序列-2">516 最长回文子序列</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0516.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.html" >https://programmercarl.com/0516.最长回文子序列.html<i class="fas fa-external-link-alt"></i></a>)</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：647 看解析，516 看解析&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-07-09 初始记录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24-07-10 完成&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="动态规划" scheme="https://kiml.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第四十三天-115不同的子序列、583两个字符串的删除操作、72编辑距离</title>
    <link href="https://kiml.github.io/posts/ca280c35/"/>
    <id>https://kiml.github.io/posts/ca280c35/</id>
    <published>2024-07-08T08:02:07.000Z</published>
    <updated>2024-07-08T13:25:23.863Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：115 不会、583 根据 115AC、72 不会</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-07-08 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="初步题解">初步题解</h2><h3 id="115-不同的子序列">115 不同的子序列</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/distinct-subsequences/" >https://leetcode.cn/problems/distinct-subsequences/<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="583-两个字符串的删除操作">583 两个字符串的删除操作</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/delete-operation-for-two-strings/" >https://leetcode.cn/problems/delete-operation-for-two-strings/<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i][j]</code> 的含义：s 到 i - 1；t 到 j - 1 位置的删除相同需要的最小步数。</p></li><li class="lvl-3"><p>递推公式：如果当前位置元素相同：<code>dp[i][j] = dp[i - 1][j - 1]; </code>（即不加这个元素时的子序列个数 + 加上这个元素的子序列个数）， 如果当前位置元素不同：<code>dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1); </code>（画图即当前位置的上左再去除一个元素并取较小值）。</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[i][0]</code> 、<code>dp[0][j]</code> 都是与元素个数有关。</p></li><li class="lvl-3"><p>遍历顺序：从上到下，从左到右。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; i++) &#123;  </span><br><span class="line">        dp[i][<span class="number">0</span>] = i;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp[<span class="number">0</span>].length; i++) &#123;  </span><br><span class="line">        dp[<span class="number">0</span>][i] = i;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= word1.length(); i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= word2.length(); j++) &#123;  </span><br><span class="line">            <span class="comment">// 当前指针位置相同，dp[i][j] = dp[i - 1][j - 1] + 1  </span></span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;  </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j - <span class="number">1</span>] + <span class="number">1</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[word1.length()][word2.length()];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="72-编辑距离">72 编辑距离</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/edit-distance" >https://leetcode.cn/problems/edit-distance<i class="fas fa-external-link-alt"></i></a>)</p><h2 id="看解析">看解析</h2><h3 id="115-不同的子序列-2">115 不同的子序列</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.html" >https://programmercarl.com/0115.不同的子序列.html<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i][j]</code> 的含义：s 到 i - 1；t 到 j - 1 位置的子序列个数。</p></li><li class="lvl-3"><p>递推公式：如果当前位置元素相同：<code>dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; </code>（即不加这个元素时的子序列个数 + 加上这个元素的子序列个数）， 如果当前位置元素不同：<code>dp[i][j] = dp[i - 1][j];</code>。</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[i][0]</code> 一定都是 1，因为也就是把以 i-1 为结尾的 s，删除所有元素，出现空字符串的个数就是 1。<code>dp[0][j]</code> 一定都是 0。<code>dp[0][0]</code> 应该是 1。</p></li><li class="lvl-3"><p>遍历顺序：从上到下，从左到右。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length() + <span class="number">1</span>][t.length() + <span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; i++) &#123;  </span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s.length(); i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= t.length(); j++) &#123;  </span><br><span class="line">            <span class="comment">// 当前指针位置相同，dp[i][j] = dp[i - 1][j - 1] + 1  </span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>)) &#123;  </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[s.length()][t.length()];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="583-两个字符串的删除操作-2">583 两个字符串的删除操作</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0583.%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.html" >https://programmercarl.com/0583.两个字符串的删除操作.html<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="72-编辑距离-2">72 编辑距离</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0072.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html" >https://programmercarl.com/0072.编辑距离.html<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i][j]</code> 的含义：word1 到 i - 1；word2 到 j - 1 位置的最小编辑数。</p></li><li class="lvl-3"><p>递推公式：需要确认四种情况：<code>word1[i - 1] == word2[j - 1]</code> 时，不操作；<code>word1[i - 1] != word2[j - 1]</code>，增删换。具体公式看代码。</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[i][0]</code> 、<code>dp[0][j]</code> 都是与元素个数有关，即删除所有元素。</p></li><li class="lvl-3"><p>遍历顺序：从上到下，从左到右。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; i++) &#123;  </span><br><span class="line">        dp[i][<span class="number">0</span>] = i;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp[<span class="number">0</span>].length; i++) &#123;  </span><br><span class="line">        dp[<span class="number">0</span>][i] = i;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= word1.length(); i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= word2.length(); j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;  </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="comment">// 三数比较  </span></span><br><span class="line">                <span class="comment">// word1删除一个元素，那么就是以下标i - 2为结尾的word1 与 j-1为结尾的word2的最近编辑距离 再加上一个操作。  </span></span><br><span class="line">                <span class="comment">// word2删除一个元素，那么就是以下标i - 1为结尾的word1 与 j-2为结尾的word2的最近编辑距离 再加上一个操作。  </span></span><br><span class="line">                <span class="comment">// 替换元素，word1替换word1[i - 1]，使其与word2[j - 1]相同，此时不用增删加元素。  </span></span><br><span class="line">                dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]), Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])) + <span class="number">1</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[word1.length()][word2.length()];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：115 不会、583 根据 115AC、72 不会&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-07-08 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="动态规划" scheme="https://kiml.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第四十二天-1143最长公共子序列、1035不相交的线、53最大子序和、392判断子序列</title>
    <link href="https://kiml.github.io/posts/2b15070f/"/>
    <id>https://kiml.github.io/posts/2b15070f/</id>
    <published>2024-07-05T06:14:16.000Z</published>
    <updated>2024-07-08T13:12:56.825Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：1143AC（方法不是最简的）、1035AC（和上一题一样）、53AC、392AC（根据 1143）</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">24-07-05 初始记录</span><br><span class="line">24-07-06 1143</span><br><span class="line">24-07-07 1143优化、1035、53、392</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="初步题解">初步题解</h2><h3 id="1143-最长公共子序列">1143 最长公共子序列</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/longest-common-subsequence/" >https://leetcode.cn/problems/longest-common-subsequence/<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i][j]</code> 的含义：text1 到 i；text2 到 j 位置的最长重复数组。</p></li><li class="lvl-3"><p>递推公式：如果当前位置元素相同：<code>dp[i][j] = dp[i - 1][j - 1] + 1; </code>， 如果当前位置元素不同：<code>dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); </code>。</p></li><li class="lvl-3"><p>dp 数组的初始化：针对初始元素是否相同及 i = 0 和 j = 0 的两种情况，都需要分别判断。</p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[text1.length()][text2.length()];  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; text1.length(); i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; text2.length(); j++) &#123;  </span><br><span class="line">            <span class="comment">// 当前指针位置相同，dp[i][j] = dp[i - 1][j - 1] + 1  </span></span><br><span class="line">            <span class="keyword">if</span> (text1.charAt(i) == text2.charAt(j)) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;  </span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;  </span><br><span class="line">                    maxLength = Math.max(dp[i][j], maxLength);  </span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;  </span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;  </span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;  </span><br><span class="line">                    dp[i][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>];  </span><br><span class="line">                    maxLength = Math.max(dp[i][j], maxLength);  </span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;  </span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][<span class="number">0</span>];  </span><br><span class="line">                    maxLength = Math.max(dp[i][j], maxLength);  </span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);  </span><br><span class="line">            &#125;  </span><br><span class="line">            maxLength = Math.max(dp[i][j], maxLength);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> maxLength;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1035-不相交的线">1035 不相交的线</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/uncrossed-lines" >https://leetcode.cn/problems/uncrossed-lines<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i][j]</code> 的含义：text1 到 i - 1；text2 到 j - 1 位置的最长重复数组。</p></li><li class="lvl-3"><p>递推公式：如果当前位置元素相同：<code>dp[i][j] = dp[i - 1][j - 1] + 1; </code>， 如果当前位置元素不同：<code>dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); </code>。</p></li><li class="lvl-3"><p>dp 数组的初始化：i = 0 或 j = 0 时，dp 值为 0</p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxUncrossedLines</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length + <span class="number">1</span>][nums2.length + <span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums1.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= nums2.length; j++) &#123;  </span><br><span class="line">            <span class="comment">// 当前位置加入计数  </span></span><br><span class="line">            <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;  </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// System.out.println(Arrays.deepToString(dp));  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[nums1.length][nums2.length];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="53-最大子序和">53 最大子序和</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/maximum-subarray/" >https://leetcode.cn/problems/maximum-subarray/<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i]</code> 的含义：数组长度为 i 时的最大子序和。</p></li><li class="lvl-3"><p>递推公式：如果当前位置元素相同：<code>dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]); </code>。</p></li><li class="lvl-3"><p>dp 数组的初始化：i = 0 时，取 <code>nums[0]</code> 的值</p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];  </span><br><span class="line">  </span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];  </span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> dp[<span class="number">0</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; dp.length; i++) &#123;  </span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);  </span><br><span class="line">        max = Math.max(max, dp[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.toString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> max;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="392-判断子序列">392 判断子序列</h3><ol><li class="lvl-3"><p>确定 <code>dp[i][j]</code> 的含义：s 到 i - 1；t 到 j - 1 位置的相同子序列长度。</p></li><li class="lvl-3"><p>递推公式：如果当前位置元素相同：<code>dp[i][j] = dp[i - 1][j - 1] + 1; </code>， 如果当前位置元素不同：<code>dp[i][j] = dp[i][j - 1]; </code>。</p></li><li class="lvl-3"><p>dp 数组的初始化：i = 0 或 j = 0 时，dp 值为 0</p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/is-subsequence" >https://leetcode.cn/problems/is-subsequence<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length() + <span class="number">1</span>][t.length() + <span class="number">1</span>];  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s.length(); i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= t.length(); j++) &#123;  </span><br><span class="line">            <span class="comment">// 当前指针位置相同，dp[i][j] = dp[i - 1][j - 1] + 1  </span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>)) &#123;  </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>];  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[s.length()][t.length()] == s.length();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="看解析">看解析</h2><h3 id="1143-最长公共子序列-2">1143 最长公共子序列</h3><p>解析：(<a class="link"   href="https://programmercarl.com/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html" >https://programmercarl.com/1143.最长公共子序列.html<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>二维数组优化</p><ol><li class="lvl-7">dp 数组的定义修改为 <code>dp[i][j]</code>：长度为 <code>[0, i - 1]</code> 的字符串 text1 与长度为 <code>[0, j - 1]</code> 的字符串 text2 的最长公共子序列为 <code>dp[i][j]</code>（即多）</li><li class="lvl-7">初始化即 i 为 0，j 为 0 时，<code>dp[i][j]</code> 的值也为 0</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[text1.length() + <span class="number">1</span>][text2.length() + <span class="number">1</span>];  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= text1.length(); i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= text2.length(); j++) &#123;  </span><br><span class="line">            <span class="comment">// 当前指针位置相同，dp[i][j] = dp[i - 1][j - 1] + 1  </span></span><br><span class="line">            <span class="keyword">if</span> (text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>)) &#123;  </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// System.out.println(Arrays.deepToString(dp));  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[text1.length()][text2.length()];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>一维数组优化</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> text1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> text2.length();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 多从二维dp数组过程分析  </span></span><br><span class="line">        <span class="comment">// 关键在于  如果记录  dp[i - 1][j - 1]</span></span><br><span class="line">        <span class="comment">// 因为 dp[i - 1][j - 1]  &lt;!=&gt;  dp[j - 1]  &lt;=&gt;  dp[i][j - 1]</span></span><br><span class="line">        <span class="type">int</span> [] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n2 + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n1; i++)&#123;</span><br><span class="line">            <span class="comment">// 这里pre相当于 dp[i - 1][j - 1]</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> dp[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n2; j++)&#123;</span><br><span class="line">                <span class="comment">//用于给pre赋值</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> dp[j];</span><br><span class="line">                <span class="keyword">if</span>(text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    <span class="comment">//这里pre相当于dp[i - 1][j - 1]   千万不能用dp[j - 1] !!</span></span><br><span class="line">                    dp[j] = pre + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// dp[j]     相当于   dp[i - 1][j]</span></span><br><span class="line">                    <span class="comment">// dp[j - 1] 相当于   dp[i][j - 1]</span></span><br><span class="line">                    dp[j] = Math.max(dp[j], dp[j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//更新dp[i - 1][j - 1], 为下次使用做准备</span></span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1035-不相交的线-2">1035 不相交的线</h3><p>解析：(<a class="link"   href="https://programmercarl.com/1035.%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF.html" >https://programmercarl.com/1035.不相交的线.html<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="53-最大子序和-2">53 最大子序和</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html" >https://programmercarl.com/0053.最大子序和（动态规划）.html<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="392-判断子序列-2">392 判断子序列</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.html" >https://programmercarl.com/0392.判断子序列.html<i class="fas fa-external-link-alt"></i></a>)</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：1143AC（方法不是最简的）、1035AC（和上一题一样）、53AC、392AC（根据 1143）&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-07-05 初始记录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24-07-06 1143&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24-07-07 1143优化、1035、53、392&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="动态规划" scheme="https://kiml.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第四十一天-300最长递增子序列、674最长连续递增序列、718最长重复子数组</title>
    <link href="https://kiml.github.io/posts/825964fb/"/>
    <id>https://kiml.github.io/posts/825964fb/</id>
    <published>2024-07-01T03:04:29.000Z</published>
    <updated>2024-07-03T10:51:56.018Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：300 看解析，674AC，718看解析</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-07-01 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="初步题解">初步题解</h2><h3 id="300-最长递增子序列">300 最长递增子序列</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/longest-increasing-subsequence" >https://leetcode.cn/problems/longest-increasing-subsequence<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i]</code> 的含义：<code>dp[i]</code> 表示第 i 个下标前的最长递增子序列的长度</p></li><li class="lvl-3"><p>递推公式：<code>dp[i] = Math.max(dp[i], dp[j] + 1)</code>。</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp</code> 数组所有元素的初始化值都为 1。</p></li><li class="lvl-4"><p>遍历顺序：从前向后遍历。</p></li><li class="lvl-4"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];  </span><br><span class="line">  </span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; dp.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;  </span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        maxLength = Math.max(maxLength, dp[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> maxLength;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="674-最长连续递增序列">674 最长连续递增序列</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence" >https://leetcode.cn/problems/longest-continuous-increasing-subsequence<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i]</code> 的含义：<code>dp[i]</code> 表示第 i 个下标前的最长连续递增子序列的长度</p></li><li class="lvl-3"><p>递推公式：<code>dp[i] = Math.max(dp[i], dp[i - 1] + 1)</code>。</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp</code> 数组所有元素的初始化值都为 1。</p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];  </span><br><span class="line">  </span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; dp.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;  </span><br><span class="line">            dp[i] = Math.max(dp[i], dp[i - <span class="number">1</span>] + <span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        maxLength = Math.max(maxLength, dp[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> maxLength;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="718-最长重复子数组">718 最长重复子数组</h3><ol><li class="lvl-3"><p>确定 <code>dp[i][j]</code> 的含义：num1 到 i - 1；num2 到 j - 1 位置的最长重复数组。</p></li><li class="lvl-3"><p>递推公式：<code>dp[i][j] = dp[i - 1][j - 1] + 1; </code>。</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp</code> 数组所有元素的初始化值都为 0。</p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）题目链接：(<a class="link"   href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray" >https://leetcode.cn/problems/maximum-length-of-repeated-subarray<i class="fas fa-external-link-alt"></i></a>)</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length + <span class="number">1</span>][nums2.length + <span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums1.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= nums2.length; j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;  </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            maxLength = Math.max(dp[i][j], maxLength);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> maxLength;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="看解析">看解析</h2><h3 id="300-最长递增子序列-2">300 最长递增子序列</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0300.%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.html" >https://programmercarl.com/0300.最长上升子序列.html<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="674-最长连续递增序列-2">674 最长连续递增序列</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0674.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97.html" >https://programmercarl.com/0674.最长连续递增序列.html<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="718-最长重复子数组-2">718 最长重复子数组</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0718.%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84.html" >https://programmercarl.com/0718.最长重复子数组.html<i class="fas fa-external-link-alt"></i></a>)</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：300 看解析，674AC，718看解析&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-07-01 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="动态规划" scheme="https://kiml.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>【代码模板】二维码的生成</title>
    <link href="https://kiml.github.io/posts/5ee0f6a5/"/>
    <id>https://kiml.github.io/posts/5ee0f6a5/</id>
    <published>2024-06-28T09:57:09.000Z</published>
    <updated>2024-07-03T10:51:40.236Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>ZXing 是一个开源的，用 Java 编写的多格式的 1D / 2D 条码图像处理库，使用 ZXing 可以生成、识别 QR Code（二维码）。常用的二维码处理库还有 zbar，近几年已经不再更新代码，下边介绍 ZXing 生成二维码的方法。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-28 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><ol><li class="lvl-3"><p>引入依赖</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 二维码生成&amp;识别组件--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.zxing<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.zxing<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javase<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>生成二维码方法</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QRCodeUtil</span> &#123;  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 生成二维码  </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content 二维码对应的URL  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> width   二维码图片宽度  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> height  二维码图片高度  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 二维码二进制流  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createQRCode</span><span class="params">(String content, <span class="type">int</span> width, <span class="type">int</span> height)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">resultImage</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;  </span><br><span class="line">        <span class="comment">// 除了尺寸，传入内容不能为空  </span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(content)) &#123;  </span><br><span class="line">            <span class="type">ServletOutputStream</span> <span class="variable">stream</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();  </span><br><span class="line">            <span class="comment">// 二维码参数  </span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span>  </span><br><span class="line">            HashMap&lt;EncodeHintType, Comparable&gt; hints = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">            <span class="comment">// 指定字符编码为“utf-8”  </span></span><br><span class="line">            hints.put(EncodeHintType.CHARACTER_SET, <span class="string">&quot;utf-8&quot;</span>);  </span><br><span class="line">            <span class="comment">// L M Q H四个纠错等级从低到高，指定二维码的纠错等级为M  </span></span><br><span class="line">            <span class="comment">// 纠错级别越高，可以修正的错误就越多，需要的纠错码的数量也变多，相应的二维吗可储存的数据就会减少  </span></span><br><span class="line">            hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.M);  </span><br><span class="line">            <span class="comment">// 设置图片的边距  </span></span><br><span class="line">            hints.put(EncodeHintType.MARGIN, <span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="comment">// zxing生成二维码核心类  </span></span><br><span class="line">                <span class="type">QRCodeWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QRCodeWriter</span>();  </span><br><span class="line">                <span class="comment">// 把输入文本按照指定规则转成二维吗  </span></span><br><span class="line">                <span class="type">BitMatrix</span> <span class="variable">bitMatrix</span> <span class="operator">=</span> writer.encode(content, BarcodeFormat.QR_CODE, width, height, hints);  </span><br><span class="line">                <span class="comment">// 生成二维码图片流  </span></span><br><span class="line">                <span class="type">BufferedImage</span> <span class="variable">bufferedImage</span> <span class="operator">=</span> MatrixToImageWriter.toBufferedImage(bitMatrix);  </span><br><span class="line">                <span class="comment">// 输出流  </span></span><br><span class="line">                ImageIO.write(bufferedImage, <span class="string">&quot;png&quot;</span>, os);  </span><br><span class="line">                <span class="comment">/**  </span></span><br><span class="line"><span class="comment">                 * 原生转码前面没有 data:image/png;base64 这些字段，返回给前端是无法被解析，所以加上前缀  </span></span><br><span class="line"><span class="comment">                 */</span>  </span><br><span class="line">                resultImage = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;data:image/png;base64,&quot;</span> + EncryptUtil.encodeBase64(os.toByteArray()));  </span><br><span class="line">                <span class="keyword">return</span> resultImage;  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(CommonErrorCode.E_200007);  </span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">                <span class="keyword">if</span> (stream != <span class="literal">null</span>) &#123;  </span><br><span class="line">                    stream.flush();  </span><br><span class="line">                    stream.close();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
ZXing 是一个开源的，用 Java 编写的多格式的 1D / 2D 条码图像处理库，使用 ZXing 可以生成、识别 QR Code（二维码）。常用的二维码处理库还有 zbar，近几年已经不再更新代码，下边介绍 ZXing 生成二维码的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-28 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="后端项目" scheme="https://kiml.github.io/categories/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="准备工作" scheme="https://kiml.github.io/categories/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第四十天-188买卖股票的最佳时机IV、309最佳买卖股票时机含冷冻期、714买卖股票的最佳时机含手续费</title>
    <link href="https://kiml.github.io/posts/ab0ba29f/"/>
    <id>https://kiml.github.io/posts/ab0ba29f/</id>
    <published>2024-06-28T01:12:43.000Z</published>
    <updated>2024-06-28T03:31:07.446Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：188 根据 123AC 了。309用另一种方法AC了。714AC。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-28 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="初步题解">初步题解</h2><h3 id="188-买卖股票的最佳时机-IV">188 买卖股票的最佳时机 IV</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv" >https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span> * k];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 初始化数据  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;  </span><br><span class="line">        dp[<span class="number">0</span>][i * <span class="number">2</span>] = -prices[<span class="number">0</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; dp.length; i++) &#123;  </span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; <span class="number">2</span> * k; j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (j % <span class="number">2</span> == <span class="number">0</span>) &#123;  </span><br><span class="line">                <span class="comment">// 偶数买入  </span></span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] - prices[i]);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="comment">// 奇数卖出  </span></span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + prices[i]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">2</span> * k - <span class="number">1</span>];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="309-最佳买卖股票时机含冷冻期">309 最佳买卖股票时机含冷冻期</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown" >https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown<i class="fas fa-external-link-alt"></i></a>)</p><p>思路：买卖股票 + 打家劫舍结合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;  </span><br><span class="line">    <span class="comment">// 0 表示持有股票的状态; 1 表示不持有股票的状态  </span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];  </span><br><span class="line">  </span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; dp.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;  </span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// 持有：前一天持有；前一天不持有（不可能）：前两天不持有  </span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">2</span>][<span class="number">1</span>] - prices[i]);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 不持有：前一天不持有；前一天持有  </span></span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="714-买卖股票的最佳时机含手续费">714 买卖股票的最佳时机含手续费</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee" >https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加上手续费就行</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 假设买入的时候支付手续费  </span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>] - fee;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; dp.length; i++) &#123;  </span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i] - fee);  </span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="看解析">看解析</h2><h3 id="188-买卖股票的最佳时机-IV-2">188 买卖股票的最佳时机 IV</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV.html" >https://programmercarl.com/0188.买卖股票的最佳时机IV.html<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="309-最佳买卖股票时机含冷冻期-2">309 最佳买卖股票时机含冷冻期</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html" >https://programmercarl.com/0309.最佳买卖股票时机含冷冻期.html<i class="fas fa-external-link-alt"></i></a>)</p><p><strong>注意这里的每一个状态，例如状态一，是持有股票股票状态并不是说今天一定就买入股票，而是说保持买入股票的状态即：可能是前几天买入的，之后一直没操作，所以保持买入股票的状态</strong>。</p><p><strong>达到买入股票状态</strong>（状态一）即：<code>dp[i][0]</code>，有两个具体操作：</p><ul class="lvl-0"><li class="lvl-2"><p>操作一：前一天就是持有股票状态（状态一），<code>dp[i][0] = dp[i - 1][0]</code></p></li><li class="lvl-2"><p>操作二：今天买入了，有两种情况</p><ul class="lvl-2"><li class="lvl-6">前一天是冷冻期（状态四），<code>dp[i - 1][3] - prices[i]</code></li><li class="lvl-6">前一天是保持卖出股票的状态（状态二），<code>dp[i - 1][1] - prices[i]</code></li></ul></li></ul><p>那么 <code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i]);</code></p><p><strong>达到保持卖出股票状态</strong>（状态二）即：dp[i][1]，有两个具体操作：</p><ul class="lvl-0"><li class="lvl-2"><p>操作一：前一天就是状态二</p></li><li class="lvl-2"><p>操作二：前一天是冷冻期（状态四），<code>dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);</code></p></li></ul><p><strong>达到今天就卖出股票状态</strong>（状态三），即：<code>dp[i][2]</code>，只有一个操作：</p><p>昨天一定是持有股票状态（状态一），今天卖出，即：<code>dp[i][2] = dp[i - 1][0] + prices[i]</code>;</p><p><strong>达到冷冻期状态</strong>（状态四），即：<code>dp[i][3]</code>，只有一个操作：</p><p>昨天卖出了股票（状态三）， <code>dp[i][3] = dp[i - 1][2];</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="literal">null</span> || prices.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bad case</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = Math.max(dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>] + prices[<span class="number">1</span>]);</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = Math.max(dp[<span class="number">0</span>][<span class="number">1</span>], -prices[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="comment">// dp公式</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">2</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="714-买卖股票的最佳时机含手续费-2">714 买卖股票的最佳时机含手续费</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html" >https://programmercarl.com/0714.买卖股票的最佳时机含手续费（动态规划）.html<i class="fas fa-external-link-alt"></i></a>)</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：188 根据 123AC 了。309用另一种方法AC了。714AC。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-28 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="动态规划" scheme="https://kiml.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第三十九天-121买卖股票的最佳时机、122买卖股票的最佳时机II、123买卖股票的最佳时机III</title>
    <link href="https://kiml.github.io/posts/f80b512c/"/>
    <id>https://kiml.github.io/posts/f80b512c/</id>
    <published>2024-06-27T01:13:33.000Z</published>
    <updated>2024-06-28T03:23:35.471Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：121 直接看的解析。122 可以写出。123 看了部分解析（主要是 dp 的定义那块）。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-27 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="初步题解">初步题解</h2><h3 id="121-买卖股票的最佳时机">121 买卖股票的最佳时机</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/" >https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/<i class="fas fa-external-link-alt"></i></a>)：可以进行一笔交易</p><ol><li class="lvl-3"><p>确定 <code>dp[i]</code> 的含义：<code>dp[i][0]</code> 表示第 i 天持有股票所得最多现金，<code>dp[i][1]</code> 表示第 i 天不持有股票所得最多现金。</p></li><li class="lvl-3"><p>递推公式：<code>dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);</code>。（分为两种情况，当前持有/不持有）</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[0][0] = -prices[0]; dp[0][1] = 0;</code>。还有一点要注意：<strong>不持有股票状态所得金钱一定比持有股票状态得到的多！</strong></p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;  </span><br><span class="line">    <span class="comment">// `dp[i][0]` 表示第 i 天持有股票所得最多现金，`dp[i][1]` 表示第 i 天不持有股票所得最多现金。  </span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 初始化  </span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];  </span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;  </span><br><span class="line">        <span class="comment">// 1. 求 dp[i][0]: 前一天也持有就为 dp[i - 1][0]，前一天不持有就为 -prices[i]        </span></span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);  </span><br><span class="line">        <span class="comment">// 2. 求 dp[i][1]: 前一天也不持有就为 dp[i - 1][1]，前一天持有就为 dp[i - 1][0] + prices[i]        </span></span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 手中不持有股票时，利润才会最大</span></span><br><span class="line">    <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="122-买卖股票的最佳时机-II">122 买卖股票的最佳时机 II</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii" >https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii<i class="fas fa-external-link-alt"></i></a>)：可以进行多笔交易</p><ol><li class="lvl-3"><p>确定 <code>dp[i]</code> 的含义：<code>dp[i][0]</code> 表示第 i 天持有股票所得最多现金，<code>dp[i][1]</code> 表示第 i 天不持有股票所得最多现金。</p></li><li class="lvl-3"><p><mark>递推公式</mark>：<code>dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);</code>。（与上一题的唯一区别为 <code>dp[i][0]</code> 的推导公式，由于可以持续买入卖出，当天持有的价格为<strong>前一天不持有的价格 - 当天价格</strong>）</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[0][0] = -prices[0]; dp[0][1] = 0;</code>。还有一点要注意：<strong>不持有股票状态所得金钱一定比持有股票状态得到的多！</strong></p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;  </span><br><span class="line">    <span class="comment">// `dp[i][0]` 表示第 i 天持有股票所得最多现金，`dp[i][1]` 表示第 i 天不持有股票所得最多现金。  </span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 初始化  </span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];  </span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;  </span><br><span class="line">        <span class="comment">// 1. 求 dp[i][0]: 前一天也持有就为 dp[i - 1][0]，前一天不持有就为 dp[i - 1][1] - prices[i]        </span></span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);  </span><br><span class="line">        <span class="comment">// 2. 求 dp[i][1]: 前一天也不持有就为 dp[i - 1][1]，前一天持有就为 dp[i - 1][0] + prices[i]        </span></span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="123-买卖股票的最佳时机-III">123 买卖股票的最佳时机 III</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/" >https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/<i class="fas fa-external-link-alt"></i></a>)：可以进行两笔交易</p><ol><li class="lvl-3"><p>确定 <code>dp[i]</code> 的含义：当天的状态一共有 5 种：没有操作，不计入。<code>dp[i][0]</code> 表示第 i 天第一次持有股票所得最多现金，<code>dp[i][1]</code> 表示第 i 天第一次不持有股票所得最多现金，<code>dp[i][2]</code> 表示第 i 天第二次持有股票所得最多现金，<code>dp[i][2]</code> 表示第 i 天第二次不持有股票所得最多现金。（这题重点把这个写出来，后面就能做题了）</p></li><li class="lvl-3"><p><mark>递推公式</mark>：<code>dp[i][0] = Math.max(dp[i - 1][0], -prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]); dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] - prices[i]); dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] + prices[i]);</code>。</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[0][0] = -prices[0]; dp[0][2] = -prices[0];</code>。</p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;  </span><br><span class="line">    <span class="comment">// `dp[i][0]` 表示第 i 天第一次持有股票所得最多现金，`dp[i][1]` 表示第 i 天第一次不持有股票所得最多现金，`dp[i][2]` 表示第 i 天第二次持有股票所得最多现金，`dp[i][2]` 表示第 i 天第二次不持有股票所得最多现金 </span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">4</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 初始化  </span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];  </span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">2</span>] = -prices[<span class="number">0</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;  </span><br><span class="line">        <span class="comment">// 1. 求 dp[i][0]: 前一天也持有就为 dp[i - 1][0]，前一天不持有就为 -prices[i]        </span></span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);  </span><br><span class="line">        <span class="comment">// 2. 求 dp[i][1]: 前一天也不持有就为 dp[i - 1][1]，前一天持有就为 dp[i - 1][0] + prices[i]        </span></span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);  </span><br><span class="line">        <span class="comment">// 3. 求 dp[i][2]: 前一天也持有为 dp[i - 1][2]，前一天不持有就为 dp[i - 1][1] - prices[i]        </span></span><br><span class="line">        dp[i][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);  </span><br><span class="line">        <span class="comment">// 4. 求 dp[i][3]: 前一天也不持有为 dp[i - 1][3]，前一天持有就为 dp[i - 1][2] + prices[i]        </span></span><br><span class="line">        dp[i][<span class="number">3</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] + prices[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">3</span>];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="看解析">看解析</h2><h3 id="121-买卖股票的最佳时机-2">121 买卖股票的最佳时机</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html" >https://programmercarl.com/0121.买卖股票的最佳时机.html<i class="fas fa-external-link-alt"></i></a>)</p><p>补充贪心算法的思路：如果第 i 天卖出股票，则最大利润为 (该天的股价 - 前面天数中最小的股价)，然后与已知的最大利润比较，如果大于则更新当前最大利润的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 贪心解法  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">minPrice</span> <span class="operator">=</span> Integer.MAX_VALUE;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">maxProfit</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> price : prices) &#123;  </span><br><span class="line">        minPrice = Math.min(price, minPrice);  </span><br><span class="line">        maxProfit = Math.max(maxProfit, price - minPrice);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> maxProfit;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="122-买卖股票的最佳时机-II-2">122 买卖股票的最佳时机 II</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html" >https://programmercarl.com/0122.买卖股票的最佳时机II（动态规划）.html<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="123-买卖股票的最佳时机-III-2">123 买卖股票的最佳时机 III</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII" >https://programmercarl.com/0123.买卖股票的最佳时机III<i class="fas fa-external-link-alt"></i></a>)</p><p>版本二：（<em>不做要求</em>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>]; </span><br><span class="line">    <span class="comment">// 存储两次交易的状态就行了</span></span><br><span class="line">    <span class="comment">// dp[0]代表第一次交易的买入</span></span><br><span class="line">    dp[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// dp[1]代表第一次交易的卖出</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// dp[2]代表第二次交易的买入</span></span><br><span class="line">    dp[<span class="number">2</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// dp[3]代表第二次交易的卖出</span></span><br><span class="line">    dp[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= prices.length; i++)&#123;</span><br><span class="line">        <span class="comment">// 要么保持不变，要么没有就买，有了就卖</span></span><br><span class="line">        dp[<span class="number">0</span>] = Math.max(dp[<span class="number">0</span>], -prices[i-<span class="number">1</span>]);</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(dp[<span class="number">1</span>], dp[<span class="number">0</span>]+prices[i-<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 这已经是第二次交易了，所以得加上前一次交易卖出去的收获</span></span><br><span class="line">        dp[<span class="number">2</span>] = Math.max(dp[<span class="number">2</span>], dp[<span class="number">1</span>]-prices[i-<span class="number">1</span>]);</span><br><span class="line">        dp[<span class="number">3</span>] = Math.max(dp[<span class="number">3</span>], dp[<span class="number">2</span>]+ prices[i-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：121 直接看的解析。122 可以写出。123 看了部分解析（主要是 dp 的定义那块）。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-27 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="动态规划" scheme="https://kiml.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第三十八天-198打家劫舍、213打家劫舍II、337打家劫舍III</title>
    <link href="https://kiml.github.io/posts/f5901d56/"/>
    <id>https://kiml.github.io/posts/f5901d56/</id>
    <published>2024-06-26T01:35:36.000Z</published>
    <updated>2024-06-28T01:09:01.615Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：都是看了解析写出。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-26 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="初步题解">初步题解</h2><h3 id="198-打家劫舍">198 打家劫舍</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/house-robber" >https://leetcode.cn/problems/house-robber<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i]</code> 的含义：下标 i 及之前的房间能偷的最大金币数。</p></li><li class="lvl-3"><p>递推公式：<code>dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])</code>。（分为两种情况，偷/不偷）</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[0] = num[0], dp[1] = Math.max(num[0], num[1])</code>。</p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];  </span><br><span class="line">  </span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];  </span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">    dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; dp.length; i++) &#123;  </span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="213-打家劫舍-II">213 打家劫舍 II</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/house-robber-ii" >https://leetcode.cn/problems/house-robber-ii<i class="fas fa-external-link-alt"></i></a>)</p><p>本题的递推与上一题相同。区别在于要不要统计头尾。思路是去除尾和去除头分别求一次最大值。然后选较大的那个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LE213</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">rob</span> <span class="operator">=</span> rob(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">200</span>, <span class="number">3</span>, <span class="number">140</span>, <span class="number">20</span>, <span class="number">10</span>&#125;);  </span><br><span class="line">        System.out.println(rob);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> Math.max(rob1(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>), rob1(nums, <span class="number">1</span>, nums.length));  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;  </span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[end - start];  </span><br><span class="line">  </span><br><span class="line">        dp[<span class="number">0</span>] = nums[start];  </span><br><span class="line">        <span class="keyword">if</span> (dp.length == <span class="number">1</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> dp[<span class="number">0</span>];  </span><br><span class="line">        &#125;  </span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[start], nums[start + <span class="number">1</span>]);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; dp.length; i++) &#123;  </span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[start + <span class="number">2</span>]);  </span><br><span class="line">            start++;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        System.out.println(Arrays.toString(dp));  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 方法二：直接交换  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rob1</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;  </span><br><span class="line">        <span class="comment">// x为上上层的最大值，y为上一层的最大值。  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> Math.max(x + nums[i], y);  </span><br><span class="line">            x = y;  </span><br><span class="line">            y = temp;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> y;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="337-打家劫舍-III">337 打家劫舍 III</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/house-robber-iii" >https://leetcode.cn/problems/house-robber-iii<i class="fas fa-external-link-alt"></i></a>)</p><p>动态规划其实就是使用状态转移容器来记录状态的变化，这里可以使用一个长度为 2 的数组，记录当前节点偷与不偷所得到的的最大金钱。</p><p><strong>这道题目算是树形 dp 的入门题目，因为是在树上进行状态转移，我们在讲解二叉树的时候说过递归三部曲，那么下面我以递归三部曲为框架，其中融合动规五部曲的内容来进行讲解</strong>。</p><p><strong>递归三部曲：</strong></p><ol><li class="lvl-3"><p>确定递归函数的参数和返回值。求一个节点两个状态的金钱值，返回值就是一个长度为 2 的数组。<strong>本题 dp 数组就是一个长度为 2 的数组</strong></p></li><li class="lvl-3"><p>确定终止条件。遇到空节点返回。</p></li><li class="lvl-3"><p>确定遍历顺序。后序遍历。</p></li></ol><p><strong>动规五部曲：</strong></p><ol><li class="lvl-3"><p>确定 <code>dp[i]</code> 的含义：下标 0 表示不偷的最大，下标 1 表示偷的最大。</p></li><li class="lvl-3"><p>递推公式即单层递归的逻辑：<code>dp[0] = cur-&gt;val + left[0] + right[0]</code>，<code>dp[1] = max(left[0], left[1]) + max(right[0], right[1])</code>。（分为两种情况，偷/不偷：<em>偷当前节点 <code>dp[1]</code>，值为当前节点值 + 不偷左右的节点的值；不偷当前节点 <code>dp[0]</code>，值为左孩子偷/不偷的最大值 + 右孩子偷/不偷的最大值</em>）</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[0] = 0, dp[1] = 0</code>，这里的初始化与递归的终止条件相。</p></li><li class="lvl-3"><p>遍历顺序：后序遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">int</span>[] dp = robDFS(root);  </span><br><span class="line">    <span class="keyword">return</span> Math.max(dp[<span class="number">0</span>], dp[<span class="number">1</span>]);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] robDFS(TreeNode root) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span>[] left = robDFS(root.left);  </span><br><span class="line">    <span class="type">int</span>[] right = robDFS(root.right);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;Math.max(left[<span class="number">0</span>], left[<span class="number">1</span>]) + Math.max(right[<span class="number">0</span>], right[<span class="number">1</span>]), root.val + left[<span class="number">0</span>] + right[<span class="number">0</span>]&#125;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="看解析">看解析</h2><h3 id="198-打家劫舍-2">198 打家劫舍</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html" >https://programmercarl.com/0198.打家劫舍.html<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="213-打家劫舍-II-2">213 打家劫舍 II</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII.html" >https://programmercarl.com/0213.打家劫舍II.html<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="337-打家劫舍-III-2">337 打家劫舍 III</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII.html" >https://programmercarl.com/0337.打家劫舍III.html<i class="fas fa-external-link-alt"></i></a>)</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：都是看了解析写出。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-26 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="动态规划" scheme="https://kiml.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="树形dp" scheme="https://kiml.github.io/tags/%E6%A0%91%E5%BD%A2dp/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第三十七天-322零钱兑换、279完全平方数、139单词拆分</title>
    <link href="https://kiml.github.io/posts/f80db845/"/>
    <id>https://kiml.github.io/posts/f80db845/</id>
    <published>2024-06-25T01:07:33.000Z</published>
    <updated>2024-06-25T08:39:26.748Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：322 递推公式看了题解。279 与 322 一样，AC 了。139 用回溯超时。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-25 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="初步题解">初步题解</h2><h3 id="322-零钱兑换">322 零钱兑换</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/coin-change" >https://leetcode.cn/problems/coin-change<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i]</code> 的含义：填满 i（包括 i）这么大容积的包，需要的最小个数为 <code>dp[i]</code></p></li><li class="lvl-3"><p>递推公式：<code>dp[i] = Math.min(dp[i], dp[i - coin] + 1)</code>。（这里比较难想，<mark>背包放这个硬币的计算为不放的结果加一</mark>）</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[0] = 0</code>。背包大小为 0，方法数也为 0。（<em>根据题中给出的示例 3</em>）</p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历（<em>完全背包</em>）。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 思路：  </span></span><br><span class="line"><span class="comment"> * 1. 硬币获取可以重复（完全背包）  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> coins 硬币数组  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> amount 数量  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;  </span><br><span class="line">    <span class="comment">// dp 表示凑成金额所需要的最小个数  </span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];  </span><br><span class="line">    Arrays.fill(dp, amount + <span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> coin; i &lt; dp.length; i++) &#123;  </span><br><span class="line">            <span class="keyword">if</span>(dp[i - coin] != amount + <span class="number">1</span>) &#123;  </span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i- coin] + <span class="number">1</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.toString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[amount] == amount + <span class="number">1</span> ? -<span class="number">1</span> : dp[amount];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="279-完全平方数">279 完全平方数</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/perfect-squares" >https://leetcode.cn/problems/perfect-squares<i class="fas fa-external-link-alt"></i></a>)</p><p>和上题完全一样，区别只有取值数组的值需要自己计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 思路：背包大小为n，从1-根号n之间取数  </span></span><br><span class="line"><span class="comment"> * 1. 数可以重复取值，完全背包  </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 和为n  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;  </span><br><span class="line">    <span class="comment">// dp[i] 表示和为n的完全平方数的最小数量  </span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];  </span><br><span class="line">    Arrays.fill(dp, n + <span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>) Math.sqrt(n);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= num; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i * i; j &lt; dp.length; j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (dp[j - i * i] != n + <span class="number">1</span>) &#123;  </span><br><span class="line">                dp[j] = Math.min(dp[j], dp[j - i * i] + <span class="number">1</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.toString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[n];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="139-单词拆分">139 单词拆分</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/word-break" >https://leetcode.cn/problems/word-break<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回溯方法。这样写会超时🤕</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;  </span><br><span class="line">    wordDict.sort(Comparator.comparingInt(String::length));  </span><br><span class="line">    <span class="keyword">return</span> wordBreakBFS(s, wordDict, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">wordBreakBFS</span><span class="params">(String s, List&lt;String&gt; wordDict, List&lt;String&gt; word)</span> &#123;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">join</span> <span class="operator">=</span> String.join(<span class="string">&quot;&quot;</span>, word);  </span><br><span class="line">    <span class="keyword">if</span> (s.length() &lt;= join.length()) &#123;  </span><br><span class="line">        <span class="keyword">return</span> s.equals(String.join(<span class="string">&quot;&quot;</span>, word));  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!s.startsWith(join)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (String string : wordDict) &#123;  </span><br><span class="line">        word.add(string);  </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> wordBreakBFS(s, wordDict, word);  </span><br><span class="line">        <span class="keyword">if</span> (b) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        word.remove(word.size() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="看解析">看解析</h2><h3 id="322-零钱兑换-2">322 零钱兑换</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html" >https://programmercarl.com/0322.零钱兑换.html<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="279-完全平方数-2">279 完全平方数</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html" >https://programmercarl.com/0279.完全平方数.html<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="139-单词拆分-2">139 单词拆分</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86.html" >https://programmercarl.com/0139.单词拆分.html<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i]</code> 的含义：字符串长度为 i，<code>dp[i]</code> 表示是否可以拆分，可以返回 true。</p></li><li class="lvl-3"><p>递推公式：如果 <code>dp[j]</code> 为 true，并且字符串下标 <code>j-i</code> 截取的字符在字典内，说明可以拆分。</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[0] = true</code>。初始值为了保证后续计算不会一直为 false。</p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历（<em>完全背包</em>）。由于是排列问题，所以先遍历背包大小。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;  </span><br><span class="line">    <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length() + <span class="number">1</span>];  </span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; dp.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (String word : wordDict) &#123;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> word.length();  </span><br><span class="line">            <span class="keyword">if</span> (i &gt;= len &amp;&amp; dp[i - len] &amp;&amp; word.equals(s.substring(i - len, i))) &#123;  </span><br><span class="line">                dp[i] = <span class="literal">true</span>;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.toString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[s.length()];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回溯记忆法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; set;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] memo;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">        set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordDict);</span><br><span class="line">        <span class="keyword">return</span> backtracking(s, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backtracking</span><span class="params">(String s, <span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="comment">// System.out.println(startIndex);</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex == s.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[startIndex] == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> s.substring(startIndex, i + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 拆分出来的单词无法匹配</span></span><br><span class="line">            <span class="keyword">if</span> (!set.contains(sub)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> backtracking(s, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (res) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里是关键，找遍了startIndex~s.length()也没能完全匹配，标记从startIndex开始不能找到</span></span><br><span class="line">        memo[startIndex] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;状态：322 递推公式看了题解。279 与 322 一样，AC 了。139 用回溯超时。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-25 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="动态规划" scheme="https://kiml.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="完全背包" scheme="https://kiml.github.io/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>面试 Redis</title>
    <link href="https://kiml.github.io/posts/25de1bd9/"/>
    <id>https://kiml.github.io/posts/25de1bd9/</id>
    <published>2024-06-24T13:09:59.000Z</published>
    <updated>2024-06-25T07:51:44.404Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br><br>❗表示必掌握，❔表示基本不会问</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-24 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="什么是-Redis">什么是 Redis</h2><p>Redis(Remote Dictionary Server) 是一个使用 C 语言编写的，开源的（BSD 许可）高性能非关系型（NoSQL）的键值对数据库。</p><p>Redis 可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。</p><h3 id="什么是-NoSQL？">什么是 NoSQL？</h3><p>NoSQL 的全称是 Not-Only SQL，指的是非关系型数据库，它是关系型数据库的补充，没有表与表之间的关系，主要用于海量数据的处理问题。</p><h3 id="除了-Redis，你还了解其它的-NoSQL-吗">除了 Redis，你还了解其它的 NoSQL 吗?</h3><p>nosql 数据库有很多，比如 HBase、MongoDB、Memcached 等，Redis 相比于其他的 nosql 而言，效率高，数据结构比较丰富。</p><ul class="lvl-0"><li class="lvl-2"><p>MongoDB</p><ul class="lvl-2"><li class="lvl-6">高性能、无模式的文档型数据库 (一个文档相当于关系数据库中的一条记录，格式是 xml 或者 json 等)，支持二级索引，非常适合文档化格式的存储及查询。MongoDB 的官方定位是通用数据库，确实和 MySQL 有些像，现在也很流行，但它还是有事务、join 等短板，在事务、复杂查询应用下无法取代关系型数据库。但 MongoDB 更注重庞大数据的存储和操作，但不适合用于临时存储的缓存，如果将数据做缓存使用，还是 Redis 性能更高。</li></ul></li><li class="lvl-2"><p>Redis</p><ul class="lvl-2"><li class="lvl-6">内存型 Key/Value 系统，读写性能非常好，支持操作原子性，很适合用来做高速缓存。</li></ul></li><li class="lvl-2"><p>HBase</p><ul class="lvl-2"><li class="lvl-6">存储容量大，一个表可以容纳上亿行、上百万列，可应对超大数据量要求扩展简单的需求。</li></ul></li></ul><h2 id="Redis-有哪些优缺点？">Redis 有哪些优缺点？</h2><p>优点</p><ul class="lvl-0"><li class="lvl-2"><p>读写性能优异。Redis 能读的速度是 110000 次/s，写的速度是 81000 次/s。</p></li><li class="lvl-2"><p>支持数据持久化。支持 AOF 和 RDB 两种持久化方式。</p></li><li class="lvl-2"><p>支持事务。Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作合并后的原子性执行。</p></li><li class="lvl-2"><p>数据结构丰富。除了支持 string 类型的 value 外还支持 hash、set、zset、list 等数据结构。</p></li><li class="lvl-2"><p>支持主从复制。主机会自动将数据同步到从机，可以进行读写分离。缺点</p></li><li class="lvl-2"><p>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写。因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。</p></li><li class="lvl-2"><p>Redis 不具备自动容错和恢复功能。主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的 IP 才能恢复。</p></li><li class="lvl-2"><p>数据不同步。主机宕机，宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题，降低了系统的可用性。</p></li><li class="lvl-2"><p>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</p></li></ul><h2 id="为什么要用-Redis-为什么要用缓存？">为什么要用 Redis/为什么要用缓存？</h2><p><strong>高性能</strong><br>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！<br><strong>高并发</strong><br>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p><h2 id="为什么要用-Redis-而不用-map-guava-做缓存">为什么要用 Redis 而不用 map/guava 做缓存?</h2><p>缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p><p>使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached 服务的高可用，整个程序架构上较为复杂。</p><h3 id="redis-与-Memcached-的区别是什么？为什么不选-Memcached">redis 与 Memcached 的区别是什么？为什么不选 Memcached?</h3><ol><li class="lvl-3"><p>memcached 所有的值均是简单的字符串，且只支持 k/v 类型，redis 作为其替代者，支持更为丰富的数据类型。</p></li><li class="lvl-3"><p>redis 可以持久化其数据，memcached 只用做缓存提升性能，不能做持久化。</p></li><li class="lvl-3"><p>memcached 存储数据有限制：1M 【大于 1M，认为就行分割】（内存碎片）</p></li><li class="lvl-3"><p>memcached 集群数据没有复制和同步机制（崩溃不会影响程序，会从数据库中取数据）。</p></li><li class="lvl-3"><p>memcached 内存不能及时回收，它只有 LRU(算法) 这一种方式，而 redis 有多种内存回收方式。</p></li></ol><h2 id="Redis-为什么这么快？">Redis 为什么这么快？</h2><ol><li class="lvl-3"><p>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O(1)；</p></li><li class="lvl-3"><p>数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；</p></li><li class="lvl-3"><p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p></li><li class="lvl-3"><p>使用多路 I/O 复用模型，非阻塞 IO；</p></li><li class="lvl-3"><p>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p></li></ol><h2 id="Redis-的主要缺点是什么？">Redis 的主要缺点是什么？</h2><ol><li class="lvl-3"><p>[[07 Redis面试#在工作中，如果数据库修改了数据，那就跟redis数据不同步了，此时该办？（缓存双写一致性问题）|缓存和数据库双写一致性问题]]</p></li><li class="lvl-3"><p>[[07 Redis面试#缓存雪崩|缓存雪崩问题]]</p></li><li class="lvl-3"><p>[[07 Redis面试#缓存穿透|缓存穿透问题]]</p></li><li class="lvl-3"><p>[[07 Redis面试#那怎么解决缓存的并发竞争问题？比如多个子系统去set一个key但最后执行顺序和我们期望顺序不一样。|缓存的并发竞争问题]]</p></li></ol><h2 id="数据类型">数据类型</h2><h3 id="Redis-的数据类型有哪些？它的数据操作是怎么样的？">Redis 的数据类型有哪些？它的数据操作是怎么样的？</h3><ul class="lvl-0"><li class="lvl-2"><p>数据类型</p><ul class="lvl-2"><li class="lvl-6">string、hash、list(有序、可重复)、set(无序、不可重复)、zset(不可重复，基于 score 实现排序)</li></ul></li><li class="lvl-2"><p>数据操作</p><ul class="lvl-2"><li class="lvl-6">Redis 中的数据存储方式是 key-value 形式</li><li class="lvl-6">Redis 不能保存 JAVA 对象，需要转为 JSON 对象后存入 Redis</li></ul></li></ul><table><thead><tr><th>数据类型</th><th>可以存储的值</th><th>操作</th><th>应用场景</th></tr></thead><tbody><tr><td>String</td><td>字符串、整数或浮点数</td><td>1.对整个字符串或者字符串的其中一部分执行操作 2.对整数和浮点数执行自增或自减操作</td><td>做简单的键值对缓存</td></tr><tr><td>List</td><td>列表</td><td>1.从两端压入或弹出元素 2.对单个或多个元素进行修剪，只保留一个范围内的元素</td><td>存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的数据</td></tr><tr><td>Set</td><td>无序集合</td><td>1.添加、获取、移除单个元素 2.检查一个元素是否在集合中 3.计算交集、并集、差集 从集合里面随机获取元素</td><td>交集、并集、差集的操作，比如两人的粉丝列表做交集</td></tr><tr><td>Hash</td><td>包含键值对的无序散列表</td><td>1.添加、获取、移除单个键值对 2.获取所有键值对 3.检查某个键是否存在</td><td>结构化的数据，比如一个对象</td></tr><tr><td>ZSet</td><td>有序集合</td><td>1.添加、获取、移除元素 2.根据分值范围或成员来获取元素 3.计算一个键的排名</td><td>去重，但可以排序，如获取前几名用户</td></tr></tbody></table><h3 id="Redis-的应用场景">Redis 的应用场景</h3><ol><li class="lvl-3"><p>计数器</p><ul class="lvl-2"><li class="lvl-6">可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</li></ul></li><li class="lvl-3"><p>缓存</p><ul class="lvl-2"><li class="lvl-6">将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</li></ul></li><li class="lvl-3"><p>会话缓存</p><ul class="lvl-2"><li class="lvl-6">可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</li></ul></li><li class="lvl-3"><p>全页缓存（FPC）</p><ul class="lvl-2"><li class="lvl-6">除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</li></ul></li><li class="lvl-3"><p>查找表</p><ul class="lvl-2"><li class="lvl-6">例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</li></ul></li><li class="lvl-3"><p>消息队列 (发布/订阅功能)</p><ul class="lvl-2"><li class="lvl-6">List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。</li></ul></li><li class="lvl-3"><p>分布式锁实现</p><ul class="lvl-2"><li class="lvl-6">在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</li></ul></li><li class="lvl-3"><p>其它</p><ul class="lvl-2"><li class="lvl-6">Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。</li></ul></li></ol><h3 id="Redis-应用场景（根据类型）">Redis 应用场景（根据类型）</h3><ul class="lvl-0"><li class="lvl-2"><p>String</p><ul class="lvl-2"><li class="lvl-6">适合最简单的 k-v 存储，类似于 memcached 的存储结构，短信验证码，配置信息等，就用这种类型来存储。</li></ul></li><li class="lvl-2"><p>Hash</p><ul class="lvl-2"><li class="lvl-6">一般 key 为 ID 或者唯一标示，value 对应的就是详情了。如商品详情，个人信息详情，新闻详情等。</li></ul></li><li class="lvl-2"><p>List</p><ul class="lvl-2"><li class="lvl-6">因为 list 是有序的，比较适合存储一些有序且数据相对固定的数据。如省市区表、字典表等。因为 list 是有序的，适合根据写入的时间来排序，如：最新的***，消息队列等。</li></ul></li><li class="lvl-2"><p>Set</p><ul class="lvl-2"><li class="lvl-6">可以简单的理解为 ID-List 的模式，如微博中一个人有哪些好友，set 最牛的地方在于，可以对两个 set 提供交集、并集、差集操作。例如：查找两个人共同的好友等。</li></ul></li><li class="lvl-2"><p>ZSet</p><ul class="lvl-2"><li class="lvl-6">自动会根据 score 的值进行排序。比较适合类似于 top 10 等不根据插入的时间来排序的数据。</li></ul></li></ul><h2 id="Redis-持久化">Redis 持久化</h2><h3 id="什么是-Redis-持久化？">什么是 Redis 持久化？</h3><ul class="lvl-0"><li class="lvl-2"><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p></li></ul><h3 id="Redis-的持久化机制是什么？各自的优缺点？">Redis 的持久化机制是什么？各自的优缺点？</h3><h4 id="RDB">RDB</h4><ul class="lvl-0"><li class="lvl-2"><p>简述</p><ul class="lvl-2"><li class="lvl-6">RDB 是二进制快照形式，数据体量小，保存效率高，但丢失风险也较大，因为它是定时定量更改才会自动持久化，无法实时存储，如果在快照之前丢失，则无法找回。</li></ul></li><li class="lvl-2"><p>优点</p><ol><li class="lvl-7">只有一个文件 dump.rdb，方便持久化。</li><li class="lvl-7">容灾性好，一个文件可以保存到安全的磁盘。</li><li class="lvl-7">性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能</li><li class="lvl-7">相对于数据集大时，比 AOF 的启动效率更高。</li></ol></li><li class="lvl-2"><p>缺点</p><ol><li class="lvl-7">数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)</li></ol></li></ul><h4 id="AOF">AOF</h4><ul class="lvl-0"><li class="lvl-2"><p>简述</p><ul class="lvl-2"><li class="lvl-6">AOF 是过程命令形式，数据体量大 (可以用 AOF 重写解决该问题)，效率低于 RDB，记录每个操作，存储格式也更复杂，但数据相对完整 (最快可以每秒同步一次)，且弥补了 RDB 不能实时存储的缺点。</li></ul></li><li class="lvl-2"><p>优点</p><ol><li class="lvl-7">数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。</li><li class="lvl-7">通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</li><li class="lvl-7">AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)</li></ol></li><li class="lvl-2"><p>缺点</p><ol><li class="lvl-7">AOF 文件比 RDB 文件大，且恢复速度慢。</li><li class="lvl-7">数据集大的时候，比 rdb 启动效率低。</li></ol></li></ul><h5 id="AOF-数据体量大，那有什么办法可以解决这个问题吗？">AOF 数据体量大，那有什么办法可以解决这个问题吗？</h5><ul class="lvl-0"><li class="lvl-2"><p>Redis 中引入了 AOF 重写机制可以压缩文件体积——执行压缩命令即可。</p></li><li class="lvl-2"><p>AOF 重写可以降低磁盘占用量，也能提高数据恢复效率，它会对同一数据的多条写命令合并为一条写命令，且为了防止数据量过大造成缓冲区溢出，每条指令最多为 64 个元素。</p></li><li class="lvl-2"><p>AOF 重写其实是一个同步开启的子进程，Redis 执行指令时，子进程也会开启重写，主进程会将写入的数据同步到子进程，子进程则开始重写 AOF 文件，写完后再返回给主进程，完成 AOF 重写。</p></li></ul><h4 id="选用">选用</h4><ul class="lvl-0"><li class="lvl-2"><p>AOF 文件比 RDB 更新频率高，优先使用 AOF 还原数据。</p></li><li class="lvl-2"><p>AOF 比 RDB 更安全也更大</p></li><li class="lvl-2"><p>RDB 性能比 AOF 好</p></li><li class="lvl-2"><p>如果两个都配了优先加载 AOF</p></li><li class="lvl-2"><p>如果对数据非常敏感用 AOF，如果追求大数据集的恢复速度选 RDB。</p></li></ul><h3 id="Redis-持久化数据和缓存怎么做扩容？">Redis 持久化数据和缓存怎么做扩容？</h3><ul class="lvl-0"><li class="lvl-2"><p>如果 Redis 被当做缓存使用，使用一致性哈希实现动态扩容缩容。</p></li><li class="lvl-2"><p>如果 Redis 被当做一个持久化存储使用，必须使用固定的 keys-to-nodes 映射关系，节点的数量一旦确定不能变化。否则的话 (即 Redis 节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有 Redis 集群可以做到这样。</p></li></ul><h2 id="数据删除">数据删除</h2><h3 id="Redis-是怎么进行数据删除的？过期删除策略？">Redis 是怎么进行数据删除的？过期删除策略？</h3><h4 id="三种过期策略">三种过期策略</h4><h5 id="定时删除">定时删除</h5><ul class="lvl-0"><li class="lvl-2"><p>创建一个定时器，当 key 设置过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作。</p></li><li class="lvl-2"><p>这样的好处是及时快速释放内存，坏处时，消耗过多的处理器性能。</p></li></ul><h5 id="惰性删除">惰性删除</h5><ul class="lvl-0"><li class="lvl-2"><p>定时删除策略中，从删除方法来看，必然会导致有 key 过期了但未从 redis 中删除的情况。</p></li><li class="lvl-2"><p>面对这种情况，redis 在操作一个 key 时，会先判断这个值是否过期，若已过期，则删除该 key；若未过期，则进行后续操作。</p></li></ul><h5 id="定期删除（常用）">定期删除（常用）</h5><ul class="lvl-0"><li class="lvl-2"><p>Redis 默认会每秒进行十次过期扫描，过期扫描不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策略。</p><ol><li class="lvl-7">从过期字典中随机 20 个 key；</li><li class="lvl-7">删除这 20 个 key 中已经过期的 key；</li><li class="lvl-7">如果过期的 key 比率超过 1/4，那就重复步骤 1；</li><li class="lvl-7">同时，为了保证过期扫描不会出现循环过度，导致线程卡死现象，算法还增加了扫描时间的上限，默认不会超过 25ms。</li><li class="lvl-7">如果某一时刻，有大量 key 同时过期，Redis 会持续扫描过期字典，造成客户端响应卡顿，因此设置过期时间时，就尽量避免这个问题，在设置过期时间时，可以给过期时间设置一个随机范围，避免同一时刻过期。</li></ol></li><li class="lvl-2"><p>(expires 字典会保存所有设置了过期时间的 key 的过期时间数据，其中，key 是指向键空间中的某个键的指针，value 是该键的毫秒精度的 UNIX 时间戳表示的过期时间。键空间是指该 Redis 集群中保存的所有键。)<br><strong>Redis 中同时使用了惰性过期和定期过期两种过期策略。</strong></p></li></ul><h3 id="怎么判断一个-Key-还有多少时间">怎么判断一个 Key 还有多少时间</h3><ul class="lvl-0"><li class="lvl-2"><p>TTL 命令（命令行）</p><ul class="lvl-2"><li class="lvl-6">正数 -&gt; 剩余时间</li><li class="lvl-6">-1 -&gt; 永久 Key</li><li class="lvl-6">-2 -&gt; Key 已经过期或者不存在</li></ul></li></ul><h3 id="如何配置定期删除执行时间间隔？">如何配置定期删除执行时间间隔？</h3><ul class="lvl-0"><li class="lvl-2"><p>redis 的定时任务默认是 10s 执行一次，如果要修改这个值，可以在 redis.conf 中修改 hz 的值。</p></li><li class="lvl-2"><p>redis.conf 中，hz 默认设为 10，提高它的值将会占用更多的 cpu，当然相应的 redis 将会更快的处理同时到期的许多 key，以及更精确的去处理超时。</p></li><li class="lvl-2"><p>hz 的取值范围是 1~500，通常不建议超过 100，只有在请求延时非常低的情况下可以将值提升到 100。</p></li></ul><h3 id="单线程的-redis，如何知道要运行定时任务">单线程的 redis，如何知道要运行定时任务</h3><ul class="lvl-0"><li class="lvl-2"><p>redis 是单线程的，线程不但要处理定时任务，还要处理客户端请求，线程不能阻塞在定时任务或处理客户端请求上，那么，redis 是如何知道何时该运行定时任务的呢？</p></li><li class="lvl-2"><p>Redis 的定时任务会记录在一个称为最小堆的数据结构中。这个堆中，最快要执行的任务排在堆的最上方。在每个循环周期，Redis 都会将最小堆里面已经到点的任务立即进行处理。处理完毕后，将最快要执行的任务还需要的时间记录下来，这个时间就是接下来处理客户端请求的最大时长，若达到了该时长，则暂时不处理客户端请求而去运行定时任务。</p></li></ul><h3 id="Redis-key-的过期时间和永久有效分别怎么设置？">Redis key 的过期时间和永久有效分别怎么设置？</h3><ul class="lvl-0"><li class="lvl-2"><p>EXPIRE 和 PERSIST 命令。</p></li></ul><h2 id="内存淘汰">内存淘汰</h2><h3 id="Redis-的内存淘汰策略有哪些？">Redis 的内存淘汰策略有哪些？</h3><ul class="lvl-0"><li class="lvl-2"><p>Redis 的内存淘汰策略是指在 Redis 的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p></li></ul><table><thead><tr><th>操作的数据集</th><th>内存淘汰策略</th><th>说明</th></tr></thead><tbody><tr><td><strong>设置过期时间的键空间选择性移除</strong>（可能会过期的数据集 server.db[i].expires）</td><td>volatile-lru</td><td>淘汰最近一次使用时间距现在<strong>最久</strong>的数据（Least Recently Used）<strong>最常用</strong></td></tr><tr><td></td><td>volatile-lfu</td><td>淘汰使用<strong>次数最少</strong>的数据（Least Frequently Used）</td></tr><tr><td></td><td>volatile-ttl</td><td>淘汰过期时间最近的数据</td></tr><tr><td></td><td>volatile-random</td><td>淘汰随机数据</td></tr><tr><td><strong>全局的键空间选择性移除</strong>（所有数据集）</td><td>allkeys-lru</td><td>淘汰最近一次使用时间距现在最久的数据</td></tr><tr><td></td><td>allkeys-lfu</td><td>淘汰使用次数最少的数据</td></tr><tr><td></td><td>allkeys-random</td><td>淘汰随机数据</td></tr><tr><td><strong>放弃数据驱逐</strong></td><td>no-enviction</td><td>禁止驱逐数据（redis4.0 中默认策略），会引发错误 OOM(Out Of Memory)</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p><strong>总结</strong></p><ul class="lvl-2"><li class="lvl-6">Redis 的内存淘汰策略的选取并不会影响过期的 key 的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。</li></ul></li></ul><h3 id="MySQL-里有-2000w-数据，redis-中只存-20w-的数据，如何保证-redis-中的数据都是热点数据？">MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据？</h3><ul class="lvl-0"><li class="lvl-2"><p>redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略 (上面的 allkeys-lru，移除最近最少使用的 key)。</p></li></ul><h3 id="Redis-主要消耗什么物理资源？">Redis 主要消耗什么物理资源？</h3><ul class="lvl-0"><li class="lvl-2"><p>内存。</p></li></ul><h3 id="Redis-的内存用完了会发生什么？">Redis 的内存用完了会发生什么？</h3><ul class="lvl-0"><li class="lvl-2"><p>如果达到设置的上限，Redis 的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当 Redis 达到内存上限时会冲刷掉旧的内容。</p></li></ul><h3 id="Redis-如何做内存优化？">Redis 如何做内存优化？</h3><ul class="lvl-0"><li class="lvl-2"><p>可以好好利用 Hash,list,sorted set,set 等集合类型数据，因为通常情况下很多小的 Key-Value 可以用更紧凑的方式存放到一起。尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的 web 系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key，而是应该把这个用户的所有信息存储到一张散列表里面</p></li></ul><h2 id="集群方案">集群方案</h2><h3 id="说一说-Redis-的主从复制">说一说 Redis 的主从复制</h3><ul class="lvl-0"><li class="lvl-2"><p>对于大型网站来说，每秒需要读取的数据远远超过单台 redis 服务所能承受的压力，而写入的数据相对来说较少，这时候用 redis 的主从复制模式可以很好的提升同一个内容的读取速度。</p></li><li class="lvl-2"><p>redis 主从复制模式其实是一个读写分离模型，将主服务器用来处理写操作，从服务器只提供读操作，不过主从复制是所有内容完全一致的，而不是分库分表的，严格来说不算集群。</p></li><li class="lvl-2"><p>主从复制模式最大的问题是只有一个主节点，没有实现高可用，所以还需要哨兵机制来实现高可用。</p></li></ul><h4 id="主从同步过程">主从同步过程</h4><ul class="lvl-0"><li class="lvl-2"><p>当启动一个 slave node 的时候，它会发送一个 <code>PSYNC &lt;runid&gt; &lt;offset&gt;</code> 命令给 master node。</p></li><li class="lvl-2"><p>如果这是 slave node 初次连接到 master node，那么会触发一次 <code>full resynchronization</code> 全量复制（<strong>接收命令判断 runid 是否匹配，判定 offset 是否在复制缓冲区中</strong>）。此时 master 会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件，</p><ul class="lvl-2"><li class="lvl-6">同时还会将从客户端 client 新收到的所有写命令缓存在 <code>replication buffer</code>（redis server 会为每一个连接到自己的客户端创建一个 replication buffer，用来缓存主库执行的命令）中。<code>RDB</code> 文件生成完毕后， master 会将这个 <code>RDB</code> 发送给 slave，slave 会先<strong>写入本地磁盘，然后再从本地磁盘加载到内存</strong>中，过程中基于旧的数据对外提供服务。<ul class="lvl-4"><li class="lvl-10">如果 <code>replication buffer</code> 写满了（client-output-buffer-limit），无论客户端是普通客户端还是从库，只能断开跟这个客户端的连接了。这样从库全量同步失败，只能再次尝试全量同步。</li></ul></li><li class="lvl-6">接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。<ul class="lvl-4"><li class="lvl-10">如果 slave node 开启了 AOF，那么立即执行重写 AOF</li></ul></li></ul></li><li class="lvl-2"><p>slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。（主库的写命令，除了传给从库后，还会写入 <code>repl_backlog_buffer</code>）</p><ul class="lvl-2"><li class="lvl-6">如果从给的 runid 和 offset 都是对的，那么主服务器就会从上次同步的 offset 位置开始进行增量同步</li><li class="lvl-6">如果 offset 已经小于了主的复制缓冲区中最小的那个偏移量，就会进行全量复制</li><li class="lvl-6">切换了主服务器也会进行全量复制</li></ul></li></ul><p>![[Pasted image 20221107210154.png|600]]</p><h3 id="什么是-Redis-哨兵？">什么是 Redis 哨兵？</h3><ul class="lvl-0"><li class="lvl-2"><p>sentinel(哨兵) 是用于监控 redis 集群中 Master 状态的工具，其本质就是一个独立运行的进程，是 Redis 的高可用解决方案。</p></li><li class="lvl-2"><p>sentinel 可以监视一个或者多个 redis master 服务，以及这些 master 服务的所有从服务；当某个 master 服务下线时，自动将该 master 下的某个从服务升级为 master 服务替代已下线的 master 服务继续处理请求，并且其余从节点开始从新的主节点复制数据。（它会直接修改配置文件，来实现修改主服务器）</p></li><li class="lvl-2"><p>在 redis 安装完成后，会有一个 redis-sentinel 的文件，这就是启动 sentinel 的脚本文件，同时还有一个 sentinel.conf 文件，这个是 sentinel 的配置文件。</p></li><li class="lvl-2"><p>但哨兵也可能会挂，所以需要对哨兵也实现高可用（<strong>集群</strong>）。</p></li></ul><h4 id="哨兵的核心知识">哨兵的核心知识</h4><ul class="lvl-0"><li class="lvl-2"><p>哨兵至少需要 3 个实例，来保证自己的健壮性。</p></li><li class="lvl-2"><p>哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。</p></li><li class="lvl-2"><p>对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</p></li></ul><h3 id="redis-cluster-集群">redis cluster 集群</h3><p>![[04 Redis面试 2022-11-07.excalidraw]]</p><h4 id="为什么要搭建-Redis-集群？">为什么要搭建 Redis 集群？</h4><ul class="lvl-0"><li class="lvl-2"><p>Redis 有内置集群 cluster，redis Cluster 是无中心节点的集群架构，本身就是去中心化的，也就是说，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。</p></li><li class="lvl-2"><p>cluster 集群中内置了哨兵机制，不需要再额外启动哨兵程序。</p></li><li class="lvl-2"><p>Redis cluster 为了保证数据的高可用，加入了主从模式，主节点只用来存，从节点只用来取，如果主节点挂掉了，就会在从节点中选取一个来充当主节点。当然，如果通过集群命令，还可以使现在任何一个节点写入。</p></li></ul><h5 id="Redis-集群工作流程">Redis 集群工作流程</h5><ol><li class="lvl-4"><p>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽 (哈希值) 区间的数据，默认分配了 16384 个槽位</p></li><li class="lvl-4"><p>每份数据分片会存储在多个互为主从的多节点上</p></li><li class="lvl-4"><p>数据写入先写主节点，再同步到从节点 (支持配置为阻塞同步)</p></li><li class="lvl-4"><p>同一分片多个节点间的数据不保持一致性</p></li><li class="lvl-4"><p>读取数据时，当客户端操作的 key 没有分配在该节点上时，redis 会返回转向指令，指向正确的节点</p></li><li class="lvl-4"><p>扩容时时需要需要把旧节点的数据迁移一部分到新节点在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是 加 1w 的端口号，比如 16379。<br>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议，<code>gossip</code> 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p></li></ol><h5 id="你知道哪些分布式寻址法？">你知道哪些分布式寻址法？</h5><ul class="lvl-0"><li class="lvl-2"><p>hash 算法（大量缓存重建）</p></li><li class="lvl-2"><p>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</p></li><li class="lvl-2"><p>redis cluster 的 hash slot （槽）算法</p></li></ul><h6 id="你了解一致性哈希吗？">你了解一致性哈希吗？</h6><ul class="lvl-0"><li class="lvl-2"><p>简单来说，一致性 Hash 算法将整个哈希值空间组织成一个虚拟的圆环，整个空间圆按顺时针方向布局，正上方点代表 0，也代表 2^32-1，即一共 2^32 个点组成的圆环称为 Hash 环。</p></li><li class="lvl-2"><p>一致性哈希算法可用于 Redis 的集群搭建，当然这种用法已经过时了，现在可以用 Redis cluster 的哈希槽来替代一致性哈希算法，实现集群搭建。</p></li><li class="lvl-2"><p>使用一致性哈希算法时，多个服务器也会落在这个 Hash 环上，并且能确定各自的位置，这样用户访问的时候，会根据用户 IP 计算出哈希值，对应到哈希环上，并顺时针行走，遇到的第一台服务器就是该用户被分配到的服务器。</p></li><li class="lvl-2"><p>但是一致性哈希会有数据倾斜的问题，也就是可能多台服务器聚集在相近的地方，这时就需要将服务器多构建几个虚拟节点，来分散到 Hash 环上的各个位置，来使数据分配的服务器较为均衡，设置的虚拟节点约多，数据分配的越是相对均匀。</p></li></ul><h4 id="Redis-集群是同步复制还是异步复制？是否会有写操作丢失情况？为什么？">Redis 集群是同步复制还是异步复制？是否会有写操作丢失情况？为什么？</h4><ul class="lvl-0"><li class="lvl-2"><p>异步复制。</p><ul class="lvl-2"><li class="lvl-6">Redis 主节点与从节点之间的数据复制是异步复制的，当客户端发送写请求给 master 节点的时候，客户端会直接返回 OK，然后主节点同步到各个从节点中。</li></ul></li><li class="lvl-2"><p>如果主节点没来得及同步给从节点时发生宕机，那么主节点内存中的数据就会丢失。</p></li></ul><h5 id="如果主节点中开启持久化，能不能保证数据不丢失呢？">如果主节点中开启持久化，能不能保证数据不丢失呢？</h5><ul class="lvl-0"><li class="lvl-2"><p>不能。</p><ul class="lvl-2"><li class="lvl-6">主节点宕机后（脑裂也会有相同的数据丢失问题），会自动启动哨兵机制，重新选举新的主节点，如果这时候旧的主节点恢复故障重启了，它就会去同步新的主节点数据，而这时新的主节点并没有同步那之前丢失的数据，旧的主节点的上的数据则会在同步新主节点上数据时，刷新掉，此时数据还是会丢失。</li></ul></li></ul><h5 id="怎么才能保证数据不丢失？或者如保证尽量少的数据丢失？">怎么才能保证数据不丢失？或者如保证尽量少的数据丢失？</h5><ul class="lvl-0"><li class="lvl-2"><p>没办法完全保证数据不丢失。但是可以通过设置主从节点间的同步复制延迟时间来尽量少的数据丢失。</p></li><li class="lvl-2"><p>比如，在 Redis 集群中，在 redis 配置文件中修改同步复制延迟的时间不超过 10s，一但延迟超过这个时间，说明主节点可能出了问题（不一定是宕机），那么配置生效，主节点只能读，不能再写入。</p><ul class="lvl-2"><li class="lvl-6">min-slaves-to-write 1</li><li class="lvl-6">min-slaves-max-lag 10</li><li class="lvl-6">要求至少有 1 个 slave，数据复制和同步的延迟不能超过 10 秒（这样脑裂最多就丢失 10s 数据）</li></ul></li><li class="lvl-2"><p>同时在客户端做降级处理，把数据写到本地磁盘。</p></li></ul><h4 id="什么是-Redis-脑裂？会存在什么问题？">什么是 Redis 脑裂？会存在什么问题？</h4><ul class="lvl-0"><li class="lvl-2"><p>一个集群中的 master 恰好网络故障，导致与 sentinal 联系不上了，sentinal 把另一个 slave 提升为了 master。此时就存在两个 master 了。</p></li><li class="lvl-2"><p>当我们发现的时候，停止掉其中的一个 master，手动切换成 slave，当它连接到提升后的 master 的时候，会开始同步数据，那么自己脑裂期间接收的写数据就被丢失了。</p></li></ul><h4 id="Redis-集群如何选择数据库？">Redis 集群如何选择数据库？</h4><ul class="lvl-0"><li class="lvl-2"><p>Redis 集群目前无法做数据库选择，默认在 0 数据库。</p></li></ul><h4 id="Redis-集群最大节点个数是多少？">Redis 集群最大节点个数是多少？</h4><ul class="lvl-0"><li class="lvl-2"><p>16384 个</p></li></ul><h4 id="生产环境中的-redis-是怎么部署的？">生产环境中的 redis 是怎么部署的？</h4><ul class="lvl-0"><li class="lvl-2"><p>redis cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署了 redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰 qps 可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求/s。</p></li><li class="lvl-2"><p>机器是什么配置？32G 内存 + 8 核 CPU + 1T 磁盘，但是分配给 redis 进程的是 10g 内存，一般线上生产环境，redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。</p></li><li class="lvl-2"><p>5 台机器对外提供读写，一共有 50g 内存。</p></li><li class="lvl-2"><p>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，redis 从实例会自动变成主实例继续提供读写服务。</p></li><li class="lvl-2"><p>你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。其实大型的公司，会有基础架构的 team 负责缓存集群的运维。</p></li></ul><h2 id="缓存异常">缓存异常</h2><h3 id="缓存预热">缓存预热</h3><ul class="lvl-0"><li class="lvl-2"><p>系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。用户直接查询事先被预热的缓存数据。<br><strong>解决方法</strong></p></li><li class="lvl-2"><p>自动：使用监听器（web/Spring boot）监听某个事件（项目启动/容器的创建），在事件触发时查询数据库，把一些热门数据提前缓存到 Redis 中</p></li><li class="lvl-2"><p>手动：使用单元测试脚本 动态的往 Redis 中进行数据的添加</p></li></ul><h3 id="缓存雪崩">缓存雪崩</h3><ul class="lvl-0"><li class="lvl-2"><p>缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。<br><strong>解决方法</strong></p></li><li class="lvl-2"><p>设置缓存的失效时间尽量错开（比如 30 天 + 随机数 (s)），热门数据时间长点，不热门的时间短点。</p></li><li class="lvl-2"><p>设置多级缓存，Nginx 缓存 +redis 缓存 +ehcache 缓存……每一个缓存都是一个集群，相同的数据会在多种服务器进行缓存，可以 100% 解决缓存雪崩。</p></li><li class="lvl-2"><p>侧面解决：优化数据库，提升效率，使用页面静态技术（多级缓存）代替从 redis 中取值。</p></li><li class="lvl-2"><p>限流/降级</p></li><li class="lvl-2"><p>超热数据使用永久 Key（定期维护）</p></li></ul><h3 id="缓存穿透">缓存穿透</h3><ul class="lvl-0"><li class="lvl-2"><p>就是指反复查询一个数据库一定不存在的数据，导致数据库压力过大，这种情况一般只有恶意攻击才会出现。<br><strong>解决方法</strong></p></li><li class="lvl-2"><p>接口层增加校验，如用户鉴权校验，id 做基础校验，id&lt;=0 的直接拦截</p></li><li class="lvl-2"><p>从缓存取不到的数据，在数据库中也没有取到，这时也可以将 key-value 对写为 key-null，缓存有效时间可以设置短点，如 30 秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个 id 暴力攻击</p></li><li class="lvl-2"><p>采用布隆过滤器（在海量数据中判断一个数据是否存在），将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。根据 Hash 判断，如果数据不存在，那么一定不存在。</p></li><li class="lvl-2"><p>加密参数，符合加密规则的参数才会被接收</p></li></ul><h3 id="缓存击穿">缓存击穿</h3><ul class="lvl-0"><li class="lvl-2"><p>是指一个热点 key 的 redis 缓存失效，导致大量请求瞬间集中到数据库。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。<br><strong>解决方法</strong></p></li><li class="lvl-2"><p>多级缓存</p></li><li class="lvl-2"><p>延长热点数据有效期。</p></li><li class="lvl-2"><p>限流/降级</p></li></ul><h3 id="缓存降级">缓存降级</h3><ul class="lvl-0"><li class="lvl-2"><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p></li></ul><h3 id="热点数据和冷数据">热点数据和冷数据</h3><ul class="lvl-0"><li class="lvl-2"><p>热点数据，缓存才有价值</p><ul class="lvl-2"><li class="lvl-6">某 IM 产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。某导航产品，我们将导航信息，缓存以后可能读取数百万次。</li></ul></li><li class="lvl-2"><p>对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。</p></li><li class="lvl-2"><p>频繁修改的数据，看情况考虑使用缓存</p><ul class="lvl-2"><li class="lvl-6">这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到 Redis 缓存，减少数据库压力。</li></ul></li></ul><h2 id="线程模型">线程模型</h2><h3 id="为什么-Redis-是单线程的？">为什么 Redis 是单线程的？</h3><ul class="lvl-0"><li class="lvl-2"><p>Redis 的底层主要是三大部分：IO 多路复用程序 + 队列 + 文件事件分派器。而文件事件分派器就是用来分派执行任务的，且它是单线程的，所以说 Redis 也是单线程的。</p></li><li class="lvl-2"><p>此外，Redis 底层是基于 C 语言所写，且是基于内存运行，所以他的 IO 速度很快，相对来说主要要占用的是 CPU 的资源，如果实用多线程反而会因为线程的切换增大开销，降低效率，对于不是处理海量数据，多用于缓存使用的 Redis 来说，使用单线程是效率最优的。</p></li></ul><h3 id="redis-是单线程的，为什么还需要用它实现分布式锁？">redis 是单线程的，为什么还需要用它实现分布式锁？</h3><p>redis 单线程与分布式锁没有关系。redis 单线程只能保证在 redis 中的读写是按一定顺序执行（reids 不保证原子性，也不会回滚，某条命令运行失败也会继续执行），但在分布式中，是多台机器间的多进程调用，为了保证执行过程中，不被其他进程抢断执行，需要有一个第三方组件来实现分布式锁。即使数据就在 redis 中，也无法保证数据在进行其他服务处理的时候，被其他进程抢走。</p><h3 id="Redis-是单线程的，如何提高多核-CPU-的利用率？">Redis 是单线程的，如何提高多核 CPU 的利用率？</h3><p>可以在同一个服务器部署多个 Redis 的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个 CPU，你可以考虑一下分区。</p><h2 id="Redis-分区">Redis 分区</h2><h3 id="为什么要做-Redis-分区">为什么要做 Redis 分区</h3><ul class="lvl-0"><li class="lvl-2"><p>分区可以让 Redis 管理更大的内存，Redis 将可以使用所有机器的内存，提升内存和计算能力。</p></li></ul><h3 id="怎么实现-Redis-分区？">怎么实现 Redis 分区？</h3><ul class="lvl-0"><li class="lvl-2"><p>Cluster 集群就很好的实现了 Redis 分区。客户端随机地请求任意一个 redis 实例，然后由 Redis 将请求转发给正确的 Redis 节点。Redis Cluster 实现了一种混合形式的查询路由，但并不是直接将请求从一个 redis 节点转发到另一个 redis 节点，而是在客户端的帮助下直接 redirected 到正确的 redis 节点。</p></li></ul><h3 id="Redis-分区的缺点是什么？">Redis 分区的缺点是什么？</h3><ul class="lvl-0"><li class="lvl-2"><p>涉及多个 key 的操作时可能会比较麻烦一点：比如两个集合 key 在不同的机子上，那就不能直接在 redis 中做交集。</p></li></ul><h3 id="Redis-分区和集群有什么区别？">Redis 分区和集群有什么区别？</h3><ul class="lvl-0"><li class="lvl-2"><p>分区是逻辑概念，即一个 master 可以分为一个 master+n 个 slave。</p></li><li class="lvl-2"><p>集群是系统结构，集群是分区概念的一种实现方式。</p></li></ul><h2 id="分布式问题">分布式问题</h2><h3 id="那怎么解决缓存的并发竞争问题？比如多个子系统去-set-一个-key-但最后执行顺序和我们期望顺序不一样">那怎么解决缓存的并发竞争问题？比如多个子系统去 set 一个 key 但最后执行顺序和我们期望顺序不一样</h3><ul class="lvl-0"><li class="lvl-2"><p>可以采用分布式锁（zookeeper 和 redis 都可以实现分布式锁）的方案。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）</p></li><li class="lvl-2"><p>基于 zookeeper 临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在 zookeeper 上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p></li><li class="lvl-2"><p>在实践中，当然是从以可靠性为主。所以首推 Zookeeper。</p></li></ul><h3 id="说一说-Redis-分布式锁">说一说 Redis 分布式锁</h3><ul class="lvl-0"><li class="lvl-2"><p>首先，分布式锁是一种思想，是为了解决多机器多进程之间的同步问题，需要引入第三方来做锁处理。</p></li><li class="lvl-2"><p>Redis 分布式锁的加锁，其实就是给 Key 键设置一个值（SET lock_key random_value NX PX 5000，NX 表示键不存在时才设置），其他进程执行前会判断 Redis 中这个 Key 是否有值，如果发现这个 Key 有值了，就说明已有其他进程在执行，则循环等待，超时则获取失败。</p></li><li class="lvl-2"><p>解锁就是将 Key 键删除，为了保证解锁的原子性操作，用 Redis 自带的 LUA 脚本完成操作。</p></li><li class="lvl-2"><p>Redis 做为分布式锁的优点是性能高，缺点是不可靠，比如在 Redis 集群架构中，一旦主节点宕机，新的主节点会给新进程也加锁。</p></li><li class="lvl-2"><p>但不论如何，分布式锁一定会带来性能消耗问题，且实际中使用查询的比例远大于写的比例，除非是重要的敏感数据，不然为了更高的性能，一般会选择舍弃使用分布式锁。</p></li></ul><h3 id="这里为什么要用-Lua-脚本来完成解锁操作？">这里为什么要用 Lua 脚本来完成解锁操作？</h3><ul class="lvl-0"><li class="lvl-2"><p>Redis 只能保证单个指令进入 redis 是单线程原子性的，但不能保证多个命令之间的顺序是原子性的，但是 Lua 指令可以将这个命令绑定，相当于只有一个执行命令，保证它们是顺序执行的。</p></li></ul><h3 id="为什么-Redis-分布式解锁要何证原子性？">为什么 Redis 分布式解锁要何证原子性？</h3><ul class="lvl-0"><li class="lvl-2"><p>主要是怕误将其他客户端的锁解开。</p></li><li class="lvl-2"><p>比如客户端 A 加锁，一段时间之后客户端 A 解锁，在进入 unlock 后执行 jedis.del() 之前，锁突然过期了，此时客户端 B 尝试加锁成功，然后客户端 A 再执行 del() 方法，这时候客户端 A 已经执行过 Random_Value 的判断，虽然和客户端 B 的不一样，但我们总不能每一行代码都做一个值判断吧，这时候客户端 A 就会将客户端 B 的锁给解除了。</p></li></ul><h3 id="Redis-分布式锁应该注意什么？">Redis 分布式锁应该注意什么？</h3><ul class="lvl-0"><li class="lvl-2"><p>加锁的时候，应考虑到执行一半宕机或故障导致没能执行到解锁的命令，产生死锁，所以需要给定一个过期时间，防止死锁。</p></li><li class="lvl-2"><p>解锁要保证原子一致性。</p></li><li class="lvl-2"><p>redis 的解锁就是把 key 删除即可，但是删除的时候不能随便删，比如线程 A 不能删除线程 B 的 key，这个时候 value 就起到作用了，random_value 我们设置为随机值，每一个线程都生成一个随机值作为 random_value，删除 key 的时候先判断随机值是否和本线程的一致，一致的才可以删除。</p></li></ul><h2 id="Redis-事务">Redis 事务</h2><h3 id="Redis-事务的概念">Redis 事务的概念</h3><ul class="lvl-0"><li class="lvl-2"><p>Redis 事务的本质是通过 MULTI、EXEC、WATCH 等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p></li><li class="lvl-2"><p>总结说：redis 事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p></li></ul><h3 id="Redis-事务的三个阶段">Redis 事务的三个阶段</h3><ol><li class="lvl-4"><p>事务开始 MULTI</p></li><li class="lvl-4"><p>命令入队</p></li><li class="lvl-4"><p>事务执行 EXEC</p><ul class="lvl-2"><li class="lvl-6">事务执行过程中，如果服务端收到有 EXEC、DISCARD、WATCH、MULTI 之外的请求，将会把请求放入队列中排队</li></ul></li></ol><h3 id="Redis-事务相关问题">Redis 事务相关问题</h3><ul class="lvl-0"><li class="lvl-2"><p>Redis 事务功能是通过 MULTI、EXEC、DISCARD 和 WATCH 四个原语实现的。（Redis 事务很鸡肋）</p></li></ul><ol><li class="lvl-3"><p>Redis 会将一个事务中的所有命令序列化，然后按顺序执行。</p></li><li class="lvl-3"><p>redis 不支持回滚，“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。</p></li><li class="lvl-3"><p>如果在一个事务中的命令出现错误，那么所有的命令都不会执行（就是除非你的命令写错了，导致所有命令不执行）；</p></li><li class="lvl-3"><p>如果在一个事务中出现运行错误，那么正确的命令会被执行。</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到 EXEC 命令。</p></li><li class="lvl-2"><p>MULTI 命令用于开启一个事务，它总是返回 OK。 MULTI 执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当 EXEC 命令被调用时，所有队列中的命令才会被执行。</p></li><li class="lvl-2"><p>EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。</p></li><li class="lvl-2"><p>通过调用 DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。</p></li><li class="lvl-2"><p>UNWATCH 命令可以取消 watch 对所有 key 的监控。</p></li></ul><h3 id="Redis-事务保证原子性吗？">Redis 事务保证原子性吗？</h3><p>Redis 中，单条命令是原子性执行的，但事务<strong>不保证原子性</strong>，且<strong>没有回滚</strong>，事务过程中任意命令执行失败，其余的命令仍会被执行。</p><h3 id="Redis-事务保证隔离性吗？">Redis 事务保证隔离性吗？</h3><p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是<strong>带有隔离性</strong>的。</p><h2 id="其他问题">其他问题</h2><h3 id="在工作中，如果数据库修改了数据，那就跟-redis-数据不同步了，此时该办？（缓存双写一致性问题）">在工作中，如果数据库修改了数据，那就跟 redis 数据不同步了，此时该办？（缓存双写一致性问题）</h3><ul class="lvl-0"><li class="lvl-2"><p>第一种是硬编码方式；</p><ul class="lvl-2"><li class="lvl-6">让服务的更新和查询分先后进行执行，服务将数据库更新后，再查返更新后的数据，把更新后的数据再更新到 redis。如果有多个服务同时调用，就用 MQ 获取 Mysql 的 binlog 中的修改顺序，依次发送消息给 redis，MySQL 的顺序记录就是先后更改的执行顺序，MQ 根据这个顺序即可保证先后的更新顺序，让 redis 的更新顺序不出问题。</li></ul></li><li class="lvl-2"><p>第二种是 Redis 缓存二次开发解决（MyBatisPlus+redis 整合：餐饮项目中使用到）。</p><ul class="lvl-2"><li class="lvl-6">用 Mybatis 二级缓存对外开放的 cache 接口进行二次开发，Cache 支持 SPI 机制，通过注解来调动相关配置类，通过实现 Mybatis 二级缓存接口 Cache 集成 Redis 缓存，可以自动更新到 MySQL 数据到 Redis 缓存中。</li><li class="lvl-6">为了防止在读写的过程中出现高并发问题，还需要加上 ReentrantReadWriteLock 读写锁，ReentrantLock 只能进入一个线程，ReentrantReadWriteLock 允许多个线程访问，提高高并发，但只支持多个线程读，不支持同时读写或写写。</li><li class="lvl-6">但是以上方式也不能完全解决同步问题，仍存在分布式的高并发问题，如果需要完全保证一致性，就需要使用分布式锁，对每个事务上锁。但这样对系统资源消耗过大，得不偿失，毕竟读取的量是远大于增删改的量的。</li></ul></li></ul><h3 id="假如-Redis-里面有-1-亿个-key，其中有-10W-个-key-是以某个固定的已知前缀开头的，如何将它们全部找出来？">假如 Redis 里面有 1 亿个 key，其中有 10W 个 key 是以某个固定的已知前缀开头的，如何将它们全部找出来？</h3><ul class="lvl-0"><li class="lvl-2"><p>使用 keys 指令可以扫出指定模式的 key 列表。</p></li></ul><h4 id="如果这个-redis-正给线上的业务提供服务，那使用-keys-指令会有什么问题？">如果这个 redis 正给线上的业务提供服务，那使用 keys 指令会有什么问题？</h4><ul class="lvl-0"><li class="lvl-2"><p>由于 redis 是单线程的，而 keys 是遍历查询，每个数据都会遍历一次，所以 keys 指令去查找大量数据会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。</p></li><li class="lvl-2"><p>可替代方式是，可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。</p></li><li class="lvl-2"><p>但这里要注意的是，scan 指令有一个坑，不会自动释放连接，需要手动释放连接。具体的解决方案我有做笔记。</p></li></ul><h4 id="scan-为什么可以不阻塞提取-key-列表？为什么会有重复问题？">scan 为什么可以不阻塞提取 key 列表？为什么会有重复问题？</h4><ul class="lvl-0"><li class="lvl-2"><p>Scan 命令其实是迭代器方式对数据进行遍历获取，但它是分次进行的，可以在中途返回查到的数据，做到不阻塞，且因为 redis 底层是 Hash 字典，会有扩容和缩容问题，所以 scan 每次都会往前退一定数索开始继续遍历，所以会有重复问题。（具体见笔记）。</p></li></ul><h3 id="使用-Redis-做过异步队列吗，是如何实现的？">使用 Redis 做过异步队列吗，是如何实现的？</h3><ul class="lvl-0"><li class="lvl-2"><p>使用 list 类型保存数据信息，rpush 生产消息，lpop 消费消息，当 lpop 没有消息时，可以 sleep 一段时间，然后再检查有没有信息，如果不想 sleep 的话，可以使用 blpop, 在没有信息的时候，会一直阻塞，直到信息的到来。redis 可以通过 pub/sub 主题订阅模式实现一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产的消息会丢失。</p></li></ul><h3 id="Redis-如何实现延时队列？">Redis 如何实现延时队列？</h3><p>使用 sortedset，使用时间戳做 score，消息内容作为 key，调用 zadd 来生产消息，消费者使用 zrangbyscore 获取 n 秒之前的数据做轮询处理。</p><h3 id="Redis-回收进程如何工作的？">Redis 回收进程如何工作的？</h3><ol><li class="lvl-3"><p>一个客户端运行了新的命令，添加了新的数据。</p></li><li class="lvl-3"><p>Redis 检查内存使用情况，如果大于 maxmemory 的限制， 则根据设定好的策略进行回收。</p></li><li class="lvl-3"><p>一个新的命令被执行，等等。</p></li><li class="lvl-3"><p>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</p></li><li class="lvl-3"><p>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p></li></ol><h3 id="Redis-回收使用的是什么算法？">Redis 回收使用的是什么算法？</h3><p>LRU 算法（将最近最久未使用的页面予以淘汰。）</p><h3 id="Redis-常见性能问题和解决方案？">Redis 常见性能问题和解决方案？</h3><ol><li class="lvl-4"><p>Master 最好不要做任何持久化工作，包括内存快照和 AOF 日志文件，特别是不要启用内存快照做持久化。</p></li><li class="lvl-4"><p>如果数据比较关键，某个 Slave 开启 AOF 备份数据，策略为每秒同步一次。</p></li><li class="lvl-4"><p>为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内。</p></li><li class="lvl-4"><p>尽量避免在压力较大的主库上增加从库</p></li><li class="lvl-4"><p>Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。</p></li><li class="lvl-4"><p>为了 Master 的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现 Slave 对 Master 的替换，也即，如果 Master 挂了，可以立马启用 Slave1 做 Master，其他不变。</p></li></ol><h3 id="Redis-官方为什么不提供-Windows-版本？">Redis 官方为什么不提供 Windows 版本？</h3><p>因为目前 Linux 版本已经相当稳定，而且用户量很大，无需开发 windows 版本，反而会带来兼容性等问题。</p><h3 id="一个字符串类型的值能存储最大容量是多少？">一个字符串类型的值能存储最大容量是多少？</h3><p>512M</p><h3 id="Redis-如何做大量数据插入？">Redis 如何做大量数据插入？</h3><p>Redis2.6 开始 redis-cli 支持一种新的被称之为 pipe mode 的新模式用于执行大量数据插入工作。</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;&lt;br&gt;
❗表示必掌握，❔表示基本不会问&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-24 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="八股文" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="面试" scheme="https://kiml.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="八股文" scheme="https://kiml.github.io/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第三十六天-完全背包、518零钱兑换 II、377组合总和 Ⅳ、CM70爬楼梯（进阶）</title>
    <link href="https://kiml.github.io/posts/b717497e/"/>
    <id>https://kiml.github.io/posts/b717497e/</id>
    <published>2024-06-22T01:08:05.000Z</published>
    <updated>2024-06-25T07:51:44.433Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：看完完全组合的解析之后，完成 518 和 377。CM70就是377。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-22 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="初步题解">初步题解</h2><h3 id="518-零钱兑换-II">518 零钱兑换 II</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/coin-change-ii/" >https://leetcode.cn/problems/coin-change-ii/<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i]</code> 的含义：填满 i（包括 i）这么大容积的包，有 <code>dp[i]</code> 种方法</p></li><li class="lvl-3"><p>递推公式：<code>dp[i] += dp[i - coin]</code>。</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[0] = 1</code>。假设数组个数为 0，获取 dp[0]，就是 1。</p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 思路：  </span></span><br><span class="line"><span class="comment"> * 1. 这是一个完全背包的题目（正序）  </span></span><br><span class="line"><span class="comment"> * 2. 求的是组合数量 dp[i] += dp[i - coin];  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> amount 总数  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> coins 硬币总和  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 有几种组合方法  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;  </span><br><span class="line">    <span class="comment">// 填满 i（包括 i）这么大容积的包，有 `dp[i]` 种方法  </span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> coin; i &lt; dp.length; i++) &#123;  </span><br><span class="line">            dp[i] += dp[i - coin];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.toString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[amount];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="377-组合总和-Ⅳ">377 组合总和 Ⅳ</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/combination-sum-iv" >https://leetcode.cn/problems/combination-sum-iv<i class="fas fa-external-link-alt"></i></a>)</p><p><strong>如果求组合数就是外层 for 循环遍历物品，内层 for 遍历背包</strong>。</p><p><strong>如果求排列数就是外层 for 遍历背包，内层 for 循环遍历物品</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 完全背包+排列</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums   数组  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 总数  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 有几种排列</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (i &gt;= num) &#123;  </span><br><span class="line">                dp[i] += dp[i - num];  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.toString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[target];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="70-爬楼梯-（进阶）">70 爬楼梯 （进阶）</h3><p>题目链接：(<a class="link"   href="https://kamacoder.com/problempage.php?pid=1067" >https://kamacoder.com/problempage.php?pid=1067<i class="fas fa-external-link-alt"></i></a>)</p><p>就是完全背包 + 排列，解法和上题一模一样。nums 取值为 <code>1- 每次最多爬的阶梯数量</code></p><h2 id="看解析">看解析</h2><h3 id="完全背包">完全背包</h3><p>有 N 件物品和一个最多能背重量为 W 的背包。第 i 件物品的重量是 <code>weight[i]</code>，得到的价值是 <code>value[i] </code>。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p><strong>完全背包和 01 背包问题唯一不同的地方就是，每种物品有无限件</strong>。</p><p><strong>二维数组</strong>：</p><ol><li class="lvl-3"><p>递推公式：<code>dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - item[i][0]] + item[i][1])</code>（即，不重复存放当前物品/重复存放当前物品）</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[i][0]</code> 均为 0。<code>dp[0][j]</code> 为第一格按背包大小取重复值。</p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">    integerBreak(<span class="number">4</span>, <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">15</span>&#125;, &#123;<span class="number">3</span>, <span class="number">20</span>&#125;, &#123;<span class="number">4</span>, <span class="number">30</span>&#125;&#125;);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] item)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[item.length][n + <span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 纵列初始化为0（数组定义，不用初始化）  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 横列初始化不一样了  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; dp[<span class="number">0</span>].length &amp;&amp; n &gt;= item[<span class="number">0</span>][<span class="number">0</span>]; j++) &#123;  </span><br><span class="line">        dp[<span class="number">0</span>][j] = j / item[<span class="number">0</span>][<span class="number">0</span>] * item[<span class="number">0</span>][<span class="number">1</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; item.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (j - item[i][<span class="number">0</span>] &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="comment">// 如果当前物品不能放入，背包值 = 当前值的前一列</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// 如果当前物品可以放入</span></span><br><span class="line"><span class="comment">// 比较前一列和（范围大小还是[0, i]，如果是 i - 1，范围大小就是[0, i - 1]）</span></span><br><span class="line"><span class="comment">// 也就是说，包不包含这个数本身（可不可以重复计数）</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - item[i][<span class="number">0</span>]] + item[i][<span class="number">1</span>]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一维数组（状态压缩）</strong>：</p><ol><li class="lvl-3"><p>递推公式：<code>dp[i] = Math.max(dp[i], dp[i - item[0]] + item[1]);</code></p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[0] = 0</code></p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历。（<strong>而完全背包的物品是可以添加多次的，所以要从小到大去遍历</strong>。（😅老实说，看了好几几遍都没懂））</p></li><li class="lvl-3"><p><strong>这里完全背包一维 dp 数组可以交换遍历顺序</strong>：因为 <code>dp[j]</code> 是用到其左边的数据 <code>dp[j - weight[i]]</code> 的，而先遍历背包再遍历物品也是满足的。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">integerBreak1</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] items)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] item : items) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; i++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (i &gt;= item[<span class="number">0</span>]) &#123;  </span><br><span class="line">                dp[i] = Math.max(dp[i], dp[i - item[<span class="number">0</span>]] + item[<span class="number">1</span>]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.toString(dp));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="518-零钱兑换-II-2">518 零钱兑换 II</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html" >https://programmercarl.com/0518.零钱兑换II.html<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="377-组合总和-Ⅳ-2">377 组合总和 Ⅳ</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html" >https://programmercarl.com/0377.组合总和Ⅳ.html<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="70-爬楼梯-（进阶）-2">70 爬楼梯 （进阶）</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html" >https://programmercarl.com/0070.爬楼梯完全背包版本.html<i class="fas fa-external-link-alt"></i></a>)</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;状态：看完完全组合的解析之后，完成 518 和 377。CM70就是377。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-22 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="动态规划" scheme="https://kiml.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="完全背包" scheme="https://kiml.github.io/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>实操：AI编程</title>
    <link href="https://kiml.github.io/posts/6501e090/"/>
    <id>https://kiml.github.io/posts/6501e090/</id>
    <published>2024-06-21T07:24:04.000Z</published>
    <updated>2024-06-25T07:51:44.441Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="7b68bbf314f78420abde5afe57101de647673b42dbed569e58a9f4796a764cd7">abeb8d7735f0ac1430d5930ae71b6720b0442317ed254a69c11041c65159e9be845a26339db56165385334e2c44d7c39d657f984d7b54ce1264d731e88a779b97bdcdaeecae33d3b87425235ece4c6220beb7e0801b3573a077dd101bd52db2668440aef62c87726f9518ccdb768ba4369515c9d3bfd2bc58ea114f5c5aac954afeee389f2ebcfa47bbbef0f1c09afd7491396fc843d696151d6f3e8704d3c6b1efb2f03cb162e5ad211adc364abe91b8842443388b201959b0a9cf55999b77c92e771ecfa0b21186bf4e3613678a24a41221c34f2dfc9391fcc23e8fa9235ec811f7ec10a5e6b8c7abde4bc2b79ae29b1ddd5eb58ecd45de728fa7d5f927ebecf559ecdd43b9548d189c43ce3a228e802750848c312ee3a3b2fd57e8c97da878827b253e37fad528653530bbffc8e1299b3309334d3a2cf92c930e6e8d6bf7c2514915f000145ed5f2574793f1dce7abf1355b3bed71460355bc7fbc0be95fcd0881c1c278fbbae27c87831a952e2605c55d7f00cc3e7125abf36eb75a1531b9b0e1df2eaab03a6d6519975f165067fb15823c2a526dc1508e899c507fced2773071f95c6e27293a9503e41309e5323a0c7e6ff103bb487c370f24439b71eed88fdb7605d6d80692b00bbe2db5918a089d1654b51c356bdcdefd193880d4b185fd20e92fc0bb172a83c4c9b30e8551cfd1352cc85aec8ead1ca5c0fe4fb371b2c8947888d0230f464dad150d061e55da231a0fc57b387c6805258384f9b6be12a7ab2450d8d729391828b211149a5e449a437f5d00b10a4baf802dfd442a50161b2679bf83b6e0083bb134f7ec2344d38a34decc42282e6699c2537582b20c669780b06d8c874ad2b9a96cf6bf8898800219131b1d19e76a7fd784e93137784fda809b7e9ebf414895234e48693b24f9a4017f2b97bba8b4f19e257bde0068ae86159350a946774712c0bec60cac841163e7da1e0b838c3fb3065934e9125902014721ee666d556593011842488b1b8498a87a4b3c63ba88450c52c9a9e5106f89db563833db37a8fa2a88db81248c43e7c3c492c6609a08f311310e5fcd37512e05e5710211e73c0e80fb0734b852a09c0d4703ba26cf3a08a6797195f11f4d503ff2ca4ae7a96df66a72a91c65943eace4f1b521e9d9861cbbd0ea2b282e6c1dd5c2ea9f56ca72f12007450ebf73265d25a1f083c447e3f243aa5fa06819f4b7945e8724ae7ab7413db17b43c2179496e204f66b39fb5c140f8783486582280edf6479f066f47ec5a16c6feac423d05c1cadbf974a38146722cac65ce97daed222cf38f1ee2c9023d8a24a3ff04d50fec0928ee68ff7aebd1c86019aefaddca24d97ae46e3976dc6c6a8c6ec7000e7500fb3b5fe9e71a3ecded19f6dac0b87d406ef73109abda629c4c4b80ef91870be195c4b1336899f7a4ff217cf877cc6662c2530efe3251e9cc5ded31c620094c2908ed53c5aa621c881683c02530e5b684962c8d4bcd905e2c45a2159afb2faac23cd0e584f259b4530d475099562185454a9297a12f0b9c27d632e39438f4ccf0321814121689e49c22bcd7fca37f8b5d065fa5e7c9504eb0f1b3b620b20117e65f7954ea09a661ba348e0c40f30e8a49a2321dee6c42fa2319be949fb3ffb7f5214f61eeb6c3f6da5a8df54bf55e33fd4db8a4f08f4b8c0137ca8fac1aad6e1964178fc0c49acdcb92b78eba9b0f1f0f5cb0971be0cfba7c33705d3ce3425543eec3c8e0560f2391b6ec4dba5d1ddb9f004109dde230c057c2f92be55e3e1fe945e6b205edb82a92f7ac2dcc95ea31d557fa46b1f8dfbca567db7da8a9682833f40768e42eac3f2a8329148c2792b893444557ce1d3d9c80b1590e92da5d39966edf7abdae35243cc6f222cc3163070bc8cfa6c2c7d20df508d9d48614014e8462babf27fcb5953bc93c59e89f5e396b8936f60929888cfb7051b7639663111c720d0bd017067ed94ed947c16065e9fcad4adb69b8ff9e033e8af40508d74660d04af101510e37e11c5d892f20f4df43fa883f0c6e949e060ea9df408243e7f4192cbf3afd0e4050f883b3506ac63dec2dc66eabb40ec54ec9778b1cfd6f5a0e4c4ac9b3a5a6c40877bb48a522ba681c062b4abefc11ac031575889c30d863b6587ba9670bca9a4ac75bcdaa606ba00fa9708e8157245d065c22f01602e7a0075bf294df0c59c4e6621d57d7384e73d72008ef2e1be18dba49843328af2488c8781b1af1733a798b4eb140b2287db1184a2573aebc622008935da9a3d8bc2946233c40233952bf387c5ffb84e33bb5b501cdba9ade7e3b2411652bb5286a355265f6d5e97708dfe11fbcac1467aa27ee1bde313d83e643674eda852344073768f20d397b91781b578c75fc427db93380507d91649f2dd15a6d815a3a98dc6a8857f099cecf196bd74ea0f465cdebfe50920ab18b1941e9d17436c1d1c728aae0f1119a563d70db1808893d2addaf004bef34c80b49cd78a474c709ae5c0a2cae5a9cbc437925c9c8a7bf37c09a3128d8bef79d8dfd4686f3424b2ed11911b87051108d38094639e4830899fcfc2c5afaaafc2436f2bd2b7b512d0becf3d2b529a3d2b44e80edb98fa8da75b941c38df47453744f4a24373d7832be0857be68d3c642fbc61c33490cac82cacca9c6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="阅读" scheme="https://kiml.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
    <category term="AI大模型全栈" scheme="https://kiml.github.io/categories/%E9%98%85%E8%AF%BB/AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%85%A8%E6%A0%88/"/>
    
    
    <category term="AI" scheme="https://kiml.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第三十五天-1049最后一块石头的重量 II、494目标和、474一和零</title>
    <link href="https://kiml.github.io/posts/bde30672/"/>
    <id>https://kiml.github.io/posts/bde30672/</id>
    <published>2024-06-21T01:19:10.000Z</published>
    <updated>2024-06-25T07:51:44.433Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：1049 和昨天那题差不多。494、474。。。☠️动规还是先了解解法。后面刷别的题组的时候再说。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-21 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="初步题解">初步题解</h2><h3 id="1049-最后一块石头的重量-II">1049 最后一块石头的重量 II</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/last-stone-weight-ii" >https://leetcode.cn/problems/last-stone-weight-ii<i class="fas fa-external-link-alt"></i></a>)</p><p>本题可以抽象成让石头分成尽量相同的两堆，然后进行相撞。即背包大小为总和除以 2，求能放入的最大价值。</p><ol><li class="lvl-3"><p>确定 <code>dp[i]</code> 的含义：从石头里任取，背包大小为 i，能放入的最大价值。<code>weight[i] = store[i]</code>，<code>value[i] = store[i]</code>。</p></li><li class="lvl-3"><p>递推公式：<code>dp[i] = Math.max(dp[i], dp[i - weight[j]] + value[j])</code>。</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[0] = 0</code>。</p></li><li class="lvl-3"><p>遍历顺序：从后向前遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(stones).sum();  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[sum / <span class="number">2</span> + <span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> stone : stones) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> dp.length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (j &gt;= stone) &#123;  </span><br><span class="line">    dp[j] = Math.max(dp[j], dp[j - stone] + stone);  </span><br><span class="line">&#125; </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> sum - dp[sum / <span class="number">2</span>] * <span class="number">2</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="494-目标和">494 目标和</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/target-sum" >https://leetcode.cn/problems/target-sum<i class="fas fa-external-link-alt"></i></a>)</p><p>完全没思路</p><h3 id="474-一和零">474 一和零</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/ones-and-zeroes" >https://leetcode.cn/problems/ones-and-zeroes<i class="fas fa-external-link-alt"></i></a>)</p><p>看不懂，题目都看不懂☠️</p><h2 id="看解析">看解析</h2><h3 id="1049-最后一块石头的重量-II-2">1049 最后一块石头的重量 II</h3><p>解析：(<a class="link"   href="https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html" >https://programmercarl.com/1049.最后一块石头的重量II.html<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="494-目标和-2">494 目标和</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html" >https://programmercarl.com/0494.目标和.html<i class="fas fa-external-link-alt"></i></a>)</p><p>假设正数集合总和是 left，负数集合总和是 right。总和 <code>sum = left + right</code>。目标值 <code>target = left - right</code>。可以得到 left 即正数之和 <code>= (sum + target)/2</code>。</p><p><strong>本题是装满有几种方法。这是一个组合问题</strong>，用的解法就和之前不一样。</p><ol><li class="lvl-3"><p>确定 <code>dp[i]</code> 的含义：填满 i（包括 i）这么大容积的包，有 <code>dp[i]</code> 种方法</p></li><li class="lvl-3"><p>递推公式：<code>dp[j] += dp[j - nums[i]]</code>。</p></li></ol><blockquote><ul class="lvl-1"><li class="lvl-2"><p>已经有一个 1（nums[i]） 的话，有 dp[4] 种方法 凑成 容量为 5 的背包。</p></li><li class="lvl-2"><p>已经有一个 2（nums[i]） 的话，有 dp[3] 种方法 凑成 容量为 5 的背包。</p></li><li class="lvl-2"><p>已经有一个 3（nums[i]） 的话，有 dp[2] 种方法 凑成 容量为 5 的背包</p></li><li class="lvl-2"><p>已经有一个 4（nums[i]） 的话，有 dp[1] 种方法 凑成 容量为 5 的背包</p></li><li class="lvl-2"><p>已经有一个 5 （nums[i]）的话，有 dp[0] 种方法 凑成 容量为 5 的背包</p></li></ul><p>那么凑整 dp[5] 有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。</p></blockquote><ol start="3"><li class="lvl-3"><p>dp 数组的初始化：<code>dp[0] = 1</code>。假设数组个数为 0，获取 dp[0]，就是 1。</p></li><li class="lvl-3"><p>遍历顺序：从后向前遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();  </span><br><span class="line">    <span class="keyword">if</span> ((sum + target) % <span class="number">2</span> == <span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (sum &lt; Math.abs(target)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> (sum + target) / <span class="number">2</span>;  </span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[left + <span class="number">1</span>];  </span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> dp.length - <span class="number">1</span>; j &gt;= num; j--) &#123;  </span><br><span class="line">    <span class="comment">// 这里比较难理解</span></span><br><span class="line">            dp[j] += dp[j - num];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.toString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[left];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="474-一和零-2">474 一和零</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html" >https://programmercarl.com/0474.一和零.html<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i][j]</code> 的含义：<strong>最多有 i 个 0 和 j 个 1 的 strs 的最大子集的大小为 <code>dp[i][j]</code></strong>。物品的重量是 0 的个数，1 的个数。价值就是 1。（难点在二维数组。。反正看了解析又感觉懂了，自己写又不会☠️）</p></li><li class="lvl-3"><p>递推公式：<code>dp[i][j] = Math.max(dp[i][j], dp[i - x][j - y]) + 1</code>。</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[0][0] = 0</code>。</p></li><li class="lvl-3"><p>遍历顺序：从后向前遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 这里x计算0的数量， y计算1的数量  </span></span><br><span class="line">    <span class="type">int</span> x, y;  </span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;  </span><br><span class="line">        x = <span class="number">0</span>;  </span><br><span class="line">        y = <span class="number">0</span>;  </span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : chars) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>) &#123;  </span><br><span class="line">                x++;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                y++;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n; j &gt;= <span class="number">0</span>; j--) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (i &gt;= x &amp;&amp; j &gt;= y) &#123;  </span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i - x][j - y] + <span class="number">1</span>);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> dp[m][n];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;状态：1049 和昨天那题差不多。494、474。。。☠️动规还是先了解解法。后面刷别的题组的时候再说。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-21 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="动态规划" scheme="https://kiml.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="01背包" scheme="https://kiml.github.io/tags/01%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Obsidian 的插件使用</title>
    <link href="https://kiml.github.io/posts/d62035eb/"/>
    <id>https://kiml.github.io/posts/d62035eb/</id>
    <published>2024-06-20T08:42:53.000Z</published>
    <updated>2024-06-25T07:51:44.447Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>整理了一些常用的 Obsidian 插件。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-20 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="工具">工具</h2><h3 id="File-Tree-定位">File Tree 定位</h3><blockquote><p>更好的文件管理方式。</p><p>介绍：内链：[[Obsidian + Git + Hexo + 图床 = Blog + 个人笔记体系#File Tree 定位]]<br>外链：<a class="link"   href="https://kiml.site/posts/121fccfa/#File-Tree-%E5%AE%9A%E4%BD%8D" >File Tree 定位<i class="fas fa-external-link-alt"></i></a></p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>插件名称：File Tree Alternative</p></li><li class="lvl-2"><p>分享地址：obsidian://show-plugin?id=table-editor-obsidian</p></li></ul><h3 id="Advanced-Tables">Advanced Tables</h3><blockquote><p>更快的表格创建方式。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>插件名称：Advanced Tables</p></li><li class="lvl-2"><p>分享链接：obsidian://show-plugin?id=table-editor-obsidian</p></li></ul><h3 id="Annotator">Annotator</h3><blockquote><p>PDF 阅读器。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>插件名称：Annotator</p></li><li class="lvl-2"><p>分享链接：obsidian://show-plugin?id=obsidian-annotator</p></li></ul><h3 id="Emoji-Toolbar">Emoji Toolbar</h3><blockquote><p>在文章中插入 emoji。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>插件名称：Emoji Toolbar</p></li><li class="lvl-2"><p>分享链接：obsidian://show-plugin?id=obsidian-emoji-toolbar</p></li></ul><h3 id="ePub-Reader">ePub Reader</h3><blockquote><p>ePub 格式文件阅读器。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>插件名称：ePub Reader</p></li><li class="lvl-2"><p>分享链接：obsidian://show-plugin?id=obsidian-epub-plugin</p></li></ul><h3 id="Excalidraw">Excalidraw</h3><blockquote><p>Excalidraw 绘图工具</p></blockquote><ul class="lvl-0"><li class="lvl-3"><p>插件名称：Excalidraw</p></li><li class="lvl-3"><p>分享链接：obsidian://show-plugin?id=obsidian-excalidraw-plugin</p></li></ul><h3 id="Latex-Suite">Latex Suite</h3><blockquote><p>数学公式支持</p></blockquote><ul class="lvl-0"><li class="lvl-3"><p>插件名称：Latex Suite</p></li><li class="lvl-3"><p>分享链接：obsidian://show-plugin?id=obsidian-latex-suite</p></li></ul><h3 id="Pandoc">Pandoc</h3><blockquote><p>将 Markdown 格式文件导出成其他格式文件。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>插件名称：Pandoc</p></li><li class="lvl-2"><p>分享链接：obsidian://show-plugin?id=obsidian-pandoc</p></li></ul><h3 id="Privacy-Glasses">Privacy Glasses</h3><blockquote><p>模糊处理文件，如果在公共场合处理文件可以用到这个。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>插件名称：Privacy Glasses</p></li><li class="lvl-2"><p>分享链接：obsidian://show-plugin?id=privacy-glasses</p></li></ul><h2 id="美化">美化</h2><h3 id="Linter">Linter</h3><blockquote><p>Markdown 文件格式化工具。（包括中日韩语与英文之间的空格，非常好用）</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>插件名称：Linter</p></li><li class="lvl-2"><p>分享链接：obsidian://show-plugin?id=obsidian-linter</p></li></ul><h3 id="Blue-Topaz-Style-Settings">Blue Topaz + Style Settings</h3><blockquote><p>目前在使用的主题，主题可以直接在 Obsidian 中搜索。可以配合 Style Settings 一起使用（非常好用）。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>插件名称：Style Settings</p></li><li class="lvl-2"><p>分享地址：obsidian://show-plugin?id=obsidian-style-settings</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;整理了一些常用的 Obsidian 插件。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-20 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="博客" scheme="https://kiml.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客" scheme="https://kiml.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
    <category term="Obsidian" scheme="https://kiml.github.io/tags/Obsidian/"/>
    
  </entry>
  
  <entry>
    <title>【AI 大模型全栈】 从 AI 编程认知 AI</title>
    <link href="https://kiml.github.io/posts/19ad1a27/"/>
    <id>https://kiml.github.io/posts/19ad1a27/</id>
    <published>2024-06-20T06:52:10.000Z</published>
    <updated>2024-06-25T08:13:55.129Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="9c9a0337128e33b88c6ac3330ac19026e743fa8d7d2ab3e42ed701b47b442cff">c106436a47eb33a4135a9ae168067982ac0c820ae084610e81b3e9f401c6ad8f00be8b5be6a75899c1b6a0dcc9774c9c04881b72f7f1cab64913722a7c4699cefd24cce868eadf574fcd17a0d116411b04830750a69d8b148e9181bf77c91c677825b05cda8bc23b92b86670207d28b33071d5ee70902a6e0bf4ebeb6491c767d99e2e10569594eb0ad66e89928fc113b18596559c654101989fa988912a5fdd2fd3e53a80f60d64a27a666ce1470b970820b2a624ce04c105a1aa2210139cf5d83fe75d223f096226a400c380c9d2cd7304d7ecc6f803891dd0ea63688ac5846e0b785eebb2a0944bcd9c7da039e02d450cd0a5ace2c742c09ae25c0bcc3f47ca6eb6876f3544d1c5e8889df007a518074acf33838249e1dbda51e0b6849a68ec417575cd9883d816efa46745dc19bf675e99eb031352536fb704342980bc15afac48ef31799c2b19753cda412bb7c99defda7e9d5d7d52be643e54667fbbdb3547e9ee3a763901468c4b08e4a75e2b350c5217269046e924e3885a3935d8268d29d8da097407b8055cc33823a1b67f2e7bcaa4091f633a9194c47f5aa56e5b3919121288aea988f190f7ce032c81dd6721ffd9f59004aacbe8ec7e38e02ca080d210901c06ed90c852323f40edffa3783e2ac8a7a4de2a5fc75cb300669248d5b96811464d3ad953e0d2f3c2d1e56ea1a2a6aef597bf1ac2a8497a18af5e555f7100d0bc3b7bb059b29061a8ceaa9293ec97b5b7fed2cff420bdf083128b5a3d595a2c4c9b927cc013ad6626fee340cd2bb324610aec1a5e4d2182d3dc2d8b00e83f386278c59c00e7f21029c89a5066f7550a4ee3e36e7f232ac70fd9feefbaf463af96f843907b31a348a927f42fc66f78621e6128088ed08a9dd124b8b5e15c18713615327db96da467a8a8c0b18fb66bfa82ba01b53a1ea44ecc6c0b2af31188de771383e5bfcc38d0c48b7b3e0568c6621c9ad52337de20a2c838e5d5cd0547539cfd68b9ee3d2e42b544f90301a9e222af79de6d5ca9151fd02207fad9fb6997ddf111a62c45ef9e488729ce1e8fbe64280d0e3527d83f82401bfed7c3f673d51baa9025ae7ab47350739877bc117b6f0ccb0a6cbb4fe39be7cde79c269cdd6af5bc11c27a472e4eca883d0ef9bfa46a75dad759375b166764936b7aae738f1fb18905d67cdb481f57c3969d87cceba997fa84ff8017c1a586d57c3c8dd3745e8c208d8483964fbea7894ff86ee6fe32f5c14d85541917e6db4c443581b5412e7043d9f85767e97dedcf46330902a018272ddba11ef70b2e1a0f1298547ef5c6c400c14e07ea67e0488db442bce551c497dea60b0c351a9d3181a8867046d73e87c7e3809f1d673f01cdf1c01e5c4d73d25ac856c2c24b542d226d82e72f8b5b17acf268fd4060480e864e10daaf4f50a6e02ef610d46a1f04386fb1439715cbfab92d5b0741100a53990d6c70f1ca7806dafa82e24cef04fd5ee9404ae66e27aafe2693b0ce5121f1844854ee3490a97df6aed376ac3f1e0ac3d5df74a5788c4aca0a7b7d7fcd78be9f5f5193bef052bc32d09236e796121685639af787bb20d61c6b90a422059fb5ee79d9a2d1172efe5ff6ef98ca38c35275128753aedbb1cfa454a9812a3ca163e58a89c340792f3d068fa0f298a4a898829980aa5888e50bc6438832220f31223884a207bd0b5f2bff594c0900da9856c2fa037f81cb5e7a41deb1048bc834ea13a04123c88678ea1138a79bbf164d1feae5c95b30339d7550dcb634cfc2edcfd46ef0e3c690c12ad5b8f3d3d8711b494bd300cb26bb7a623c0917e22d5fd739e6ac8c68c886952d8f0891e7cee81d3b5939de2e5847829a32c0023372b243b6d91fcda28715b42e7ba70005060814398cdc424d25b6fae313394e78683f6a942425f7348b529ea04e031e6b9ebe2759a30b93004d62a6921f5775b6fff0ddbcfa653f336d69e131c3e23e9344788fa7c69692406da359eb6fc362c5215b7f9588bf7c815128c46dcc577db37fbda95f85ab2ba140adbe97296ec17da07aea7db09c8e62d519d253ae4c79ea7dcfbbaa9ee652c2007243db9dc2ab91acb0a3fe8094383c8c4f3a69ccbf2dfe2260ac247c211ec1a8c8da106ba0fa6c044926260f27352e3831f715a9d8231cf281adfbf160f0ab44772c0e65c9df1f3d3c26db9057b8eb42803ff3b9f7d7cec5e1f80adac361296ff9c2301a8899bdd6e5cb01ea96b766ac919a077e52bcc104009b5b956166f4460463217a5336019186f681725ab5afe331d2decd741d92b9a7d6a1c081eb0be3de17fc085d5c47d9dd87ca3edd09b49f6c3b786a0a35745e70c46a7fc0c36b04b15ede3f109565429adafa1bf8ff59cf50174213915fb21ac2bc8b7a9b583620e0aae36100c8feff10bf8d95c997845f4c621e9b7583f8d75024963da06c1dec287c644de5a4823ee81d6277005de3aa84da62a60063d3cc8c5111fc77aa76c2fea082bb56ac70403fd9836bd5d3633657b474420a98891f441a9dd9a9c6f9cc1b279ed349abd6975c2ad354337df439600e14ae0060ecf9a5dbbb9a6a0086c6c0e75c549077677f9858cdb391ba4b5ed7a219dcbb755f7e475119d5e8a536ec7b2fbe60aa31e2c8f1d8954d2e09354958310e9f96498d544adb5dd982d39d3a4370b6e89e1fea5043e83897e823d4bd0d2aebfe4f5b3843ecaf106df98ad85c87c956959cb1432f6e6a4ceac779614a272c981d11edba9724376f8345c7485bbb7de93a14469b509d65eb4d16ddcc76101e19751edc0e81d2a6501787646e8a741c919c7cc363da4099b452be833c863e4c96b9f508b1ecf680a1fa58761c96a18e194eec6ac7251a8fd7b7737c6be99d3a55730a5f72243023e9a78b135473c9ff01df99628aa7025518b3be494fa1b34f002ef8ff3502e7af377f8e536fef35cb1d5a6fab96a8ad45ed7a9cbb6125403fc95df95d4b33144afd3eb60a10be010f8602e10180e9ac785d33f9369b9913da33384d4235efb2ef99ab20f8296b5a915d2fcb4308568188ece0cf467757be0a4dd54a75fa2e940ae326365426bba5b7613daf4ecc7be6421a5e0aebb6a3c95d677f37b20d1dbded8ae3d8a6cbf6dea7dd4739c8bc15c4e7bd1f7acdd310e1aea6c24f365c77ea542995b90eb759d495d10144ae8c128efaf9da49d05fd392940aa0783a0704360b5d01d3f86c1bd362381d3839f8063ed43dffb4e229902ae67d38f84cbb7d0b64a263573bd1feab6ec0fe7a9c510615b3a49215b88e24cbefa7b9095311b7f34f67e0a5d528da33cf49caf43f4598523572ca96b4e91ac323fc0f2bc01d18f2a3d85047d9fbb8b0e02ba8f0018083b3094dcae224c0b462f3bed1961ef75c25eb06c02884811ce3da5d6a8d945a30db3d8bf0898ebfafe685969dce942abf29cd6c96797b21778b0144bff08a4e9cf32a4f5303f641d475ec7d3a34699a7b300210053c8481b933580de04169ac9a1a65471da3c88ee7a94970b8bd9f55f0aba67de105896ea0c8f0d4105f5a0a381cbde34e777d06048609815f2d05e7c3179e918a7a6f2749ba92a42c40f1bfed8650d7d3594b95f7697414dcf717c025294691a8483fbc65c8e728c5e2e821532a7e6950f6838ffd1acda6fb67b6633919e62b33da05983193511adf36e16ecc05732249ef5755d858846c5d0bd6be88dc7bc0afb7e1eec4781435532d66651cc87c2ddb0dd2d1acfcf1fde489aeeeb41c0f507c05288aded8378cc76e73645e604caca6539fc20465a770dbc49e02bed3bdc00515ae297efd05d94176403796e3d8b1d2c4a29b21e1492229a56c16fdfed9241ceec89db6f21d31933ba9938ea9ed58e7cd0c7f52400383a4d1bc01716dfbc137816390734b3802e45dff21f7f227c07e59cdb23c0db13eed4e29c6709112b962e1b40b4e20ce2f8d16ac5d52de2290cec9cfb696fc998bb6e63d56f667682209bbf880cb877c9fde97d32ecfdfb2fb967e71e582ba9ddd8cb9028ccf9666a700a57d7ff8ff95f530867d881c359e600c37e74cbd08c5caf083292149a07d2b63356a75b7d2133deeba8e39ecf1ea73d6b83afcba809b51073c483e132dababa6a916e6df666ab03b4849ff82d1418289ad48b97f909e884755dc09c52bfe9ed0e7beb81383c8bc65d2d101070fb50e62eba6787454d5b236db02c372c0f18237a4e2500d525ddab0ea389c6ec364340278b1611f62dcfdff2cbbe537959c729bcbf9bdf75b30303b41d748ba3a042380eab0407b81fd8dca5da1a14b9d8b2e811263c6f73b82ed5b9752ffbc51b2d07b180fb0f0259631f567c4b9d5dceb0a5e30f85f6807291b93a22becbfa02b280aa3cd6bea8b82ff4b1de689ffa2effc444f3114ca25688302a9d26129313e6fd4ee10c83eb8c439b2979b1492c854c2dd9947e6f6d0e3d1f322511750902d0f243d76ddf7d8e761df99ffa3b21891d1a754864f3fbb11e50e17bcf83292bdfea71c5940c1526421ea3500fae265fa63e4fb6ae5fda433c3c1d5c384d699f99bba2c76c1d55141ad3c5ddf2005effa15224499b378c0c4c674de2eab8965079d777119f3b48c5f9da682ea01709d4e325e796d006c071b87ab5ad7311258331389fdf237b99df5dc1b9b61354796835b79caea8766ebf6de6ff99b14331b87fe73d2ef9fd5b97191773f552ffc2ebd65bb93f25d94563552497ecf20c90638cc96b2838676e95f8859f58c09a849b39e9ffec04f8c170fd11ad7237b1c951e52a646118674ed2c299cc2fa5bc8cd4aa2527b628b607c0f9733b97227941c178a472bd09a54cdb9dd1d37bcc314a4ada2ff71288222485d4edb9ed15b7542674cd8f793cabd638844231b32dac0b6fdace47b8e0241cdc64ec93160ae82fcf1fb5c14a06586a53297f7d30f9df5052046ec2fce924a215521b2ff7dd8bd078ec38f5eee9207b13921b42cee8bb801ba11b1d09c6bcf5eb29a6f6c0a09dcb5aa2b369320a96311efcae3548ab930c0d26d23692a91b9b198464a021f9a73c2b7978adb56aa5bfc06d19a71140742551dbaa99ccb8f64661bb7f3fe97bc081a9e2b6365167c363fa2e62b23e5c5f5459d43947013457abc7de70aa12cab0945d01b72e8fe77abdf3e188ded692fbf65f75a5fd9a6cc35bf3c91be88add7ec0c8543785792f34fce5beb5b1502b2510a0dc4e69e0bd3805297f20cf6c10d1f1fa55ad2123821e8cef9f6333d0425f84d680045c81d8d0a77ea4f97365656401d98595ab067c272782969f22e4df03863f5eadaecdfe24d6592b2d83268db5e73d05b8d93890715b33ecf1d4ed767be74f84cfa0e494bbfb4d938a0f21bf0e818f65cef68654e59217f2f40fe2e0d35dd2a483f90323729f0df933443ae1706ba19945a78537578203c9a9ba8e22f1373cc20ef2f4139675c6b6b32f7c4475dd5cbb7ee71b8de6bfccc41383b42ff8d5b4290461d5a9ff36d05642333c81c641442b1f1c426597cf60819e43bd5f8de27ae634e4013dd2e25f1f08009b9d68e8a83c79b6cdb8899497c6dd8f34c853fc1dc97e4f674dc9e006af44db78538f5c46d3e018a91f955def64b6bd77f352d4226bc78f176c02296a5568290f518e38a3b665dbfc06fbee3b1791c5c8a3d1f470adbebce78aac18b875ea0677a1cdcdd15b84eeb3b8f4821440db45757bde1005eeac615bd50e270abfbb2db9bccaf1d8bb9ee3b01b691016cf450e676ed8b157b0480c9a3a55e876775dbe0dc38aca5667f26e383b1a283c7e1af11610cc08cbc39a0b2d57da3773dbce62a11fdbfed90174ed7f109bdf1178a32ce647620b9e4ad625be0ab74be92d96ee0836593377f7f502daf9fa0df9920411b7242fe0a8b40bbe578b6c32122236e2dbefad2464859562fe9e5d00d9b69162061cdd477daee03c448cca693f9a0672f7e1fde4adb059788c1f3a01dee98e6b7f68627bad822bceeeb54877c408d7407d83450208cfc228c938917129c4fd7789db100cf113f1e88f7d20bfae1dbb80b4e02cd6eb4b02c248300c3442d5be3cb30356be60f258bb3e42a17457781054e3a09d0a8e8b3b742ca1d4c9983bcfbe3360432eb9fd171393a60d37b1ad89886f2ecced907e7b463564eca1fbba9f5325c3a2a048e28e309336dde663abc323116b9d99b78342293b56d44d97c2dd8ed617d1c68c403b3f732eef4b5cbda631eea005d89b263030a918018cf12b41db3e1c6ddd39cd8caec697a1a566b7c4ebdda10ea839692fed9c51f29bb7ab8276eac8ac2d08013ca75c1885d89b2fc5dd6cd4e7543a723a75e15a80a5a25dc420c3c1f2d635a87e9a0ef3e0a75bdf0925c8f2ba895d54964a30bc0b46544f142ad8e3cbf2a8e9904c9d5beed8b6e556dd68034c5e462b6cfbc18dfeb79ff9b0d3efe96f14bde09dd0167332feed85bb05018fec6ecb88d12c7ef5164459c4f4794827b8fe64cf8d2adcc5628064bfa62fe0fd758f32a76d24c94120e8067af20db98bed999f0f3cefeff952b8fda935525042a7b2c18d693a10b36f048ba33c1dca006ede6bd3f000403141a437477270c8d7f7126cff774259c806aa038c1830f46efb81f473622dcd73e420c87c9f6d4d6bb1bcb88149ee6460adf90a29067aafc8527687f985d1a3a6683a64fdeaac11e2dca132237231f55a6b374c2766ac65e998f1964c6a88c6a289e5d9a7520ffff86b77fc8d0ede8840dc427b59d3f20eeaf2cd629c8c73e94ec2702433df25ba39b1f97660f41a5e8fccdbb4205c206eba0841ca4053ea37e1da04b149ccaca540073ba4449ea8638eb5f909beaf74240f2096e1d81d0534091cc505085270a968d2743f79a665f5fd0c7ad8e77a63e9d1518f8204b9eed695cb7f3dfd15383613373c09d5e74fa0fbbadb6fd91a9033a002748f1943223f3985e1bd02a4e6a970b36ce7c7f5cc92f6e0e20295da8c675f501a83cf20236adfce5bc4debf23c0a1de69fcadb4e1b499d200ea4421369ab2c8e93f3984112f062530dab4a5b602681c7efb3a3b47a6126b50188ca12cdc1e17bc51e21fb9aeb7fa57425bb59c55585a2fc754b261404f4bfaea33136efb052268ebe50a84b67fcad4e92793ae2cca46036501c526dc6089d222547279c5a065455f4db70b4c6fa1a5901d333e037872090cfe0d84fbb0de411db8455aa33e184c529fb9ba0dfc55f8bc56677d9e0c5a03609d1d1d3c130d637dd542a4c705c394644e0e851029bb022ac68d1a73e1ffbdd063a619a221d837432608de4584834eaa009b61a99207b65033fb3e0c9fa8841552f5989274aa1444bc7cb0b2222ae3ad9d226508a06adc1e48a42bc053f16afec1ad3f4ba1fb005e46ce751026377cd7e88e4fc7bc20dc7ec36cb9eb6755ffa90138c392a56a21bd5d7fa25926eff1a21f1bfe47db4b1b666f5299409f7f34eaa4878ab3d3dcf021346313bc018311c8f38aa4257c6ed473db2b516458994693edc68af6221aad1be3fc2a4b0f8869304429a97883854ccb63289e77c881778a14e5c746bfedbc9223356ea60d6133858fff3462fcfaeed110bdacd00454b4c67a98ca2b07fa516b584177b0af4300c1c17e2b17784b1c45662df979c1e651ead7b6954012b9ccf48073b6b70fb786176a8baf23d12d29fdddb50a2540f4f87feb2d450654a9abb99cec46ac83d40543c9cfd52a4091ef426d4c64c67ea38eee955b631b86f9d3d63e874dd41dfeb4ae1a3e74b6a0a9aa0d53809d120102a757e466a597120180482589f8e1668fbbe0b1aa194d6fc3d88afc351aed1bb9d04ec63bce88a8e8bd3401dc6d7395017c95e577e1bd99ab4b685778b16774ebdef42170b977395b766683279172233d39bfecd2092923d82750d5a29c71e58f736602f2f720c9bfcae21dbcaf86bddf43e03b37c55dd63a00b65793992a36a743c732e5d4bc6e2259ce0822bd572e7057b8b95b855756fe725ddbbf3af23e072ebd3ae806a817d6b94b91cbb9e7c914b29ec1b25869b3b6cb3c379397c0275e6527cc9b83122cbf029d500997f8eadd9a470c82d9559beba4b5cf532bb144db005fe2d9c28ca70ac139893446d8bc1033018361b75a00f02387d614948eab57772959c3def491e3ce1e4d3a75fdbe753e5ff79a64c9adcfe1ec8c4139f186d6e382358e04c75d34ff3d47b0a14b8ebac438fc734e1d61a7654a52b9c24ee411f211a463f26d316df62ab23ad14d0c926d8d5e91a2a698dff95c1a23ccde3e417c862ad9cf8ebd21e0a15276471bb430c623e2c554f2d5e0735e1b3dd7192ff713a428ae556142d4e690a8bcef8ccaad48984986a8515599ced68a8b27a7ca8f282fe01265741e92176b2b8fabedc6fd3611f699ed523b3a1da9811303e0534c2f272d4f363735c52275433150eb962c6e5b69a97666bb2e473cd3742a04dd7fa1a95ba8b9143208bf8daabe43c356b533055ba3863792376d0fa410648fa6b24ca3e59f82822cee80220747391874f6e69d9ea5bf5ee55153a6872fdcee952a60e561f99800dcb8f9c84a52c341740ce7d1335c3f15ff18ae57ddec3414579caa345b1ec235835438e5084c8aa8b52e461cc96bd820b04098e76ad4fedaf1d379c5302e28cdf06718a1c9d760bef2e36af2afcd23450d5d8bdf1a7b1a859eec79b16f1fd256c6d47aee12ac11de9383b06f667fbae606f171d3f12c4c8a34d9ad9b8f224ae13f8e98a529ae1c9535fc4fbff373317a10e6876e6b216f2f36b4b5a3b5c61bc9a1adc9575585487e18bedf3b523f98d6e3b2be1f3cbf272179d7bccf47e4b233d1b4bde7f15fe0577313af388178a151117d6fb9895ed84d3dbb7eb52a9867a17c5ff292aca7afc168409f5be2d4f88138cb0fbeca786d97d8f5a635899cd0d2a9e8f26e48e4ded1cd6a0437544f41c1a6bc24fc67626fd9c7239ced3c3b26e48d23a4ba96aaee4357ee960a387eb24ebeeeae1517f72f246a0558841e1efc7747145cf4b129301e51cf921df5839d10ee60be54cd65c3c44dcc461acb115e51f2bc57b04d3c341170d694523f258c6cfa595130ab0a3ee7878045b1b9cd35988a573e1ef5ee58123f0688f44977f385157f4891a546a367c6b66fbcb55bf0d27f40ebdf40f3c5836a8603b9935d316b9b0440791630509319d0f976e573f7365716ddb062c8dddcf07349b7f696952b6f6d0b2cf0a4ea88156ce7a65acb883ea137dc367c5953951eb7046c52b87b800cca0ff8612b3328034a2b56d71d45179a39cd27f5769066cb463a325fac44b2d404132c8f0477aa01bde25cb68a93779e75fbf60dbe063d8960018391658660fc9832cc544915fa678318e1a75d7b6a748585642a05a11b684fd33098691a0b3d1524f6ff6a2a85b763af7f912d992330b1b2cf9c4bd2f1e527a0a1455c13b7b00edf051a8bbc31cd67ac20ec8eb49589c8c08c2671ba3683aaae16d35dca872fc5797eaa0f5b153fa3fbc7c30edcecfb62a7dcb59f32504478e246122534e63d5c85d42d3cceba723dbd587f7051bf28f455dbf146994e72a2b4b147e45cc146c4829ff294b92c3acfe4febdcddd3ca4d00b20e15b69084c7d81d2f5dae1836d0017d6672bd49e862524390186e571d6cf1d858449d441aff1e156a496006521b2ecb2185408d6acb18d5c0052ec793092590f2c05ecd1c8041d16dfa0d7cd8ca37861e739c51310f0ef51c75008748ed02765ba4c4e9247851b68146a155fb8c58113849c32c0876a792cf7766397b767165115bea5f0717f0e42dee951e979549d52e8f0eec0ed6af5834393efb6366912958c98c9f3df11c532c41084f93791c148ab27335236517ce15a8618a7612aa8df42503268080056fc449418959c8740c21407d2589fe7a98e625920af00bb430e25def176786ac6ba8a9119fed09249df19a0ed4e8288fa5bfd3b566312574ea379a62091267e419b9cb63bfe5b87db230b35d65d30433acdd89f181a7500457e0274d121dc9eb642ec94cedca60cad8f052f28a46c9cb659ea07da148a153052ce463ae9e9a351fbe635741d627da3990257e46157054c3105bf8c83288c59242a0976efd37a3142161edc8223bb14b9a47552793c80f094dc2b7fd2ff85926cc0d8e1c2cf99778050e8c488218d9824afd8d910951afe9f3d1c3056eded3bcf5d3eb83f5f01e11530916cf406008ee3c2f22b85cbab21b31b348b9225e689d7b0792ca8f574eb739298666df1e782abd624885e014f96810eeaafb8932e95cccce0d505e92e7bfd486ce28ecc239b776ab3b7faa45f10a04732ee23c23cb78f1886491b482c542f6dcb404fadd5a49b4fa4a35901ca6d71e8eea793785342c0547685d61efcf0bc0d88f4fdd6135aa1c04b731bc3b855303b8734d797e84c0bd1e661a1c2b4a5a9e3dbe7e23a863a1f56e013e4445f9d7850c5a3acf376e66cabaa68e9ef5e442d2cc761be1aa4afc1df5f98580ac5da562b2b9c99d69320a71c1bdd5236fd54ced16545a861889f8cec4509142d362007a1ce54d886206b84f6a477c32bf4a2b5fb9dc9e1c4ef7a3f8ca0deb9d7eb2f02c0ae78de3419a9866ffa98f518b117119e7a23ba8e0ed34ba57139f4c87ca1dcd667d401a6f744e90019260dc6d799ea77cfc55090e24f6bd7e307a271c45c701c35300abbf68ad36fcdb135bbd75a07edfe00477834c610d79dca696421e26763a37e0205473e9a5df0f775eb7963a3f174db201f669506b8fef8b83490415fc9ca40c603dd2fa08bd45f0c8fb8bb0bb03d4875688e40feb554802d3a4754b3565972f38a9ca5f503d0db72314880a7b76ccd5dcebbb363fa0d050504280e06ad8585263131e9c90f509fbdb1d2bfd4c8e4d9cb16312cab4d34cb8d8ee193f1d076a7ebea81916bef70e7c642c231cbdb996023a8e47a008914aa140a3e862aa7881aca12c51543079acbf68b940a37d56ab900bcd0b38b1ea4f564c792ca449889413d792dab5c44e47fa970a8127599192a5bea225b449ba359b6b52f4caceb782d64e10d4b59f9309eb3d623552b265c9bab569061ea4bf3caaa7a1e65bbf4a09259ef36161fa23b89bc06f02e07e8853a04dffffb8b316399c24f13562e721ee049af0560ffc8db306d41c634c4d02f2b56b033dcd7397500a44e87aa7cf5ec34f82fae1b4ed7b90c7563e3f531fedd07fb42545730089e67d62dd1e4a45a3a7da183988c1505c341138b7c42133f4b69d66bd074cdf8840adc1585862317970b63d3e1ca7df9584727b902a46546a8b9663817ed9fb3618efd8ad112062146f215946f6d3921592c809c4211a74e92a4a1c70c1578b0363a4e0369076cf0238555cf2247bd14e47d1cdb1a9e101b76c84a4ee780f566b69f10e69470dbd12b3bd98b86f9e5fa8637b0aa0e8f8c7194405e80f7df1d874bae8dec33eb88c9f313c03909f492d48cf4ac5d494ac23c23ae800f5f37dd11ff51150cfb55e633ec99f35ad54f298fd9d153c30a418b1ce5fcdc3577aa6228fe5ef5d876fa3d644d77c7c3128760b543d6b54f28d9f0a3ee051a0cd5f32752ab8d85c30dffd7bb4961ede679737f3786d1d16587b6d76b0e232df6e6d0ffd31c7edc9520c386ae86cabc2412708c8042f6eb083c84bb6788ffd3c43c9bc0cd008803a8f8eba04fb0520468b68ad44169fb90b9cd76aced7a6a8f1e028094414444cbe76ad3c867cb7d0a1f29319f5f7c9db365206393ba725c86d8c9cfd156f55a8ab17f4a58ec413fac6d127de805d29969858e8c61e61be76c4ac56d026427ccbde79ea1c7fc498f77495ee1b0df3fc36e9bfcfc51b94c24bfa4de45654e879b183c83174437322e7ab58cc1c5c02caf72895c748c800bdbc47e2a3b964bf2f23b92548ed73d97cd81e3d7c174e47f1c5f6f10ce0284f552580feb7598ca7dbf5fb811c8572b2370481011513ffe61437fea5af817bb3a866c8ff56f548b8ea80d04cd411b199a143aa9408bc345a14a79b0e52de617fe598419f7972b87755d3b3b63b115edb750f5c7c1d196d92823eb945b2debf7d647f2bbe9f4399426042b289b553ee464c676ffad31a6841e09c89fdd1dcd268b76e7e3058fab302954000c08ca51f1513eb844deec61502c20c301d3717903659d6bdba1febcc479e4046c6caaec5a84000459dd6a482bb9ed63f831d925cfe04b5159e5e7a3e967da5f6c93e2bf2325a018ae8e85c85f3ebe36653f70c5f8d86fec590efbbbe48a14f5d1a6bd838600e365d17cda253f9f9c59c7ae3169270fb65778aa9a210d51b8d7c604c383307e103b5eedb7342d9183ca152a45a416dc816dd5ff6293155d2d07625cb62b21f7efaf1e7a3863cfaec148eaf5f5f4d2885c0eb3c376fd251e792a7605f749ab88e7a995d8dd1532372425e41a75e1bb682e2193ab44513a43c5b661b108f0f133c3d6a99e547a37353dac947a0d5ce77662b74c8132aa898e52f7ecd3acb6c4320301ac52d8dcdf384b7d93f0c6c8270c1fa8127a414e300fc9cf2e8131a2ec03f516934691f0a330febcfb85cead1bde55aff96333641d0670deeafd8017e7dbc68d97db2455296fc17615f9c1756192bf1c46982cb7241d6685a3f15fcdd4bcb4ed37a401d3b9039920e3b3f25f0dc8d0d2fcc959a6db80ec4d4edbb9995ec0801c64a727dae86c7b1cd8736d82f0b875ae6c198c36033fed46d13f636cc38c69caf2ff299fce5015de1681e00ba228cd200b36a61bc8551948e2755ff9745dedf644c3c84d34e3398b17c25a02048b7c83dde335f1373fb9b450fe7388aa17cd0b550fd79c9793f87a8fe8d1138eb69a59b3ebc6ea98e3045eb7761e1384fc8208b3b47173a0a040ee921bd51a04e9d6bd797aa988514c0cfe9b17806c131d029d45cbfcb4e40edc9cbdc469609d8e73a2bddc3b4c6a47d76899b4d2137eb4dfe164870ae5613388217c254fc9277522d2f951b515c25c0eadcb3de9771924db55e89d5f4a35fb0fbaa10afe07b6b80b00b3338488a133d9aca6863efa523cbe8d05487541351e2643f4c8e68f3da79ac7b85022e4dcc24ca448738d6995a0ea98820d51d6c71927720d98cb4c05cf7b8e63c566025feac7fbee9876e1540db66d4c5753479751a682453a2e6c9d1a15d570362638f5dc23762ecefef078562e36dbf0a10c9906d9a7c7e05b590dc02fee3fb7841d834dc99adaae36d09147ce4fa8f9390cd36515aed17fe12eed6a438731e3fb5b9b116df8196ddb520e65355d156be3473aae6edef78f30b6daf16c5c1c8e574aa40b3feeae35c3055df18f3d694e547e33fbf15e177d45a60665b2137ce7959f330eccf05e0c534434a5be064b3669809c9dfcc79887456f69d28f20913bc333b241be74c3f386324ca56095fa6156185668fa2621b3745a1351c345e9724b4061f8710c597d615ded17658b3f886c315fd3885c96312d17b610156df72163b48cefc95d3d5585de4d02e6df1380646c4e76a7041ea9221e6527afa23041f2b556e6eb138d96a05ce5172f5c617f279138e05d37d8aa7e167406a8554fda91a00a22bf6b6935d933c36f985c908e5f263d65caf801e3988d4b376b6e38ef3b1c626cc1bf346e3588effe31d75ff8c5a5a36a9522b8be0def978787a21a5b4d09af8de996c644723dc62829b6a59e711e4121a1d259629b4b0479a1f68f49c603bbd29fa0fcd336fae531e480b9f2043385697feb412b57ca9cf9441d2ee22e7812a640aaa6e974c6686f80727316fbb17d48afdd2262cffe2d73ba901a0ba0dffe70f43097feecfa31045ca415935ba5992a34a1b6aa0bd607140a8a53e5f3d6c004ad3bc8e6e711838d5d6daab6f1760d2e1cf8ebb28d2defb46efc9ba3251e380a4e476e9461a5e6e4a08c40132ddaa1b3b915b88929dc2e92809f88ca663871493217102af796d9338047dc439dae743070be23b6d7ce89015a0d8c94c495644603284293291223a4b6725fe01984ba20b66ad13264bdcf721a2afc82ef014059cb8ef532aa8d742d6c751ec05a3b16d116d6bd949b5790bf749c466be316091a08163dd343a7c3ec62172bb2f03562dea96664e3c051d1259eb08f124618a3d974302a64509566406297ec11f3979f7cc9ef84164db9959e5083908411efd17bfcdc7fe7137a5a893f6ffe1f48371ec1bcd921bf713f04a44bea5b48bad11fd0ca18f2d6157a366671fd295cc42de7db60be8a9e374f0d4df617ee4f78cbfb18eb7d3aadfa6adfe9ed9dd4975b3fa6e8aa5a5231002dcf81899a5e88124f84805ce7cf5a8e100d54ba76b8d1ba4ada6ea30c791ca2917fa97b964ca3feb6f4184d00095d00c5c65b4f06e4398ebcbd669b49ac0391de97c831ad7d3850150664c88b7b5346cf97e2fc825260c859135e3fba9bb1c4bd80e5c6d8609bf8b64d564347448964650d33053cdc1855ce22b986a3fd84269495dd5afa86a7304e7bde9061eec382b718abc8140b1f7fffe8862c6dbefa456130973065ccb018c06cee3b3885c084de994bca1c31e5db73d8b7eb062e59c31dd1c32b395900e0c8a3990fb0738e544093d815e8d9d77018740fb58e80894b676120dc461849bceb74d7d832c396a5513318ff6249ae3bd466bdc180897c22bbde4acaa5f7a29d438b107cdeb735845bc3bdc1d24216ad883f9939c5923534a9eb2648befcb25c3e7499b234b344d7665c30528bcb53217f163efa97388de67dc714d9c5cdf9c58281ee0253b498c48292df19dbe4cb214ca0faabcb1e8033c835e757b62b3251807b641845e5329ee2fd3449a616d8d414590b0de38362f4f05eaefc6137aa90de3dd8dfa5df7849718b14c912f24653e006049130a0615def65803111b965e1150961463ea09c2050249162dbe1eb2f51c458cfcdbd58de38634e071ae1b9fe992db20c568de00ae32104dd893dc7562193027b1b7b99e86730e6fad176a3210c14dc39b8100ded9c0250521a8dc485e76f6a52c73b94023abdc125d3f27a996ddea1a9220c0f41e59d54019fb39c2f49a90f63ba1d48e9b5d037c815a0cdc0c721cc2a016cc0d5a9b2dca74c48a52f0602ed678a0d021d8a1d45377af2ce0e82ba4611dc01b3928e20e93fd07721968a58cc0063dd30f7012913c9fd0b30fbf55db80d91569638d11b64ac1b31effd8e6dc50d06756b87c22b1f2d94dd35dcca512f545899ff52230ef67f133c843382f63af9dd17a98b106bddb0bee3ea809f3f7ccb0cab2a05b1a5bae97e0d614237ca63932bd0634cc57edced7d067ef8273265a7bf9a179e9858cc0b621fde7477fe7093f6e8f412811d3d8aab24aba1e09fd81042cda15f602318bee2bce67bfdadf2d0760bc17f408e0a77643563d5781d53f77b56e55638dd32c22df0d9b0da3aed07f335b4195f19bc9ba01f2b61fffacb754330ac169d733ee2982fe54dbd6963d0a8418fb00a9de4de10d01ccb467dc1d37bfc9f136e258767188d4e1782d78445df0a13a911413cfe3e647c2ec5e362e14179fa9507bae3d841d819b61c6a4e7a18b65773ea6ab29cae0ac7568961d7db7ff2c347165a091c8a128e8fd792daf91092779d96a6ba90ee21c6ffcf9866889f0d2d6f7cd1144461560a9fbde7ac09cdecb51d1efd576ee69c8e4c9629038ac485c630d027f5021d35ab2afc20c46f36d9e5e6ca59eecb77c2fe1ad65bc2c14332574fa10cfa6437fbb40a6585ffa24199ba4a79ff2b3caf91d76159baef2eef56f90b298c957ddee186310008debbb98a89a54e639b381998c06e4ef1b9acbdf10cad0c911faaf9217a6038926bad28e12c0fdfe633e2c3f1cb835abb407914c7a551441ea336c0c56fc01763e284f7f8550beaeec22d3879b1a51fd8dc9fb24975c25e88fa5cced61a696c6d28fbfe5578ff1470427b2023bf01c021fed913a9fa9310c081bd639b6e658785f2efd1ee0426140efc5dcb8565284b0a73e5b90f0d74a624b4968ca0a78f05036fc8ee548e563e4e4289cea529b04addbd06d3a997030418c3b52dc578ea311d0960841bcb350bf8945580dd76e1a10eaf1768b84ed16575f5efa017a6b8d8f875c6eba0b50863f139573257fa539b346c7e093ae7134c914873c3afdc23b6014011f5630c371b7c9f1626a3ff57cdd7e2aa00fb911e436feaca2ab54a0cac6ad42c9e9c7196e30df39cf567b2ee8a951acc9ea89ff1cb18fe69bc452f7c238aa8d1deef48ceec4ae1a3b920451eb87ffb6dc8a4979d51ba75c9c63554ec225dc207b7964dcaf76f2fef36ce90ae46353f8db3c8c97fc3e2045ea92ef1137be9413206d1608c6f9ac687bc675bd77110c8a3a895c34a55be6f893be9d269be7a39530720267350e20b97c142900b6cc937665ce9895d0966720dc8984387f33d4e9b6e4bafd35f015b6ecd4bc1f479c97adbe4b35942fe1e30167402f6d67ef5c895598224b52c3653d84c15a37f30068111a788e532625dc8b28f5d876d0e151eca1d03fe3fcca2e6121d1dfd2e42b113671391898cd21d3891011f2f6a7cc106903373cba4627372b8ab0cbf9e4d396173e82ba249be7bbf1743f6115229528fcdd286d79f93e0d958c614cbde7df8c5ba36a9863414aacd4c218084dd66a36d01d2a7466fa76e260f8e425132addd97819f9bd13ecbe452ce1e3c3b21934f46135ab3b49b15f27105d9439b4a0183715dcc858cdfaf18d9061c7837252694b125ba29c2dc6a6c44b71d4118264b5613a3edaff0f9531e6afbc99efbb96f0918cadee45cc7042f5bca5da80042c8763003048200d7c1e3cf4aa24c1ef157e18b076636711c8793d778ea7f7697fe6d4f0129247c3ed7bd20e9c3b08634aa14683f7b2f7e3110338edb905337df03d8e98728e61a52cda1605e02b3fc2cb991c01c7b14e6a55d62c7dd42b4e5fdda7b51b758cb25711ccb35cf1ba704a97421a0164cd962b03c97fdbe7ed009aaa2b58487d513de7bf2c4b25b9b8b09de10db95d88672599f8864c59264fd36ac8428a432dc6b743a9130fe82230ef5da37fc3a3eb80fb0753827cefda0bd0f5b2a33fd5145bb5d4a61ffad1557a6bdefe454d11bc6a686a2f69a2a702caf0d9675c6d8070f8a0082fdd7c1f1d82944b35acae74e82c4beae43ed0adc0b3f2223fd4efde03b38e23eb3dafa597924d7487757e3cd971f6fd089b589baecd9a60f5d56c0657a72dac017404f2e5854ba5577d3e08d478fe29adf1baf6590c95be426446ccc43af94153f6998a9fab42ee9e22fb3db8c4b019b881d41b814c72b502b2f0f72f14ae78de85cf87d28a68f3f0c384bea814532bc557a8d7ad8fa3d2c4544efbf256879754986b0751d37e53516a52207e85f3578354a75cd9221f4329e9cb5be62cf4c7d0ba28a84720c697a65f515dc53217f1b19d51ceeb591a06b58d99d60609f37669503a67e8f1f832f8a74a61697cf9a880aafb3941cc2a34f56cfffd098ecb50093f6b19193773834f864c5bbbb7898baebf50515fe8f1655b2e6857fc6e444fe54c6c69f47a8cf2cde679eba694051289b11140f0f3e10ffdba7d98d9936f481bc2f52fea0735925330fc24d3f9cd4ce65a86950c65d2676dd4267b2e8c4182f9c87b5d61eabfa4fc41bd0b84688e4ab0778ea0de1ab88cae53e00291a7a250f7ff876bdb3c749dc8d6a3a50e30ab647d71185066f11d895440b0a282e8963623aa89a3f199230a991a5270ec1af2324738470996267b72dac7e18c9d34437c073199ed6da43e4ac94494bb6c30b2fb0cc5fc7e55292171f3f2d94e572ef2cdd1aa3a29dc79d7c9024797bffba4be463dd283a14a820dd10c8aaa43230b941d05fb1d4eadfbc109c842963e6e0e5d50e3c06e9cfbaaee3d76e5d6048866af7c59bcaf6b3712a59cdc71f9e20b0f1139ff8acc82e2fb0f64ab3018b627bc368cd125936aac65e44f14f22cc5d24e99bfdca86d74be4229a720f4a5eeec589ffc59442c6e96b661a77dc4af2ac11f04a42dc9e47c9c637d94a1f0a14c97eaaa50bbbbc1371290d7aa30e4ab5ab8eee4cf9d8910d72bba674d399f5e42adbdb44c15362719dcfd52dbbadcc9300726dd95d67b2c75bcf431a7dc3c1f2af36cd674cb9101f6b12cd4748f0888856aa0da41b1f5e51eea191d9647eeb49e0b463e1f296aa2739afa2d74301f96d00a568bd19a2a43539625a1dc1655c0f757ec985064a17887f2fa55061d6a39902d3cebf19d0f752b2830c25b4a5900cf1a56cc563688f2a1655f89842589541b8f66743d67d323a03ebda26cdfd7120ebcd06d97ddd5bae36571cb0bc94e4c0ef8522f4b88c8f8c2aabf562efcf9dc2c28687bc016b623be112b02b24ff979ddd9ed15b00612e5351eb83bed8c06d4a54d20fd5ba26e13777a63832b6f7a7c0fb2476bb2fc3f5ffa53dbdcbde3efdfdb83fafbf9d015abe169a1103187e15eaed57a68428eec0e9b94cb2056f676622df66e32acaef21c0443dd3f8b27ca0c4f5ca4b7cf81050cadcb5cecb2bbc5705b915c106d5b0f82dd279305a66d72133440321387bda949cd62cbb56489dd911a9b62d6fa0533d8320fbf10eefa239cb619e6f20f03bd4dcc43049a1e26929a6bdfa13bfb8d63cea98d80d0b4b86dddd2b78a3889fbbba3cbe1ed2076d25a47c1862e166054c88edc9874c854c1366781a7fdfb67b3bdf10bf02af320d8cad45402d83c8f5de4320b90c3304a272d0d5cb3f3d0ee663cfc1c67c106f226a90814db619efe67ed0fcda0c2a258691e59d2b94e990bf1445dc4bd935fe20f405a4dc54ca9a5f4969260b086560a8e8d8153e1d62b7f76a8934df29fae320f560f5b141484a44a6d19fadd360e469250c7f205f75a8d04a4a7bd387c8ff2c111041cc1ea102face3120383177e5590b283da4b286cba592043b276b30797152e3bc51fd1a8f94ea63fb60dde490286be5cd6e2331c24c68b0c9c2916b466a8c13425d228dfc3bb33844692370d8f94b6acb84d910ffc81a18b44fd1f62de7ff12eedca61407b36af6422d885f92c5b720e0ed19a6798f8bdbfba2abb382051f4f706677935dedfbbbf00d180a98313d65abc6e122af6f2c5fea555296bb77d1de44e0b3a6dee6b5a6413872920f2ba23c378a822a2e010cb5eacfcf5ac9fb8fa5650ad29a0624e9930233e7757c8cec863a26fbe6a24e8cfcf1c1c7f79a1e3cad55678d0a66b22a471fba82b347af1adf10cc895c2808f864816b2cf8fa98d77d56fa32157e197a986916fa168338b839367ecbc541d79a9a883dbf1aaf043a2b8024bb2e357360af829d721605a822b388a75e4a81e539f9ad59c04dbeec491558cd6e10f8bee1c4b7bd8528d33a246d0c0b8644bdd7a99eae61bf881c21957b59951cb2ca7038a277054eb444a19dce19101bebde7c2aee24bf818e48fdf2e60dd39372736c8fb7421d640ca21311f9fe1c2fbec7ebb45843f4d905dbc7e4dd11068f35f02577622a25b95129b84cbdd98993a28afef96119e8b5e6c3991d42a00ceabc7eb50aba6a2b71ba32db0df0d1eabec80c8b9e4317b2d2379f5e38141188f4cc06bc61350ccd9c8602ef0c318c28d66258a98dee74b551b7aab9af2ce3b422aa6362d9d9a1dcb21d328037f94c06d914f3797177d3e54481306445141f27086d29b19f3f9af222c628ff22eb966b1349dafae940ce9186823c5c24c9908b00c5ce408ecf22ca731dfd74a6391ed571dec8a285e24d465231800b696acb71beb3e456c68d3f79e3f62d6bef58620eb959e657912b05a440f0bf9f5659736abb3daf230f0da4165d57d55e52cf4f35be81fd4dd9b44758b4013f24df29be6c1fa031358612b15211b339e42e54af8c2eab43747677ebf8bc3f6d5f1bde66ab99c4d33c5f210b5495697fe97852bfa5d994d9e4115997bce6784fd33fd3434eeb12395afe90902cec7aa88ae9b5baa2714e5679fc404cf0d52da9c40e318824f92c8d6180ba2ea3b96e600dbf3f4e5b632f3365ac675a153a30a8f3c5076329f1abb5e611a764f6e395dd1a0b01cc52626f6d28a6565258d9fd69b53a14474ee3688965bb4834a55bdd383cbb95857cf8566b919db389dc1f7a5cd8c8e88e1b6141c81892d7d7fc1008186c248947f9f598e440fbee1ccc27fad75fedf94d0bdc829dae162cef4144ccabb14df1d339138f9b0a7927b183e8bc0b044243bb00a6609574228f36750ad38d55c3eca99a8bb2a899c21a46d052be47544acbb093b24277c2f18952653029579a3e34230897c8552affd703d8f5d89063fcbc51605ae8f8c3b9ec088e40ce8a38eaa5ffb4683745bc7b55e63090eac938b5777c6c0a634a8df8eac5f329df419a126735e0b8c23d770fe5ace19254c825039c99c6c1774d9e521d25fe71b92a0dce494f72be71ecac7b635fb9b7e5859593f2530c446abfe5126a6062469a3b91e518c726399d173e452a6ec501243c850ac45c5504556fe9d4362cddf84e4f553952ef5ce5fc9e868d962b5511e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="阅读" scheme="https://kiml.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
    <category term="AI大模型全栈" scheme="https://kiml.github.io/categories/%E9%98%85%E8%AF%BB/AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%85%A8%E6%A0%88/"/>
    
    
    <category term="AI" scheme="https://kiml.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第三十四天-01背包问题 二维、01背包问题 一维、416分割等和子集</title>
    <link href="https://kiml.github.io/posts/23390fe6/"/>
    <id>https://kiml.github.io/posts/23390fe6/</id>
    <published>2024-06-20T01:05:13.000Z</published>
    <updated>2024-06-25T07:51:44.434Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：前两题为背包基础题，直接看的题解。416 也是看的解析。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-20 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="初步题解">初步题解</h2><h3 id="416-分割等和子集">416 分割等和子集</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/partition-equal-subset-sum" >https://leetcode.cn/problems/partition-equal-subset-sum<i class="fas fa-external-link-alt"></i></a>)</p><h2 id="看解析">看解析</h2><h3 id="01-背包问题-二维">01 背包问题 二维</h3><p>题目链接 + 解析：(<a class="link"   href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html" >https://programmercarl.com/背包理论基础01背包-1.html<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i][j]</code> 的含义：<strong>从下标为 <code>[0-i]</code> 的物品里任意取，放进容量为 j 的背包，价值总和最大是多少</strong>。</p></li><li class="lvl-3"><p>递推公式：<code>dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])</code>（即，不存放当前物品/存放当前物品）</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[i][0]</code> 均为 0，<code>dp[0][j]</code> 需要根据实际情况来。</p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">    integerBreak(<span class="number">4</span>, <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">15</span>&#125;, &#123;<span class="number">3</span>, <span class="number">20</span>&#125;, &#123;<span class="number">4</span>, <span class="number">30</span>&#125;&#125;);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 二维数组解法  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 背包大小  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item 物品及重量及价值  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] item)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[item.length][n + <span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; dp[<span class="number">0</span>].length &amp;&amp; n &gt;= item[<span class="number">0</span>][<span class="number">0</span>]; i++) &#123;  </span><br><span class="line">        dp[<span class="number">0</span>][i] = item[<span class="number">0</span>][<span class="number">1</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; item.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (j - item[i][<span class="number">0</span>] &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];  </span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;  </span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - item[i][<span class="number">0</span>]] + item[i][<span class="number">1</span>]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="01-背包问题-一维">01 背包问题 一维</h3><p>题目链接 + 解析：(<a class="link"   href="https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2" >https://programmercarl.com/背包理论基础01背包-2<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[j]</code> 的含义：<strong>从物品里任意取，放进容量为 j 的背包，价值总和最大是多少</strong>。</p></li><li class="lvl-3"><p>递推公式：<code>dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i])</code>（即，要么等于原值，要么等于放入物品的值）</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[0] = 0</code>。</p></li><li class="lvl-3"><p>遍历顺序：<strong>从后向前遍历</strong>。（这里需要注意，因为递推公式内需要上一层的原值，只有倒序遍历，可以获取上一层的原值。）</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 一维数组解法  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 背包大小  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> item 物品及重量及价值  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">integerBreak1</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] item)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] ints : item) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> dp.length - <span class="number">1</span>; j &gt;= ints[<span class="number">0</span>]; j--) &#123;    </span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - ints[<span class="number">0</span>]] + ints[<span class="number">1</span>]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.toString(dp));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="416-分割等和子集-2">416 分割等和子集</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html" >https://programmercarl.com/0416.分割等和子集.html<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[j]</code> 的含义：<strong>从物品里任意取，求总量的最大值，判断是否等于 <code>j</code> 即 <code>sum/2</code></strong>。这题要抽象，设置 i 位置的重量和价值都为 i</p></li><li class="lvl-3"><p>递推公式：<code>dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i])</code>（<strong>如果 <code>dp[j] == j</code> 说明，集合中的子集总和正好可以凑成总和 j</strong>）</p></li><li class="lvl-3"><p>dp 数组的初始化：因为是正整数数组，所以可以初始化为 0。</p></li><li class="lvl-3"><p>遍历顺序：从后向前遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();  </span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> != <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[sum / <span class="number">2</span> + <span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> dp.length - <span class="number">1</span>; j &gt;= num; j--) &#123;    </span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - num] + num);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (dp[sum / <span class="number">2</span>] == sum / <span class="number">2</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;状态：前两题为背包基础题，直接看的题解。416 也是看的解析。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-20 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="动态规划" scheme="https://kiml.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="01背包" scheme="https://kiml.github.io/tags/01%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
</feed>
