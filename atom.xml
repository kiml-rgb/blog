<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Keep Theme</title>
  
  <subtitle>Keep theme quick starter</subtitle>
  <link href="https://kiml.github.io/atom.xml" rel="self"/>
  
  <link href="https://kiml.github.io/"/>
  <updated>2024-06-17T13:03:07.156Z</updated>
  <id>https://kiml.github.io/</id>
  
  <author>
    <name>Keep Team</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Keep 主题更新 tools 功能报错 btoa is not defined</title>
    <link href="https://kiml.github.io/posts/9344475e/"/>
    <id>https://kiml.github.io/posts/9344475e/</id>
    <published>2024-06-17T10:35:00.000Z</published>
    <updated>2024-06-17T13:03:07.156Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>不是专业前端，此问题通过Chat GLM解决</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-17 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>问题</h1><p>Keep主题更新tools功能，但是访问tools模板页面报错：btoa is not defined。</p><h1>原因</h1><p>根据Chat GLM的描述。</p><blockquote><p>如果你遇到了 <code>btoa is not defined</code> 的错误，这意味着 <code>btoa</code> 函数在你的环境中不可用。<code>btoa</code> 是浏览器环境中用于将字符串编码为 Base64 的函数，而在 Node.js 环境中没有这个全局函数。</p><p>在 Node.js 中，你可以使用 <code>Buffer</code> 类来实现相似的功能。下面是一个不使用 <code>btoa</code> 的替代方案，它可以在 Node.js 和浏览器环境中都工作。</p></blockquote><h1>解决</h1><p>找到<code>node_module</code>中 keep 主题的安装位置：一般在这个地方（<code>.../blog/node_modules/hexo-theme-keep/layout/_template</code>）。在这个文件夹中的<code>tools-nav.ejs</code>为更新后的tools页面模板文件。</p><p>修改开始部分代码，注释第一行，改成使用 Buffer 转换的方式（这部分也是Chat GLM给出的建议）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;%  </span><br><span class="line"><span class="comment">// const btoaStr = (str) =&gt; btoa(encodeURIComponent(str)).trim().replaceAll(&#x27;=&#x27;, &#x27;&#x27;)  </span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">btoaStr</span> = (<span class="params">str</span>) =&gt; &#123;  </span><br><span class="line">    <span class="comment">// 使用 Buffer 将字符串转换为 Base64 编码  </span></span><br><span class="line">    <span class="keyword">const</span> base64 = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(str).<span class="title function_">toString</span>(<span class="string">&#x27;base64&#x27;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 去除 Base64 编码字符串中的等号  </span></span><br><span class="line">    <span class="keyword">const</span> base64Url = base64.<span class="title function_">replace</span>(<span class="regexp">/\+/g</span>, <span class="string">&#x27;-&#x27;</span>).<span class="title function_">replace</span>(<span class="regexp">/\//g</span>, <span class="string">&#x27;_&#x27;</span>).<span class="title function_">replace</span>(<span class="regexp">/=/g</span>, <span class="string">&#x27;&#x27;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> base64Url;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">const</span> tools_data = theme.<span class="property">source_data</span>.<span class="property">tools</span>  </span><br><span class="line"><span class="keyword">const</span> tools_nav_data = theme.<span class="property">source_data</span>.<span class="property">tools</span>.<span class="title function_">filter</span>(<span class="function">(<span class="params">t</span>) =&gt;</span> t?.<span class="property">category</span>)  </span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
不是专业前端，此问题通过Chat GLM解决&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-17 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="bug记录" scheme="https://kiml.github.io/categories/bug%E8%AE%B0%E5%BD%95/"/>
    
    <category term="2024" scheme="https://kiml.github.io/categories/bug%E8%AE%B0%E5%BD%95/2024/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第三十一天-56合并区间、738单调递增的数字、968监控二叉树</title>
    <link href="https://kiml.github.io/posts/28ed1b79/"/>
    <id>https://kiml.github.io/posts/28ed1b79/</id>
    <published>2024-06-17T01:05:37.000Z</published>
    <updated>2024-06-17T08:39:47.674Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：56、738AC。968看提示说比较难，先去做贪心的总结。968不会，直接看解析。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-17 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="56合并区间">56合并区间</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/merge-intervals" >https://leetcode.cn/problems/merge-intervals<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;  </span><br><span class="line">    ArrayList&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    <span class="comment">// 按左边界排序  </span></span><br><span class="line">    Arrays.sort(intervals, (o1, o2) -&gt; &#123;  </span><br><span class="line">        <span class="keyword">if</span> (o1[<span class="number">0</span>] == o2[<span class="number">0</span>]) &#123;  </span><br><span class="line">            <span class="keyword">return</span> o1[<span class="number">1</span>] - o2[<span class="number">1</span>];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>];  </span><br><span class="line">    &#125;);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (intervals.length &lt;= <span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> intervals;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">0</span>];  </span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> intervals[<span class="number">0</span>][<span class="number">1</span>];  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; intervals.length; i++) &#123;  </span><br><span class="line">        <span class="comment">// 没有重合区间，将上一个合并区间加入list，并更新最新的合并区间  </span></span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt; intervals[i - <span class="number">1</span>][<span class="number">1</span>]) &#123;  </span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start, end&#125;);  </span><br><span class="line">            start = intervals[i][<span class="number">0</span>];  </span><br><span class="line">            end = intervals[i][<span class="number">1</span>];  </span><br><span class="line">        <span class="comment">// 更新合并的右边界  </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            end = Math.max(end, intervals[i][<span class="number">1</span>]);  </span><br><span class="line">            <span class="comment">// 更新右边界  </span></span><br><span class="line">            intervals[i][<span class="number">1</span>] = end;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 最后需要将最后一个合并区间加入  </span></span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start, end&#125;);  </span><br><span class="line">    <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[list.size()][]);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="738单调递增的数字">738单调递增的数字</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/monotone-increasing-digits" >https://leetcode.cn/problems/monotone-increasing-digits<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> n + <span class="string">&quot;&quot;</span>;  </span><br><span class="line">    <span class="keyword">if</span> (num.length() &lt;= <span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> n;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">char</span>[] chars = num.toCharArray();  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> chars.length - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (chars[i - <span class="number">1</span>] &gt; chars[i]) &#123;  </span><br><span class="line">            chars[i - <span class="number">1</span>]--;  </span><br><span class="line">            <span class="comment">// 从i开始都变成9  </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; chars.length; j++) &#123;  </span><br><span class="line">                chars[j] = <span class="string">&#x27;9&#x27;</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> Integer.parseInt(String.valueOf(chars));  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化了一下，感觉循环还是放外面好</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> n + <span class="string">&quot;&quot;</span>;  </span><br><span class="line">    <span class="keyword">if</span> (num.length() &lt;= <span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> n;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> -<span class="number">1</span>;  </span><br><span class="line">    <span class="type">char</span>[] chars = num.toCharArray();  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> chars.length - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (chars[i - <span class="number">1</span>] &gt; chars[i]) &#123;  </span><br><span class="line">            chars[i - <span class="number">1</span>]--;  </span><br><span class="line">            start = i;  </span><br><span class="line"><span class="comment">//          // 从i开始都变成9  </span></span><br><span class="line"><span class="comment">//          for (int j = i; j &lt; chars.length; j++) &#123;  </span></span><br><span class="line"><span class="comment">//              chars[j] = &#x27;9&#x27;;  </span></span><br><span class="line"><span class="comment">//          &#125;  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (start != -<span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="comment">// 从i开始都变成9  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> start; j &lt; chars.length; j++) &#123;  </span><br><span class="line">            chars[j] = <span class="string">&#x27;9&#x27;</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> Integer.parseInt(String.valueOf(chars));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="968监控二叉树">968监控二叉树</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/binary-tree-cameras" >https://leetcode.cn/problems/binary-tree-cameras<i class="fas fa-external-link-alt"></i></a>)</p><h1>看解析</h1><h2 id="56合并区间-2">56合并区间</h2><p>解析：(<a class="link"   href="https://programmercarl.com/0056.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html" >https://programmercarl.com/0056.合并区间.html<i class="fas fa-external-link-alt"></i></a>)</p><h2 id="738单调递增的数字-2">738单调递增的数字</h2><p>解析：(<a class="link"   href="https://programmercarl.com/0738.%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97.html" >https://programmercarl.com/0738.单调递增的数字.html<i class="fas fa-external-link-alt"></i></a>)</p><h2 id="968监控二叉树-2">968监控二叉树</h2><p>解析：(<a class="link"   href="https://programmercarl.com/0968.%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html" >https://programmercarl.com/0968.监控二叉树.html<i class="fas fa-external-link-alt"></i></a>)</p><p>思路：本题要从叶子节点分析，贪心贪叶子节点的上一个节点为摄像头（这种情况下摄像头最少）。然后，根据节点状态，一共分了3种：0 无覆盖；1 有摄像头；2 有覆盖。按照下图的思路做题，就可以解出，还是比较难想的。</p><p>内链：[[968监控二叉树图示.excalidraw]]<br>外链：<img                         lazyload                       alt="image"                       data-src="https://blog-resources.oss-cn-hangzhou.aliyuncs.com/Z2406/Snipaste_2024-06-17_16-14-55.png"                        alt="|1300"                 ></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCameraCover</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (minCameraCoverTravel(root) == <span class="number">0</span>) &#123;  </span><br><span class="line">        res++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> res;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">minCameraCoverTravel</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="comment">// 空节点默认为有覆盖的状态  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 后续遍历  </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> minCameraCoverTravel(root.left);  </span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> minCameraCoverTravel(root.right);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 前两个if可以互换  </span></span><br><span class="line">    <span class="comment">// 情况1  </span></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">2</span> &amp;&amp; right == <span class="number">2</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="comment">// 情况2，加一个摄像头   </span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == <span class="number">0</span> || right == <span class="number">0</span>) &#123;  </span><br><span class="line">        res++;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：56、738AC。968看提示说比较难，先去做贪心的总结。968不会，直接看解析。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-17 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="贪心算法" scheme="https://kiml.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第三十天-452用最少数量的箭引爆气球、435无重叠区间、763划分字母区间</title>
    <link href="https://kiml.github.io/posts/253a4d3a/"/>
    <id>https://kiml.github.io/posts/253a4d3a/</id>
    <published>2024-06-15T01:04:21.000Z</published>
    <updated>2024-06-15T02:50:25.366Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：可能因为熬夜，思绪都是飘的。都是看了解析写出来的。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-15 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="452用最少数量的箭引爆气球">452用最少数量的箭引爆气球</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons" >https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons<i class="fas fa-external-link-alt"></i></a>)</p><p>没有思路。</p><h2 id="435无重叠区间">435无重叠区间</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/non-overlapping-intervals" >https://leetcode.cn/problems/non-overlapping-intervals<i class="fas fa-external-link-alt"></i></a>)</p><p>还是没有思路。</p><h2 id="763划分字母区间">763划分字母区间</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/partition-labels/description/" >https://leetcode.cn/problems/partition-labels/description/<i class="fas fa-external-link-alt"></i></a>)</p><p>直接看的解析。</p><h1>看解析</h1><h2 id="452用最少数量的箭引爆气球-2">452用最少数量的箭引爆气球</h2><p>解析：(<a class="link"   href="https://programmercarl.com/0452.%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83.html" >https://programmercarl.com/0452.用最少数量的箭引爆气球.html<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 思路：看了一下题目就是要求重叠的区间  </span></span><br><span class="line"><span class="comment"> * 关键在于更新最小右边界  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> points 坐标点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最小弓箭数  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;  </span><br><span class="line">    Arrays.sort(points, Comparator.comparingInt(o -&gt; o[<span class="number">0</span>]));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (points.length &lt;= <span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> points.length;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; points.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (points[i][<span class="number">0</span>] &gt; points[i - <span class="number">1</span>][<span class="number">1</span>]) &#123;  </span><br><span class="line">            count++;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            points[i][<span class="number">1</span>] = Math.min(points[i][<span class="number">1</span>], points[i - <span class="number">1</span>][<span class="number">1</span>]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> count;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="435无重叠区间-2">435无重叠区间</h2><p>解析：(<a class="link"   href="https://programmercarl.com/0435.%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html" >https://programmercarl.com/0435.无重叠区间.html<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 思路：和上一题差不多，找重叠的，然后移除了  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> intervals 区间的集合  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">eraseOverlapIntervals</span><span class="params">(<span class="type">int</span>[][] intervals)</span> &#123;  </span><br><span class="line">    Arrays.sort(intervals, Comparator.comparingInt(o -&gt; o[<span class="number">0</span>]));  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (intervals.length &lt;= <span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> count;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; intervals.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt;= intervals[i - <span class="number">1</span>][<span class="number">1</span>])&#123;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            count++;  </span><br><span class="line">            intervals[i][<span class="number">1</span>] = Math.min(intervals[i][<span class="number">1</span>], intervals[i - <span class="number">1</span>][<span class="number">1</span>]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> count;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="763划分字母区间-2">763划分字母区间</h2><p>解析：(<a class="link"   href="https://programmercarl.com/0763.%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html" >https://programmercarl.com/0763.划分字母区间.html<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 思路：  </span></span><br><span class="line"><span class="comment"> * 1. 找到每个字母的区间  </span></span><br><span class="line"><span class="comment"> * 2. 根据遍历中最远结束节点，更新切割位置  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 字符串  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String s)</span> &#123;  </span><br><span class="line">    <span class="type">char</span>[] chars = s.toCharArray();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 记录每个字母最后出现的节点  </span></span><br><span class="line">    <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];  </span><br><span class="line">    Arrays.fill(ints, -<span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) &#123;  </span><br><span class="line">        ints[chars[i] - <span class="string">&#x27;a&#x27;</span>] = i;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="comment">// 记录上一个切割的位置（用于计算存入list的长度）  </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> -<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) &#123;  </span><br><span class="line">        <span class="comment">// 把节点更新为要结束的地方  </span></span><br><span class="line">        idx = Math.max(idx, ints[chars[i] - <span class="string">&#x27;a&#x27;</span>]);  </span><br><span class="line">        <span class="comment">// 直到可以结束  </span></span><br><span class="line">        <span class="keyword">if</span> (i == idx) &#123;  </span><br><span class="line">            list.add(i - last);  </span><br><span class="line">            last = i;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> list;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：可能因为熬夜，思绪都是飘的。都是看了解析写出来的。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-15 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="贪心算法" scheme="https://kiml.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>面试-反射、GC、JVM优化</title>
    <link href="https://kiml.github.io/posts/6f2f510a/"/>
    <id>https://kiml.github.io/posts/6f2f510a/</id>
    <published>2024-06-14T13:37:11.000Z</published>
    <updated>2024-06-17T07:38:22.907Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>❗表示必掌握，❔表示基本不会问</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">24-06-14 初始记录 这JVM的图居然是我以前画的，一点都不记得了。</span><br><span class="line">24-06-16 补充JVM，部分问题没有深入，需要看新的视频。</span><br></pre></td></tr></table></figure><span id="more"></span><h1>JVM</h1><p>内链：[[JVM.excalidraw|2000]]<br>外链：<img                         lazyload                       alt="image"                       data-src="https://blog-resources.oss-cn-hangzhou.aliyuncs.com/Z2406/Snipaste_2024-06-17_15-35-20.png"                        alt=""                 ></p><h2 id="❗JVM中有哪几块内存区域？Java-8之后对内存分代做了什么改进？">❗JVM中有哪几块内存区域？Java 8之后对内存分代做了什么改进？</h2><blockquote><p>首先：一般来说：Spring boot会内置一个tomcat，tomcat自己是基于java来开发的。我们启动的其实是tomcat（一个JVM进程），我们写的代码，会被tomcat加载到JVM中。</p><p>tomcat去负责接收请求，执行我们写好的代码（基于Spring框架的一堆代码）</p></blockquote><ol><li class="lvl-3"><p>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，个人感觉的他就是为多线程准备的，程序计数器是每个线程独有的，所以是线程安全的。它主要用于记录每个线程的执行情况。</p></li><li class="lvl-3"><p>Java 虚拟机栈（Java Virtual Machine Stacks）：线程私有，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p></li><li class="lvl-3"><p>本地方法栈（Native Method Stack）：线程私有，与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的（Native方法是JVM底层的C语言对其它系统或硬件进行交互）。</p></li><li class="lvl-3"><p>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；Java堆也叫GC堆，是垃圾收集器管理的主要区域，堆中可以细分为：新生代、老年代；再细致一点，新生代中又分为：Eden Space(伊甸园)、Survivor空间，Survivor空间又分为From区和to区。</p></li><li class="lvl-3"><p>方法区（Methed Area）：1.8之后方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p><strong>方法区补充点：</strong></p><ul class="lvl-2"><li class="lvl-6">在JDK1.7以前HotSpot虚拟机使用永久代来实现方法区，永久代的大小在启动JVM时可以设置一个固定值（-XX:MaxPermSize），不可变。</li><li class="lvl-6">在JDK1.7中 存储在永久代的部分数据就已经转移到Java Heap（堆）或者Native memory。譬如符号引用(Symbols)转移到了native memory，原本存放在永久代的字符常量池移出。但永久代仍存在于JDK 1.7中，并没有完全移除。</li><li class="lvl-6">JDK1.8中进行了较大改动：<ul class="lvl-4"><li class="lvl-10">移除了永久代（PermGen），替换为元空间（Metaspace）；</li><li class="lvl-10">永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；</li><li class="lvl-10">永久代中的 interned Strings 和 class static variables 转移到了 Java heap（堆）；</li><li class="lvl-10">永久代参数 （PermSize MaxPermSize） -&gt; 元空间参数（MetaspaceSize MaxMetaspaceSize）</li></ul></li></ul></li><li class="lvl-2"><p>永久代（元空间）</p><ul class="lvl-2"><li class="lvl-6">在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间，Metaspace）的区域所取代。</li><li class="lvl-6">值得注意的是：元空间并不在虚拟机中，而是使用本地内存（之前，永久代是在jvm中）。</li><li class="lvl-6">这样，解决了以前永久代的OOM问题，元数据和class对象存在永久代中，容易出现性能问题和内存溢出，毕竟是和老年代共享堆空间。java8后，永久代升级为元空间独立后，也降低了老年代GC的复杂度。</li></ul></li></ul><h2 id="❔你知道JVM是如何运行起来的吗？我们的对象是如何分配的。">❔你知道JVM是如何运行起来的吗？我们的对象是如何分配的。</h2><blockquote><p>大白话：比如说我们有一个类里面包含了main方法，你去执行这个main方法，此时会启动一个JVM的进程。默认会有一个main线程，这个main线程就负责执行这个main方法的代码，进而创建各种对象。</p><p>tomcat也是一样的，类加载到JVM里面，Spring将我们的类实例化成各种Bean容器。会有工作线程来执行我们bean实例对象里的方法和代码，进而也会创建其他的各种对象，实现业务逻辑。</p></blockquote><p>例子：Spring容器中的JVM。</p><ol><li class="lvl-3"><p>类加载器把我们写的类加载到元空间</p></li><li class="lvl-3"><p>Spring容器通过反射技术，获取元空间中的类，创建bean实例对象对象存入堆内存。</p></li><li class="lvl-3"><p>tomcat线程执行请求会在栈内存通过栈帧存放局部变量，引用堆内存中的实例变量</p></li></ol><h2 id="❗JVM在哪些情况下会触发垃圾回收">❗JVM在哪些情况下会触发垃圾回收</h2><blockquote><p>在JVM内存里必然有一个内存的分代模型。比如说一个4核8G的机器，堆内存可能也就4G左右（其他例如栈内存、元空间区域存放类信息也需要空间）。</p><p>堆内存内部再分，比如给年轻代2GB、给老年代2GB，默认情况下Eden和s1、s2的比例是：8:1:1。</p></blockquote><p>如果Eden满了，必然会触发垃圾回收（young GC）。<em>回收的对象就是没有人引用的对象</em>：方法执行过程中的局部变量引用对象、类中的静态变量引用的对象这两类对象不会被回收，其他对象基本上都可以被回收。</p><h3 id="❗JVM年轻代的回收算法。">❗JVM年轻代的回收算法。</h3><blockquote><p>垃圾回收的时候有一个概念：stop the world。停止jvm内的工作线程的运行，然后扫描所有的对象，判断哪些可以回收，哪些不可以回收。</p><p>年轻代内大部分都是垃圾对象。</p></blockquote><p>垃圾回收：<strong>复制算法</strong>。</p><ol><li class="lvl-3"><p>把年轻代内的存活对象复制到s1，触发young GC把Eden清空。</p></li><li class="lvl-3"><p>第二次满，把年轻代内的存活对象和s1内存活的对象，复制到s2。然后把Eden和s1清空</p></li><li class="lvl-3"><p>Eden又满，把年轻代内的存活对象和s2内存活的对象，复制到s1。然后把Eden和s2清空</p></li></ol><h3 id="❗对象什么时候会转移到老年代中">❗对象什么时候会转移到老年代中</h3><ol><li class="lvl-3"><p>有的对象在年轻代里熬过了很多次垃圾回收（默认是15次，可以设置），就会被认为是长期存活的对象，会从年轻代转移到老年代。（例如：<em>Spring 容器内的一些Bean对象</em>）</p></li><li class="lvl-3"><p>Eden垃圾回收时，发现存活对象的大小，比Suivivor区还要大，就会直接放入老年代。</p></li><li class="lvl-3"><p>很大的对象，会直接存入老年代。</p></li></ol><h3 id="❗JVM老年代的回收算法">❗JVM老年代的回收算法</h3><blockquote><p>老年代内的对象，很多都是长期被引用的，不能用复制算法，效率比较低。</p></blockquote><p>老年代使用的算法是<strong>标记清除（回收）算法</strong>或者<strong>标记压缩算法</strong>。</p><p>标记清除（回收）：</p><ol><li class="lvl-3"><p>首先会从GC root进行遍历，把可达对象（存过的对象）打标记</p></li><li class="lvl-3"><p>再从GC root二次遍历，将没有被打上标记的对象清除掉。优点：老年代对象一般是比较稳定的，相比复制算法，不需要复制大量对象。之所以将所有对象扫描2次，看似比较消耗时间，其实不然，是节省了时间。举个栗子，数组 1,2,3,4,5,6。删除2,3,4，如果每次删除一个数字，那么5,6要移动3次，如果删除1次，那么5,6只需移动1次。</p></li></ol><p>缺点：这种方式需要中断其他线程（STW），相比复制算法，可能产生内存碎片。</p><p>标记压缩：和标记清除算法基本相同，不同的就是，在清除完成之后，会把存活的对象向内存的一边进行压缩，这样就可以解决内存碎片问题。</p><p>当老年代也满了装不下的时候，就会抛出OOM（Out of Memory）异常。</p><h3 id="❗常用的垃圾回收器">❗常用的垃圾回收器</h3><ol><li class="lvl-3"><p>parnew+cms的组合（jdk8以及8以前）<br>parnew是新生代回收器，多线程。cms是老年代垃圾回收（比较慢，一般比年轻代慢10倍以上），cms的垃圾回收算法，刚开始用标记清理，然后整理。会产生几个阶段，尽可能并发进行</p></li><li class="lvl-3"><p>G1(Garbage First)（从jdk9往后主推）回收整个堆。</p></li></ol><h2 id="❗生产环境中的Tomcat如何设置JVM参数。如何检查JVM运行情况。">❗生产环境中的Tomcat如何设置JVM参数。如何检查JVM运行情况。</h2><blockquote><p>Java Web系统，在tomcat的一个配置脚本，catalina脚本里找一下。</p></blockquote><p>核心了解点：</p><ol><li class="lvl-3"><p>内存区域大小的分配，每个线程的栈大小，metaspace大小，堆内存的大小，年轻代和老年代分别的大小，eden和survivor区域的大小。（没有设置，会有默认值，可以通过命令行查看）</p></li><li class="lvl-3"><p>垃圾回收器用了什么，每种垃圾回收器是否有对应的一些特殊的参数设置，那些特殊的参数分别用来干什么的。</p></li></ol><p>❗为什么要这么设置？当前系统运行的时候，jvm的表现如何？<br>// todo 额，这部分都在打广告，打算看了另一个视频再补充。</p><h3 id="实际项目中是否做过JVM-GC优化，怎么做的？">实际项目中是否做过JVM GC优化，怎么做的？</h3><blockquote><p>没做过，直接单机压测，然后调优。</p></blockquote><p>// todo</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
❗表示必掌握，❔表示基本不会问&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-14 初始记录 这JVM的图居然是我以前画的，一点都不记得了。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24-06-16 补充JVM，部分问题没有深入，需要看新的视频。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="八股文" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="面试" scheme="https://kiml.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="八股文" scheme="https://kiml.github.io/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第二十九天-134加油站、135分发糖果、860柠檬水找零、406根据身高重建队列</title>
    <link href="https://kiml.github.io/posts/d65e5e22/"/>
    <id>https://kiml.github.io/posts/d65e5e22/</id>
    <published>2024-06-14T06:29:22.000Z</published>
    <updated>2024-06-15T01:05:25.699Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：134AC但是时间比较长、135看了部分题解AC、860AC（但是HashMap）、406不会</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-14 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="134加油站">134加油站</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/gas-station" >https://leetcode.cn/problems/gas-station<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 思路：有两个 式子 相-，可以得到一个数组。  </span></span><br><span class="line"><span class="comment"> * 然后求这个数组，sum &gt; 0 的情况。  </span></span><br><span class="line"><span class="comment"> * 环形循环不好处理，直接将路线延长一倍  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> gas 汽油  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cost 消耗  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> -<span class="number">1</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = i; i &lt; gas.length * <span class="number">2</span> &amp;&amp; startIndex &lt; gas.length; i++, j++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (startIndex != -<span class="number">1</span> &amp;&amp; i - startIndex == gas.length) &#123;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">0</span> &amp;&amp; i &lt; gas.length) &#123;  </span><br><span class="line">            startIndex = i;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (j &gt;= gas.length) &#123;  </span><br><span class="line">            j = i - gas.length;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 获取本段路的剩余情况  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> gas[j] - cost[j];  </span><br><span class="line">  </span><br><span class="line">        sum += diff;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">            startIndex = -<span class="number">1</span>;  </span><br><span class="line">            sum = <span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> startIndex;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="135分发糖果">135分发糖果</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/candy" >https://leetcode.cn/problems/candy<i class="fas fa-external-link-alt"></i></a>)</p><p>提前看了一部分解析，不能同时考虑左右（没看真的想不到🤕）。但是很慢。看了解析，和我写的一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (ratings.length &lt;= <span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> ratings.length;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[ratings.length];  </span><br><span class="line">    result[<span class="number">0</span>] = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; ratings.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;  </span><br><span class="line">            result[i] = result[i - <span class="number">1</span>] + <span class="number">1</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            result[i] = <span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    System.out.println(Arrays.toString(result));  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ratings.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>] &amp;&amp; result[i] &lt;= result[i + <span class="number">1</span>]) &#123;  </span><br><span class="line">            result[i] = result[i + <span class="number">1</span>] + <span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    System.out.println(Arrays.toString(result));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(result).sum();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="860柠檬水找零">860柠檬水找零</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/lemonade-change" >https://leetcode.cn/problems/lemonade-change<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lemonadeChange</span><span class="params">(<span class="type">int</span>[] bills)</span> &#123;  </span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">    map.put(<span class="number">5</span>, <span class="number">0</span>);  </span><br><span class="line">    map.put(<span class="number">10</span>, <span class="number">0</span>);  </span><br><span class="line">    map.put(<span class="number">20</span>, <span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> bill : bills) &#123;  </span><br><span class="line">        <span class="comment">// 收钱  </span></span><br><span class="line">        map.put(bill, map.get(bill) + <span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (bill == <span class="number">10</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (map.get(<span class="number">5</span>) &lt; <span class="number">1</span>) &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            map.put(<span class="number">5</span>, map.get(<span class="number">5</span>) - <span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (bill == <span class="number">20</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (map.get(<span class="number">5</span>) &gt;= <span class="number">1</span> &amp;&amp; map.get(<span class="number">10</span>) &gt;= <span class="number">1</span>) &#123;  </span><br><span class="line">                map.put(<span class="number">5</span>, map.get(<span class="number">5</span>) - <span class="number">1</span>);  </span><br><span class="line">                map.put(<span class="number">10</span>, map.get(<span class="number">10</span>) - <span class="number">1</span>);  </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (map.get(<span class="number">5</span>) &gt;= <span class="number">3</span>)&#123;  </span><br><span class="line">                map.put(<span class="number">5</span>, map.get(<span class="number">5</span>) - <span class="number">3</span>);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="406根据身高重建队列">406根据身高重建队列</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/queue-reconstruction-by-height" >https://leetcode.cn/problems/queue-reconstruction-by-height<i class="fas fa-external-link-alt"></i></a>)</p><p>没有思路，虽然看了提示要和135一样分开处理，但是还是没有思路。</p><h1>看解析</h1><h2 id="134加油站-2">134加油站</h2><p>题解：(<a class="link"   href="https://programmercarl.com/0134.%E5%8A%A0%E6%B2%B9%E7%AB%99.html" >https://programmercarl.com/0134.加油站.html<i class="fas fa-external-link-alt"></i></a>)</p><p>看了解析，明明思路是一样的，就是慢一点。❗忽略了一个点，<strong>如果总和大于0， 那么必定有解</strong>。无语解析里那个totalSum真的太妙了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">totalSum</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; gas.length; i++) &#123;  </span><br><span class="line">        curSum += gas[i] - cost[i];  </span><br><span class="line">        totalSum += gas[i] - cost[i];  </span><br><span class="line">        <span class="keyword">if</span> (curSum &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">            index = (i + <span class="number">1</span>) % gas.length;  </span><br><span class="line">            curSum = <span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (totalSum &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> index;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="135分发糖果-2">135分发糖果</h2><p>解析：(<a class="link"   href="https://programmercarl.com/0135.%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C.html" >https://programmercarl.com/0135.分发糖果.html<i class="fas fa-external-link-alt"></i></a>)</p><h2 id="860柠檬水找零-2">860柠檬水找零</h2><p>解析：(<a class="link"   href="https://programmercarl.com/0860.%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6.html" >https://programmercarl.com/0860.柠檬水找零.html<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">不用HashMap，直接两个<span class="type">int</span>进行加减🤡</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lemonadeChange</span><span class="params">(<span class="type">int</span>[] bills)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">five</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">ten</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> bill : bills) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (bill == <span class="number">5</span>) &#123;  </span><br><span class="line">            five++;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bill == <span class="number">10</span>) &#123;  </span><br><span class="line">            ten++;  </span><br><span class="line">            five--;  </span><br><span class="line">            <span class="keyword">if</span> (five &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bill == <span class="number">20</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (five &gt;= <span class="number">1</span> &amp;&amp; ten &gt;= <span class="number">1</span>) &#123;  </span><br><span class="line">                five--;  </span><br><span class="line">                ten--;  </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (five &gt;= <span class="number">3</span>) &#123;  </span><br><span class="line">                five -= <span class="number">3</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="406根据身高重建队列-2">406根据身高重建队列</h2><p>解析：(<a class="link"   href="https://programmercarl.com/0406.%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97.html" >https://programmercarl.com/0406.根据身高重建队列.html<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 思路: 先按身高排序, 然后根据前面的人数进行队列调整。  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> people 队伍需求  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 排号的队列  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] reconstructQueue(<span class="type">int</span>[][] people) &#123;  </span><br><span class="line">    Arrays.sort(people, (o1, o2) -&gt; &#123;  </span><br><span class="line">        <span class="keyword">if</span> (o1[<span class="number">0</span>] == o2[<span class="number">0</span>]) &#123;  </span><br><span class="line">            <span class="keyword">return</span> o1[<span class="number">1</span>] - o2[<span class="number">1</span>];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> o2[<span class="number">0</span>] - o1[<span class="number">0</span>];  </span><br><span class="line">    &#125;);  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列调整用LinkedList。按顺序在下标位置插入，这样每次插入的值都在相应的下标上。</span></span><br><span class="line"><span class="comment">// 把旧的大于等于它的值往后调整，不影响之前的排序。</span></span><br><span class="line">    LinkedList&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] person : people) &#123;  </span><br><span class="line">        list.add(person[<span class="number">1</span>], person);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[people.length][]);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：134AC但是时间比较长、135看了部分题解AC、860AC（但是HashMap）、406不会&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-14 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="贪心算法" scheme="https://kiml.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第二十八天-122买卖股票的最佳时机II、55 跳跃游戏、45跳跃游戏II、1005K次取反后最大化的数组和</title>
    <link href="https://kiml.github.io/posts/8d31312e/"/>
    <id>https://kiml.github.io/posts/8d31312e/</id>
    <published>2024-06-14T01:01:01.000Z</published>
    <updated>2024-06-15T01:05:18.011Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：122AC，55看了题解AC，45AC，题解代码更简单一点</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-14 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="122买卖股票的最佳时机II">122买卖股票的最佳时机II</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii" >https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii<i class="fas fa-external-link-alt"></i></a>)</p><p>画图很简单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 就是算所有增区间的值  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> prices 列表  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 股票金额  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt;= prices[i - <span class="number">1</span>]) &#123;  </span><br><span class="line">            sum +=prices[i] - prices[i - <span class="number">1</span>];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> sum;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="55-跳跃游戏">55 跳跃游戏</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/jump-game/" >https://leetcode.cn/problems/jump-game/<i class="fas fa-external-link-alt"></i></a>)</p><p>没有思路。看了部分题解，说是求覆盖最大的范围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (i &gt; maxIndex) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里看了题解优化了一下</span></span><br><span class="line">        maxIndex = Math.max(nums[i] + i, maxIndex);  </span><br><span class="line">        <span class="keyword">if</span> (maxIndex &gt;= nums.length - <span class="number">1</span>)&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="45跳跃游戏II">45跳跃游戏II</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/jump-game-ii/" >https://leetcode.cn/problems/jump-game-ii/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 假设每次都跳跃区间内最远的距离  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">maxJ</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> count;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length;) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (i + nums[i] &gt;= nums.length - <span class="number">1</span>) &#123;  </span><br><span class="line">            count++;  </span><br><span class="line">            <span class="keyword">return</span> count;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt;= i + nums[i] &amp;&amp; j &lt; nums.length; j++) &#123;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (j + nums[j] &gt;= maxIndex) &#123;  </span><br><span class="line">                maxIndex = j + nums[j];  </span><br><span class="line">                maxJ = j;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        count++;  </span><br><span class="line">        i = maxJ;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> count;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1005K次取反后最大化的数组和">1005K次取反后最大化的数组和</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations" >https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 思路：可以多次选择同一个数字，返回最大和，说明可以先排序  </span></span><br><span class="line"><span class="comment"> * 1. 从小到大排列， 把所有负数变正  </span></span><br><span class="line"><span class="comment"> * 2. 还有次数剩余。奇数次剩余，就把绝对值最小的翻转一次。  </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 翻转次数  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">largestSumAfterKNegations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;  </span><br><span class="line">    Arrays.sort(nums);  </span><br><span class="line">    <span class="type">int</span> <span class="variable">minAbs</span> <span class="operator">=</span> Integer.MAX_VALUE;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (Math.abs(nums[i]) &lt; minAbs) &#123;  </span><br><span class="line">            minAbs = Math.min(minAbs, Math.abs(nums[i]));  </span><br><span class="line">            index = i;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (k &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">            nums[i] = -nums[i];  </span><br><span class="line">            k--;  </span><br><span class="line">        &#125;  </span><br><span class="line">        sum += nums[i];  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">1</span>) &#123;  </span><br><span class="line">        sum -= <span class="number">2</span> * nums[index];  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> sum;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看解析</h1><h2 id="122买卖股票的最佳时机II-2">122买卖股票的最佳时机II</h2><p>解析：(<a class="link"   href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII.html" >https://programmercarl.com/0122.买卖股票的最佳时机II.html<i class="fas fa-external-link-alt"></i></a>)</p><h2 id="55-跳跃游戏-2">55 跳跃游戏</h2><p>解析：(<a class="link"   href="https://programmercarl.com/0055.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F.html" >https://programmercarl.com/0055.跳跃游戏.html<i class="fas fa-external-link-alt"></i></a>)</p><h2 id="45跳跃游戏II-2">45跳跃游戏II</h2><p>解析：(<a class="link"   href="https://programmercarl.com/0045.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII.html" >https://programmercarl.com/0045.跳跃游戏II.html<i class="fas fa-external-link-alt"></i></a>)</p><p>题解的思路在于增加覆盖范围。每更新一次覆盖范围，就结果+1（这里比较绕，但是这样就不用双层循环了）。简化版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 当前覆盖的最远距离下标</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 下一步覆盖的最远距离下标</span></span><br><span class="line">      <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= end &amp;&amp; end &lt; nums.length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">          temp = Math.max(temp, i + nums[i]);</span><br><span class="line">          <span class="comment">// 可达位置的改变次数就是跳跃次数</span></span><br><span class="line">          <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">              end = temp;</span><br><span class="line">              result++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="1005K次取反后最大化的数组和-2">1005K次取反后最大化的数组和</h2><p>解析：(<a class="link"   href="https://programmercarl.com/1005.K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C.html" >https://programmercarl.com/1005.K次取反后最大化的数组和.html<i class="fas fa-external-link-alt"></i></a>)</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：122AC，55看了题解AC，45AC，题解代码更简单一点&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-14 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="贪心算法" scheme="https://kiml.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第二十七天-455分发饼干、376摆动序列、53最大子序和</title>
    <link href="https://kiml.github.io/posts/dc3e282a/"/>
    <id>https://kiml.github.io/posts/dc3e282a/</id>
    <published>2024-06-13T01:17:44.000Z</published>
    <updated>2024-06-15T01:05:11.670Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：455AC、376、53都需要看解析，感觉贪心上来都是一点思路都没有，可能题做的不够多。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-13 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="455分发饼干">455分发饼干</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/assign-cookies" >https://leetcode.cn/problems/assign-cookies<i class="fas fa-external-link-alt"></i></a>)</p><p>属于小饼干优先。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[] g = &#123;<span class="number">10</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>&#125;;  </span><br><span class="line">    <span class="type">int</span>[] s = &#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;  </span><br><span class="line">    System.out.println(findContentChildren(g, s));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 感觉上s从小排序，g从小排序。按序分配就行。  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> g 孩子胃口  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 饼干数  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;  </span><br><span class="line">    Arrays.sort(s);  </span><br><span class="line">    Arrays.sort(g);  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; g.length &amp;&amp; j &lt; s.length; j++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (g[i] &lt;= s[j]) &#123;  </span><br><span class="line">            count++;  </span><br><span class="line">            i++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> count;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="376摆动序列">376摆动序列</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/wiggle-subsequence" >https://leetcode.cn/problems/wiggle-subsequence<i class="fas fa-external-link-alt"></i></a>)</p><p>没有思路。看了一点点解析，画图。把坡删了。（但是又忽略了单调坡的情况，具体题解在看解析部分）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> nums.length;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>] != nums[<span class="number">1</span>]) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">2</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        count = <span class="number">2</span>;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        count = <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; nums.length; i++) &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">slopePre</span> <span class="operator">=</span> nums[i - <span class="number">1</span>] - nums[i - <span class="number">2</span>];  </span><br><span class="line">        <span class="type">int</span> <span class="variable">slope</span> <span class="operator">=</span> nums[i] - nums[i - <span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> ((slopePre &gt;= <span class="number">0</span>  &amp;&amp; slope &lt; <span class="number">0</span>) || (slopePre &lt;= <span class="number">0</span> &amp;&amp; slope &gt; <span class="number">0</span>)) &#123;  </span><br><span class="line">            count++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> count;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="53最大子序和">53最大子序和</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/maximum-subarray" >https://leetcode.cn/problems/maximum-subarray<i class="fas fa-external-link-alt"></i></a>)</p><p>没有思路。看了部分解析，说是连续和如果出现负数，直接抛弃，从下一个数开始。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路是连续和为负，就直接抛弃连续和  </span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;  </span><br><span class="line">        sum += num;  </span><br><span class="line">        max = Math.max(sum, max);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">            sum = <span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> max;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看解析</h1><h2 id="455分发饼干-2">455分发饼干</h2><p>解析：(<a class="link"   href="https://programmercarl.com/0455.%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2.html" >https://programmercarl.com/0455.分发饼干.html<i class="fas fa-external-link-alt"></i></a>)</p><p>有两种思路，大饼干优先满足胃口大的；小饼干优先满足胃口小的。</p><h2 id="376摆动序列-2">376摆动序列</h2><p>解析：(<a class="link"   href="https://programmercarl.com/0376.%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97.html" >https://programmercarl.com/0376.摆动序列.html<i class="fas fa-external-link-alt"></i></a>)</p><p>思路：</p><ol><li class="lvl-3"><p>怎样算有峰值<code>(preDiff &gt;= 0  &amp;&amp; curDiff &lt; 0) || (preDiff &lt;= 0 &amp;&amp; curDiff &gt; 0)</code></p></li><li class="lvl-3"><p>数组首怎么计数：默认加上一个平节点，即preDiff为0</p></li><li class="lvl-3"><p>单调坡度有平坡：只在坡度进行更新的时候，才把前一个坡值进行记录</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> nums.length;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 当前的差值  </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">curDiff</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="comment">// 前一个坡的差值  </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">preDiff</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;  </span><br><span class="line">        curDiff = nums[i] - nums[i - <span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> ((preDiff &gt;= <span class="number">0</span>  &amp;&amp; curDiff &lt; <span class="number">0</span>) || (preDiff &lt;= <span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span>)) &#123;  </span><br><span class="line">            count++;  </span><br><span class="line">            <span class="comment">// 只有坡度更新才记录坡值  </span></span><br><span class="line">            preDiff = curDiff;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> count;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个偷懒版本是先去重，再找坡。但是要循环两次，时间复杂度变高。</p><h2 id="53最大子序和-2">53最大子序和</h2><p>解析：(<a class="link"   href="https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.html" >https://programmercarl.com/0053.最大子序和.html<i class="fas fa-external-link-alt"></i></a>)</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：455AC、376、53都需要看解析，感觉贪心上来都是一点思路都没有，可能题做的不够多。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-13 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="贪心算法" scheme="https://kiml.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第二十六天-332重新安排行程、51N皇后、 37解数独</title>
    <link href="https://kiml.github.io/posts/cf86d462/"/>
    <id>https://kiml.github.io/posts/cf86d462/</id>
    <published>2024-06-12T03:06:01.000Z</published>
    <updated>2024-06-13T13:47:38.664Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：今天的题，看标注说都很难，先去总结再做这个。时间不太够了，都是直接看的解析然后做题。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">24-06-12 初始记录</span><br><span class="line">24-06-13 完成题解</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="332重新安排行程">332重新安排行程</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/reconstruct-itinerary" >https://leetcode.cn/problems/reconstruct-itinerary<i class="fas fa-external-link-alt"></i></a>)</p><h2 id="51N皇后">51N皇后</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/n-queens" >https://leetcode.cn/problems/n-queens<i class="fas fa-external-link-alt"></i></a>)</p><h2 id="37解数独">37解数独</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/sudoku-solver" >https://leetcode.cn/problems/sudoku-solver<i class="fas fa-external-link-alt"></i></a>)</p><h1>看解析</h1><h2 id="332重新安排行程-2">332重新安排行程</h2><p>题目链接/文章讲解：(<a class="link"   href="https://programmercarl.com/0332.%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B.html" >https://programmercarl.com/0332.重新安排行程.html<i class="fas fa-external-link-alt"></i></a>)<br>解法超时（第80个用例）：加上剪枝不会超时。别的思路都和清晰，但是剪枝那一步有点难想到。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> &#123;  </span><br><span class="line">    List&lt;String&gt; resultOne = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 按字典排序排序（目的地排序）</span></span><br><span class="line">    tickets.sort(Comparator.comparing(o -&gt; o.get(<span class="number">1</span>)));  </span><br><span class="line">    <span class="comment">// 用于记录当前节点是否使用  </span></span><br><span class="line">    <span class="type">boolean</span>[] flagList = <span class="keyword">new</span> <span class="title class_">boolean</span>[tickets.size()];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 行程必须从JFK开始  </span></span><br><span class="line">    resultOne.add(<span class="string">&quot;JFK&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 这里如果找到一条就直接返回  </span></span><br><span class="line">    findItineraryDFS(flagList, tickets, resultOne);  </span><br><span class="line">    <span class="keyword">return</span> resultOne;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">findItineraryDFS</span><span class="params">(<span class="type">boolean</span>[] flagList, List&lt;List&lt;String&gt;&gt; tickets, List&lt;String&gt; resultOne)</span> &#123;  </span><br><span class="line">    <span class="comment">// tickets为线路数，节点数要加1  </span></span><br><span class="line">    <span class="keyword">if</span> (resultOne.size() == tickets.size() + <span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; tickets.size(); i++) &#123;  </span><br><span class="line">    <span class="comment">// 为了防止超时加上这句的剪枝</span></span><br><span class="line">    <span class="comment">// 如果这张票和上张票相同 且上张票没用过 说明是从上张票回溯过来的，已经遍历过这种情况，跳过</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; tickets.get(i).equals(tickets.get(i - <span class="number">1</span>)) &amp;&amp; !flagList[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (!flagList[i] &amp;&amp; tickets.get(i).get(<span class="number">0</span>).equals(resultOne.get(resultOne.size() - <span class="number">1</span>))) &#123;  </span><br><span class="line">            resultOne.add(tickets.get(i).get(<span class="number">1</span>));  </span><br><span class="line">            flagList[i] = <span class="literal">true</span>;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (findItineraryDFS(flagList, tickets, resultOne)) &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            resultOne.remove(resultOne.size() - <span class="number">1</span>);  </span><br><span class="line">            flagList[i] = <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="51N皇后-2">51N皇后</h2><p>题目链接/文章讲解：(<a class="link"   href="https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html" >https://programmercarl.com/0051.N皇后.html<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LE51</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        solveNQueens(<span class="number">4</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;  </span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">        <span class="type">char</span>[][] chars = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span>[] c : chars) &#123;  </span><br><span class="line">            Arrays.fill(c, <span class="string">&#x27;.&#x27;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        solveNQueensDFS(<span class="number">0</span>, n, chars, result);  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row    行数  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n      棋盘大小  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chars  棋盘摆法  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result 结果  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">solveNQueensDFS</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> n, <span class="type">char</span>[][] chars, List&lt;List&lt;String&gt;&gt; result)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;  </span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span>[] aChar : chars) &#123;  </span><br><span class="line">                list.add(String.copyValueOf(aChar));  </span><br><span class="line">            &#125;  </span><br><span class="line">            result.add(list);  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (isValid(row, i, n, chars)) &#123;  </span><br><span class="line">                chars[row][i] = <span class="string">&#x27;Q&#x27;</span>;  </span><br><span class="line">                solveNQueensDFS(row + <span class="number">1</span>, n, chars, result);  </span><br><span class="line">                chars[row][i] = <span class="string">&#x27;.&#x27;</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> n, <span class="type">char</span>[][] chars)</span> &#123;  </span><br><span class="line">        <span class="comment">// 检查列  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; ++i) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (chars[i][col] == <span class="string">&#x27;Q&#x27;</span>) &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 检查45度对角线  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (chars[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 检查135度对角线  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt;= n - <span class="number">1</span>; i--, j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (chars[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="37解数独-2">37解数独</h2><p>题目链接/文章讲解：(<a class="link"   href="https://programmercarl.com/0037.%E8%A7%A3%E6%95%B0%E7%8B%AC.html" >https://programmercarl.com/0037.解数独.html<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LE37</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;  </span><br><span class="line">        solveSudokuDFS(board);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">solveSudokuDFS</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (board[i][j] != <span class="string">&#x27;0&#x27;</span>) &#123;  </span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">k</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>; k &lt;= <span class="string">&#x27;9&#x27;</span>; k++) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (isvalid(i, j, k, board)) &#123;  </span><br><span class="line">                        board[i][j] = k;  </span><br><span class="line">  </span><br><span class="line">                        <span class="keyword">if</span> (solveSudokuDFS(board)) &#123;  </span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        board[i][j] = <span class="string">&#x27;.&#x27;</span>;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="comment">// 走到这一行，说明直到递归完毕，都没有返回true   </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 判断棋盘放入这个数是否合法  </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i     行  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j     列  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k     值  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> board 棋盘  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否合法  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isvalid</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span> k, <span class="type">char</span>[][] board)</span> &#123;  </span><br><span class="line">        <span class="comment">// 行中是否含有这个数  </span></span><br><span class="line">        <span class="comment">// 列中是否含有这个数  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; board.length; index++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (board[i][index] == k) &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (board[index][j] == k) &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 9宫格中是否含有这个数  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (i / <span class="number">3</span>) * <span class="number">3</span>;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (j / <span class="number">3</span>) * <span class="number">3</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">indexX</span> <span class="operator">=</span> x; indexX &lt; x + <span class="number">3</span>; indexX++) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">indexY</span> <span class="operator">=</span> y; indexY &lt; y + <span class="number">3</span>; indexY++) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (board[indexX][indexY] == k) &#123;  </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：今天的题，看标注说都很难，先去总结再做这个。时间不太够了，都是直接看的解析然后做题。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-12 初始记录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24-06-13 完成题解&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="回溯算法" scheme="https://kiml.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第二十五天-491递增子序列 、46全排列 、47全排列 II</title>
    <link href="https://kiml.github.io/posts/f191c36/"/>
    <id>https://kiml.github.io/posts/f191c36/</id>
    <published>2024-06-11T08:02:17.000Z</published>
    <updated>2024-06-12T13:04:11.990Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：491超时。46AC。47不是很对，要看解析，主要是去重那一步。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">24-06-11 初始记录</span><br><span class="line">24-06-12 完成</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="491递增子序列">491递增子序列</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/non-decreasing-subsequences" >https://leetcode.cn/problems/non-decreasing-subsequences<i class="fas fa-external-link-alt"></i></a>)</p><p>超时了，主要是去重那一步应该。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    List&lt;Integer&gt; resultOne = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    findSubsequencesDFS(<span class="number">0</span> , nums, resultOne, result);  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findSubsequencesDFS</span><span class="params">(<span class="type">int</span> startIndex, <span class="type">int</span>[] nums, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;  </span><br><span class="line">    <span class="comment">// 先这样判断是否重复  </span></span><br><span class="line">    <span class="keyword">if</span> (resultOne.size() &gt;= <span class="number">2</span> &amp;&amp; !result.contains(resultOne)) &#123;  </span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(resultOne));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; nums.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (resultOne.size() != <span class="number">0</span> &amp;&amp; resultOne.get(resultOne.size() - <span class="number">1</span>) &gt; nums[i]) &#123;  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        resultOne.add(nums[i]);   </span><br><span class="line">        findSubsequencesDFS(i + <span class="number">1</span>, nums, resultOne, result);  </span><br><span class="line">        resultOne.remove(resultOne.size() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="46全排列">46全排列</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/permutations/description/" >https://leetcode.cn/problems/permutations/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 排列每个变量都要统计，所以不需要startIndex</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    List&lt;Integer&gt; resultOne = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    permuteDFS(nums, resultOne, result);  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">permuteDFS</span><span class="params">(<span class="type">int</span>[] nums, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (resultOne.size() == nums.length) &#123;  </span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(resultOne));  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (resultOne.contains(nums[i])) &#123;  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        resultOne.add(nums[i]);  </span><br><span class="line">        permuteDFS(nums, resultOne, result);  </span><br><span class="line">        resultOne.remove(resultOne.size() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="47全排列-II">47全排列 II</h2><p>题目链接：(<a class="link"   href="http://leetcode.cn/problems/permutations-ii/" >leetcode.cn/problems/permutations-ii/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 和上一题唯一的区别就是数组元素重复。  </span></span><br><span class="line"><span class="comment"> * 所以不能用数组直接统计，得用index记录这个是否被记过  </span></span><br><span class="line"><span class="comment"> * 还有点缺陷。重复元素会按不同下标被重复计入.  </span></span><br><span class="line"><span class="comment"> * 和之前一样，单层元素不能重复。  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums nums  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    List&lt;Integer&gt; resultOne = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    Arrays.sort(nums);  </span><br><span class="line">    permuteUniqueDFS(nums, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), resultOne, result);  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">permuteUniqueDFS</span><span class="params">(<span class="type">int</span>[] nums, List&lt;Integer&gt; resultIndex, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (resultOne.size() == nums.length) &#123;  </span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(resultOne));  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 判断这层有没有使用过这个数字，和LE491一样  </span></span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();  </span><br><span class="line">    <span class="comment">// set记录下标  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (resultIndex.contains(i)) &#123;  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (set.contains(nums[i])) &#123;  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        resultIndex.add(i);  </span><br><span class="line">        resultOne.add(nums[i]);  </span><br><span class="line">        set.add(nums[i]);  </span><br><span class="line">        permuteUniqueDFS(nums, resultIndex, resultOne, result);  </span><br><span class="line">        resultOne.remove(resultOne.size() - <span class="number">1</span>);  </span><br><span class="line">        resultIndex.remove(resultIndex.size() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看题解</h1><h2 id="491递增子序列-2">491递增子序列</h2><p>(<a class="link"   href="https://programmercarl.com/0491.%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html" >https://programmercarl.com/0491.递增子序列.html<i class="fas fa-external-link-alt"></i></a>)</p><p>视频讲解：(<a class="link"   href="https://www.bilibili.com/video/BV1EG4y1h78v" >https://www.bilibili.com/video/BV1EG4y1h78v<i class="fas fa-external-link-alt"></i></a>)<br>加了剪枝操作的优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    List&lt;Integer&gt; resultOne = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    findSubsequencesDFS(<span class="number">0</span> , nums, resultOne, result);  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findSubsequencesDFS</span><span class="params">(<span class="type">int</span> startIndex, <span class="type">int</span>[] nums, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;   </span><br><span class="line">    <span class="keyword">if</span> (resultOne.size() &gt;= <span class="number">2</span>) &#123;  </span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(resultOne));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; nums.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (resultOne.size() != <span class="number">0</span> &amp;&amp; resultOne.get(resultOne.size() - <span class="number">1</span>) &gt; nums[i]) &#123;  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 判断这层是否使用  </span></span><br><span class="line">        <span class="keyword">if</span> (map.getOrDefault(nums[i], <span class="number">0</span>) &gt;= <span class="number">1</span>) &#123;  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        map.put(nums[i], map.getOrDefault(nums[i], <span class="number">0</span>) + <span class="number">1</span>);  </span><br><span class="line">        resultOne.add(nums[i]);  </span><br><span class="line">        findSubsequencesDFS(i + <span class="number">1</span>, nums, resultOne, result);  </span><br><span class="line">        resultOne.remove(resultOne.size() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="46全排列-2">46全排列</h2><p>(<a class="link"   href="https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html" >https://programmercarl.com/0046.全排列.html<i class="fas fa-external-link-alt"></i></a>)</p><p>视频讲解：(<a class="link"   href="https://www.bilibili.com/video/BV19v4y1S79W" >https://www.bilibili.com/video/BV19v4y1S79W<i class="fas fa-external-link-alt"></i></a>)</p><h2 id="47全排列-II-2">47全排列 II</h2><p>(<a class="link"   href="https://programmercarl.com/0047.%E5%85%A8%E6%8E%92%E5%88%97II.html" >https://programmercarl.com/0047.全排列II.html<i class="fas fa-external-link-alt"></i></a>)</p><p>视频讲解：(<a class="link"   href="https://www.bilibili.com/video/BV1R84y1i7Tm" >https://www.bilibili.com/video/BV1R84y1i7Tm<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    List&lt;Integer&gt; resultOne = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    Arrays.sort(nums);  </span><br><span class="line">    permuteUniqueDFS(nums, <span class="keyword">new</span> <span class="title class_">boolean</span>[]&#123;&#125;, resultOne, result);  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 用数组标记因为这个树更像一个矩阵  </span></span><br><span class="line"><span class="comment"> * 数组可以标记nums又可以标记层数  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">permuteUniqueDFS</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] used, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (resultOne.size() == nums.length) &#123;  </span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(resultOne));  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// set记录下标  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;  </span><br><span class="line">        <span class="comment">// 记录了index值，即这index被使用了（这里可以理解）  </span></span><br><span class="line">        <span class="keyword">if</span> (used[i]) &#123;  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 如果这个数值和前面的数值相同  </span></span><br><span class="line">        <span class="comment">// 首先一定要排序，这样nums数组中的前面一个节点，就一定是被用过了  </span></span><br><span class="line">        <span class="comment">// 然后现在到这个节点，前面一个节点的状态是false(这里横向看)，说明已经回溯了。节点已经被添加，跳过这层  </span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 这层是否使用过  </span></span><br><span class="line">        used[i] = <span class="literal">true</span>;  </span><br><span class="line">        resultOne.add(nums[i]);  </span><br><span class="line">        permuteUniqueDFS(nums, used, resultOne, result);  </span><br><span class="line">        resultOne.remove(resultOne.size() - <span class="number">1</span>);  </span><br><span class="line">        used[i] = <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：491超时。46AC。47不是很对，要看解析，主要是去重那一步。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-11 初始记录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24-06-12 完成&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="回溯算法" scheme="https://kiml.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第二十四天-93复原IP地址、78子集、90子集II</title>
    <link href="https://kiml.github.io/posts/c27b36b8/"/>
    <id>https://kiml.github.io/posts/c27b36b8/</id>
    <published>2024-06-11T06:02:58.000Z</published>
    <updated>2024-06-12T13:03:38.862Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：93可以AC。78、90AC。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-11 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="93复原IP地址">93复原IP地址</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/restore-ip-addresses" >https://leetcode.cn/problems/restore-ip-addresses<i class="fas fa-external-link-alt"></i></a>)<br>解的时候不知道单字符串怎么操作了，加了一个数组。慢了很多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;  </span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    List&lt;String&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (s.length() &lt; <span class="number">4</span> || s.length() &gt; <span class="number">12</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    restoreIpAddressesDFS(<span class="number">0</span>, temp, s, result);  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * * <span class="doctag">@param</span> startIndex 开始Index  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 输入的s  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> result 切割的字符串集  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">restoreIpAddressesDFS</span><span class="params">(<span class="type">int</span> startIndex, List&lt;String&gt; temp, String s, List&lt;String&gt; result)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= s.length() &amp;&amp; temp.size() == <span class="number">4</span>) &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">resultOne</span> <span class="operator">=</span> String.join(<span class="string">&quot;.&quot;</span>, temp);  </span><br><span class="line">        result.add(resultOne);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; s.length() &amp;&amp; Integer.parseInt(s.substring(startIndex, i + <span class="number">1</span>)) &lt; <span class="number">256</span>; i++) &#123;  </span><br><span class="line">        <span class="comment">// 8 为 substring 的取值就在 1 - 3之间  </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">substring</span> <span class="operator">=</span> s.substring(startIndex, i + <span class="number">1</span>);  </span><br><span class="line">        <span class="keyword">if</span> (substring.length() &lt; <span class="number">1</span> || substring.length() &gt; <span class="number">3</span>) &#123;  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (substring.length() &gt; <span class="number">1</span> &amp;&amp; substring.startsWith(<span class="string">&quot;0&quot;</span>)) &#123;  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        temp.add(substring);  </span><br><span class="line">        restoreIpAddressesDFS(i + <span class="number">1</span>, temp, s, result);  </span><br><span class="line">        temp.remove(temp.size() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="78子集">78子集</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/subsets" >https://leetcode.cn/problems/subsets<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    List&lt;Integer&gt; resultOne = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 排序  </span></span><br><span class="line">    Arrays.sort(nums);  </span><br><span class="line">    </span><br><span class="line">    subsetsDFS(<span class="number">0</span>, nums, resultOne, result);  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 这个和之前的区别在于，如果转化成一颗树。之前只要求叶子节点。这个全部都要  </span></span><br><span class="line"><span class="comment"> * 而且还要不重复（😗写错了，看成90的题了。这题还要更简单一点。）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> startIndex 起始index  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">subsetsDFS</span><span class="params">(<span class="type">int</span> startIndex, <span class="type">int</span>[] nums, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;    </span><br><span class="line">    result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(resultOne));  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; nums.length; i++) &#123;  </span><br><span class="line">        resultOne.add(nums[i]);  </span><br><span class="line">        subsetsDFS(i + <span class="number">1</span>, nums, resultOne, result);  </span><br><span class="line">        resultOne.remove(resultOne.size() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="90子集II">90子集II</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/subsets-ii" >https://leetcode.cn/problems/subsets-ii<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    List&lt;Integer&gt; resultOne = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 排序  </span></span><br><span class="line">    Arrays.sort(nums);  </span><br><span class="line">  </span><br><span class="line">    subsetsDFS(<span class="number">0</span>, nums, resultOne, result);  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> startIndex 起始index  </span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">subsetsDFS</span><span class="params">(<span class="type">int</span> startIndex, <span class="type">int</span>[] nums, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;  </span><br><span class="line">    result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(resultOne));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; nums.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= startIndex &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        resultOne.add(nums[i]);  </span><br><span class="line">        subsetsDFS(i + <span class="number">1</span>, nums, resultOne, result);  </span><br><span class="line">        resultOne.remove(resultOne.size() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看解析</h1><h2 id="93复原IP地址-2">93复原IP地址</h2><p>题目链接/文章讲解：(<a class="link"   href="https://programmercarl.com/0093.%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80.html" >https://programmercarl.com/0093.复原IP地址.html<i class="fas fa-external-link-alt"></i></a>)</p><p>视频讲解：(<a class="link"   href="https://www.bilibili.com/video/BV1XP4y1U73i/" >https://www.bilibili.com/video/BV1XP4y1U73i/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">restoreIpAddressesHandler(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// number表示stringbuilder中ip段的数量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">restoreIpAddressesHandler</span><span class="params">(String s, <span class="type">int</span> start, <span class="type">int</span> number)</span> &#123;</span><br><span class="line"><span class="comment">// 如果start等于s的长度并且ip段的数量是4，则加入结果集，并返回</span></span><br><span class="line"><span class="keyword">if</span> (start == s.length() &amp;&amp; number == <span class="number">4</span>) &#123;</span><br><span class="line">result.add(stringBuilder.toString());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果start等于s的长度但是ip段的数量不为4，或者ip段的数量为4但是start小于s的长度，则直接返回</span></span><br><span class="line"><span class="keyword">if</span> (start == s.length() || number == <span class="number">4</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 剪枝：ip段的长度最大是3，并且ip段处于[0,255]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; s.length() &amp;&amp; i - start &lt; <span class="number">3</span> &amp;&amp; Integer.parseInt(s.substring(start, i + <span class="number">1</span>)) &gt;= <span class="number">0</span></span><br><span class="line">&amp;&amp; Integer.parseInt(s.substring(start, i + <span class="number">1</span>)) &lt;= <span class="number">255</span>; i++) &#123;</span><br><span class="line"><span class="comment">// 如果ip段的长度大于1，并且第一位为0的话，continue</span></span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> - start &gt; <span class="number">1</span> &amp;&amp; s.charAt(start) - <span class="string">&#x27;0&#x27;</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">stringBuilder.append(s.substring(start, i + <span class="number">1</span>));</span><br><span class="line"><span class="comment">// 当stringBuilder里的网段数量小于3时，才会加点；如果等于3，说明已经有3段了，最后一段不需要再加点</span></span><br><span class="line"><span class="keyword">if</span> (number &lt; <span class="number">3</span>) &#123;</span><br><span class="line">stringBuilder.append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">number++;</span><br><span class="line">restoreIpAddressesHandler(s, i + <span class="number">1</span>, number);</span><br><span class="line">number--;</span><br><span class="line"><span class="comment">// 删除当前stringBuilder最后一个网段，注意考虑点的数量的问题</span></span><br><span class="line"><span class="comment">// 主要这里没有写出来❗</span></span><br><span class="line">stringBuilder.delete(start + number, i + number + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="78子集-2">78子集</h2><p>题目链接/文章讲解：(<a class="link"   href="https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html" >https://programmercarl.com/0078.子集.html<i class="fas fa-external-link-alt"></i></a>)</p><p>视频讲解：(<a class="link"   href="https://www.bilibili.com/video/BV1U84y1q7Ci" >https://www.bilibili.com/video/BV1U84y1q7Ci<i class="fas fa-external-link-alt"></i></a>)</p><h2 id="90子集II-2">90子集II</h2><p>题目链接/文章讲解：(<a class="link"   href="https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html" >https://programmercarl.com/0090.子集II.html<i class="fas fa-external-link-alt"></i></a>)</p><p>视频讲解：(<a class="link"   href="https://www.bilibili.com/video/BV1vm4y1F71J" >https://www.bilibili.com/video/BV1vm4y1F71J<i class="fas fa-external-link-alt"></i></a>)</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：93可以AC。78、90AC。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-11 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="回溯算法" scheme="https://kiml.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第二十三天-39组合总和、40组合总和II、131分割回文串</title>
    <link href="https://kiml.github.io/posts/2f09909f/"/>
    <id>https://kiml.github.io/posts/2f09909f/</id>
    <published>2024-06-11T01:00:46.000Z</published>
    <updated>2024-06-12T09:59:59.483Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：39AC但是可以继续优化剪枝。40AC。131分割没有做过，直接看解析了（动态规划求回文这个没有看，后面刷到动态规划再研究）。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-11 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="39组合总和">39组合总和</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/combination-sum" >https://leetcode.cn/problems/combination-sum<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;  </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    List&lt;Integer&gt; resultOne = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    combinationSumDFS(<span class="number">0</span>, <span class="number">0</span>, target, candidates, resultOne, result);  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">combinationSumDFS</span><span class="params">(<span class="type">int</span> startIndex, <span class="type">int</span> sum, <span class="type">int</span> target, <span class="type">int</span>[] candidates, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (sum &gt;= target) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (target == sum) &#123;  </span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(resultOne));  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; candidates.length; i++) &#123;  </span><br><span class="line">        resultOne.add(candidates[i]);  </span><br><span class="line">        combinationSumDFS(i, sum + candidates[i], target, candidates, resultOne, result);  </span><br><span class="line">        resultOne.remove(resultOne.size() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="40组合总和II">40组合总和II</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/combination-sum-ii" >https://leetcode.cn/problems/combination-sum-ii<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;  </span><br><span class="line">    Arrays.sort(candidates);  </span><br><span class="line">  </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    List&lt;Integer&gt; resultOne = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    combinationSum2DFS(<span class="number">0</span>, <span class="number">0</span>, target, candidates, resultOne, result);  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 思路：  </span></span><br><span class="line"><span class="comment"> * 1. 和上题差不多。但是数组变成有重复元素的了。  </span></span><br><span class="line"><span class="comment"> * 2. 想法是每层遍历的时候，去重  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">combinationSum2DFS</span><span class="params">(<span class="type">int</span> startIndex, <span class="type">int</span> sum, <span class="type">int</span> target, <span class="type">int</span>[] candidates, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (sum == target) &#123;  </span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(resultOne));  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;</span><br><span class="line"><span class="comment">// 在单层的数组内去重</span></span><br><span class="line">        <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= startIndex &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) &#123;  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        resultOne.add(candidates[i]);  </span><br><span class="line">        combinationSum2DFS(i + <span class="number">1</span>, sum + candidates[i], target, candidates, resultOne, result);  </span><br><span class="line">        resultOne.remove(resultOne.size() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="131分割回文串">131分割回文串</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/palindrome-partitioning" >https://leetcode.cn/problems/palindrome-partitioning<i class="fas fa-external-link-alt"></i></a>)</p><h1>看解析</h1><h2 id="39组合总和-2">39组合总和</h2><p>题目链接/文章讲解：(<a class="link"   href="https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html" >https://programmercarl.com/0039.组合总和.html<i class="fas fa-external-link-alt"></i></a>)</p><p>视频讲解：(<a class="link"   href="https://www.bilibili.com/video/BV1KT4y1M7HJ/" >https://www.bilibili.com/video/BV1KT4y1M7HJ/<i class="fas fa-external-link-alt"></i></a>)</p><p>本来以为只要return就不用优化了（好像没有什么关系，还是会继续往下走），但是题解中说可以减少一次进入递归。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;  </span><br><span class="line">    <span class="comment">// 要剪枝必须要排序  </span></span><br><span class="line">    Arrays.sort(candidates);  </span><br><span class="line">  </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    List&lt;Integer&gt; resultOne = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    combinationSumDFS(<span class="number">0</span>, <span class="number">0</span>, target, candidates, resultOne, result);  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">combinationSumDFS</span><span class="params">(<span class="type">int</span> startIndex, <span class="type">int</span> sum, <span class="type">int</span> target, <span class="type">int</span>[] candidates, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (target == sum) &#123;  </span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(resultOne));  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// for循环的判断做了剪枝优化处理  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;  </span><br><span class="line">        resultOne.add(candidates[i]);  </span><br><span class="line">        combinationSumDFS(i, sum + candidates[i], target, candidates, resultOne, result);  </span><br><span class="line">        resultOne.remove(resultOne.size() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="40组合总和II-2">40组合总和II</h2><p>题目链接/文章讲解：(<a class="link"   href="https://programmercarl.com/0040.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII.html" >https://programmercarl.com/0040.组合总和II.html<i class="fas fa-external-link-alt"></i></a>)</p><p>视频讲解：(<a class="link"   href="https://www.bilibili.com/video/BV12V4y1V73A/" >https://www.bilibili.com/video/BV12V4y1V73A/<i class="fas fa-external-link-alt"></i></a>)</p><p><img                         lazyload                       alt="image"                       data-src="https://blog-resources.oss-cn-hangzhou.aliyuncs.com/240612/2020111820220675.png"                        alt=""                 ><br><strong>在candidates[i] == candidates[i - 1]相同的情况下：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>used[i - 1] == true，说明同一树枝candidates[i - 1]使用过</p></li><li class="lvl-2"><p>used[i - 1] == false，说明同一树层candidates[i - 1]使用过</p></li></ul><h2 id="131分割回文串-2">131分割回文串</h2><p>题目链接/文章讲解：(<a class="link"   href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html" >https://programmercarl.com/0131.分割回文串.html<i class="fas fa-external-link-alt"></i></a>)</p><p>视频讲解：(<a class="link"   href="https://www.bilibili.com/video/BV1c54y1e7k6/" >https://www.bilibili.com/video/BV1c54y1e7k6/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;  </span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    List&lt;String&gt; string = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    partitionDFS(<span class="number">0</span>, s, string, result);  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">partitionDFS</span><span class="params">(<span class="type">int</span> startIndex, String s, List&lt;String&gt; string, List&lt;List&lt;String&gt;&gt; result)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (startIndex &gt;= s.length()) &#123;  </span><br><span class="line">        result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(string));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; s.length(); i++) &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">substring</span> <span class="operator">=</span> s.substring(startIndex, i + <span class="number">1</span>);  </span><br><span class="line">        <span class="keyword">if</span> (!isPartition(substring)) &#123;  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        string.add(substring);  </span><br><span class="line">        partitionDFS(i + <span class="number">1</span>, s, string, result);  </span><br><span class="line">        string.remove(string.size() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 判断传入字符串是否为回文字符串  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> substring 截取的字符串  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isPartition</span><span class="params">(String substring)</span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j= substring.length() - <span class="number">1</span>; i &lt; j; i++, j--) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (substring.charAt(i) != substring.charAt(j)) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化版 动态规划法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; result;</span><br><span class="line">    LinkedList&lt;String&gt; path;</span><br><span class="line">    <span class="type">boolean</span>[][] dp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line">        path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[str.length + <span class="number">1</span>][str.length + <span class="number">1</span>];</span><br><span class="line">        isPalindrome(str);</span><br><span class="line">        backtracking(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String str, <span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (startIndex &gt;= str.length()) &#123;</span><br><span class="line">            <span class="comment">//如果起始位置大于s的大小，说明找到了一组分割方案</span></span><br><span class="line">            result.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; str.length(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[startIndex][i]) &#123;</span><br><span class="line">                    <span class="comment">//是回文子串，进入下一步递归</span></span><br><span class="line">                    <span class="comment">//先将当前子串保存入path</span></span><br><span class="line">                    path.addLast(str.substring(startIndex, i + <span class="number">1</span>));</span><br><span class="line">                    <span class="comment">//起始位置后移，保证不重复</span></span><br><span class="line">                    backtracking(str, i + <span class="number">1</span>);</span><br><span class="line">                    path.pollLast();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//不是回文子串，跳过</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过动态规划判断是否是回文串,参考动态规划篇 52 回文子串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">isPalindrome</span><span class="params">(<span class="type">char</span>[] str)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= str.length; ++i) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; str.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str[j] == str[i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i - j &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                        dp[j][i] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dp[j + <span class="number">1</span>][i - <span class="number">1</span>]) &#123;</span><br><span class="line">                        dp[j][i] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：39AC但是可以继续优化剪枝。40AC。131分割没有做过，直接看解析了（动态规划求回文这个没有看，后面刷到动态规划再研究）。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-11 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="回溯算法" scheme="https://kiml.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>面试-Spring、Spring MVC、Spring Boot</title>
    <link href="https://kiml.github.io/posts/dcaead99/"/>
    <id>https://kiml.github.io/posts/dcaead99/</id>
    <published>2024-06-10T14:16:35.000Z</published>
    <updated>2024-06-17T07:45:19.301Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>❗表示必掌握，❔表示基本不会问</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">24-06-10 初始记录</span><br><span class="line">24-06-12 继续</span><br><span class="line">24-06-13 继续</span><br><span class="line">24-06-14 补充剩下的知识点。Spring这块的知识后续需要看书、看源码。</span><br></pre></td></tr></table></figure><span id="more"></span><h1>Spring</h1><h2 id="说说Spring常用的几个注解？">说说Spring常用的几个注解？</h2><table><thead><tr><th>注解</th><th>使用</th></tr></thead><tbody><tr><td>@Component</td><td>取代.xml中的<bean id="">；用于三层架构类之外。</td></tr><tr><td>@Controller</td><td>衍生注解；用于Controller层</td></tr><tr><td>@Service</td><td>衍生注解；用于Service层</td></tr><tr><td>@Repository</td><td>衍生注解；用于Dao层</td></tr><tr><td>@Bean</td><td>取代.xml中工厂创建bean对象,方法的返回值成为bean对象。</td></tr><tr><td>@Autowired</td><td>取代.xml中<property>中的ref注入，底层是CGLIB动态代理。这个是本地注入。</td></tr><tr><td>@Aspect</td><td>定义在类上；设置当前类为切面类</td></tr><tr><td>@Before</td><td>定义在方法上；标注当前方法作为前置通知</td></tr></tbody></table><h2 id="谈谈你对Spring的理解？">谈谈你对Spring的理解？</h2><p>Spring是一个完整的生态，不单单是一个技术框架。</p><h2 id="❗Spring-框架中都用到了哪些设计模式？">❗Spring 框架中都用到了哪些设计模式？</h2><p>工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；</p><p>单例模式：Bean默认为单例模式。</p><p>代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</p><p>模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</p><p>观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。</p><h2 id="Spring两大核心思想是什么？">Spring两大核心思想是什么？</h2><p>IOC：解耦，使代码复用，可维护性大幅提升。</p><p>AOP：提供切面编程，同样增强生产力。</p><h3 id="❗说一说你对IOC的理解？">❗说一说你对IOC的理解？</h3><p>❗大白话：最原始的tomcat+servlet的编码原理。使用的时候<code>Myservice myservie = new MyserviceImpl()</code>。耦合度很高，修改一个类要修改很多文件。然后我们引入Spring这个框架。会去由框架Spring容器创建实例Bean，对象间就会直接引用（依赖注入）。然后Spring MVC(核心Servlet Filter 去处理请求)。IOC底层就是反射（+工厂模式）、通过类去创建对象。</p><p>IoC（Inversion Of Control）控制反转，其实是一种思想，用于解决程序间的耦合问题。【解耦】</p><p>原本我们创建对象是直接在类中，通过new的方式创建，控制权在于程序员自己，现在我们把new对象的工作交给spring完成，我们只需要通过配置文件进行配置即可。反转的是对象的创建权力。【便捷】</p><p>ioc容器，可以简单理解为一个工厂，但是他的功能比普通工厂要强大很多，内部帮助我们完成了对象的创建和效果的整个过程管理，同时提供了很多扩展机会。【可扩展】</p><h3 id="❗说一说你对AOP的理解？">❗说一说你对AOP的理解？</h3><p>他有几个概念，可以做一个切面。在一些类的方法中，都先织入一些代码处理类似的逻辑（日志、权限认证、事务）。Spring在运行的时候，会有一个动态代理的技术。他会动态生成一个类，把我们的类注入，实现织入的那些代码。</p><h4 id="Spring-AOP里面的几个名词">Spring AOP里面的几个名词</h4><p>（1）切面（Aspect）：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。</p><p>（2）连接点（Join point）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。 应用可能有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</p><p>（3）通知（Advice）：在AOP术语中，切面的工作被称为通知。</p><p>（4）切入点（Pointcut）：切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。</p><p>（5）引入（Introduction）：引入允许我们向现有类添加新方法或属性。</p><p>（6）目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。它通常是一个代理对象。也有人把它叫做 被通知（adviced） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。</p><p>（7）织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。在目标对象的生命周期里有多少个点可以进行织入</p><h4 id="Spring通知有哪些类型？">Spring通知有哪些类型？</h4><p>在AOP术语中，切面的工作被称为通知，实际上是程序执行时要通过SpringAOP框架触发的代码段。<br>Spring切面可以应用5种类型的通知：</p><ul class="lvl-0"><li class="lvl-2"><p>前置通知（Before）：在目标方法被调用之前调用通知功能；</p></li><li class="lvl-2"><p>后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；</p></li><li class="lvl-2"><p>返回通知（After-returning ）：在目标方法成功执行之后调用通知；</p></li><li class="lvl-2"><p>异常通知（After-throwing）：在目标方法抛出异常后调用通知；</p></li><li class="lvl-2"><p>环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。</p></li></ul><h4 id="❗cglib动态代理和jdk动态代理的区别">❗cglib动态代理和jdk动态代理的区别</h4><p>// todo<br>动态代理，其实就是动态的创建一个类出来，创建这个类的实例对象，在这个里面引用你真正自己写的类，所有方法的调用，都先走代理类对象，做一些代码上的增强。</p><p>如果类实现了某个接口，spring aop会使用jdk动态代理。如果某个类没有实现接口，spring aop会使用cglib动态代理。cglib是生成类的一个子类，可以动态生成字节码，覆盖一些方法，进行方法增强。</p><h2 id="Bean对象的创建方式有哪几种？">Bean对象的创建方式有哪几种？</h2><ol><li class="lvl-3"><p>通过IoC直接创建bean对象</p></li><li class="lvl-3"><p>通过IoC创建bean工厂，再通过bean工厂的方法创建bean对象</p></li><li class="lvl-3"><p>通过IoC创建bean工厂，再通过bean工厂的静态方法创建bean对象</p></li></ol><h3 id="❗Spring中的Bean是不是线程安全的？">❗Spring中的Bean是不是线程安全的？</h3><p>❔bean的作用域可以分为5个范围：</p><ol><li class="lvl-3"><p>singleton（单例）：默认每个容器中只有一个实例对象</p></li><li class="lvl-3"><p>prototype：每次创建一个新的</p></li><li class="lvl-3"><p>request：</p></li><li class="lvl-3"><p>session：</p></li><li class="lvl-3"><p>global-session</p></li></ol><p>不是，Spring框架中的单例bean不是线程安全的。</p><p>spring 中的 bean 默认是单例模式，spring 框架并没有对单例 bean 进行多线程的封装处理。</p><p>实际上大部分时候 spring bean 无状态的（比如 dao 类），所以某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”（单例）变更为“prototype”（多例），这样请求 bean 相当于 new Bean()了，所以就可以保证线程安全了。</p><p>有状态：就是有数据存储功能。</p><p>无状态：就是不会保存数据。</p><h3 id="❗Spring-Bean的生命周期">❗Spring Bean的生命周期</h3><ol><li class="lvl-3"><p>首先，我们知道bean对象的创建不是由我们自己创建的，而是由Spring来给我们创建的，而我们需要做的是告诉Spring我们需要创建哪些Bean对象。我们可以通过xml、注解等方式来提供创建Bean对象所以需要的信息，而Spring要创建bean对象，就首先得有一个BeanFactory工厂来创建Bean对象，如果这个Bean对象已经存在，则销毁清空Bean工厂的内容，如果不存在，就会通过DefaultListableBeanFactory方法先创建一个Bean对象工厂（即BeanFactory）。</p></li><li class="lvl-3"><p>BeanFactory要创建Bean对象，就需要Bean对象的相关信息，这些信息就是通过xml或注解方式获得，所以第二步是需要读取这些bean的相关信息，通过LoadBeanDefinition来加载配置文件，并将相关信息加载成一个个BeanDefinition对象（Bean与BeanDefinition的关系就像类与字节码文件之间的关系）。</p></li><li class="lvl-3"><p>BeanDefinitions生成后，会通过invokeBeanFactoryPostProcessors方法对所有的BeanDefinitions以及BeanFactory进行后置处理执行：</p><ol><li class="lvl-7">拿到当前应用上下文 beanFactoryPostProcessors 变量中的值，默认情况返回为空。</li><li class="lvl-7">实例化并调用所有已注册的 BeanFactoryPostProcessor信息，也就是Bean的相关定义。</li></ol></li><li class="lvl-3"><p>BeanFactory工厂的相关增强处理结束后，BanFactory就会正式开始实Bean对象的实例化，由InstantiateSingletons方法通过反射创建Bean对象，其中会判断该对象是否是单例或者懒加载：如果不是单例或者不是懒加载，就采用FactoryBean单独构创建对象；如果是单例对象或懒加载，就由BeanFactory工厂直接反射创建对象。</p></li><li class="lvl-3"><p>BeanFactory将对象实例化之后，Spring会通过BeanPostProcessor（bean对象后置处理器）对Bean对象的初始化的前后进行后置处理，填充Bean对象的属性，完成初始化。</p></li><li class="lvl-3"><p>通过Map数据类型放这些Bean对象存放在IOC容器中。</p></li><li class="lvl-3"><p>bean销毁：注册销毁的回调方法，当对象销毁时，会执行destory-method方法。</p></li></ol><p>下面可以不看，感觉这块视频讲的乱七八糟的。大白话：再注解里定义bean，Spring容器根据配置创建、管理bean之间的依赖关系等。生命周期：创建-&gt;使用-&gt;销毁。从(1)实例化bean，(2)设置依赖属性（依赖注入），过程中可能会进行动态代理的处理。(3)处理Aware接口，如果Bean实现了ApplicationContextAware接口，Spring容器会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文。把容器注入给Bean。(4)如果要对Bean进行一些自定义的处理，可以让Bean实现BeanPostProcessors接口。(5)如果Bean配置了init-method，会根据配置进行初始化。(6)清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destroy()方法。(7)如果Bean的Spring配置中配置了destory-method属性，会在销毁时，进行调用。</p><h4 id="Spring为什么启动时要实例化几乎所有的Bean，这样启动不是很消耗资源吗">Spring为什么启动时要实例化几乎所有的Bean，这样启动不是很消耗资源吗?</h4><p>主要的好处有两个：性能、提前暴露问题。</p><p>启动时花费几十秒初始化好所有的bean，处理好所有的依赖注入，在运行时就可以免去初始化这步了，首次访问响应速度自然更好。</p><p>提前暴露问题就是在启动时初始化bean，可以检查循环依赖、bean重复、bean不存在等等一系列的问题，有问题直接报错启动失败, 那你在部署的时候就能直接发现问题，而不是等线上运行一段时间后突然反馈有问题又得跑到服务器上看日志。</p><h4 id="spring里面的-bean为什么要注册，作用是什么？">spring里面的 bean为什么要注册，作用是什么？</h4><p>注册就是把信息存起来，内部是基于集合实现的，注册方便之后对于信息的调取。</p><h4 id="BeanFactory和FactoryBean的区别是什么？">BeanFactory和FactoryBean的区别是什么？</h4><p>BeanFactory：由Bean工厂统一生成对象，相当于一个模子克隆出来。</p><p>FactoryBean：单独构造复杂对象，在Spring中BeanFactory进行实例化时，判断该对象不是单例或者不是懒加载形式，就改由FactoryBean来单独创建对象。</p><h2 id="Spring有哪些依赖注入法？">Spring有哪些依赖注入法？</h2><ol><li class="lvl-3"><p>Set方法注入：注入最简单，最常用的注入方式，支持注解+xml。</p></li><li class="lvl-3"><p>构造器注入：是指带有参数的构造函数注入，支持注解+xml</p></li><li class="lvl-3"><p>静态工厂的方式注入：通过调用静态工厂的方法来获取自己需要的对象，只支持xml。</p></li><li class="lvl-3"><p>实例工厂的方式注入：获取对象实例的方法不是静态的，所以需要new一个工厂类，再调用普通的实例方法，只支持xml。有两种实现方式：(1) 注解（@Autowired,@Resource,@Required）(2) 配置文件（xml）</p></li></ol><h3 id="❗Spring的循环依赖是什么？">❗Spring的循环依赖是什么？</h3><ol><li class="lvl-3"><p>使用context.getBean(A.class)，旨在获取容器内的单例A(若A不存在，就会走A这个Bean的创建流程)，显然初次获取A是不存在的，因此走A的创建之路~</p></li><li class="lvl-3"><p>实例化A（注意此处仅仅是实例化），并将它放进缓存（此时A已经实例化完成，已经可以被引用了）</p></li><li class="lvl-3"><p>初始化A：@Autowired依赖注入B（此时需要去容器内获取B）</p></li><li class="lvl-3"><p>为了完成依赖注入B，会通过getBean(B)去容器内找B。但此时B在容器内不存在，就走向B的创建之路~</p></li><li class="lvl-3"><p>实例化B，并将其放入缓存。（此时B也能够被引用了）</p></li><li class="lvl-3"><p>初始化B，@Autowired依赖注入A（此时需要去容器内获取A）</p></li><li class="lvl-3"><p>此处重要：初始化B时会调用getBean(A)去容器内找到A，上面我们已经说过了此时候因为A已经实例化完成了并且放进了缓存里，所以这个时候去看缓存里是已经存在A的引用了的，所以getBean(A)能够正常返回</p></li><li class="lvl-3"><p>B初始化成功（此时已经注入A成功了，已成功持有A的引用了），return（注意此处return相当于是返回最上面的getBean(B)这句代码，回到了初始化A的流程中~）。</p></li><li class="lvl-3"><p>因为B实例已经成功返回了，因此最终A也初始化成功</p></li><li class="lvl-4"><p>到此，B持有的已经是初始化完成的A，A持有的也是初始化完成的B，完美~</p></li></ol><h3 id="使用-Autowired注解自动装配的过程是怎样的？">使用@Autowired注解自动装配的过程是怎样的？</h3><p>使用@Autowired注解来自动装配指定的bean。在使用@Autowired注解之前需要在Spring配置文件进行配置，<code>&lt;context:annotation-config /&gt;。</code></p><p>在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性。在使用@Autowired时，首先在容器中查询对应类型的bean：</p><ul class="lvl-0"><li class="lvl-2"><p>如果查询结果刚好为一个，就将该bean装配给@Autowired指定的数据；</p></li><li class="lvl-2"><p>如果查询的结果不止一个，那么@Autowired会根据名称来查找；</p></li><li class="lvl-2"><p>如果上述查找的结果为空，那么会抛出异常。解决方法时，使用required=false。</p></li></ul><h2 id="❗Spring的事务实现原理，对于事物传播机制的理解。">❗Spring的事务实现原理，对于事物传播机制的理解。</h2><p>原理：<code>@Transactional</code> + AOP</p><ul class="lvl-0"><li class="lvl-2"><p>【常用】【默认】PROPAGATION_REQUIRED：如果当前没有事务，那就创建一个新事务，如果当前存在事务，那就加入该事务。</p></li><li class="lvl-2"><p>【常用】PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，那就以非事务执行。</p></li><li class="lvl-2"><p>PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛异常。</p></li><li class="lvl-2"><p>【场景】PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</p></li><li class="lvl-2"><p>PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p></li><li class="lvl-2"><p>PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，就抛异常。</p></li><li class="lvl-2"><p>【场景】PROPAGATION_NESTED：如果当前存在事务，就嵌套事务内执行，如果没有事务，就按REQUIRED属性执行。<strong>外层代码回滚，内层代码一起回滚；内层代码回滚，外层代码不一起回滚。</strong></p></li></ul><h3 id="说一下-spring-的事务隔离？">说一下 spring 的事务隔离？</h3><p>spring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：</p><ol><li class="lvl-3"><p>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</p></li><li class="lvl-3"><p>ISOLATION_READ_UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</p></li><li class="lvl-3"><p>ISOLATION_READ_COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</p></li><li class="lvl-3"><p>ISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</p></li><li class="lvl-3"><p>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。</p></li><li class="lvl-2"><p>不可重复读 ：是指在一个事务内，多次读同一数据。</p></li><li class="lvl-2"><p>幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所有数据行的记录就变多或者变少了。</p></li></ul><h2 id="画一张图说Spring的核心架构。">画一张图说Spring的核心架构。</h2><p>// todo<br>没有从源码层面讲解，这块需要后面补充。</p><h1>Spring MVC</h1><p><em>看了一下别的问题都是比较古老的问题。应该不会问到，暂时不记录。</em></p><h2 id="❗请描述Spring-MVC的工作流程？描述一下-DispatcherServlet-的工作流程？">❗请描述Spring MVC的工作流程？描述一下 DispatcherServlet 的工作流程？</h2><ol><li class="lvl-3"><p>用户发送请求至前端控制器DispatcherServlet；</p></li><li class="lvl-3"><p>DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle；</p></li><li class="lvl-3"><p>处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；</p></li><li class="lvl-3"><p>DispatcherServlet 调用 HandlerAdapter处理器适配器；</p></li><li class="lvl-3"><p>HandlerAdapter 经过适配调用 具体处理器(Handler，也叫后端控制器)；</p></li><li class="lvl-3"><p>Handler执行完成返回ModelAndView；</p></li><li class="lvl-3"><p>HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；</p></li><li class="lvl-3"><p>DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；</p></li><li class="lvl-3"><p>ViewResolver解析后返回具体View；</p></li><li class="lvl-4"><p>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）</p></li><li class="lvl-4"><p>DispatcherServlet响应用户。</p></li></ol><h1>Spring Boot</h1><h2 id="❗SringBoot的核心注解是哪个？它主要由哪几个注解组成？">❗SringBoot的核心注解是哪个？它主要由哪几个注解组成？</h2><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p><ul class="lvl-0"><li class="lvl-2"><p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</p></li><li class="lvl-2"><p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。</p></li><li class="lvl-2"><p>@ComponentScan：Spring组件扫描。</p></li></ul><h2 id="❗SpringBoot的工作原理-自动配置-SPI机制是怎么样子的？">❗SpringBoot的工作原理/自动配置/SPI机制是怎么样子的？</h2><p>SpringBoot使用的@SpringApplication注解，然后使用@EnableAutoConfiguration以及@ComponentScan自动装配，注解@EnableAutoConfiguration使用了@Import加载，使用@Import导入的类会被Spring加载到IOC容器中，最后使用了SpringFactoriesLoader反射出maven中META-INF下spring.factories，将反射的bean对象加载到Spring容器中（也就是SpringBoot的SPI机制）。</p><h2 id="Spring-Boot-是否可以使用-XML-配置">Spring Boot 是否可以使用 XML 配置 ?</h2><p>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。</p><h2 id="Spring-boot-核心配置文件是什么？bootstrap-properties-和-application-properties-有何区别">Spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?</h2><p>单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。<br>Spring boot 核心的两个配置文件：</p><ul class="lvl-0"><li class="lvl-2"><p>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。且 bootstrap 里面的属性不能被覆盖；</p></li><li class="lvl-2"><p>application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。</p></li></ul><h2 id="Spring-Boot的配置文件分类有哪几种？它们的优先级如何？">Spring Boot的配置文件分类有哪几种？它们的优先级如何？</h2><p>SpringBoot是基于约定的，所以很多配置都有默认值，但如果想使用自己的配置替换默认配置的话，就可以使用application.properties或者application.yml（application.yaml）进行配置。</p><p>默认配置文件名称：application</p><p><strong>在同一级目录下优先级为：properties&gt;yml &gt; yaml</strong></p><h2 id="Spring-Boot-打成的-jar-和普通的-jar-有什么区别">Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</h2><p>Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 java -jar xxx.jar 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。</p><p>Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在<code>\BOOT-INF\classes</code>目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。</p><h2 id="Spring-Boot-中如何实现定时任务">Spring Boot 中如何实现定时任务 ?</h2><p>定时任务也是一个常见的需求，Spring Boot 中对于定时任务的支持主要还是来自 Spring 框架。</p><p>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一个则是使用第三方框架 Quartz（/kwɔːts/）。</p><p>使用 Spring 中的 @Scheduled  （/'ʃedjuːld/）的方式主要通过 @Scheduled 注解来实现。</p><p>使用 Quartz ，则按照 Quartz 的方式，定义 Job 和 Trigger 即可。</p><p>如果是分布式定时任务，可以采用XXL-Job。</p><h2 id="❗画一张图说Spring-Boot的核心架构。">❗画一张图说Spring Boot的核心架构。</h2><p>Spring Boot本身是Spring项目发展到一定阶段后的产物。一开始是Spring框架，MyBatis，Spring MVC（SSM）做一些开发，打包部署到线上的tomcat。tomcat启动，接收http请求，转发给Spring MVC框架。</p><p>开发的时候还会去整合其他的一些框架（redis、elasticsearch、rabbitmq…）等东西。使用Spring Boot可以简化之前的开发流程，之前框架的整合流程比较繁琐。</p><p>Spring Boot内嵌的web服务器（比如tomcat）可以直接把写好的代码运行（减少部署tomcat）。</p><p>Spring Boot比较重要的一个是<strong>自动装配</strong>，引入stater的依赖，会一定程度上自动完成相应的配置和定义（原先需要手工配置xml配置文件，定义一些bean，写sql文件…）。</p><p>内链：[[SpringBoot启动流程.excalidraw]]<br>外链：<img                         lazyload                       alt="image"                       data-src="https://blog-resources.oss-cn-hangzhou.aliyuncs.com/240612/Snipaste_2024-06-12_22-30-28.png"                        alt=""                 ></p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
❗表示必掌握，❔表示基本不会问&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-10 初始记录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24-06-12 继续&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24-06-13 继续&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24-06-14 补充剩下的知识点。Spring这块的知识后续需要看书、看源码。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="八股文" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="面试" scheme="https://kiml.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="八股文" scheme="https://kiml.github.io/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    <category term="Spring" scheme="https://kiml.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第二十二天-216组合总和III、17电话号码的字母组合</title>
    <link href="https://kiml.github.io/posts/82bed832/"/>
    <id>https://kiml.github.io/posts/82bed832/</id>
    <published>2024-06-10T06:53:08.000Z</published>
    <updated>2024-06-12T13:02:15.355Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：216可以AC。17看了部分解析写出来的。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-10 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="216组合总和III">216组合总和III</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/combination-sum-iii" >https://leetcode.cn/problems/combination-sum-iii<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LE22</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; combinationSum3 = combinationSum3(<span class="number">9</span>, <span class="number">45</span>);  </span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; integerList : combinationSum3) &#123;  </span><br><span class="line">            System.out.println(Arrays.toString(integerList.stream().mapToInt(n -&gt; n).toArray()));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;  </span><br><span class="line">        <span class="comment">// 结果集  </span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">        <span class="comment">// 单个结果  </span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">        combinationSum(<span class="number">1</span>, k, n, <span class="number">0</span>, list, result);  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> sum, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;  </span><br><span class="line">        <span class="comment">// 剪枝操作  </span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; n) &#123;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (list.size() == k) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (sum == n) &#123;  </span><br><span class="line">                List&lt;Integer&gt; resultOne = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);  </span><br><span class="line">                result.add(resultOne);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> start; j &lt;= <span class="number">9</span> - (k - list.size()) + <span class="number">1</span>; j++) &#123;  </span><br><span class="line">            list.add(j);  </span><br><span class="line">            combinationSum(j + <span class="number">1</span>, k, n, sum + j, list, result);  </span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17电话号码的字母组合">17电话号码的字母组合</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number" >https://leetcode.cn/problems/letter-combinations-of-a-phone-number<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> digits 按键数组  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;  </span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    String[] buttonList = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (digits == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(digits)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> list;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    combinations(<span class="number">0</span>, digits, buttonList, <span class="string">&quot;&quot;</span>, list);  </span><br><span class="line">    <span class="keyword">return</span> list;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * * <span class="doctag">@param</span> i 遍历的层数  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">combinations</span><span class="params">(<span class="type">int</span> i, String digits, String[] buttonList, String str, List&lt;String&gt; list)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (i == digits.length()) &#123;  </span><br><span class="line">        list.add(str);  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> Integer.parseInt(digits.charAt(i) + <span class="string">&quot;&quot;</span>);  </span><br><span class="line">    <span class="type">String</span> <span class="variable">letter</span> <span class="operator">=</span> buttonList[digit];  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; letter.length(); j++) &#123;  </span><br><span class="line">        str+=letter.charAt(j);  </span><br><span class="line">        combinations(i + <span class="number">1</span>, digits, buttonList, str, list);  </span><br><span class="line">        str = str.substring(<span class="number">0</span>, str.length() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看解析</h1><h2 id="216组合总和III-2">216组合总和III</h2><p>题目链接/文章讲解：(<a class="link"   href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html" >https://programmercarl.com/0216.组合总和III.html<i class="fas fa-external-link-alt"></i></a>)</p><p>视频讲解：<a class="link"   href="https://www.bilibili.com/video/BV1wg411873x" >https://www.bilibili.com/video/BV1wg411873x<i class="fas fa-external-link-alt"></i></a></p><h2 id="17电话号码的字母组合-2">17电话号码的字母组合</h2><p>题目链接/文章讲解：(<a class="link"   href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html" >https://programmercarl.com/0017.电话号码的字母组合.html<i class="fas fa-external-link-alt"></i></a>)</p><p>视频讲解：<a class="link"   href="https://www.bilibili.com/video/BV1yV4y1V7Ug" >https://www.bilibili.com/video/BV1yV4y1V7Ug<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：216可以AC。17看了部分解析写出来的。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-10 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="回溯算法" scheme="https://kiml.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第二十一天-理论基础、77组合</title>
    <link href="https://kiml.github.io/posts/ff56c28f/"/>
    <id>https://kiml.github.io/posts/ff56c28f/</id>
    <published>2024-06-10T01:33:43.000Z</published>
    <updated>2024-06-12T09:58:33.229Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：理论基础总结在[[面试-数据结构和算法]]中。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-05-10 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="77组合">77组合</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/combinations/" >https://leetcode.cn/problems/combinations/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;  </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    combineDFS(<span class="number">1</span>, n, k, list, result);  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * * <span class="doctag">@param</span> start 当前开始节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n n  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k k  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list 每个list  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> result 最后的结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">combineDFS</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> n, <span class="type">int</span> k, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (list.size() == k) &#123;  </span><br><span class="line">        List&lt;Integer&gt; resultOne = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(k);  </span><br><span class="line">        resultOne.addAll(list);  </span><br><span class="line">        result.add(resultOne);  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> start; j &lt;= n; j++) &#123;  </span><br><span class="line">        list.add(j);  </span><br><span class="line">        combineDFS(j + <span class="number">1</span>, n, k, list, result);  </span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看解析</h1><h2 id="77组合-2">77组合</h2><p>题目链接/文章讲解：<a class="link"   href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html" >https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html<i class="fas fa-external-link-alt"></i></a></p><p>视频讲解：<a class="link"   href="https://www.bilibili.com/video/BV1ti4y1L7cv" >https://www.bilibili.com/video/BV1ti4y1L7cv<i class="fas fa-external-link-alt"></i></a></p><p>剪枝操作：<a class="link"   href="https://www.bilibili.com/video/BV1wi4y157er" >https://www.bilibili.com/video/BV1wi4y157er<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;  </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    combineDFS(<span class="number">1</span>, n, k, list, result);  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * * <span class="doctag">@param</span> start 当前开始节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n n  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k k  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list 每个list  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> result 最后的结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">combineDFS</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> n, <span class="type">int</span> k, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (list.size() == k) &#123;  </span><br><span class="line">        List&lt;Integer&gt; resultOne = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(k);  </span><br><span class="line">        resultOne.addAll(list);  </span><br><span class="line">        result.add(resultOne);  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 附带剪枝操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> start; j &lt;= (n - (k - list.size())) + <span class="number">1</span>; j++) &#123;  </span><br><span class="line">        list.add(j);  </span><br><span class="line">        combineDFS(j + <span class="number">1</span>, n, k, list, result);  </span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：理论基础总结在[[面试-数据结构和算法]]中。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-05-10 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="回溯算法" scheme="https://kiml.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第二十天-669修剪二叉搜索树、108将有序数组转换为二叉搜索树、538把二叉搜索树转换为累加树</title>
    <link href="https://kiml.github.io/posts/d99de55b/"/>
    <id>https://kiml.github.io/posts/d99de55b/</id>
    <published>2024-06-09T07:54:48.000Z</published>
    <updated>2024-06-12T09:57:53.790Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：669通过，但是有更简单的方法。108AC。538没有思路，看了解题思路写出来了。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-09 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="669修剪二叉搜索树">669修剪二叉搜索树</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/trim-a-binary-search-tree" >https://leetcode.cn/problems/trim-a-binary-search-tree<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 思路：查找节点，删除节点</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> low  区间左范围</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> high 区间右范围</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先剪枝</span></span><br><span class="line">        cut(root, low, high);</span><br><span class="line">        <span class="comment">// 再减单个</span></span><br><span class="line">        <span class="keyword">return</span> travel(root, low, high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TreeNode <span class="title function_">travel</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (low &lt;= root.val &amp;&amp; root.val &lt;= high) &#123;</span><br><span class="line">            root.left = travel(root.left, low, high);</span><br><span class="line">            root.right = travel(root.right, low, high);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 删除这个节点</span></span><br><span class="line">                <span class="comment">// 1.右子树补位(找到右子树的最左侧节点)</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root.right;</span><br><span class="line">                <span class="keyword">while</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125;</span><br><span class="line">                cur.left = root.left;</span><br><span class="line">                root = root.right;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root.left = travel(root.left, low, high);</span><br><span class="line">        root.right = travel(root.right, low, high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">cut</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 整条剪掉</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; high) &#123;</span><br><span class="line">            root.right = <span class="literal">null</span>;</span><br><span class="line">            root.left = trimBST(root.left, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; low) &#123;</span><br><span class="line">            root.left = <span class="literal">null</span>;</span><br><span class="line">            root.right = trimBST(root.right, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        cut(root.left, low, high);</span><br><span class="line">        cut(root.right, low, high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为时间复杂度太高，后面又写了一个版本，但是这个版本AC不了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> root;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; high) &#123;  </span><br><span class="line"><span class="keyword">return</span> root.left;  </span><br><span class="line">            <span class="comment">// return trimBST(root.left, low, high);  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; low) &#123;  </span><br><span class="line">            <span class="comment">// 继续向右遍历  </span></span><br><span class="line"><span class="keyword">return</span> root.right;  </span><br><span class="line">            <span class="comment">// return trimBST(root.right, low, high);  </span></span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (low &lt;= root.val &amp;&amp; root.val &lt;= high) &#123;  </span><br><span class="line">            root.left = trimBST(root.left, low, high);  </span><br><span class="line">            root.right = trimBST(root.right, low, high);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span> &amp;&amp; (root.val &lt; low || root.val &gt; high)) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;  </span><br><span class="line">                root = root.right;  </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="literal">null</span>) &#123;  </span><br><span class="line">                root = root.left;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="comment">// 删除这个节点  </span></span><br><span class="line">                <span class="comment">// 1.右子树补位(找到右子树的最左侧节点)  </span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root.right;  </span><br><span class="line">                <span class="keyword">while</span> (cur.left != <span class="literal">null</span>) &#123;  </span><br><span class="line">                    cur = cur.left;  </span><br><span class="line">                &#125;  </span><br><span class="line">                cur.left = root.left;  </span><br><span class="line">                root = root.right;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> root;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="108将有序数组转换为二叉搜索树">108将有序数组转换为二叉搜索树</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/" >https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> sortedDFS(nums, <span class="number">0</span>, nums.length);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> TreeNode <span class="title function_">sortedDFS</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (i &gt;= j) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (j - i) / <span class="number">2</span> + i;  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">treeNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);  </span><br><span class="line">    treeNode.left = sortedDFS(nums, i, mid);  </span><br><span class="line">    treeNode.right = sortedDFS(nums , mid + <span class="number">1</span>, j);  </span><br><span class="line">    <span class="keyword">return</span> treeNode;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="538把二叉搜索树转换为累加树">538把二叉搜索树转换为累加树</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/convert-bst-to-greater-tree" >https://leetcode.cn/problems/convert-bst-to-greater-tree<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 看了题解之后写出来的  </span></span><br><span class="line"><span class="comment"> * 思路：  </span></span><br><span class="line"><span class="comment"> * 1.二叉搜索树，中序遍历（左中右）有序  </span></span><br><span class="line"><span class="comment"> * 2.要按倒序相加，遍历方向相反  </span></span><br><span class="line"><span class="comment"> * 3.取一个指针指向前节点不断累加  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">0</span>);  </span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    getTreeNodeTravel(root);  </span><br><span class="line">    <span class="keyword">return</span> root;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getTreeNodeTravel</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    getTreeNodeTravel(root.right);  </span><br><span class="line">  </span><br><span class="line">    root.val = pre.val + root.val;  </span><br><span class="line">    pre = root;  </span><br><span class="line">    getTreeNodeTravel(root.left);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看解析</h1><h2 id="669修剪二叉搜索树-2">669修剪二叉搜索树</h2><p>题目链接/文章讲解： <a class="link"   href="https://programmercarl.com/0669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html" >https://programmercarl.com/0669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html<i class="fas fa-external-link-alt"></i></a></p><p>视频讲解： [<a class="link"   href="https://www.bilibili.com/video/BV17P41177ud" >https://www.bilibili.com/video/BV17P41177ud<i class="fas fa-external-link-alt"></i></a>](<a class="link"   href="https://www.bilibili.com/video/BV17P41177ud" >https://www.bilibili.com/video/BV17P41177ud<i class="fas fa-external-link-alt"></i></a></p><p>看了题解发现是下面两行导致不能AC。这里不能直接剪掉，忽略了情况。并且用了下面的继续递归，就不用再删除节点了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.val &gt; high) &#123;  </span><br><span class="line"><span class="keyword">return</span> root.left;  </span><br><span class="line">    <span class="comment">// return trimBST(root.left, low, high);  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span> (root.val &lt; low) &#123;  </span><br><span class="line">    <span class="comment">// 继续向右遍历  </span></span><br><span class="line"><span class="keyword">return</span> root.right;  </span><br><span class="line">    <span class="comment">// return trimBST(root.right, low, high);  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>正确方法</strong>（🥴好难）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> root;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; high) &#123;  </span><br><span class="line">        <span class="keyword">return</span> trimBST(root.left, low, high);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; low) &#123;   </span><br><span class="line">        <span class="keyword">return</span> trimBST(root.right, low, high);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (low &lt;= root.val &amp;&amp; root.val &lt;= high) &#123;  </span><br><span class="line">        root.left = trimBST(root.left, low, high);  </span><br><span class="line">        root.right = trimBST(root.right, low, high);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> root;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="108将有序数组转换为二叉搜索树-2">108将有序数组转换为二叉搜索树</h2><p>题目链接/文章讲解： <a class="link"   href="https://programmercarl.com/0108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html" >https://programmercarl.com/0108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html<i class="fas fa-external-link-alt"></i></a></p><p>视频讲解：[<a class="link"   href="https://www.bilibili.com/video/BV1uR4y1X7qL" >https://www.bilibili.com/video/BV1uR4y1X7qL<i class="fas fa-external-link-alt"></i></a>](<a class="link"   href="https://www.bilibili.com/video/BV1uR4y1X7qL" >https://www.bilibili.com/video/BV1uR4y1X7qL<i class="fas fa-external-link-alt"></i></a></p><h2 id="538把二叉搜索树转换为累加树-2">538把二叉搜索树转换为累加树</h2><p>题目链接/文章讲解： <a class="link"   href="https://programmercarl.com/0538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html" >https://programmercarl.com/0538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html<i class="fas fa-external-link-alt"></i></a></p><p>视频讲解：<a class="link"   href="https://www.bilibili.com/video/BV1d44y1f7wP" >https://www.bilibili.com/video/BV1d44y1f7wP<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：669通过，但是有更简单的方法。108AC。538没有思路，看了解题思路写出来了。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-09 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="二叉树" scheme="https://kiml.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="二叉搜索树" scheme="https://kiml.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
    <category term="累加树" scheme="https://kiml.github.io/tags/%E7%B4%AF%E5%8A%A0%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第十九天-235二叉搜索树的最近公共祖先、701二叉搜索树中的插入操作、450删除二叉搜索树中的节点</title>
    <link href="https://kiml.github.io/posts/49e785ab/"/>
    <id>https://kiml.github.io/posts/49e785ab/</id>
    <published>2024-06-09T01:30:05.000Z</published>
    <updated>2024-06-12T06:35:27.094Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：235、701AC，701还有更简单的写法。450通过失败。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-09 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="235二叉搜索树的最近公共祖先">235二叉搜索树的最近公共祖先</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree" >https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree<i class="fas fa-external-link-alt"></i></a>)</p><p>看了一部分的解析。主要在于<strong>当我们从上向下去递归遍历，第一次遇到 cur节点是数值在<code>[q, p]</code>区间中，那么cur就是 q和p的最近公共祖先。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (p.val &lt; q.val) &#123;  </span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestorTravel(root, p, q);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestorTravel(root, q, p);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">lowestCommonAncestorTravel</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || (p.val &lt;= root.val &amp;&amp; root.val &lt;= q.val)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> root;  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; q.val) &#123;  </span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="701二叉搜索树中的插入操作">701二叉搜索树中的插入操作</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/" >https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用双指针</span></span><br><span class="line">TreeNode pre;  </span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (pre.val &gt; val)&#123;  </span><br><span class="line">                pre.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);  </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre.val &lt; val) &#123;  </span><br><span class="line">                pre.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> root;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    pre = root;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; val) &#123;  </span><br><span class="line">        insertIntoBST(root.left, val);  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; val) &#123;  </span><br><span class="line">        insertIntoBST(root.right, val);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> root;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="450删除二叉搜索树中的节点">450删除二叉搜索树中的节点</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/delete-node-in-a-bst" >https://leetcode.cn/problems/delete-node-in-a-bst<i class="fas fa-external-link-alt"></i></a>)</p><p>想的是左子树顶位子的情况。看了解析用了右子树顶位，好像确实好理解一点。（包括讲解中的普通二叉树删除，也是用了右子树顶位）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样子用例85不能通过</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;  </span><br><span class="line">    <span class="comment">// 为空直接返回  </span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> root;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root.val == key) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;  </span><br><span class="line">            root = root.right;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="literal">null</span>) &#123;  </span><br><span class="line">            root = root.left;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">// 应该是这里写得不对</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> root.right;  </span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">leftRight</span> <span class="operator">=</span> root.left.right;  </span><br><span class="line">            root = root.left;  </span><br><span class="line">            <span class="keyword">if</span> (leftRight != <span class="literal">null</span>) &#123;  </span><br><span class="line">                root.right = leftRight;  </span><br><span class="line">                root.right.right = right;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                root.right = right;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> root;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; key) &#123;  </span><br><span class="line">        root.left = deleteNode(root.left, key);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        root.right = deleteNode(root.right, key);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> root;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看解析</h1><h2 id="235二叉搜索树的最近公共祖先-2">235二叉搜索树的最近公共祖先</h2><p>题目链接/文章讲解：<a class="link"   href="https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html" >https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html<i class="fas fa-external-link-alt"></i></a></p><p>视频讲解：[<a class="link"   href="https://www.bilibili.com/video/BV1Zt4y1F7ww" >https://www.bilibili.com/video/BV1Zt4y1F7ww<i class="fas fa-external-link-alt"></i></a>](<a class="link"   href="https://www.bilibili.com/video/BV1Zt4y1F7ww" >https://www.bilibili.com/video/BV1Zt4y1F7ww<i class="fas fa-external-link-alt"></i></a></p><h2 id="701二叉搜索树中的插入操作-2">701二叉搜索树中的插入操作</h2><p>题目链接/文章讲解：<a class="link"   href="https://programmercarl.com/0701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html" >https://programmercarl.com/0701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html<i class="fas fa-external-link-alt"></i></a></p><p>视频讲解：<a class="link"   href="https://www.bilibili.com/video/BV1Et4y1c78Y" >https://www.bilibili.com/video/BV1Et4y1c78Y<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文章中给的简化版本，确实这样子思路更清晰了</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="comment">// 如果当前节点为空，也就意味着val找到了合适的位置，此时创建节点直接返回。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; val)&#123;</span><br><span class="line">            root.right = insertIntoBST(root.right, val); <span class="comment">// 递归创建右子树</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; val)&#123;</span><br><span class="line">            root.left = insertIntoBST(root.left, val); <span class="comment">// 递归创建左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="450删除二叉搜索树中的节点-2">450删除二叉搜索树中的节点</h2><p>题目链接/文章讲解：<a class="link"   href="https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html" >https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html<i class="fas fa-external-link-alt"></i></a></p><p>视频讲解：<a class="link"   href="https://www.bilibili.com/video/BV1tP41177us" >https://www.bilibili.com/video/BV1tP41177us<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">  <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> root.right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> root.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 只有这部分不一样</span></span><br><span class="line">      <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root.right;</span><br><span class="line">      <span class="keyword">while</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        cur = cur.left;</span><br><span class="line">      &#125;</span><br><span class="line">      cur.left = root.left;</span><br><span class="line">      root = root.right;</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (root.val &gt; key) root.left = deleteNode(root.left, key);</span><br><span class="line">  <span class="keyword">if</span> (root.val &lt; key) root.right = deleteNode(root.right, key);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：235、701AC，701还有更简单的写法。450通过失败。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-09 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="二叉树" scheme="https://kiml.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="二叉搜索树" scheme="https://kiml.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode与本地结果不一致问题</title>
    <link href="https://kiml.github.io/posts/f9d0f046/"/>
    <id>https://kiml.github.io/posts/f9d0f046/</id>
    <published>2024-06-08T02:50:13.000Z</published>
    <updated>2024-06-12T06:35:27.070Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>参考文章：<a class="link"   href="https://www.jianshu.com/p/2e8f7621953d" >Leetcode与本地结果不一致问题解决及分析<i class="fas fa-external-link-alt"></i></a></p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.06.08 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>问题</h1><p>Leetcode提交的代码，测试用例不通过。想在本地调式查看，但是本地是没有问题的。</p><h1>原因</h1><p>本地在main方法中直接调试，部分全局变量使用了<code>static</code>关键字，Leetcode只加载了一次Solution类。导致全局变量没有恢复初始值。</p><h1>解决</h1><p>全部变量再提交到Leetcode时，手动删除<code>static</code>关键字。</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
参考文章：&lt;a class=&quot;link&quot;   href=&quot;https://www.jianshu.com/p/2e8f7621953d&quot; &gt;Leetcode与本地结果不一致问题解决及分析&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.06.08 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="bug记录" scheme="https://kiml.github.io/categories/bug%E8%AE%B0%E5%BD%95/"/>
    
    <category term="2024" scheme="https://kiml.github.io/categories/bug%E8%AE%B0%E5%BD%95/2024/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第十八天-530二叉搜索树的最小绝对差、501二叉搜索树中的众数、236二叉树的最近公共祖先</title>
    <link href="https://kiml.github.io/posts/47cc7c82/"/>
    <id>https://kiml.github.io/posts/47cc7c82/</id>
    <published>2024-06-08T01:02:07.000Z</published>
    <updated>2024-06-12T06:35:27.093Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：530暴力遍历、501暴力、236不会。看了昨天的题解把530改成了双指针。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.06.08 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="530二叉搜索树的最小绝对差">530二叉搜索树的最小绝对差</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst" >https://leetcode.cn/problems/minimum-absolute-difference-in-bst<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    getMinDiff(root, list);  </span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.abs(list.get(<span class="number">0</span>) - list.get(<span class="number">1</span>));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; list.size(); i++) &#123;  </span><br><span class="line">        min = Math.min(Math.abs(list.get(i) - list.get(i - <span class="number">1</span>)), min);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> min;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getMinDiff</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    getMinDiff(root.left, list);  </span><br><span class="line">    list.add(root.val);  </span><br><span class="line">    getMinDiff(root.right, list);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后面看了昨天最后一题的题解，这里可以用双指针</span></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 双指针的解法  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="type">Integer</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;  </span><br><span class="line">TreeNode pre;  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference1</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> min;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    getMinimumDifference1(root.left);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 中间遍历  </span></span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">null</span>) &#123;  </span><br><span class="line">        min = Math.min(Math.abs(root.val - pre.val), min);  </span><br><span class="line">    &#125;  </span><br><span class="line">    pre = root;  </span><br><span class="line">  </span><br><span class="line">    getMinimumDifference1(root.right);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> min;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="501二叉搜索树中的众数">501二叉搜索树中的众数</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/find-mode-in-binary-search-tree" >https://leetcode.cn/problems/find-mode-in-binary-search-tree<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">    find(root, map);  </span><br><span class="line">    List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; collect = map.entrySet().stream()  </span><br><span class="line">            .sorted((o1, o2) -&gt; o2.getValue() - o1.getValue())  </span><br><span class="line">            .collect(Collectors.toList());  </span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    list.add(collect.get(<span class="number">0</span>).getKey());  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; collect.size(); i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (collect.get(i).getValue().equals(collect.get(<span class="number">0</span>).getValue())) &#123;  </span><br><span class="line">            list.add(collect.get(i).getKey());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> list.stream().mapToInt(i -&gt; i).toArray();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(TreeNode root, Map&lt;Integer, Integer&gt; map)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    find(root.left, map);  </span><br><span class="line">    map.put(root.val, map.getOrDefault(root.val, <span class="number">0</span>) + <span class="number">1</span>);  </span><br><span class="line">    find(root.right, map);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="236二叉树的最近公共祖先">236二叉树的最近公共祖先</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree" >https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree<i class="fas fa-external-link-alt"></i></a>)</p><p>没有思路。</p><h1>看解析</h1><h2 id="530二叉搜索树的最小绝对差-2">530二叉搜索树的最小绝对差</h2><p>题目链接/文章讲解：<a class="link"   href="https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html" >https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html<i class="fas fa-external-link-alt"></i></a></p><p>视频讲解：<a class="link"   href="https://www.bilibili.com/video/BV1DD4y11779" >https://www.bilibili.com/video/BV1DD4y11779<i class="fas fa-external-link-alt"></i></a></p><h2 id="501二叉搜索树中的众数-2">501二叉搜索树中的众数</h2><p>题目链接/文章讲解：<a class="link"   href="https://programmercarl.com/0501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.html" >https://programmercarl.com/0501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.html<i class="fas fa-external-link-alt"></i></a></p><p>视频讲解：<a class="link"   href="https://www.bilibili.com/video/BV1fD4y117gp" >https://www.bilibili.com/video/BV1fD4y117gp<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双指针的前一个节点  </span></span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line"><span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 双指针解法  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;  </span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 递归逻辑  </span></span><br><span class="line">    findModeTravel(root, list);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> list.stream().mapToInt(i -&gt; i).toArray();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findModeTravel</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    findModeTravel(root.left, list);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="literal">null</span>) &#123;  </span><br><span class="line">        count = <span class="number">1</span>;  </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pre.val == root.val)&#123;  </span><br><span class="line">        count++;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        count = <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    pre = root;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (count == maxCount) &#123;  </span><br><span class="line">        list.add(root.val);  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; maxCount) &#123;  </span><br><span class="line">        maxCount = count;  </span><br><span class="line">        list.clear();  </span><br><span class="line">        list.add(root.val);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    findModeTravel(root.right, list);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="236二叉树的最近公共祖先-2">236二叉树的最近公共祖先</h2><p>题目链接/文章讲解：<a class="link"   href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html" >https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html<i class="fas fa-external-link-alt"></i></a></p><p>视频讲解：<a class="link"   href="https://www.bilibili.com/video/BV1jd4y1B7E2" >https://www.bilibili.com/video/BV1jd4y1B7E2<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;  </span><br><span class="line">    <span class="comment">// return root也是空 可以和下面一起写  </span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (root == p || root == q) &#123;  </span><br><span class="line">        <span class="keyword">return</span> root;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (left!= <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> root;  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> left;  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right != <span class="literal">null</span> &amp;&amp; left == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> right;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：530暴力遍历、501暴力、236不会。看了昨天的题解把530改成了双指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.06.08 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="双指针" scheme="https://kiml.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="二叉树" scheme="https://kiml.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="二叉搜索树" scheme="https://kiml.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第十七天-654最大二叉树、617合并二叉树、700二叉搜索树中的搜索、98验证二叉搜索树</title>
    <link href="https://kiml.github.io/posts/c463689e/"/>
    <id>https://kiml.github.io/posts/c463689e/</id>
    <published>2024-06-07T08:56:26.000Z</published>
    <updated>2024-06-12T06:35:27.093Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：654AC、617AC可优化、700AC、98不会</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.06.07 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="654最大二叉树">654最大二叉树</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/maximum-binary-tree/" >https://leetcode.cn/problems/maximum-binary-tree/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> getMaxIndex(nums);  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[maxIndex]);  </span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> root;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    root.left = constructMaximumBinaryTree(Arrays.copyOfRange(nums, <span class="number">0</span>, maxIndex));  </span><br><span class="line">    root.right = constructMaximumBinaryTree(Arrays.copyOfRange(nums, maxIndex + <span class="number">1</span>, nums.length));  </span><br><span class="line">    <span class="keyword">return</span> root;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMaxIndex</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> -<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; max) &#123;  </span><br><span class="line">            maxIndex = i;  </span><br><span class="line">            max = nums[i];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> maxIndex;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="617合并二叉树">617合并二叉树</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/merge-two-binary-trees/" >https://leetcode.cn/problems/merge-two-binary-trees/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">value1</span> <span class="operator">=</span> root1 == <span class="literal">null</span> ? <span class="number">0</span> : root1.val;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">value2</span> <span class="operator">=</span> root2 == <span class="literal">null</span> ? <span class="number">0</span> : root2.val;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(value1 + value2);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">null</span>) &#123;  </span><br><span class="line">        node.left = mergeTrees(<span class="literal">null</span>, root2.left);  </span><br><span class="line">        node.right = mergeTrees(<span class="literal">null</span>, root2.right);  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root2 == <span class="literal">null</span>)&#123;  </span><br><span class="line">        node.left = mergeTrees(root1.left, <span class="literal">null</span>);  </span><br><span class="line">        node.right = mergeTrees(root1.right, <span class="literal">null</span>);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        node.left = mergeTrees(root1.left, root2.left);  </span><br><span class="line">        node.right = mergeTrees(root1.right, root2.right);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> node;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="700二叉搜索树中的搜索">700二叉搜索树中的搜索</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/search-in-a-binary-search-tree" >https://leetcode.cn/problems/search-in-a-binary-search-tree<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * BFS </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (val == root.val) &#123;  </span><br><span class="line">        <span class="keyword">return</span> root;  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root.val) &#123;  </span><br><span class="line">        <span class="keyword">return</span> searchBST(root.left, val);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> searchBST(root.right, val);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * DFS </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> TreeNode <span class="title function_">searchBSTDFS</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;  </span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (val == root.val) &#123;  </span><br><span class="line">            <span class="keyword">return</span> root;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root.val)&#123;  </span><br><span class="line">            root = root.left;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            root = root.right;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="98验证二叉搜索树">98验证二叉搜索树</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/validate-binary-search-tree/" >https://leetcode.cn/problems/validate-binary-search-tree/<i class="fas fa-external-link-alt"></i></a>)</p><p>只比较了<strong>左节点小于中间节点，右节点大于中间节点</strong>，实际上要加上<strong>左子树所有节点小于中间节点，右子树所有节点大于中间节点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有通过，少算了一种情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 左子树不为空并且大于  </span></span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.left.val &gt;= root.val) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        <span class="comment">// 右子树不为空并且小于  </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.right != <span class="literal">null</span> &amp;&amp; root.right.val &lt;= root.val) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left) &amp;&amp; isValidBST(root.right);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看解析</h1><h2 id="654最大二叉树-2">654最大二叉树</h2><p>题目链接/文章讲解：(<a class="link"   href="https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html" >https://programmercarl.com/0654.最大二叉树.html<i class="fas fa-external-link-alt"></i></a>)</p><p>视频讲解：<a class="link"   href="https://www.bilibili.com/video/BV1MG411G7ox" >https://www.bilibili.com/video/BV1MG411G7ox<i class="fas fa-external-link-alt"></i></a></p><h2 id="617合并二叉树-2">617合并二叉树</h2><p>题目链接/文章讲解：(<a class="link"   href="https://programmercarl.com/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html" >https://programmercarl.com/0617.合并二叉树.html<i class="fas fa-external-link-alt"></i></a>)</p><p>视频讲解：<a class="link"   href="https://www.bilibili.com/video/BV1m14y1Y7JK" >https://www.bilibili.com/video/BV1m14y1Y7JK<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化后</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees1</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">null</span> &amp;&amp; root2 != <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> root2;  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root1 != <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> root1;  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root1.val + root2.val);  </span><br><span class="line">        node.left = mergeTrees(root1.left, root2.left);  </span><br><span class="line">        node.right = mergeTrees(root1.right, root2.right);  </span><br><span class="line">        <span class="keyword">return</span> node;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="700二叉搜索树中的搜索-2">700二叉搜索树中的搜索</h2><p>题目链接/文章讲解：(<a class="link"   href="https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html" >https://programmercarl.com/0700.二叉搜索树中的搜索.html<i class="fas fa-external-link-alt"></i></a>)</p><p>视频讲解：<a class="link"   href="https://www.bilibili.com/video/BV1wG411g7sF" >https://www.bilibili.com/video/BV1wG411g7sF<i class="fas fa-external-link-alt"></i></a></p><p>二叉搜索树是一个有序树：</p><ul class="lvl-0"><li class="lvl-2"><p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p></li><li class="lvl-2"><p>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p></li><li class="lvl-2"><p>它的左、右子树也分别为二叉搜索树</p></li></ul><h2 id="98验证二叉搜索树-2">98验证二叉搜索树</h2><p>题目链接/文章讲解：(<a class="link"   href="https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html" >https://programmercarl.com/0098.验证二叉搜索树.html<i class="fas fa-external-link-alt"></i></a>)</p><p>视频讲解：<a class="link"   href="https://www.bilibili.com/video/BV18P411n7Q4" >https://www.bilibili.com/video/BV18P411n7Q4<i class="fas fa-external-link-alt"></i></a></p><p>关键在于：<strong>中序遍历下，输出的二叉搜索树节点的数值是有序序列。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    inorder(root, list);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (list.size() &lt;= <span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size() - <span class="number">1</span>; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (list.get(i) &gt;= list.get(i + <span class="number">1</span>)) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    inorder(root.left, list);  </span><br><span class="line">    list.add(root.val);  </span><br><span class="line">    inorder(root.right, list);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 单次循环搞定</span></span><br><span class="line"><span class="comment"> * 双指针法</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">TreeNode max;  </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST1</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 左  </span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> isValidBST1(root.left);  </span><br><span class="line">    <span class="keyword">if</span> (!left) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 中  </span></span><br><span class="line">    <span class="keyword">if</span> (max != <span class="literal">null</span> &amp;&amp; root.val &lt;= max.val) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    max = root;  </span><br><span class="line">    <span class="comment">// 右  </span></span><br><span class="line">    <span class="keyword">return</span> isValidBST1(root.right);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：654AC、617AC可优化、700AC、98不会&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.06.07 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="双指针" scheme="https://kiml.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="二叉树" scheme="https://kiml.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="二叉搜索树" scheme="https://kiml.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第十六天-513找树左下角的值、112路径总和、113路径总和ii、106从中序与后序遍历序列构造二叉树、105从前序与中序遍历序列构造二叉树</title>
    <link href="https://kiml.github.io/posts/2305b4a/"/>
    <id>https://kiml.github.io/posts/2305b4a/</id>
    <published>2024-06-07T01:10:00.000Z</published>
    <updated>2024-06-12T06:35:27.091Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：513用层序AC、112AC（但时间复杂度较高））（解析中给的方法和想的不一样），113AC、106不会</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.06.07 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="513找树左下角的值">513找树左下角的值</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/find-bottom-left-tree-value" >https://leetcode.cn/problems/find-bottom-left-tree-value<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 看题目感觉层序遍历简单一点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    findBottomDFS(root, <span class="number">0</span>, list);  </span><br><span class="line">    List&lt;Integer&gt; theLastLayer = list.get(list.size() - <span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">return</span> theLastLayer.stream().filter(Objects::nonNull).collect(Collectors.toList()).get(<span class="number">0</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findBottomDFS</span><span class="params">(TreeNode root, <span class="type">int</span> i, List&lt;List&lt;Integer&gt;&gt; list)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 深度增加  </span></span><br><span class="line">    i++;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (list.size() &lt; i) &#123;  </span><br><span class="line">        ArrayList&lt;Integer&gt; innerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">        list.add(innerList);  </span><br><span class="line">    &#125;  </span><br><span class="line">    list.get(i - <span class="number">1</span>).add(root.val);  </span><br><span class="line">  </span><br><span class="line">    findBottomDFS(root.left, i, list);  </span><br><span class="line">    findBottomDFS(root.right, i, list);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="112路径总和、113路径总和ii">112路径总和、113路径总和ii</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/path-sum/description/" >https://leetcode.cn/problems/path-sum/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 感觉之前做过求路径的题（递归+迭代）这题应该变换一下  </span></span><br><span class="line"><span class="comment"> * 时间复杂度好像有点高，剩下那题等看完解析后再写</span></span><br><span class="line"><span class="comment"> * 后面改用sum直接加减不遍历求总和，但是leetcode不通过，本地倒是测试没问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetSum 目标和  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();  </span><br><span class="line">    <span class="keyword">return</span> hasPathSumBFS(root, list, targetSum);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasPathSumBFS</span><span class="params">(TreeNode root, List&lt;Integer&gt; list, <span class="type">int</span> targetSum)</span> &#123;  </span><br><span class="line">    list.add(root.val);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="comment">// 求list中的总和  </span></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> list.stream().collect(Collectors.summarizingInt(value -&gt; value)).getSum();  </span><br><span class="line">        <span class="keyword">return</span> sum == targetSum;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> <span class="literal">false</span>;  </span><br><span class="line">    <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> <span class="literal">false</span>;  </span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;  </span><br><span class="line">        left = hasPathSumBFS(root.left, list, targetSum);  </span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;  </span><br><span class="line">        right = hasPathSumBFS(root.right, list, targetSum);  </span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> left || right;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/path-sum-ii/" >https://leetcode.cn/problems/path-sum-ii/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;  </span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    pathSumBFS(root, targetSum, result, list);  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">pathSumBFS</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum, List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; list)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    targetSum -= root.val;  </span><br><span class="line">    list.add(root.val);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (targetSum == <span class="number">0</span>) &#123;  </span><br><span class="line">            List&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);  </span><br><span class="line">            result.add(arrayList);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;  </span><br><span class="line">        pathSumBFS(root.left, targetSum, result, list);  </span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;  </span><br><span class="line">        pathSumBFS(root.right, targetSum, result, list);  </span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="106从中序与后序遍历序列构造二叉树、105从前序与中序遍历序列构造二叉树">106从中序与后序遍历序列构造二叉树、105从前序与中序遍历序列构造二叉树</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/" >https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不会，直接看解析</span><br></pre></td></tr></table></figure><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" >https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/<i class="fas fa-external-link-alt"></i></a>)</p><p>更快的解法是把inorder放到map内，这样查找不用遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (preorder.length == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[<span class="number">0</span>]);  </span><br><span class="line">    <span class="keyword">if</span> (preorder.length == <span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> root;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">indexIn</span> <span class="operator">=</span> -<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (inorder[i] == preorder[<span class="number">0</span>]) &#123;  </span><br><span class="line">            indexIn = i;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 左子树  </span></span><br><span class="line">    <span class="type">int</span>[] leftTreeInorder = Arrays.copyOfRange(inorder, <span class="number">0</span>, indexIn);  </span><br><span class="line">    <span class="comment">// 右子树  </span></span><br><span class="line">    <span class="type">int</span>[] rightTreeInorder = Arrays.copyOfRange(inorder, indexIn + <span class="number">1</span>, inorder.length);  </span><br><span class="line">  </span><br><span class="line">    root.left = buildTree(Arrays.copyOfRange(preorder, <span class="number">1</span>, leftTreeInorder.length + <span class="number">1</span>), leftTreeInorder);  </span><br><span class="line">    root.right = buildTree(Arrays.copyOfRange(preorder, inorder.length - rightTreeInorder.length, inorder.length), rightTreeInorder);  </span><br><span class="line">    <span class="keyword">return</span> root;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看解析</h1><h2 id="513找树左下角的值-2">513找树左下角的值</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html" >https://programmercarl.com/0513.找树左下角的值.html<i class="fas fa-external-link-alt"></i></a>)</p><p>那么如何找最左边的呢？可以使用前序遍历（当然中序，后序都可以，因为本题没有 中间节点的处理逻辑，只要左优先就行），保证优先左边搜索，然后记录深度最大的叶子节点，此时就是树的最后一行最左边的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归法</span></span><br><span class="line"><span class="type">int</span> value;  </span><br><span class="line"><span class="type">int</span> <span class="variable">maxDeep</span> <span class="operator">=</span> Integer.MIN_VALUE;  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValueBFS</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    value = root.val;  </span><br><span class="line">    findLeftValue(root,<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">return</span> value;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findLeftValue</span><span class="params">(TreeNode root, <span class="type">int</span> deep)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (deep &gt; maxDeep) &#123;  </span><br><span class="line">            value = root.val;  </span><br><span class="line">            maxDeep = deep;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;  </span><br><span class="line">        findLeftValue(root.left, deep + <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;  </span><br><span class="line">        findLeftValue(root.right, deep + <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="112路径总和、113路径总和ii-2">112路径总和、113路径总和ii</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html" >https://programmercarl.com/0112.路径总和.html<i class="fas fa-external-link-alt"></i></a>)</p><p>绕晕了，如果把<code>targetSum -= root.val;</code>这句话写在函数最前面，就不用回溯。可以看三行简化的那个注释。我理解的是Java里int不能传递值，递归内层对targetSum的值进行改变，外层不会变化，所以就不用回溯了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没搞懂怎么就不用回溯了，因为int不能传值吗？</span></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 感觉之前做过求路径的题（递归+迭代）这题应该变换一下  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetSum 目标和  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    targetSum -= root.val;  </span><br><span class="line">    <span class="keyword">return</span> hasPathSumBFS(root, targetSum);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasPathSumBFS</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="comment">// 求list中的总和  </span></span><br><span class="line">        <span class="keyword">return</span> targetSum == <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;  </span><br><span class="line">        targetSum -= root.left.val;  </span><br><span class="line">        <span class="keyword">if</span> (hasPathSumBFS(root.left, targetSum)) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 这里的回溯就是把当前节点减掉（数值加上）。包括之前也是，但是之前是list不太好移除，所以选择移除最后一位</span></span><br><span class="line">        targetSum += root.left.val;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 上面三行可以简化成  </span></span><br><span class="line"><span class="comment">if (root.left != null) &#123;  </span></span><br><span class="line"><span class="comment">    // 这里targetSum的值是没有变化的。减完的值进入循环，就不用回溯了  </span></span><br><span class="line"><span class="comment">    hasPathSumBFS(root.left, targetSum - root.left.val);  </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;  </span><br><span class="line">        targetSum -= root.right.val;  </span><br><span class="line">        <span class="keyword">if</span> (hasPathSumBFS(root.right, targetSum)) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        targetSum += root.right.val;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 简化版本  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> targetSum == <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="106从中序与后序遍历序列构造二叉树、105从前序与中序遍历序列构造二叉树-2">106从中序与后序遍历序列构造二叉树、105从前序与中序遍历序列构造二叉树</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html" >https://programmercarl.com/0106.从中序与后序遍历序列构造二叉树.html<i class="fas fa-external-link-alt"></i></a>)</p><p>更快的解法是把inorder放到map内，这样查找不用遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 1.后序最后一个节点为根节点  </span></span><br><span class="line"><span class="comment"> * 2.根据这个节点切割中序数组（节点前为左子树，节点后为右子树）  </span></span><br><span class="line"><span class="comment"> * 3.根据中序数组的切割切割后序数组  </span></span><br><span class="line"><span class="comment"> * 4.递归  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inorder 中序遍历结果  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> postorder 后序遍历结果  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 树  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (inorder.length != postorder.length) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (postorder.length == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postorder[postorder.length - <span class="number">1</span>]);  </span><br><span class="line">    <span class="keyword">if</span> (postorder.length == <span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> root;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">indexIn</span> <span class="operator">=</span> -<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (inorder[i] == postorder[postorder.length - <span class="number">1</span>]) &#123;  </span><br><span class="line">            indexIn = i;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 左子树  </span></span><br><span class="line">    <span class="type">int</span>[] leftTreeInorder = Arrays.copyOfRange(inorder, <span class="number">0</span>, indexIn);  </span><br><span class="line">    <span class="comment">// 右子树  </span></span><br><span class="line">    <span class="type">int</span>[] rightTreeInorder = Arrays.copyOfRange(inorder, indexIn + <span class="number">1</span>, inorder.length);  </span><br><span class="line">  </span><br><span class="line">    root.left = buildTree(leftTreeInorder, Arrays.copyOfRange(postorder, <span class="number">0</span>, leftTreeInorder.length));  </span><br><span class="line">    root.right = buildTree(rightTreeInorder, Arrays.copyOfRange(postorder, leftTreeInorder.length, postorder.length - <span class="number">1</span>));  </span><br><span class="line">    <span class="keyword">return</span> root;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：513用层序AC、112AC（但时间复杂度较高））（解析中给的方法和想的不一样），113AC、106不会&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.06.07 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="二叉树" scheme="https://kiml.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
</feed>
