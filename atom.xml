<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Keep Theme</title>
  
  <subtitle>Keep theme quick starter</subtitle>
  <link href="https://kiml.github.io/atom.xml" rel="self"/>
  
  <link href="https://kiml.github.io/"/>
  <updated>2024-06-05T08:38:40.686Z</updated>
  <id>https://kiml.github.io/</id>
  
  <author>
    <name>Keep Team</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用mapstruct转换对象，报错Cannot find implementation for……</title>
    <link href="https://kiml.github.io/2024/06/05/100000027/"/>
    <id>https://kiml.github.io/2024/06/05/100000027/</id>
    <published>2024-06-05T08:31:33.000Z</published>
    <updated>2024-06-05T08:38:40.686Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>参考文章：<a class="link"   href="https://blog.csdn.net/qq_41169544/article/details/127664756" >mapstruct 报错 java.lang.ClassNotFoundException: Cannot find implementation for<i class="fas fa-external-link-alt"></i></a></p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.06.05 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>问题</h1><p>使用mapstruct转换对象，接口可以启动，但是执行报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassNotFoundException: Cannot find implementation for com.…….convert.AuthorizationPrivilegeConvert</span><br></pre></td></tr></table></figure><h1>原因</h1><p>注解没有引用全。</p><h1>解决</h1><p>添加依赖，重启服务。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-jdk8<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>……<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>……<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
参考文章：&lt;a class=&quot;link&quot;   href=&quot;https://blog.csdn.net/qq_41169544/article/details/127664756&quot; &gt;mapstruct 报错 java.lang.ClassNotFoundException: Cannot find implementation for&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.06.05 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="Java" scheme="https://kiml.github.io/tags/Java/"/>
    
    <category term="BUG" scheme="https://kiml.github.io/tags/BUG/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第十四天-104二叉树的最大深度、111二叉树的最小深度、222完全二叉树的节点个数</title>
    <link href="https://kiml.github.io/2024/06/05/100000026/"/>
    <id>https://kiml.github.io/2024/06/05/100000026/</id>
    <published>2024-06-05T01:07:38.000Z</published>
    <updated>2024-06-05T03:13:00.619Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：104、111可以AC，222没有思路</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.06.04 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="104二叉树的最大深度">104二叉树的最大深度</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/" >https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 思路：递归计算左右子树的深度。取较大值  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> maxDepth(root.left);  </span><br><span class="line">    <span class="type">int</span> <span class="variable">rightLength</span> <span class="operator">=</span> maxDepth(root.right);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftLength, rightLength);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="111二叉树的最小深度">111二叉树的最小深度</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/" >https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 思路：  </span></span><br><span class="line"><span class="comment"> * 递归终止条件  </span></span><br><span class="line"><span class="comment"> * 1.根节点为空，直接返回0  </span></span><br><span class="line"><span class="comment"> * 2.根节点的左右节点有一个为空，返回另一个节点的最小深度  </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root.right == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + minDepth(root.left);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + minDepth(root.right);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.min(minDepth(root.right), minDepth(root.left));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="222完全二叉树的节点个数">222完全二叉树的节点个数</h2><p>题目链接:(<a class="link"   href="https://leetcode.cn/problems/count-complete-tree-nodes/description/" >https://leetcode.cn/problems/count-complete-tree-nodes/description/<i class="fas fa-external-link-alt"></i></a>)<br>没有AC，思路只有一半。根据题解：递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后按满二叉树的情况来算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误解法，正确解法在看解析部分。</span></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 思路：既然是完全二叉树。深度可以很简单的求出来  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> getDepth(root);  </span><br><span class="line">    <span class="comment">// n - 1 层的节点数量  </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (depth - <span class="number">1</span>) ^ <span class="number">2</span> - <span class="number">1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 求完全二叉树的深度  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;  </span><br><span class="line">        depth++;  </span><br><span class="line">        root = root.left;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> depth;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看解析</h1><h2 id="104二叉树的最大深度-2">104二叉树的最大深度</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html" >https://programmercarl.com/0104.二叉树的最大深度.html<i class="fas fa-external-link-alt"></i></a>)<br>本题可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是深度，使用后序求的是高度。</p><ul class="lvl-0"><li class="lvl-2"><p>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）</p></li><li class="lvl-2"><p>二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）<br><strong>根节点的高度就是二叉树的最大深度</strong>。</p></li></ul><h3 id="559-N-叉树的最大深度">559. N 叉树的最大深度</h3><p>题目链接(<a class="link"   href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/" >https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (Node child : root.children) &#123;  </span><br><span class="line">        max = Math.max(maxDepth(child), max);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + max;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="111二叉树的最小深度-2">111二叉树的最小深度</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html" >https://programmercarl.com/0111.二叉树的最小深度.html<i class="fas fa-external-link-alt"></i></a>)<br><strong>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</strong> 注意是<strong>叶子节点</strong>。（左右孩子都为空的节点才是叶子节点）</p><h2 id="222完全二叉树的节点个数-2">222完全二叉树的节点个数</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html" >https://programmercarl.com/0222.完全二叉树的节点个数.html<i class="fas fa-external-link-alt"></i></a>)<br>递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后按满二叉树的情况来算。<strong>所以需要判断是否是满二叉树</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 完全二叉树求节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> root.left;  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> root.right;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> <span class="number">0</span>, rightLength = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (left != <span class="literal">null</span>) &#123;  </span><br><span class="line">        left = left.left;  </span><br><span class="line">        leftLength++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span> (right != <span class="literal">null</span>) &#123;  </span><br><span class="line">        right = right.right;  </span><br><span class="line">        rightLength++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (leftLength == rightLength) &#123;  </span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftLength) - <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> countNodes(root.left) + countNodes(root.right) + <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：104、111可以AC，222没有思路&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.06.04 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="二叉树" scheme="https://kiml.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>面试-并发</title>
    <link href="https://kiml.github.io/2024/06/03/100000024/"/>
    <id>https://kiml.github.io/2024/06/03/100000024/</id>
    <published>2024-06-03T13:42:40.000Z</published>
    <updated>2024-06-05T01:05:14.957Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>❗表示必掌握，❔表示基本不会问</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.06.03 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="❗说说synchronized关键字的底层原理">❗说说synchronized关键字的底层原理</h2><p><strong>因为synchronized可以同时保证原子性、可见性和有序性，所以在并发编程中经常会用到他，synchronized主要有三种用法</strong>：修饰实例方法、修饰静态方法、修饰代码块。</p><p>synchronized 修饰代码块时，JVM 采用monitorenter 、monitorexit 两个指令来实现同步，monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指向同步代码块的结束位置。</p><p>synchronized 修饰同步方法时，JVM 采用ACC_SYNCHRONIZED 标记符来实现同步，这个标了该方法是一个同步方法。</p><p>❗大白话（修饰代码块）：每个对象实例都会关联一个monitor，一个类的class对象也会关联一个monitor。一个线程过来，把monitor置1（可以重复加锁，二次加monitor变成2、3…）。当线程走出synchronized，执行monitorexit，底层获取对应的monitor进行释放。线程2加锁失败，陷入一个阻塞等待的状态。</p><h2 id="❗对CAS的理解及其底层实现原理">❗对CAS的理解及其底层实现原理</h2><p>CAS 叫做比较并交换，CAS 指令包含 3 个参数：新值，旧值，内存值（内存位置），线程会先获取内存值，然后复制到变量副本，生成旧值，旧值在一系列操作后生成新值。</p><p>若旧值=内存值，说明没有被其他线程抢先占有，则修改内存值为新值；</p><p>若旧值≠内存值，说明内存值已经被其他线程修改，则自旋获取新的内存值，然后重新操作。</p><p>大白话：比如说使用synchronized对于代码块进行加锁，这个时候多个线程的执行是串行的。比如一个累加的计数器，优化可以把int类型的累加字段改成AtomicInteger类型（<strong>原子类</strong>），方法改为incrementAndGet，此时不用synchronized也是线程安全的。这个原子类底层就是CAS（Compare and Set）。在线程执行incrementAndGet时，会先读取，再尝试设置：当一个线程成功执行CAS操作（就是对比旧值是否是原来的值），另一个就会失败，失败就会重新读取，再次设置。</p><h3 id="❗CAS会出现经典的ABA问题">❗CAS会出现经典的ABA问题</h3><p>原因：第一个线程刚获得A，第二个线程就抢走也获得A，然后改成B后又改成A，这时候第一个线程发现变量是A，就继续执行。但是这样会出现潜藏的问题，比如修改的是金额，存一笔和存两笔是两个概念。</p><p>解决：加入版本号解决。</p><h2 id="❗ConcurrentHashMap实现线程安全的底层原理">❗ConcurrentHashMap实现线程安全的底层原理</h2><p>JDK1.8以前，多个数组，分段加锁，一个数组一个锁。他将一个大的 ConcurrentHashMap分成16个小的 Segment。也就是说可以同时承受16个线程的并发。<br>JDK1.8以后，数组里每个元素进行put操作，都是有一个不同的锁，对当个位置进行put操作时，采取的是CAS的策略。如果CAS操作失败，就使用synchronized对这个位置的对象进行锁定，然后基于链表或红黑树，对数组元素进行写入。</p><h2 id="❗对JDK中的AQS的理解，AQS的实现原理">❗对JDK中的AQS的理解，AQS的实现原理</h2><p>多线程访问数据除了synchronized，CAS，ConcurrentHashMap，还有Lock。ReentrantLock的底层就是AQS（Abstract Queue Synchronizer）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">// 默认使用非公平锁</span></span><br><span class="line"><span class="comment">// 传入参数true，就使用公平锁</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">lock.lock();</span><br><span class="line"></span><br><span class="line">look.unlock();</span><br></pre></td></tr></table></figure><p>大白话：AQS底层有个state，多个线程执行CAS更新state；还有一个变量记录加锁线程。AQS中会有一个等待队列的概念。当前一个线程释放了锁，会去唤醒等待队列中的队首元素。</p><p>非公平锁：在唤醒等待队列的过程中，如果有另一个线程抢占锁，是可以成功的。公平锁：在唤醒等待队列的过程中，如果需要抢占锁，需要加入到等待队列内，进行等待。</p><h3 id="ReentrantLock与Synchronized的区别。">ReentrantLock与Synchronized的区别。</h3><h2 id="说说线程池的底层工作原理">说说线程池的底层工作原理</h2><p>避免频繁的创建线程，销毁线程……</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>) <span class="comment">// corePoolSize</span></span><br></pre></td></tr></table></figure><p>如果线程池内数量小于corePoolSize，就会创建一个线程执行任务。线程池一般会带一个队列，当线程执行任务完成，会等待阻塞在队列上（队首），尝试从队列继续获取任务。如果任务多于corePoolSize，会进入阻塞队列。</p><p>FixedThreadPool的队列是LinkedBlockingQueue，无界阻塞队列，即队列长度无线大。</p><h2 id="线程池的核心配置参数">线程池的核心配置参数</h2>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
❗表示必掌握，❔表示基本不会问&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.06.03 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="八股文" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="面试" scheme="https://kiml.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="八股文" scheme="https://kiml.github.io/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    <category term="多线程" scheme="https://kiml.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>面试-基础</title>
    <link href="https://kiml.github.io/2024/06/03/100000025/"/>
    <id>https://kiml.github.io/2024/06/03/100000025/</id>
    <published>2024-06-03T13:09:05.000Z</published>
    <updated>2024-06-04T06:03:53.754Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>❗表示必掌握，❔表示基本不会问</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.06.03 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="❗Java的基本数据类型">❗Java的基本数据类型</h2><p>byte，short，int，long，float，double，char，boolean</p><h2 id="面向对象的三大特性">面向对象的三大特性</h2><p>继承、多态、封装</p><h2 id="JDK和JRE的区别">JDK和JRE的区别</h2><p>JRE：Java 运⾏时环境。它是运⾏已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，Java 命令和其他的⼀些基础构件。但是，它不能⽤于创建新程序。</p><p>JDK(Java Development Kit)：它是功能⻬全的 Java SDK。它拥有 JRE 所拥有的⼀切，还有编译器（javac）和⼯具（如 javadoc 和 jdb）。它能够创建和编译程序。</p><p><strong>简单来说，JDK 包含 JRE，JRE 包含 JVM。</strong></p><h2 id="Java支持多继承和多实现吗">Java支持多继承和多实现吗</h2><p>不支持多继承，支持多实现。</p><h2 id="构造函数和一般函数有什么区别">构造函数和一般函数有什么区别</h2><ol><li class="lvl-3"><p>定义格式不同</p></li><li class="lvl-3"><p>构造函数是在对象创建时，就被调用，用于初始化，而且初始化动作只执行一次。 一般函数，是对象创建后，需要调用才执行，可以被调用多次。</p></li></ol><h2 id="Java怎么创建对象">Java怎么创建对象</h2><ol><li class="lvl-3"><p>使用 new 关键字</p></li><li class="lvl-3"><p>使用newInstance方法</p></li></ol><blockquote><p>Java 反射中有一个 newInstance() 方法，可以创建对象，步骤如下：获取要创建的类的 Class 对象。如果只需要调用这个类的访问权限为 public 无参构造器，<strong>直接使用 Class 类的实例方法 newInstance()</strong>。获取 Class 对象的构造器对象，通过调用 Class 类的实例方法 getDeclaredConstractors() 来获取构造器对象的数组。(获取所有构造器，无视访问权限的限制，数组顺序按照代码中的顺序决定)如果调用的构造器是 private 的，需要调用 Constractor 类的父类 AccessibleObject 类的实例方法 setAccessible(true) 来打破访问限制。使用 Constractor 类的实例方法 newInstance()。获取 Class 对象的方法有3个，此处不多赘述。获取Constractor 对象的方法有4个，此处不多赘述。</p></blockquote><ol start="3"><li class="lvl-3"><p>使用clone()方法</p></li></ol><blockquote><p>Object 类是所有类的直接或间接父类，Object 类中提供了 实例方法 native()，在给定对象的基础上，创建一个完全相同的对象。步骤如下：想要使用 clone() 方法创建对象的类，实现 Cloneable 接口。在类的内部，重写 Object 类的 clone() 方法。备注：没有实现 Cloneable 接口，会抛出 CloneNotSupportedException 异常。Object 类提供的 clone() 方法，访问权限是 protected，所以如果不重写 clone() 方法，是没有权限调用的。Object 类的 clone() 方法，是 native 方法。</p></blockquote><ol start="4"><li class="lvl-3"><p>❔使用反序列化的readObject()方法</p></li></ol><blockquote><p>这个方法一共分两步：将对象序列化，存储到一个文件中。从文件中反序列化，得到类对象。</p><p>序列化：想要序列化对象的类，实现Serializable接口。使用文件输出流FileOutputStream创建存储序列化之后对象的文件。使用对象输出流ObjectOutputStream的实例方法writeObject(obj)。判断类中是否存在，名为writeReplace()，返回类型为Object的方法，若有，写入这个方法的返回值；否则，写入obj对象。</p><p>反序列化：使用文件输入流FileInputStream找到存储序列化对象的文件。使用对象输入流ObjectInputStream的实例方法readObject()。判断类中是否存在，名为readResolve()，返回类型为Object的方法，若有读取这个对象；否则，反序列化文件中的对象流。</p><p>备注：在类中，writeReplace()和readResoleve()是两个非常特殊的方法，其特征签名需要严格限制：方法名限定，参数个数限定为0，返回类型必须是Object，不能为Object的子类，但是可以抛出不同的异常。访问修饰符没有限制，但一般推荐为private，防止误操作。其特殊的地方还在于将其设为private方法，没有其他方法调用的情况下，编译器不会发出警告。</p></blockquote><h2 id="Java中的异常">Java中的异常</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Throwable -&gt;Exception -&gt; ClassNotFoundException</span><br><span class="line">  -&gt; IOException</span><br><span class="line">  -&gt; RuntimeException      -&gt; NullPointerException</span><br><span class="line">  -&gt; NumberFormatException</span><br><span class="line">  -&gt; IndexOutOfBoundsException</span><br><span class="line">  ......</span><br><span class="line">          -&gt;Error</span><br></pre></td></tr></table></figure><h2 id="❗抽象类和接口的区别">❗抽象类和接口的区别</h2><ol><li class="lvl-3"><p>定义：接口定义：interface；抽象类：abstrat class;</p></li><li class="lvl-3"><p>抽象类可以定义构造方法供子类调用，接口不可以；</p></li><li class="lvl-3"><p>接口的所有方法都是抽象方法，所有属性都是常量：static final 类型；而抽象类中可以有不是抽象的方法和不是常量的属性；</p></li><li class="lvl-3"><p>抽象类只能单继承，而接口之间可以多继承，接口之间的继承用extexds,类实现接口用implements.</p></li></ol><h2 id="和equals"><code>==</code>和<code>equals()</code></h2><p><code>==</code>：</p><ol><li class="lvl-3"><p>如果比较的对象是基本数据类型，则比较的是其存储的值是否相等；</p></li><li class="lvl-3"><p>如果比较的是引用数据类型，则比较的是所指向对象的地址值是否相等（是否是同一个对象）。<code>equals</code>：</p></li><li class="lvl-3"><p>如果没有对 equals 方法进行重写，则相当于<code>==</code>，比较的是引用类型的变量所指向的对象的地址值。</p></li><li class="lvl-3"><p>一般情况下，类会重写equals方法用来比较两个对象的内容是否相等。比如String类中的equals()是被重写了，比较的是对象的值。</p></li></ol><h2 id="为什么重写equals方法，还必须要重写hashcode方法">为什么重写equals方法，还必须要重写hashcode方法</h2><ol><li class="lvl-3"><p>保证是同一个对象，如果重写了equals方法，而没有重写hashcode方法，会出现equals相等的对象，hashcode不相等的情况，重写hashcode方法就是为了避免这种情况的出现。</p></li><li class="lvl-3"><p>使用hashcode方法提前校验，可以避免每一次比对都调用equals方法，提高效率</p></li></ol><p>重写后：</p><ol><li class="lvl-3"><p>equals()相等的两个对象，hashcode()一定相等；</p></li><li class="lvl-3"><p>hashcode()不等，一定能推出equals()也不等；</p></li><li class="lvl-3"><p>hashcode()相等，equals()可能相等，也可能不等。</p></li><li class="lvl-3"><p>所以先进行hashcode（）判断，不等就不用equals（）方法了。</p></li><li class="lvl-3"><p>但equels是是根据对象的特征进行重写的，有时候特征相同，但hash值不同，也不是一个对象。 所以两个都重写才能保障是同一个对象。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
❗表示必掌握，❔表示基本不会问&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.06.03 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="八股文" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="面试" scheme="https://kiml.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="八股文" scheme="https://kiml.github.io/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第十三天-层序遍历、226翻转二叉树、101对称二叉树 2</title>
    <link href="https://kiml.github.io/2024/06/03/100000023/"/>
    <id>https://kiml.github.io/2024/06/03/100000023/</id>
    <published>2024-06-03T02:22:57.000Z</published>
    <updated>2024-06-05T01:08:46.690Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：层序遍历直接看解析。226、101看了部分解析。可以完成递归法。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.06.03 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="102二叉树的层序遍历">102二叉树的层序遍历</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/" >https://leetcode.cn/problems/binary-tree-level-order-traversal/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    ArrayList&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    levelOrderDFS(root, <span class="number">0</span>, resultList);  </span><br><span class="line">    levelOrderBFS(root, resultList);  </span><br><span class="line">    <span class="keyword">return</span> resultList;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 迭代法实现层序遍历（广度优先）  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resultList 返回的list  </span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">levelOrderBFS</span><span class="params">(TreeNode root, ArrayList&lt;List&lt;Integer&gt;&gt; resultList)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();  </span><br><span class="line">    queue.offer(root);  </span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;  </span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 遍历当前层所有节点  </span></span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();  </span><br><span class="line">            list.add(node.val);  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 把这层所有的左节点加入  </span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;  </span><br><span class="line">                queue.offer(node.left);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// 把这层所有的右节点加入  </span></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;  </span><br><span class="line">                queue.offer(node.right);  </span><br><span class="line">            &#125;  </span><br><span class="line">            size--;  </span><br><span class="line">        &#125;  </span><br><span class="line">        resultList.add(list);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 递归方式实现层序遍历(深度优先)  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 层数  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resultList 遍历结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">levelOrderDFS</span><span class="params">(TreeNode root, <span class="type">int</span> i, ArrayList&lt;List&lt;Integer&gt;&gt; resultList)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    i++;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 如果小于，说明第一次进这层，需要初始化这个位置的list  </span></span><br><span class="line">    <span class="keyword">if</span> (resultList.size() &lt; i) &#123;  </span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">        resultList.add(list);  </span><br><span class="line">    &#125;  </span><br><span class="line">    resultList.get(i - <span class="number">1</span>).add(root.val);  </span><br><span class="line">  </span><br><span class="line">    levelOrderDFS(root.left, i, resultList);  </span><br><span class="line">    levelOrderDFS(root.right, i, resultList);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="226翻转二叉树">226翻转二叉树</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/invert-binary-tree/description/" >https://leetcode.cn/problems/invert-binary-tree/description/<i class="fas fa-external-link-alt"></i></a>)<br>看了一部分的题目解析，突然反应过来tree不用自己构建，直接用方法简单很多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * DFS递归  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 翻转结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    invertTreePreorder(root);  </span><br><span class="line">    <span class="keyword">return</span> root;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invertTreePreorder</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>();  </span><br><span class="line">    <span class="comment">// 指针交换  </span></span><br><span class="line">    temp = root.left;  </span><br><span class="line">    root.left = root.right;  </span><br><span class="line">    root.right = temp;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;  </span><br><span class="line">        invertTreePreorder(root.left);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;  </span><br><span class="line">        invertTreePreorder(root.right);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="101对称二叉树">101对称二叉树</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/symmetric-tree/description/" >https://leetcode.cn/problems/symmetric-tree/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 这题和翻转放在一起  </span></span><br><span class="line"><span class="comment"> * 第一思路就是翻转之后比较是否相等(但是是指针引用，翻转之后是不能进行比较的)  </span></span><br><span class="line"><span class="comment"> * 看了部分讲解，说是把左子，右子拆分成两棵树来看.  </span></span><br><span class="line"><span class="comment"> * 可以拆分之后翻转一棵树，然后比较是否相等。  </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> root.right;  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> root.left;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 左子树翻转  </span></span><br><span class="line">    invertTreePreorder(left);  </span><br><span class="line">    <span class="keyword">return</span> isEqual(right, left);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEqual</span><span class="params">(TreeNode right, TreeNode left)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (right == <span class="literal">null</span> &amp;&amp; left == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> ((right == <span class="literal">null</span> &amp;&amp; left != <span class="literal">null</span>) || (right != <span class="literal">null</span> &amp;&amp; left == <span class="literal">null</span>)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (right.val != left.val) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> isEqual(right.right, left.right) &amp;&amp; isEqual(right.left, left.left);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invertTreePreorder</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    TreeNode temp;  </span><br><span class="line">    <span class="comment">// 指针交换  </span></span><br><span class="line">    temp = root.left;  </span><br><span class="line">    root.left = root.right;  </span><br><span class="line">    root.right = temp;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;  </span><br><span class="line">        invertTreePreorder(root.left);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;  </span><br><span class="line">        invertTreePreorder(root.right);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看解析</h1><h2 id="102二叉树的层序遍历-2">102二叉树的层序遍历</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html" >https://programmercarl.com/0102.二叉树的层序遍历.html<i class="fas fa-external-link-alt"></i></a>)<br>层序遍历一个二叉树。需要借用一个辅助数据结构即队列来实现，<strong>队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></p><p><strong>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</strong></p><h2 id="226翻转二叉树-2">226翻转二叉树</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html" >https://programmercarl.com/0226.翻转二叉树.html<i class="fas fa-external-link-alt"></i></a>)<br><strong>递归的中序遍历是不行的，因为使用递归的中序遍历，某些节点的左右孩子会翻转两次。</strong></p><h2 id="101对称二叉树-2">101对称二叉树</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html" >https://programmercarl.com/0101.对称二叉树.html<i class="fas fa-external-link-alt"></i></a>)<br>本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。<br><strong>正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**   </span></span><br><span class="line"><span class="comment"> * 看完解析后的思路，不用翻转直接比较是否相等  </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> root.right;  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> root.left;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> compare(right, left);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode right, TreeNode left)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (right == <span class="literal">null</span> &amp;&amp; left == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> ((right == <span class="literal">null</span> &amp;&amp; left != <span class="literal">null</span>) || (right != <span class="literal">null</span> &amp;&amp; left == <span class="literal">null</span>)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (right.val != left.val) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> compare(right.right, left.left) &amp;&amp; compare(right.left, left.right);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代法</span></span><br><span class="line"><span class="comment">     * 使用双端队列，相当于两个栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric2</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        deque.offerFirst(root.left);</span><br><span class="line">        deque.offerLast(root.right);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> deque.pollFirst();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> deque.pollLast();</span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="literal">null</span> &amp;&amp; rightNode == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            if (leftNode == null &amp;&amp; rightNode != null) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (leftNode != null &amp;&amp; rightNode == null) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (leftNode.val != rightNode.val) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">// 以上三个判断条件合并</span></span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="literal">null</span> || rightNode == <span class="literal">null</span> || leftNode.val != rightNode.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerFirst(leftNode.left);</span><br><span class="line">            deque.offerFirst(leftNode.right);</span><br><span class="line">            deque.offerLast(rightNode.right);</span><br><span class="line">            deque.offerLast(rightNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代法</span></span><br><span class="line"><span class="comment">     * 使用普通队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric3</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        deque.offer(root.left);</span><br><span class="line">        deque.offer(root.right);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> deque.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> deque.poll();</span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="literal">null</span> &amp;&amp; rightNode == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            if (leftNode == null &amp;&amp; rightNode != null) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (leftNode != null &amp;&amp; rightNode == null) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (leftNode.val != rightNode.val) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">// 以上三个判断条件合并</span></span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="literal">null</span> || rightNode == <span class="literal">null</span> || leftNode.val != rightNode.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里顺序与使用Deque不同</span></span><br><span class="line">            deque.offer(leftNode.left);</span><br><span class="line">            deque.offer(rightNode.right);</span><br><span class="line">            deque.offer(leftNode.right);</span><br><span class="line">            deque.offer(rightNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：层序遍历直接看解析。226、101看了部分解析。可以完成递归法。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.06.03 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="二叉树" scheme="https://kiml.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>面试-总览</title>
    <link href="https://kiml.github.io/2024/06/02/100000021/"/>
    <id>https://kiml.github.io/2024/06/02/100000021/</id>
    <published>2024-06-02T13:59:58.000Z</published>
    <updated>2024-06-02T14:30:11.967Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>这个部分作为一个背题打卡List。展示面试前必须掌握的东西。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.06.02 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>集合HashMap</h1><ul class="lvl-0"><li class="lvl-2"><p><input type="checkbox" id="checkbox0"><label for="checkbox0">put的过程</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox1"><label for="checkbox1">头插法和尾插法的区别</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox2"><label for="checkbox2">1.7和1.8的扩容机制(先扩容在添加调整为先添加在扩容)</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox3"><label for="checkbox3">链表和红黑树的转化过程</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox4"><label for="checkbox4">线程不安全的问题(解决方案)</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox5"><label for="checkbox5">ConcurrentHashMap的1.7和1.8原理和区别</label></p></li></ul><h1>ArrayList</h1><ul class="lvl-0"><li class="lvl-2"><p><input type="checkbox" id="checkbox6"><label for="checkbox6">什么是双向链表</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox7"><label for="checkbox7">底层原理</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox8"><label for="checkbox8">和LinkedList的区别</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox9"><label for="checkbox9">线程不安全如何解决</label></p></li></ul><h1>多线程</h1><ul class="lvl-0"><li class="lvl-2"><p><input type="checkbox" id="checkbox10"><label for="checkbox10">实现方式，每种实现方式的区别</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox11"><label for="checkbox11">Volatile关键字</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox12"><label for="checkbox12">CAS自旋锁</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox13"><label for="checkbox13">Lock锁是公平锁还是非公平锁</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox14"><label for="checkbox14">你了解AQS机制它的核心原理是什么</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox15"><label for="checkbox15">公平锁，非公平锁，偏向锁，轻量锁</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox16"><label for="checkbox16">线程的6种状态</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox17"><label for="checkbox17">线程池的7大核心参数</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox18"><label for="checkbox18">4个拒绝策略</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox19"><label for="checkbox19">多线程的执行流程</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox20"><label for="checkbox20">线程池的常用实现方法</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox21"><label for="checkbox21">ThreadLocal的原理</label></p></li></ul><h1>JVM</h1><ul class="lvl-0"><li class="lvl-2"><p><input type="checkbox" id="checkbox22"><label for="checkbox22">说一下 JVM 的主要组成部分及其作用</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox23"><label for="checkbox23">说一下 JVM 运行时数据区</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox24"><label for="checkbox24">堆里面的分区：Eden，survival （from+ to），老年代，各自的特点是什么</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox25"><label for="checkbox25">说一下 JVM 调优的工具</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox26"><label for="checkbox26">常用的 JVM 调优的参数都有哪些</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox27"><label for="checkbox27">简述Java垃圾回收机制</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox28"><label for="checkbox28">什么是Full GC</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox29"><label for="checkbox29">什么情况下会触发</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox30"><label for="checkbox30">说一下 JVM 有哪些垃圾回收算法</label></p></li></ul><h1>数据库</h1><ul class="lvl-0"><li class="lvl-2"><p><input type="checkbox" id="checkbox31"><label for="checkbox31">索引的机制和底层原理</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox32"><label for="checkbox32">什么是组合索引</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox33"><label for="checkbox33">最左匹配原则</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox34"><label for="checkbox34">数据库的事务</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox35"><label for="checkbox35">引擎的原理</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox36"><label for="checkbox36">数据库悲观锁和乐观锁的实现</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox37"><label for="checkbox37">b+树的好处</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox38"><label for="checkbox38">数据库的优化</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox39"><label for="checkbox39">多个数据源如何操作</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox40"><label for="checkbox40">数据库的优化</label></p></li></ul><h1>框架</h1><ul class="lvl-0"><li class="lvl-2"><p><input type="checkbox" id="checkbox41"><label for="checkbox41">Spring的事务传播机制</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox42"><label for="checkbox42">bean 的生命周期</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox43"><label for="checkbox43">SpringMVC的执行流程</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox44"><label for="checkbox44">ioc</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox45"><label for="checkbox45">di</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox46"><label for="checkbox46">aop</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox47"><label for="checkbox47">SpringBoot异常处理机制</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox48"><label for="checkbox48">简化操作的原理</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox49"><label for="checkbox49">自定义注解</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox50"><label for="checkbox50">Springcloud的组件</label></p></li></ul><h1>Redis</h1><ul class="lvl-0"><li class="lvl-2"><p><input type="checkbox" id="checkbox51"><label for="checkbox51">Redis的数据类型</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox52"><label for="checkbox52">常用命令</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox53"><label for="checkbox53">持久化方法</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox54"><label for="checkbox54">雪崩、击穿、穿透</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox55"><label for="checkbox55">过期策略</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox56"><label for="checkbox56">淘汰策略</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox57"><label for="checkbox57">与数据库的一致性</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox58"><label for="checkbox58">哨兵模式</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox59"><label for="checkbox59">集群</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox60"><label for="checkbox60">分布式锁</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox61"><label for="checkbox61">异步队列</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox62"><label for="checkbox62">延时队列</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox63"><label for="checkbox63">线程模型</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox64"><label for="checkbox64">分区</label></p></li></ul><h1>MQ</h1><ul class="lvl-0"><li class="lvl-2"><p><input type="checkbox" id="checkbox65"><label for="checkbox65">为什么要用MQ</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox66"><label for="checkbox66">MQ的优势</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox67"><label for="checkbox67">消息补偿机制</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox68"><label for="checkbox68">一致性</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox69"><label for="checkbox69">预防消息丢失</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox70"><label for="checkbox70">可靠性</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox71"><label for="checkbox71">不重复消费</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox72"><label for="checkbox72">集群镜像模式</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox73"><label for="checkbox73">MQ的工作模式</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox74"><label for="checkbox74">项目应用场景</label></p></li></ul><h1>场景</h1><ul class="lvl-0"><li class="lvl-2"><p><input type="checkbox" id="checkbox75"><label for="checkbox75">请求量大如何拦截</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox76"><label for="checkbox76">如何去两个库查数据</label></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
这个部分作为一个背题打卡List。展示面试前必须掌握的东西。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.06.02 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="八股文" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>面试-集合</title>
    <link href="https://kiml.github.io/2024/06/01/100000020/"/>
    <id>https://kiml.github.io/2024/06/01/100000020/</id>
    <published>2024-06-01T03:32:49.000Z</published>
    <updated>2024-06-03T13:14:41.547Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>集合常见问题，其中HashMap很重要❗表示必掌握，❔表示基本不会问</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.06.01 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>Java集合</h1><p>集合分为单列集合(collection)和双列集合(map)。单列集合又包括List(可重复)和Set(不可重复)，List分为ArrayList和LinkedList，Set分为HashSet和TreeSet。双列集合Map分为TreeMap和HashMap。单列集合是实现Iterable接口产成的对象，支持迭代器和增强for。</p><h2 id="迭代器">迭代器</h2><h3 id="基础">基础</h3><p><strong>所有的单列集合都可以使用迭代器，因为他们都继承了Iterable接口</strong>，这个接口里的Iterator方法可以返回一个Iterator对象，这个Iterator对象就是迭代器对象，底层针对不同类型的集合都写了不同的实现类，所以集合可以直接使用迭代器进行遍历查询。这种只需要提供一种方法（iterator方法）访问一个容器对象中各个元素，而又不暴露该对象的内部细节的方式就是迭代器设计模式。</p><h3 id="迭代器倒序">迭代器倒序</h3><p>List集合可以使用迭代器倒着遍历，ListIterator有previous()方法和hasprevious()方法，可以自动指向并取出上一个元素。Set集合不能用迭代器倒着遍历，但可以根据它的大小顺序倒着取出。</p><h3 id="使用foreach、iterator、for在有什么区别？效率上哪个更高？">使用foreach、iterator、for在有什么区别？效率上哪个更高？</h3><p>区别上：普通for循环一般用来处理比较简单的有序的，可预知大小的集合或数组.<br>foreach可用于遍历任何集合或数组，而且操作简单易懂，唯一的不好就是需要了解集合内部类型，它的底层有函数式编程注解 @FunctionalInterface，也就是说它可以进行Lamda形式简写。<br>iterator是最强大的，他可以随时修改或者删除集合内部的元素，并且是在不需要知道元素和集合的类型的情况下进行的，当你需要对不同的容器实现同样的遍历方式时，迭代器是最好的选择！至于增强for和iterator其实是一样的，增强for编译后的.class文件中，就是iterator，所以二者除了写法是用第三方参数来表示，效率上没有任何区别。</p><p>效率上：这个需要多方考虑，比如普通for循环用在数组是遍历最快的，它是直接获取数据，但普通for不能用在不知道长度的集合中，这就需要用iterator或者foreach，相对来说，iterator效率会高于foreach，因为foreach在访问过程中产生一个额外的Enumerator对象，这个对象会进行版本检查处理，所以它是线安全的。对于ArrayList来说，它是通过一个数组实现的，可以随机存取；但是LinkedList是通过链表实现的，当要遍历依个取出时，for循环时要取的每个元素都必须从头开始遍历，而iterator遍历则从头开始，边遍历边取，取完只需要一次遍历，所以for循环需要的时间远远超过foreach循环。 对于数组来说，for和foreach循环效率差不多，但是对于链表来说，for循环效率明显比foreach低。</p><h2 id="ArrayList和LinkedList的底层原理">ArrayList和LinkedList的底层原理</h2><p>首先，List集合是有序集合，即存取有序，List集合的特点是存取顺序一致，存储元素可重复，都有索引。<br>ArrayList的底层是数组，一个索引对应一个元素，所以查询速度快；但是在增删时，需要调整整组数据的移动，所以增删较慢。而LinkedList的底层是双向链表，每次查询时都要从两头开始查询（离头近就从头查，离尾近就从尾查），所以查询较慢；但是增删时，只需要将链表头结点和尾结点指向新插入的结点即可，所以增删速度较快。但如果是新增的数据量较大的情况下，ArrayList的新增效率反面比LinkedList的效率更高。因为ArrayListr底层数组的扩容是1.5倍，数据量越大，扩容的速度就越快，而链表仍需一个个断开链接和重续新链接。最后，<strong>jdk8版还对ArrayList做了懒加载优化，在之前是构造ArrayList时就默认开辟10个空间，jdk8之后变成了只有放入第1个元素时，才会开辟10个空间。</strong><br>❗❗<strong>数组的起始长度是0，在向数组中添加第一个元素时，数组容量扩为10。</strong> 后续扩容因子为1.5倍。每次扩容都是复制到新的数组。</p><h2 id="分别讲一下Set集合和Tree这种数据结构">分别讲一下Set集合和Tree这种数据结构</h2><p>Set集合的特点是必须排序，没有索引，不可重复。Set集合分为HashSet和TreeSet，HashSet底层使用的是哈希表，它的排序规则是按照底Hash函数决定的，无法人为设置；而TreeSet的底层则是使用红黑树，可以使用自然排序（自定义类中实现Comparable接口，重写CompareTo方法）或比较器排序（在创建TreeSet对象创建一个Comparator的匿名内部类，并重写Compare方法），扩容时通过结点链接。<br> <br> ### TreeSet使用Iterator遍历的过程是怎么样的？<br> 因为TreeSet是按大小排序的，所以会根据从左往右，从下往上的顺序打印。<br> <br> ## List集合是线程不安全的，你是怎么使用List集合的呢？<br> 使用Collections集合工具类，对集合进行同步处理：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()); </span><br></pre></td></tr></table></figure><br>但是在多线程开发中，对其进行遍历，需要添加 synchronized 关键字，因为List的 add、index 等方法中都是带有synchronized 关键字，但是在 iterator 中没有synchronized 关键字。</p><h2 id="HashMap">HashMap</h2><h3 id="❗HashMap底层的数据结构">❗HashMap底层的数据结构</h3><p>数组 + 最简单的原理。对存入的key进行hash计算，根据计算出的hash值，对数组长度进行取模，获取到要存入的位置。<br><strong>JDK8以前，Hash表的底层是【数组】+【链表】<br>JDK8及之后，变成了【数组】+【链表】+【红黑树】</strong></p><h3 id="❗JDK-1-8-中对hash算法和寻址算法是如何优化的？">❗JDK 1.8 中对hash算法和寻址算法是如何优化的？</h3><p>hash算法：hash值与hash值右移16位进行异或计算。得到结果位高16位+高16位与低16位的异或值。（<strong>这一步主要为了低16位在下一步寻址的时候，使低16位保留高16位的特征，减少哈希冲突</strong>）寻址：<code>(n - 1)&amp;hash</code> 算出数组内的一个位置。</p><p>为什么使用&amp;运算不使用取模运算？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">取模运算性能比较差，而且(n - 1)&amp;hash的效果和hash对n取模，效果是一样的。</span><br><span class="line"></span><br><span class="line">为什么效果是一样的？</span><br><span class="line">因为数组的长度一直是2的n次方，只要他保持数组长度是2的n次方，那么效果就是一样的。</span><br></pre></td></tr></table></figure><h3 id="❗HashMap如何解决hash碰撞？">❗HashMap如何解决hash碰撞？</h3><p>hash冲突，链表+红黑树，O(n)和O(logn)</p><h3 id="❗HashMap如何进行扩容？">❗HashMap如何进行扩容？</h3><p>2倍扩容。扩容之后要进行rehash。即hash值与新数组长度<code>(n - 1)</code>进行与操作。如果值与原来不一样，新的index就是<code>旧index + oldCap</code>，通过这个方式，避免了rehash的时候，进行取模（效率不高）。</p><p>Hash表中数组的分手手动初始化，和自动初始化，自动初初始会在第一次插入元素时开辟空间，<strong>默认长度为16</strong>，扩容因子为0.75，<strong>每次扩容量为自身的2倍长度</strong>，扩容之后存入数组的新索引位置就会改变。手动初始化的话，可以在创建对象时自定义初始数组长度，但HashMap不一定会自主设置的数值初始化数组，而按2的n次方创建。</p><p>HashMap1.7版本的的扩容时机是先判断是否达到阈值，达到先扩容，再添加元素，并且采用的是头插法，也就是旧元素挂在新元素下。而HashMap1.8的扩容时机是先添加元素是否达到阈值，达到直接扩容，且使用的是尾插法，即新元素挂在旧元素下面。</p><p>初始化后，当存入新的键值对时，会先判断数组长度是否大于64，再判断链表元素是否大于等于8时，如果两者都成立，链表会自动转换成红黑树，如果数组小于64，会从第9个开始先扩容，直到数组大于等于64时，链表长度再增加，就会转为红黑树。</p><h4 id="❔为什么要转为红黑树呢？">❔为什么要转为红黑树呢？</h4><p>链表取一个数需要遍历链表，而红黑树相对效率要高。</p><h4 id="❔为什么不直接使用红黑树呢？">❔为什么不直接使用红黑树呢？</h4><p>HashMap源码中有相关描述： “因为树节点的大小是链表节点大小的两倍，所以只有在容器中包含足够的节点保证使用才用它”，显然尽管转为树使得查找的速度更快，但是在节点数比较小的时候，此时对于红黑树来说内存上的劣势会超过查找等操作的优势，自然使用链表更加好，但是在节点数比较多的时候，综合考虑，红黑树比链表要好。</p><h4 id="❔为什么转为红黑树的条件是8而不是第9第10个呢？">❔为什么转为红黑树的条件是8而不是第9第10个呢？</h4><p>源码中有对这个进行计算，正常的随机哈希码下，哈希冲突多到超过8个的概率不到千万分之一，几乎可以忽略不计了，再往后调整并没有很大意义。如果哈希冲突有那么多，说明极大可能是人为设置，故意制造哈希冲突导致，这时候就转为化红黑树，来保证查询效率。</p><h4 id="❔那什么时候退出红黑树呢？">❔那什么时候退出红黑树呢？</h4><p>当哈希冲突个数从第8个变到第6个时，红黑树转化为链表。</p><h4 id="❔6与8之间的第7个冲突时，会是什么状态？">❔6与8之间的第7个冲突时，会是什么状态？</h4><p>分情况看。8退6，是红黑树转链表，6进8，是链表转红黑树，中间的7是防止频繁变动做的一个预留位，如果是8退6，中间的7就是红黑树；如果是6进8，中间的7就是链表。</p><h3 id="为什么1-7是头插法，1-8是尾插法？">为什么1.7是头插法，1.8是尾插法？</h3><p>1.7版本使用头插法是因为头插法是操作速度最快的，找到数组位置就直接找到插入位置了，但这样插入方法在并发场景下会因为多个线程同时扩容出现循环列表，也就是Hashmap的死锁问题。</p><p>1.8版本加入了红黑树来优化哈希桶中的遍历效率，相比头插法而言，尾插法在操作额外的遍历消耗（指遍历哈希桶）已经小很多，也可以避免之前的循环列表问题，同时如果已经变成红黑树了，也不能再用头插法了，而是按红黑树自己的规则排列了。</p><h4 id="❗多线程下的HashMap线程安全吗？为什么？">❗多线程下的HashMap线程安全吗？为什么？</h4><p>HashMap本身就是不安全的，多线程下，在添加元素时容易出现数据覆盖情况而丢失数据，也可能在扩容时，迁移数据出现数据覆盖情况而丢失数据。</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
集合常见问题，其中HashMap很重要❗表示必掌握，❔表示基本不会问&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.06.01 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="八股文" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="Java" scheme="https://kiml.github.io/tags/Java/"/>
    
    <category term="Java基础" scheme="https://kiml.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="HashMap" scheme="https://kiml.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第十二天-二叉树理论基础、递归遍历、迭代遍历、统一迭代</title>
    <link href="https://kiml.github.io/2024/06/01/100000019/"/>
    <id>https://kiml.github.io/2024/06/01/100000019/</id>
    <published>2024-06-01T03:17:20.000Z</published>
    <updated>2024-06-04T01:29:58.172Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>递归、迭代、统一迭代。都是看完解析之后完成的。统一迭代有点难理解。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-03 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="144二叉树的前序遍历">144二叉树的前序遍历</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/" >https://leetcode.cn/problems/binary-tree-preorder-traversal/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    preOrder(root, list);  </span><br><span class="line">    <span class="keyword">return</span> list;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 前序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list 遍历结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; list)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 当前  </span></span><br><span class="line">    list.add(root.val);  </span><br><span class="line">    <span class="comment">// 左子树  </span></span><br><span class="line">    preOrder(root.left, list);  </span><br><span class="line">    <span class="comment">// 右子树  </span></span><br><span class="line">    preOrder(root.right, list);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 迭代法  </span></span><br><span class="line"><span class="comment"> * 前序遍历 中左右  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> list;  </span><br><span class="line">    &#125;  </span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  </span><br><span class="line">    stack.push(root);  </span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;  </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();  </span><br><span class="line">        list.add(pop.val);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 栈先进后出，先进右  </span></span><br><span class="line">        <span class="keyword">if</span> (pop.right != <span class="literal">null</span>) &#123;  </span><br><span class="line">            stack.push(pop.right);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (pop.left != <span class="literal">null</span>) &#123;  </span><br><span class="line">            stack.push(pop.left);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> list;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="94二叉树的中序遍历">94二叉树的中序遍历</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/" >https://leetcode.cn/problems/binary-tree-inorder-traversal/description/<i class="fas fa-external-link-alt"></i></a>)<br>中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了<strong>处理顺序和访问顺序是不一致的。</strong><br>那么<strong>在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    inOrder(root, list);  </span><br><span class="line">    <span class="keyword">return</span> list;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 中序遍历  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list 遍历结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; list)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    inOrder(root.left, list);  </span><br><span class="line">    list.add(root.val);  </span><br><span class="line">    inOrder(root.right, list);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 迭代法  </span></span><br><span class="line"><span class="comment"> * 中序遍历 左中右  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> list;  </span><br><span class="line">    &#125;  </span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;  </span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() || cur != <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="comment">// 先遍历左子节点(直至到最后一个左子节点)  </span></span><br><span class="line">            stack.push(cur);  </span><br><span class="line">            cur = cur.left;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// 此时从栈里弹出的数据，就是要处理的数据  </span></span><br><span class="line">            cur = stack.pop();  </span><br><span class="line">            list.add(cur.val);  </span><br><span class="line">            cur = cur.right;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> list;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="145二叉树的后序遍历">145二叉树的后序遍历</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/" >https://leetcode.cn/problems/binary-tree-postorder-traversal/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归法</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    postOrder(root, list);  </span><br><span class="line">    <span class="keyword">return</span> list;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 后序遍历  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list 遍历结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; list)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    postOrder(root.left, list);  </span><br><span class="line">    postOrder(root.right, list);  </span><br><span class="line">    list.add(root.val);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 后序遍历 左右中  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> list;  </span><br><span class="line">    &#125;  </span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  </span><br><span class="line">    stack.push(root);  </span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;  </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();  </span><br><span class="line">        list.add(pop.val);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 栈先进后出，先进右  </span></span><br><span class="line">        <span class="keyword">if</span> (pop.left != <span class="literal">null</span>) &#123;  </span><br><span class="line">            stack.push(pop.left);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (pop.right != <span class="literal">null</span>) &#123;  </span><br><span class="line">            stack.push(pop.right);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 上部分代码与前序相同，left和right遍历顺序颠倒。得到的数组为中右左遍历得出的结果  </span></span><br><span class="line">    <span class="comment">// 翻转得到的结果，即为左右中遍历得出的结果  </span></span><br><span class="line">    Collections.reverse(list);  </span><br><span class="line">    <span class="keyword">return</span> list;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1>看解析</h1><h2 id="❗递归的三要素">❗递归的三要素</h2><p>文章讲解：(<a class="link"   href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html" >https://programmercarl.com/二叉树的递归遍历.html<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</p></li><li class="lvl-3"><p><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</p></li><li class="lvl-3"><p><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</p></li></ol><h2 id="迭代法">迭代法</h2><p><strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>所以所有递归的题目，理论上都可以使用栈解决。题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html" >https://programmercarl.com/二叉树的迭代遍历.html<i class="fas fa-external-link-alt"></i></a>)</p><h1>统一迭代</h1><p><strong>迭代法实现的先中后序，其实风格也不是那么统一，除了先序和后序，有关联，中序完全就是另一个风格了，一会用栈遍历，一会又用指针来遍历。</strong><br>在迭代法的中序遍历中提到说使用栈的话，<strong>无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况</strong>。<strong>那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong> 这种方法也可以叫做标记法。题目链接/文章讲解：(<a class="link"   href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html" >https://programmercarl.com/二叉树的统一迭代法.html<i class="fas fa-external-link-alt"></i></a>)</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
递归、迭代、统一迭代。都是看完解析之后完成的。统一迭代有点难理解。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-03 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="二叉树" scheme="https://kiml.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第十一天-239滑动窗口最大值、347前 K 个高频元素</title>
    <link href="https://kiml.github.io/2024/05/31/100000016/"/>
    <id>https://kiml.github.io/2024/05/31/100000016/</id>
    <published>2024-05-31T02:33:19.000Z</published>
    <updated>2024-06-01T03:00:19.391Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：239超时，347直接用的Stream流。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">24.05.31 初始记录</span><br><span class="line">24.06.01 完成题目</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="239滑动窗口最大值">239滑动窗口最大值</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/sliding-window-maximum/description/" >https://leetcode.cn/problems/sliding-window-maximum/description/<i class="fas fa-external-link-alt"></i></a>)<br>暴力解法：循环判断最大值（超时）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LE239</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();  </span><br><span class="line">        <span class="type">int</span>[] split = Arrays.stream(s.split(<span class="string">&quot;,&quot;</span>)).mapToInt(Integer::parseInt).toArray();  </span><br><span class="line">        <span class="type">int</span>[] ints = maxSlidingWindow(split, Integer.parseInt(scanner.nextLine()));  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> anInt : ints) &#123;  </span><br><span class="line">            System.out.println(anInt);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= k) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;getMax(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>)&#125;;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= nums.length - k; i++) &#123;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> getMax(nums, i, i + k - <span class="number">1</span>);  </span><br><span class="line">            list.add(max);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> list.stream().mapToInt(i -&gt; i).toArray();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i; k &lt;= j; k++) &#123;  </span><br><span class="line">            max = Math.max(max, nums[k]);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> max;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="347前-K-个高频元素">347前 K 个高频元素</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/top-k-frequent-elements/description/" >https://leetcode.cn/problems/top-k-frequent-elements/description/<i class="fas fa-external-link-alt"></i></a>)</p><p>直接用Stream流的解法，估计上班会用这个。。。甚至可以优化成一行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;  </span><br><span class="line">    <span class="comment">// map用于计数  </span></span><br><span class="line">    TreeMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;  </span><br><span class="line">        map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> map.entrySet().stream()  </span><br><span class="line">            .sorted((o1, o2) -&gt; o2.getValue() - o1.getValue())  </span><br><span class="line">            .limit(k)  </span><br><span class="line">            .map(Map.Entry::getKey)  </span><br><span class="line">            .mapToInt(i -&gt; i)  </span><br><span class="line">            .toArray();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看解析</h1><h2 id="239滑动窗口最大值-2">239滑动窗口最大值</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html#%E6%80%9D%E8%B7%AF" >https://programmercarl.com/0239.滑动窗口最大值.html#思路<i class="fas fa-external-link-alt"></i></a>)</p><blockquote><p>思路：这题放在队列专题，肯定是要用到队列思想的。按暴力的解法，求最大值的那个循环（这样效率就是<code>O(n * k)</code>），在这边可以用单调队列解决。<br><strong>其实队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。</strong><br>那么这个维护元素单调递减的队列就叫做<strong>单调队列，即单调递减或单调递增的队列。Java中没有直接支持单调队列，需要我们自己来实现一个单调队列</strong></p></blockquote><p>设计单调队列的时候，pop，和push操作要保持如下规则：</p><ol><li class="lvl-3"><p>pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作</p></li><li class="lvl-3"><p>push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止（<strong>所以这里要用while</strong>）</p></li></ol><p>保持如上规则，每次窗口移动的时候，只要问que.peek()就可以返回当前窗口的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 定义一个单调队列  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;  </span><br><span class="line">    Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> num)</span> &#123;  </span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty() &amp;&amp; num &gt; deque.getLast()) &#123;  </span><br><span class="line">            deque.removeLast();  </span><br><span class="line">        &#125;  </span><br><span class="line">        deque.add(num);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 判断队顶元素是否是要移除的元素  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pull</span><span class="params">(<span class="type">int</span> num)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!deque.isEmpty() &amp;&amp; deque.peek() == num) &#123;  </span><br><span class="line">            deque.poll();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> deque.peek();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;  </span><br><span class="line">    <span class="type">MyQueue</span> <span class="variable">myQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyQueue</span>();  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;  </span><br><span class="line">        myQueue.push(nums[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - k + <span class="number">1</span>];  </span><br><span class="line">    ints[j++] = myQueue.peek();  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt;nums.length; i++) &#123;  </span><br><span class="line">        <span class="comment">// 窗口滑动，移除元素（移除时要判断元素是否在单调队列内）  </span></span><br><span class="line">        myQueue.pull(nums[i - k]);  </span><br><span class="line">        <span class="comment">// 窗口滑动，添加最新元素到单调队列  </span></span><br><span class="line">        myQueue.push(nums[i]);  </span><br><span class="line">        <span class="comment">// 获取单调队列队顶元素（根据定义的规则，一定是区间内最大的）  </span></span><br><span class="line">        ints[j++] = myQueue.peek();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> ints;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="347前-K-个高频元素-2">347前 K 个高频元素</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0347.%E5%89%8DK%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html" >https://programmercarl.com/0347.前K个高频元素.html<i class="fas fa-external-link-alt"></i></a>)<br>这题属于：前K个大数问题。这种问题一般用<strong>大顶堆</strong>（根节点最大）或<strong>小顶堆</strong>（根节点最小）。需要使用小顶堆，<strong>因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。</strong></p><p>emmmmm感觉和Stream流没有什么区别（可能在于他用的容器吧）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Comparator接口说明:</span></span><br><span class="line"><span class="comment"> * 返回负数，形参中第一个参数排在前面；返回正数，形参中第二个参数排在前面</span></span><br><span class="line"><span class="comment"> * 对于队列：排在前面意味着往队头靠</span></span><br><span class="line"><span class="comment"> * 对于堆（使用PriorityQueue实现）：从队头到队尾按从小到大排就是最小堆（小顶堆），</span></span><br><span class="line"><span class="comment"> *                                从队头到队尾按从大到小排就是最大堆（大顶堆）---&gt;队头元素相当于堆的根节点</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//解法1：基于大顶堆实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent1(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">//key为数组元素值,val为对应出现次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在优先队列中存储二元组(num, cnt),cnt表示元素值num在数组中的出现次数</span></span><br><span class="line">        <span class="comment">//出现次数按从队头到队尾的顺序是从大到小排,出现次数最多的在队头(相当于大顶堆)</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((pair1, pair2) -&gt; pair2[<span class="number">1</span>] - pair1[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;<span class="comment">//大顶堆需要对所有元素进行排序</span></span><br><span class="line">            pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(), entry.getValue()&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123; <span class="comment">//依次从队头弹出k个,就是出现频率前k高的元素</span></span><br><span class="line">            ans[i] = pq.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//解法2：基于小顶堆实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent2(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">//key为数组元素值,val为对应出现次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在优先队列中存储二元组(num, cnt),cnt表示元素值num在数组中的出现次数</span></span><br><span class="line">        <span class="comment">//出现次数按从队头到队尾的顺序是从小到大排,出现次数最低的在队头(相当于小顶堆)</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((pair1, pair2) -&gt; pair1[<span class="number">1</span>] - pair2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; <span class="comment">//小顶堆只需要维持k个元素有序</span></span><br><span class="line">            <span class="keyword">if</span> (pq.size() &lt; k) &#123; <span class="comment">//小顶堆元素个数小于k个时直接加</span></span><br><span class="line">                pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(), entry.getValue()&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry.getValue() &gt; pq.peek()[<span class="number">1</span>]) &#123; <span class="comment">//当前元素出现次数大于小顶堆的根结点(这k个元素中出现次数最少的那个)</span></span><br><span class="line">                    pq.poll(); <span class="comment">//弹出队头(小顶堆的根结点),即把堆里出现次数最少的那个删除,留下的就是出现次数多的了</span></span><br><span class="line">                    pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(), entry.getValue()&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">//依次弹出小顶堆,先弹出的是堆的根,出现次数少,后面弹出的出现次数多</span></span><br><span class="line">            ans[i] = pq.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：239超时，347直接用的Stream流。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.05.31 初始记录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24.06.01 完成题目&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="队列" scheme="https://kiml.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
    <category term="单调队列" scheme="https://kiml.github.io/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
    <category term="优先级队列" scheme="https://kiml.github.io/tags/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>面试-SPI</title>
    <link href="https://kiml.github.io/2024/05/30/100000017/"/>
    <id>https://kiml.github.io/2024/05/30/100000017/</id>
    <published>2024-05-30T08:37:53.000Z</published>
    <updated>2024-06-02T14:30:11.967Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>SPI相关的面试问题及用法</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.05.30 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="SPI介绍">SPI介绍</h2><p>​SPI全称Service Provider Interface，是Java提供的一套用来被第三方实现或者扩展的API，它可以用来启用框架扩展和替换组件。<br>Java的SPI机制就是将一些==<strong>类信息写在约定的文件中</strong>==，然后由特定的类加载器ServiceLoader加载解析文件获取资源。<br>Java SPI 基于 “<strong>接口编程＋策略模式＋配置文件</strong>(约定)”组合实现的动态加载机制。它提供了一种服务发现机制，允许在程序外部动态指定具体实现。一般情况下是调用方调用实现好的接口，但是当接口存在于调用方这边时，就是 SPI ，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。​以下是SPI的一些运用场景:</p><table><thead><tr><th>场景</th><th>说明</th></tr></thead><tbody><tr><td>数据库驱动</td><td>数据库驱动加载接口实现类的加载 JDBC加载不同类型数据库的驱动</td></tr><tr><td>日志门面SLF4J接口实现类加载</td><td>SLF4J加载不同提供商的日志实现类</td></tr><tr><td>Spring</td><td>Spring中大量使用了SPI,比如：对servlet3.0规范对ServletContainerInitializer的实现、自动类型转换Type Conversion SPI(Converter SPI、Formatter SPI)等</td></tr><tr><td>Dubbo</td><td>Dubbo中也大量使用SPI的方式实现框架的扩展, 不过它对Java提供的原生SPI做了封装，允许用户扩展实现Filter接口</td></tr><tr><td>SpringBoot</td><td>SpringBoot基于SPI思想实现自动装配</td></tr><tr><td>插件扩展</td><td>开源框架，想使用别人的插件，扩展某个功能。</td></tr></tbody></table><h2 id="ServiceLoader"><a class="link"   href="https://javaguide.cn/java/basis/spi.html#serviceloader" >ServiceLoader<i class="fas fa-external-link-alt"></i></a></h2><p>点击标题跳转链接到JavaGuide。</p><h2 id="面试大白话">面试大白话</h2><p>Java中的SPI就是你提供一个接口，然后让别人提供实现类。然后将这个实现放在<code>resources/META-INF/services/</code>中。这样Java启动的时候就会去扫描这个下面的jar包，并把他加载进来。一般来说用在开源框架中的插件扩展，然后比较常见的思想提现就是Java的JDBC实现，可以根据自己使用的数据库，将对应的jar包引用进来。</p><p>（Dubbo中可能问到的问题）Dubbo中也使用了这个思想: 比如说有一行代码是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Protocol</span> <span class="variable">protocol</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();</span><br></pre></td></tr></table></figure><p>然后在使用Protocol接口时，dubbo他会去找一个你配置的Protocol，他就会将你配置的Protocol实现类，加载到jvm中来，然后实例化对象，就用你的那个Protocol实现类就可以了。这个Protocol就是用来配置他的网络协议的，然后在源码中可以看到，默认使用的是dubbo协议，就是DubboProtocol。dubbo里面提供了大量的类似上面的扩展点，就是说，你如果要扩展一个东西，只要自己写个jar，让你的consumer或者是provider工程，依赖你的那个jar，在你的jar里指定目录下配置好接口名称对应的文件，里面通过key=实现类（这些都可以在官网的文档里找到）。</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
SPI相关的面试问题及用法&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.05.30 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="八股文" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="SPI" scheme="https://kiml.github.io/tags/SPI/"/>
    
    <category term="面试题" scheme="https://kiml.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="Java基础" scheme="https://kiml.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>【代码模板】文件存储</title>
    <link href="https://kiml.github.io/2024/05/30/100000014/"/>
    <id>https://kiml.github.io/2024/05/30/100000014/</id>
    <published>2024-05-30T07:13:41.000Z</published>
    <updated>2024-06-01T03:35:56.227Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>项目中常用到文件上传的功能。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.05.30 初始记录（Minio，阿里云OSS）</span><br></pre></td></tr></table></figure><span id="more"></span><h1>文件上传</h1><ol><li class="lvl-3"><p>校验</p><ul class="lvl-2"><li class="lvl-6">文件是否为空</li><li class="lvl-6">文件的格式</li><li class="lvl-6">文件的大小</li></ul></li><li class="lvl-3"><p>文件重命名</p></li><li class="lvl-3"><p>文件目录分离</p><ul class="lvl-2"><li class="lvl-6">使用目录分离算法(Hash把hash值作为目录名称)</li><li class="lvl-6">按照日期分目录(每天创建一个新的目录)</li><li class="lvl-6">按照用户名分目录</li></ul></li><li class="lvl-3"><p>图片保存地点</p><ul class="lvl-2"><li class="lvl-6">web服务器（项目所运行在的电脑）</li><li class="lvl-6">云存储服务商</li><li class="lvl-6">自己搭建文件服务器（FastDFS Minio）</li></ul></li></ol><h2 id="通用部分代码">通用部分代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 文件上传  </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> file 文件  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Boolean  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;common&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonController</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> R <span class="title function_">uploadPic</span><span class="params">(MultipartFile file)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 校验</span></span><br><span class="line">        <span class="comment">// 校验文件是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (ObjectUtil.isNull(file)) <span class="keyword">return</span> R.error(<span class="string">&quot;上传文件不能为空&quot;</span>);</span><br><span class="line">        <span class="comment">// 校验文件的格式</span></span><br><span class="line">        <span class="keyword">if</span> (!StrUtil.containsAnyIgnoreCase(FileUtil.getSuffix(file.getOriginalFilename()), <span class="string">&quot;jpg&quot;</span>, <span class="string">&quot;png&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> R.error(<span class="string">&quot;上传文件格式错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 校验文件的大小</span></span><br><span class="line">        <span class="keyword">if</span> (file.getSize() / <span class="number">1024</span> / <span class="number">1024</span> &gt; <span class="number">2</span>) <span class="keyword">return</span> R.error(<span class="string">&quot;文件过大，限制在2MB以内&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 给文件进行重命名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> UUID.fastUUID().toString() + <span class="string">&quot;.&quot;</span> + FileUtil.getSuffix(file.getOriginalFilename());</span><br><span class="line">        <span class="comment">// 给文件目录分离</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 图片保存地点（不同保存地点实现方式不同）</span></span><br><span class="line">        .....</span><br><span class="line">        <span class="keyword">return</span> R.success(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同的保存地点">不同的保存地点</h2><h2 id="web服务器（项目所运行在的电脑）">web服务器（项目所运行在的电脑）</h2><ol><li class="lvl-3"><p>文件上传部分代码</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种情况下，文件存储路径为服务器上的路径名称</span></span><br><span class="line">file.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\images\\&quot;</span> + fileName));</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>下载</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>前端直接访问服务器域名+存储地址</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种情况下，代码中需要添加访问资源映射地址</span></span><br><span class="line"><span class="comment">// 在拦截器中配置</span></span><br><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> AuthInterceptor authInterceptor;  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DWG</span> <span class="operator">=</span> <span class="string">&quot;file:&quot;</span> + <span class="string">&quot;D:/images/&quot;</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">    <span class="comment">// 添加访问资源的地址</span></span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/virtual/**&quot;</span>).addResourceLocations(DWG);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;  </span><br><span class="line">        registry.addInterceptor(authInterceptor)  </span><br><span class="line">                .addPathPatterns(<span class="string">&quot;/**&quot;</span>)  </span><br><span class="line">                .excludePathPatterns(<span class="string">&quot;/**/login/**&quot;</span>, <span class="string">&quot;/**/*.html&quot;</span>, <span class="string">&quot;/**/*.js&quot;</span>, <span class="string">&quot;/**/*.css&quot;</span>, <span class="string">&quot;/doc.*&quot;</span>,  </span><br><span class="line">                        <span class="string">&quot;/swagger-ui.*&quot;</span>,  </span><br><span class="line">                        <span class="string">&quot;/swagger-resources&quot;</span>,  </span><br><span class="line">                        <span class="string">&quot;/webjars/**&quot;</span>,  </span><br><span class="line">                        <span class="string">&quot;/v2/api-docs/**&quot;</span>,  </span><br><span class="line">                        <span class="string">&quot;/virtual/**&quot;</span>  </span><br><span class="line">                );  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>前端通过接口下载文件</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;download&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">downloadPic</span><span class="params">(String name, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\images\\&quot;</span> + name);</span><br><span class="line">    <span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((len = fileInputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        outputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fileInputStream.close();</span><br><span class="line">    outputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="云存储服务商">云存储服务商</h2><p>通过开通云存储服务商的OSS服务，调用提供的API，实现文件存储。一般后面两种情况会直接编写Util类方便多处调用。</p><h3 id="阿里云">阿里云</h3><h4 id="Maven依赖">Maven依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aliyun.oss<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置文件">配置文件</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">aliyun:</span>  </span><br><span class="line">  <span class="attr">oss:</span>  </span><br><span class="line">    <span class="attr">endpoint:</span> <span class="string">oss-cn-hangzhou.aliyuncs.com</span>  </span><br><span class="line">    <span class="attr">accessKeyId:</span> <span class="string">xxxxxxxxxxxxxxxx</span>  </span><br><span class="line">    <span class="attr">accessKeySecret:</span> <span class="string">xxxxxxxxxxxxxxxx</span>  </span><br><span class="line">    <span class="attr">bucket:</span>  <span class="string">xxxxxxxxxxxxxxxx</span></span><br><span class="line">    <span class="attr">userFolder:</span> <span class="string">user/</span>  </span><br><span class="line">    <span class="attr">managerFolder:</span> <span class="string">manager/</span></span><br></pre></td></tr></table></figure><h4 id="代码">代码</h4><ul class="lvl-0"><li class="lvl-2"><p>OssAutoConfiguration.java</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123;OSSClient.class&#125;)</span>  </span><br><span class="line"><span class="meta">@EnableConfigurationProperties(OssProperties.class)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OssAutoConfiguration</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OssProperties ossProperties;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OssAutoConfiguration</span><span class="params">(<span class="keyword">final</span> OssProperties ossProperties)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.ossProperties = ossProperties;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> OssClientFactoryBean <span class="title function_">ossClientFactoryBean</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">final</span> <span class="type">OssClientFactoryBean</span> <span class="variable">factoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OssClientFactoryBean</span>();  </span><br><span class="line">        factoryBean.setEndpoint(<span class="built_in">this</span>.ossProperties.getEndpoint());  </span><br><span class="line">        factoryBean.setAccessKeyId(<span class="built_in">this</span>.ossProperties.getAccessKeyId());  </span><br><span class="line">        factoryBean.setAccessKeySecret(<span class="built_in">this</span>.ossProperties.getAccessKeySecret());  </span><br><span class="line">        <span class="keyword">return</span> factoryBean;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>OssClientFactoryBean.class</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OssClientFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;OSSClient&gt;, InitializingBean, DisposableBean &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> OSSClient ossClient;  </span><br><span class="line">    <span class="keyword">private</span> String endpoint;  </span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;  </span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> OSSClient <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.ossClient;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;  </span><br><span class="line">        <span class="keyword">return</span> OSSClient.class;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.ossClient != <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="built_in">this</span>.ossClient.shutdown();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        Assert.notNull(<span class="built_in">this</span>.endpoint, <span class="string">&quot;&#x27;aliyun.oss.endpoint&#x27; must be not null&quot;</span>);  </span><br><span class="line">        Assert.notNull(<span class="built_in">this</span>.accessKeyId, <span class="string">&quot;&#x27;aliyun.oss.accessKeyId&#x27; must be not null&quot;</span>);  </span><br><span class="line">        Assert.notNull(<span class="built_in">this</span>.accessKeySecret, <span class="string">&quot;&#x27;aliyun.oss.accessKeySecret&#x27; must be not null&quot;</span>);  </span><br><span class="line">        <span class="built_in">this</span>.ossClient = <span class="keyword">new</span> <span class="title class_">OSSClient</span>(<span class="built_in">this</span>.endpoint, <span class="built_in">this</span>.accessKeyId, <span class="built_in">this</span>.accessKeySecret);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEndpoint</span><span class="params">(<span class="keyword">final</span> String endpoint)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.endpoint = endpoint;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccessKeyId</span><span class="params">(<span class="keyword">final</span> String accessKeyId)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.accessKeyId = accessKeyId;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccessKeySecret</span><span class="params">(<span class="keyword">final</span> String accessKeySecret)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.accessKeySecret = accessKeySecret;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>OssProperties.java</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span>  </span><br><span class="line"><span class="meta">@Setter</span>  </span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;aliyun.oss&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OssProperties</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String endpoint;  </span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;  </span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret;  </span><br><span class="line">    <span class="keyword">private</span> String bucket;  </span><br><span class="line">    <span class="keyword">private</span> String userFolder;  </span><br><span class="line">    <span class="keyword">private</span> String managerFolder;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>OssUtil.class</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OssUtil</span> &#123;  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> OSSClient ossClient;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> OssProperties ossProperties;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 上传文件  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> folder &quot;需要加/ 如&quot;xxx/&quot;&quot;  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 文件地址  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(MultipartFile file, String folder)</span> &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">bucketName</span> <span class="operator">=</span> ossProperties.getBucket();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 判断Bucket的存在  </span></span><br><span class="line">        <span class="keyword">if</span> (!ossClient.doesBucketExist(bucketName)) &#123;  </span><br><span class="line">            <span class="comment">// 创建存储空间  </span></span><br><span class="line">            <span class="type">Bucket</span> <span class="variable">bucket</span> <span class="operator">=</span> ossClient.createBucket(bucketName);  </span><br><span class="line">            bucketName = bucket.getName();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">String</span> <span class="variable">objectName</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">// 以输入流的形式上传文件  </span></span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> file.getInputStream();  </span><br><span class="line">            <span class="comment">// 文件名  </span></span><br><span class="line">            <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> file.getOriginalFilename();  </span><br><span class="line">            <span class="keyword">if</span> (ObjectUtil.isNull(originalFilename)) &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LogicException</span>(<span class="string">&quot;文件名称获取失败&quot;</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="type">val</span> <span class="variable">suffix</span> <span class="operator">=</span> originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));  </span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> UUID.fastUUID().toString() + suffix.toLowerCase();  </span><br><span class="line">            objectName = folder + DateUtil.format(<span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="string">&quot;yy-MM/dd&quot;</span>) + <span class="string">&quot;/&quot;</span> + fileName;  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 文件大小  </span></span><br><span class="line">            <span class="type">long</span> <span class="variable">fileSize</span> <span class="operator">=</span> file.getSize();  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 创建上传Object的Metadata  </span></span><br><span class="line">            <span class="type">ObjectMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMetadata</span>();  </span><br><span class="line">            <span class="comment">// 上传的文件的长度  </span></span><br><span class="line">            metadata.setContentLength(is.available());  </span><br><span class="line">            <span class="comment">// 指定该Object被下载时的网页的缓存行为  </span></span><br><span class="line">            metadata.setCacheControl(<span class="string">&quot;no-cache&quot;</span>);  </span><br><span class="line">            <span class="comment">// 指定该Object下设置Header  </span></span><br><span class="line">            metadata.setHeader(<span class="string">&quot;Pragma&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);  </span><br><span class="line">            <span class="comment">// 指定该Object被下载时的内容编码格式  </span></span><br><span class="line">            metadata.setContentEncoding(<span class="string">&quot;utf-8&quot;</span>);  </span><br><span class="line">            <span class="comment">// 文件的MIME，定义文件的类型及网页编码，决定浏览器将以什么形式、什么编码读取文件。如果用户没有指定则根据Key或文件名的扩展名生成，  </span></span><br><span class="line">            <span class="comment">// 如果没有扩展名则填默认值application/octet-stream  </span></span><br><span class="line">            metadata.setContentType(AliyunOssFileTypeEnum.getText(suffix.toLowerCase()));  </span><br><span class="line">            <span class="comment">// 指定该Object被下载时的名称（指示MINME用户代理如何显示附加的文件，打开或下载，及文件名称）  </span></span><br><span class="line">            metadata.setContentDisposition(<span class="string">&quot;filename/filesize=&quot;</span> + originalFilename + <span class="string">&quot;/&quot;</span> + fileSize + <span class="string">&quot;Byte.&quot;</span>);  </span><br><span class="line">            <span class="comment">// 上传文件 (上传文件流的形式)  </span></span><br><span class="line">            <span class="type">PutObjectResult</span> <span class="variable">putResult</span> <span class="operator">=</span> ossClient.putObject(bucketName, objectName, is, metadata);  </span><br><span class="line">            <span class="comment">// 解析结果  </span></span><br><span class="line">            <span class="type">String</span> <span class="variable">resultStr</span> <span class="operator">=</span> putResult.getETag();  </span><br><span class="line">            log.info(<span class="string">&quot;唯一MD5数字签名:&quot;</span> + resultStr);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (OSSException oe) &#123;  </span><br><span class="line">            <span class="comment">// oe.printStackTrace();  </span></span><br><span class="line">            log.error(<span class="string">&quot;上传阿里云OSS服务器异常.&quot;</span> + oe.getMessage(), oe);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException ce) &#123;  </span><br><span class="line">            <span class="comment">// ce.printStackTrace();  </span></span><br><span class="line">            log.error(<span class="string">&quot;阿里云OSS服务连接异常.&quot;</span> + ce.getMessage(), ce);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            <span class="comment">// e.printStackTrace();  </span></span><br><span class="line">            log.error(<span class="string">&quot;文件流异常.&quot;</span> + e.getMessage(), e);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;https://&quot;</span> + ossProperties.getBucket() + <span class="string">&quot;.&quot;</span> + ossProperties.getEndpoint() + <span class="string">&quot;/&quot;</span> + objectName;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 上传文件 byte ()  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> folder &quot;需要加/ 如&quot;xxx/&quot;&quot;  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 文件地址  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">imgUploadByByte</span><span class="params">(<span class="type">byte</span>[] bytes, String folder)</span> &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">bucketName</span> <span class="operator">=</span> ossProperties.getBucket();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 判断Bucket的存在  </span></span><br><span class="line">        <span class="keyword">if</span> (!ossClient.doesBucketExist(bucketName)) &#123;  </span><br><span class="line">            <span class="comment">// 创建存储空间  </span></span><br><span class="line">            <span class="type">Bucket</span> <span class="variable">bucket</span> <span class="operator">=</span> ossClient.createBucket(bucketName);  </span><br><span class="line">            bucketName = bucket.getName();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">String</span> <span class="variable">objectName</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);  </span><br><span class="line">  </span><br><span class="line">            <span class="type">val</span> <span class="variable">suffix</span> <span class="operator">=</span> <span class="string">&quot;jpg&quot;</span>;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> UUID.fastUUID().toString() +suffix;  </span><br><span class="line">            objectName = folder + DateUtil.format(<span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="string">&quot;yy-MM/dd&quot;</span>) + <span class="string">&quot;/&quot;</span> + fileName;  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 创建上传Object的Metadata  </span></span><br><span class="line">            <span class="type">ObjectMetadata</span> <span class="variable">metadata</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMetadata</span>();  </span><br><span class="line">            <span class="comment">// 上传的文件的长度  </span></span><br><span class="line">            metadata.setContentLength(inputStream.available());  </span><br><span class="line">            <span class="comment">// 指定该Object被下载时的网页的缓存行为  </span></span><br><span class="line">            metadata.setCacheControl(<span class="string">&quot;no-cache&quot;</span>);  </span><br><span class="line">            <span class="comment">// 指定该Object下设置Header  </span></span><br><span class="line">            metadata.setHeader(<span class="string">&quot;Pragma&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);  </span><br><span class="line">            <span class="comment">// 指定该Object被下载时的内容编码格式  </span></span><br><span class="line">            metadata.setContentEncoding(<span class="string">&quot;utf-8&quot;</span>);  </span><br><span class="line">            <span class="comment">// 文件的MIME，定义文件的类型及网页编码，决定浏览器将以什么形式、什么编码读取文件。如果用户没有指定则根据Key或文件名的扩展名生成，  </span></span><br><span class="line">            <span class="comment">// 如果没有扩展名则填默认值application/octet-stream  </span></span><br><span class="line">            metadata.setContentType(AliyunOssFileTypeEnum.getText(suffix));  </span><br><span class="line">            <span class="comment">// 上传文件 (上传文件流的形式)  </span></span><br><span class="line">            <span class="type">PutObjectResult</span> <span class="variable">putResult</span> <span class="operator">=</span> ossClient.putObject(bucketName, objectName, inputStream, metadata);  </span><br><span class="line">            <span class="comment">// 解析结果  </span></span><br><span class="line">            <span class="type">String</span> <span class="variable">resultStr</span> <span class="operator">=</span> putResult.getETag();  </span><br><span class="line">            log.info(<span class="string">&quot;唯一MD5数字签名:&quot;</span> + resultStr);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (OSSException oe) &#123;  </span><br><span class="line">            <span class="comment">// oe.printStackTrace();  </span></span><br><span class="line">            log.error(<span class="string">&quot;上传阿里云OSS服务器异常.&quot;</span> + oe.getMessage(), oe);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClientException ce) &#123;  </span><br><span class="line">            <span class="comment">// ce.printStackTrace();  </span></span><br><span class="line">            log.error(<span class="string">&quot;阿里云OSS服务连接异常.&quot;</span> + ce.getMessage(), ce);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            <span class="comment">// e.printStackTrace();  </span></span><br><span class="line">            log.error(<span class="string">&quot;文件流异常.&quot;</span> + e.getMessage(), e);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;https://&quot;</span> + ossProperties.getBucket() + <span class="string">&quot;.&quot;</span> + ossProperties.getEndpoint() + <span class="string">&quot;/&quot;</span> + objectName;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 根据objectName删除OSS服务器上的文件  </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> objectName     模拟文件夹名 如&quot;qj_nanjing/&quot; + Bucket下的文件的路径名+文件名 如：&quot;upload/cake.jpg&quot;  </span></span><br><span class="line"><span class="comment">     */</span>   </span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">deleteFile</span><span class="params">(String objectName)</span> &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">bucketName</span> <span class="operator">=</span> ossProperties.getBucket();  </span><br><span class="line">        ossClient.deleteObject(bucketName, objectName);  </span><br><span class="line">        log.info(<span class="string">&quot;删除&quot;</span> + bucketName + <span class="string">&quot;下的文件&quot;</span> + objectName + <span class="string">&quot;成功&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 根据url获取objectName  </span></span><br><span class="line"><span class="comment">     *     * <span class="doctag">@param</span> url url  </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getObjectNameByUrl</span><span class="params">(String url)</span> &#123;  </span><br><span class="line"><span class="comment">//        url = url.replace(&quot;https://&quot; + ossProperties.getBucket() + &quot;.&quot; + ossProperties.getEndpoint() + &quot;/&quot;, &quot;&quot;);  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">firstIndex</span> <span class="operator">=</span> url.indexOf(<span class="string">&quot;/&quot;</span>);  </span><br><span class="line">        <span class="type">int</span> <span class="variable">secondIndex</span> <span class="operator">=</span> url.indexOf(<span class="string">&quot;/&quot;</span>, firstIndex + <span class="number">1</span>);  </span><br><span class="line">        <span class="type">int</span> <span class="variable">thirdIndex</span> <span class="operator">=</span> url.indexOf(<span class="string">&quot;/&quot;</span>, secondIndex + <span class="number">1</span>);  </span><br><span class="line">        <span class="type">int</span> <span class="variable">suffix</span> <span class="operator">=</span> url.lastIndexOf(<span class="string">&quot;?&quot;</span>) &gt; <span class="number">0</span> ? url.lastIndexOf(<span class="string">&quot;?&quot;</span>) : url.length();  </span><br><span class="line">        url = url.substring(thirdIndex + <span class="number">1</span>, suffix);  </span><br><span class="line">        <span class="keyword">return</span> url;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 获取上传文件url (非公共读写时)  </span></span><br><span class="line"><span class="comment">     *     * <span class="doctag">@param</span> objectName 模拟文件夹名 如&quot;qj_nanjing/&quot; + Bucket下的文件的路径名+文件名 如：&quot;upload/cake.jpg&quot;  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> url  </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUrl</span><span class="params">(String objectName)</span> &#123;  </span><br><span class="line">        <span class="comment">//设置URl过期时间为99年：3600L*1000*24*365*99  </span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">expiration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="keyword">new</span> <span class="title class_">Date</span>().getTime() + <span class="number">3600L</span> * <span class="number">1000</span> * <span class="number">24</span> * <span class="number">365</span> * <span class="number">99</span>);  </span><br><span class="line">        <span class="type">GeneratePresignedUrlRequest</span> <span class="variable">generatePresignedUrlRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneratePresignedUrlRequest</span>(ossProperties.getBucket(), objectName);  </span><br><span class="line">        generatePresignedUrlRequest.setExpiration(expiration);  </span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> ossClient.generatePresignedUrl(generatePresignedUrlRequest);  </span><br><span class="line">        <span class="keyword">return</span> url.toString();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Minio">Minio</h3><h4 id="Maven依赖-2">Maven依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.minio<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>minio<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SPI--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置文件-2">配置文件</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">minio:</span>  </span><br><span class="line">  <span class="attr">endpoint:</span> <span class="string">xxxxxxxxxxxxxxxxxxxxxx</span> <span class="comment">#MinIO服务所在地址  </span></span><br><span class="line">  <span class="attr">bucketName:</span> <span class="string">xxxxxxxxxxx</span> <span class="comment">#存储桶名称  </span></span><br><span class="line">  <span class="attr">accessKey:</span> <span class="string">xxxxxxxxxxxxxxxx</span> <span class="comment">#访问的key  </span></span><br><span class="line">  <span class="attr">secretKey:</span> <span class="string">xxxxxxxxxxxxxxxxxxx</span> <span class="comment">#访问的秘钥</span></span><br></pre></td></tr></table></figure><h4 id="代码-2">代码</h4><ul class="lvl-0"><li class="lvl-2"><p>MinioProp.java</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;minio&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinioProp</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String endpoint;  </span><br><span class="line">    <span class="keyword">private</span> String accessKey;  </span><br><span class="line">    <span class="keyword">private</span> String secretKey;  </span><br><span class="line">    <span class="keyword">private</span> String bucketName;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getEndpoint</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> endpoint;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEndpoint</span><span class="params">(String endpoint)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.endpoint = endpoint;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAccessKey</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> accessKey;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAccessKey</span><span class="params">(String accessKey)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.accessKey = accessKey;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSecretKey</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> secretKey;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSecretKey</span><span class="params">(String secretKey)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.secretKey = secretKey;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBucketName</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> bucketName;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBucketName</span><span class="params">(String bucket)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.bucketName = bucket;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>OSSFile.java</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OSSFile</span> &#123;  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 文件名  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> String fileName;  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 文件存储地址  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> String url;  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 文件ObjectName  </span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="keyword">private</span> String objectName;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>MinioUtil.java</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="meta">@Slf4j</span>  </span><br><span class="line"><span class="meta">@EnableConfigurationProperties(MinioProp.class)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinioUtil</span> &#123;  </span><br><span class="line">    <span class="meta">@Resource</span>  </span><br><span class="line">    <span class="keyword">private</span> MinioProp prop;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> MinioClient minioClient;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 创建minioClient  </span></span><br><span class="line"><span class="comment">     */</span>    <span class="meta">@PostConstruct</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createMinioClient</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">null</span> == minioClient) &#123;  </span><br><span class="line">                log.info(<span class="string">&quot;minioClient create start&quot;</span>);  </span><br><span class="line">                minioClient = MinioClient.builder().endpoint(prop.getEndpoint())  </span><br><span class="line">                        .credentials(prop.getAccessKey(), prop.getSecretKey())  </span><br><span class="line">                        .build();  </span><br><span class="line">                createBucket();  </span><br><span class="line">                log.info(<span class="string">&quot;minioClient create end&quot;</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            log.error(<span class="string">&quot;连接MinIO服务器异常：&quot;</span> + e);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 初始化Bucket  </span></span><br><span class="line"><span class="comment">     *     * <span class="doctag">@throws</span> Exception 异常  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createBucket</span><span class="params">()</span>  </span><br><span class="line">            <span class="keyword">throws</span> IOException, InvalidKeyException, InvalidResponseException, InsufficientDataException, NoSuchAlgorithmException, ServerException, InternalException, XmlParserException, InvalidBucketNameException, ErrorResponseException, RegionConflictException &#123;  </span><br><span class="line">        <span class="keyword">if</span> (!minioClient.bucketExists(BucketExistsArgs.builder().bucket(prop.getBucketName()).build())) &#123;  </span><br><span class="line">            minioClient.makeBucket(MakeBucketArgs.builder().bucket(prop.getBucketName()).build());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 查看存储bucket是否存在  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean  </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">bucketExists</span><span class="params">(String bucketName)</span> &#123;  </span><br><span class="line">        Boolean found;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            found = minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> found;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 创建存储bucket  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Boolean  </span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">makeBucket</span><span class="params">(String bucketName)</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (!bucketExists(bucketName)) &#123;  </span><br><span class="line">                minioClient.makeBucket(MakeBucketArgs.builder()  </span><br><span class="line">                        .bucket(bucketName)  </span><br><span class="line">                        .build());  </span><br><span class="line">                <span class="type">String</span> <span class="variable">policyJson</span> <span class="operator">=</span> <span class="string">&quot;&#123;\n&quot;</span> +  </span><br><span class="line">                        <span class="string">&quot;\t\&quot;Version\&quot;: \&quot;&quot;</span>+<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-mm-dd&quot;</span>).format(System.currentTimeMillis())+<span class="string">&quot;\&quot;,\n&quot;</span> +  </span><br><span class="line">                        <span class="string">&quot;\t\&quot;Statement\&quot;: [&#123;\n&quot;</span> +  </span><br><span class="line">                        <span class="string">&quot;\t\t\&quot;Effect\&quot;: \&quot;Allow\&quot;,\n&quot;</span> +  </span><br><span class="line">                        <span class="string">&quot;\t\t\&quot;Principal\&quot;: &#123;\n&quot;</span> +  </span><br><span class="line">                        <span class="string">&quot;\t\t\t\&quot;AWS\&quot;: [\&quot;*\&quot;]\n&quot;</span> +  </span><br><span class="line">                        <span class="string">&quot;\t\t&#125;,\n&quot;</span> +  </span><br><span class="line">                        <span class="string">&quot;\t\t\&quot;Action\&quot;: [\&quot;s3:GetBucketLocation\&quot;, \&quot;s3:ListBucket\&quot;, \&quot;s3:ListBucketMultipartUploads\&quot;],\n&quot;</span> +  </span><br><span class="line">                        <span class="string">&quot;\t\t\&quot;Resource\&quot;: [\&quot;arn:aws:s3:::&quot;</span> + bucketName + <span class="string">&quot;\&quot;]\n&quot;</span> +  </span><br><span class="line">                        <span class="string">&quot;\t&#125;, &#123;\n&quot;</span> +  </span><br><span class="line">                        <span class="string">&quot;\t\t\&quot;Effect\&quot;: \&quot;Allow\&quot;,\n&quot;</span> +  </span><br><span class="line">                        <span class="string">&quot;\t\t\&quot;Principal\&quot;: &#123;\n&quot;</span> +  </span><br><span class="line">                        <span class="string">&quot;\t\t\t\&quot;AWS\&quot;: [\&quot;*\&quot;]\n&quot;</span> +  </span><br><span class="line">                        <span class="string">&quot;\t\t&#125;,\n&quot;</span> +  </span><br><span class="line">                        <span class="string">&quot;\t\t\&quot;Action\&quot;: [\&quot;s3:AbortMultipartUpload\&quot;, \&quot;s3:DeleteObject\&quot;, \&quot;s3:GetObject\&quot;, \&quot;s3:ListMultipartUploadParts\&quot;, \&quot;s3:PutObject\&quot;],\n&quot;</span> +  </span><br><span class="line">                        <span class="string">&quot;\t\t\&quot;Resource\&quot;: [\&quot;arn:aws:s3:::&quot;</span> + bucketName + <span class="string">&quot;/*\&quot;]\n&quot;</span> +  </span><br><span class="line">                        <span class="string">&quot;\t&#125;]\n&quot;</span> +  </span><br><span class="line">                        <span class="string">&quot;&#125;\n&quot;</span>;  </span><br><span class="line">                minioClient.setBucketPolicy(SetBucketPolicyArgs.builder().bucket(bucketName).config(policyJson).build());  </span><br><span class="line">                log.info(<span class="string">&quot;buckets：【&#123;&#125;】,创建[readwrite]策略成功！&quot;</span>, bucketName);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                log.info(<span class="string">&quot;minio bucket-&gt;&gt;&gt;【&#123;&#125;】already exists&quot;</span>, bucketName);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 删除存储bucket  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Boolean  </span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="keyword">public</span> Boolean <span class="title function_">removeBucket</span><span class="params">(String bucketName)</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            minioClient.removeBucket(RemoveBucketArgs.builder()  </span><br><span class="line">                    .bucket(bucketName)  </span><br><span class="line">                    .build());  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 获取全部bucket  </span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="keyword">public</span> List&lt;Bucket&gt; <span class="title function_">getAllBuckets</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            List&lt;Bucket&gt; buckets = minioClient.listBuckets();  </span><br><span class="line">            <span class="keyword">return</span> buckets;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 文件上传  </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file 文件  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Boolean  </span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="keyword">public</span> OSSFile <span class="title function_">upload</span><span class="params">(MultipartFile file)</span> &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> file.getOriginalFilename();  </span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(originalFilename))&#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 重命名  </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> UUID.fastUUID() + originalFilename.substring(originalFilename.lastIndexOf(<span class="string">&quot;.&quot;</span>));  </span><br><span class="line">        <span class="type">String</span> <span class="variable">objectName</span> <span class="operator">=</span> DateUtil.format(<span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="string">&quot;yy-MM/dd&quot;</span>) + <span class="string">&quot;/&quot;</span> + fileName;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="type">PutObjectArgs</span> <span class="variable">objectArgs</span> <span class="operator">=</span> PutObjectArgs.builder().bucket(prop.getBucketName()).object(objectName)  </span><br><span class="line">                    .stream(file.getInputStream(), file.getSize(), -<span class="number">1</span>).contentType(file.getContentType()).build();  </span><br><span class="line">            <span class="comment">//文件名称相同会覆盖  </span></span><br><span class="line">            minioClient.putObject(objectArgs);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">OSSFile</span> <span class="variable">ossFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OSSFile</span>();  </span><br><span class="line">        ossFile.setFileName(originalFilename);  </span><br><span class="line">        ossFile.setObjectName(objectName);  </span><br><span class="line">        ossFile.setUrl(prop.getEndpoint() + <span class="string">&quot;/&quot;</span> + prop.getBucketName() + <span class="string">&quot;/&quot;</span> + objectName);  </span><br><span class="line">        <span class="keyword">return</span> ossFile;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 预览图片  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">preview</span><span class="params">(String fileName)</span>&#123;  </span><br><span class="line">        <span class="comment">// 查看文件地址  </span></span><br><span class="line">        <span class="type">GetPresignedObjectUrlArgs</span> <span class="variable">build</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetPresignedObjectUrlArgs</span>().builder().bucket(prop.getBucketName()).object(fileName).method(Method.GET).build();  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> minioClient.getPresignedObjectUrl(build);  </span><br><span class="line">            <span class="keyword">return</span> url;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 文件下载  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName 文件名称  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res response  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Boolean  </span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">download</span><span class="params">(String fileName, HttpServletResponse res)</span> &#123;  </span><br><span class="line">        <span class="type">GetObjectArgs</span> <span class="variable">objectArgs</span> <span class="operator">=</span> GetObjectArgs.builder().bucket(prop.getBucketName())  </span><br><span class="line">                .object(fileName).build();  </span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">response</span> <span class="operator">=</span> minioClient.getObject(objectArgs))&#123;  </span><br><span class="line">            <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];  </span><br><span class="line">            <span class="type">int</span> len;  </span><br><span class="line">            <span class="keyword">try</span> (<span class="type">FastByteArrayOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FastByteArrayOutputStream</span>())&#123;  </span><br><span class="line">                <span class="keyword">while</span> ((len=response.read(buf))!=-<span class="number">1</span>)&#123;  </span><br><span class="line">                    os.write(buf,<span class="number">0</span>,len);  </span><br><span class="line">                &#125;  </span><br><span class="line">                os.flush();  </span><br><span class="line">                <span class="type">byte</span>[] bytes = os.toByteArray();  </span><br><span class="line">                res.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);  </span><br><span class="line">                <span class="comment">// 设置强制下载不打开  </span></span><br><span class="line">                <span class="comment">// res.setContentType(&quot;application/force-download&quot;);  </span></span><br><span class="line">                res.addHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;fileName=&quot;</span> + fileName);  </span><br><span class="line">                <span class="keyword">try</span> (<span class="type">ServletOutputStream</span> <span class="variable">stream</span> <span class="operator">=</span> res.getOutputStream())&#123;  </span><br><span class="line">                    stream.write(bytes);  </span><br><span class="line">                    stream.flush();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 查看文件对象  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 存储bucket内文件对象信息  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> List&lt;Item&gt; <span class="title function_">listObjects</span><span class="params">()</span> &#123;  </span><br><span class="line">        Iterable&lt;Result&lt;Item&gt;&gt; results = minioClient.listObjects(  </span><br><span class="line">                ListObjectsArgs.builder().bucket(prop.getBucketName()).build());  </span><br><span class="line">        List&lt;Item&gt; items = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">for</span> (Result&lt;Item&gt; result : results) &#123;  </span><br><span class="line">                items.add(result.get());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> items;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 删除  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(String fileName)</span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            minioClient.removeObject( RemoveObjectArgs.builder().bucket(prop.getBucketName()).object(fileName).build());  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拓展">拓展</h4><p>Minio这个被写成了SPI加载到别的服务中，这边再加一下关于SPI的知识。<img                       lazyload                     alt="image"                     data-src="https://blog-resources.oss-cn-hangzhou.aliyuncs.com/240530/Snipaste_2024-05-30_16-20-31.png"                      alt=""                ><br>如图resources文件夹下的META-INF文件夹下的spring.factories文件。如果要把MinioUtil这个方法加载到别的项目中，可以这么写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.hzjzxx.minio.utils.MinioUtil</span><br></pre></td></tr></table></figure><p>关于SPI的知识：</p><blockquote><p>内链：[[面试-SPI]]<br>外链：<a class="link"   href="https://kiml.site/2024/05/30/100000015/" >SPI相关<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
项目中常用到文件上传的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.05.30 初始记录（Minio，阿里云OSS）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="后端项目" scheme="https://kiml.github.io/categories/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="准备工作" scheme="https://kiml.github.io/categories/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
    
    
    <category term="Minio" scheme="https://kiml.github.io/tags/Minio/"/>
    
    <category term="Oss" scheme="https://kiml.github.io/tags/Oss/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第十天-20有效的括号、1047删除字符串中的所有相邻重复项、150逆波兰表达式求值</title>
    <link href="https://kiml.github.io/2024/05/30/100000013/"/>
    <id>https://kiml.github.io/2024/05/30/100000013/</id>
    <published>2024-05-30T02:00:23.000Z</published>
    <updated>2024-05-30T03:19:09.426Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：20AC，1047AC，150AC</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.05.30 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="20有效的括号">20有效的括号</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/valid-parentheses/description/" >https://leetcode.cn/problems/valid-parentheses/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LE20</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);  </span><br><span class="line">        System.out.println(isValid(scanner.nextLine()));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;  </span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>) &#123;  </span><br><span class="line">                stack.push(c);  </span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty()) &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="type">Character</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();  </span><br><span class="line">            <span class="keyword">if</span> ((c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; pop != <span class="string">&#x27;(&#x27;</span> ) || (c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; pop != <span class="string">&#x27;[&#x27;</span> ) || (c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; pop != <span class="string">&#x27;&#123;&#x27;</span> )) &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1047删除字符串中的所有相邻重复项">1047删除字符串中的所有相邻重复项</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/" >https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);  </span><br><span class="line">    System.out.println(removeDuplicates(scanner.nextLine()));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;  </span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (stack.isEmpty()) &#123;  </span><br><span class="line">            stack.push(c);  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (c == stack.peek()) &#123;  </span><br><span class="line">            stack.pop();  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            stack.push(c);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();  </span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stack.size();  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;  </span><br><span class="line">        str.insert(<span class="number">0</span>, stack.pop());  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> str.toString();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="150逆波兰表达式求值">150逆波兰表达式求值</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/" >https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/<i class="fas fa-external-link-alt"></i></a>)<br>可以直接根据题目中给的链接查看<a class="link"   href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437" >逆波兰表示法<i class="fas fa-external-link-alt"></i></a>的意思</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;  </span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  </span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(tokens[<span class="number">0</span>]);  </span><br><span class="line">    <span class="keyword">for</span> (String token : tokens) &#123;  </span><br><span class="line">        <span class="keyword">switch</span> (token) &#123;  </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>: &#123;  </span><br><span class="line">                num = stack.pop() + stack.pop();  </span><br><span class="line">                stack.push(num);  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>: &#123;  </span><br><span class="line">                <span class="type">Integer</span> <span class="variable">num2</span> <span class="operator">=</span> stack.pop();  </span><br><span class="line">                <span class="type">Integer</span> <span class="variable">num1</span> <span class="operator">=</span> stack.pop();  </span><br><span class="line">                num = num1 - num2;  </span><br><span class="line">                stack.push(num);  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>: &#123;  </span><br><span class="line">                num = stack.pop() * stack.pop();  </span><br><span class="line">                stack.push(num);  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>: &#123;  </span><br><span class="line">                <span class="type">Integer</span> <span class="variable">num2</span> <span class="operator">=</span> stack.pop();  </span><br><span class="line">                <span class="type">Integer</span> <span class="variable">num1</span> <span class="operator">=</span> stack.pop();  </span><br><span class="line">                num = num1 / num2;  </span><br><span class="line">                stack.push(num);  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">default</span>: &#123;  </span><br><span class="line">                stack.push(Integer.parseInt(token));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> num;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看解析</h1><h2 id="20有效的括号-2">20有效的括号</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0020.%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html" >https://programmercarl.com/0020.有效的括号.html<i class="fas fa-external-link-alt"></i></a>)</p><h2 id="1047删除字符串中的所有相邻重复项-2">1047删除字符串中的所有相邻重复项</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/1047.%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9.html" >https://programmercarl.com/1047.删除字符串中的所有相邻重复项.html<i class="fas fa-external-link-alt"></i></a>)</p><h2 id="150逆波兰表达式求值-2">150逆波兰表达式求值</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0150.%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC.html" >https://programmercarl.com/0150.逆波兰表达式求值.html<i class="fas fa-external-link-alt"></i></a>)</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：20AC，1047AC，150AC&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.05.30 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="栈" scheme="https://kiml.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第九天-232用栈实现队列、225用队列实现栈</title>
    <link href="https://kiml.github.io/2024/05/30/100000012/"/>
    <id>https://kiml.github.io/2024/05/30/100000012/</id>
    <published>2024-05-30T01:01:47.000Z</published>
    <updated>2024-05-30T02:18:46.525Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：都是直接看的解析，不是很难。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.05.30 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="232用栈实现队列">232用栈实现队列</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/implement-queue-using-stacks/description/" >https://leetcode.cn/problems/implement-queue-using-stacks/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LE232</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">MyQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyQueue</span>();  </span><br><span class="line">        queue.push(<span class="number">1</span>);  </span><br><span class="line">        queue.push(<span class="number">2</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;queue.peek() = &quot;</span> + queue.peek());  </span><br><span class="line">        System.out.println(<span class="string">&quot;queue.pop() = &quot;</span> + queue.pop());  </span><br><span class="line">        System.out.println(<span class="string">&quot;queue.empty() = &quot;</span> + queue.empty());  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;  </span><br><span class="line">        Stack&lt;Integer&gt; stackIn;  </span><br><span class="line">        Stack&lt;Integer&gt; stackOut;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;  </span><br><span class="line">            stackIn = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  </span><br><span class="line">            stackOut = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;  </span><br><span class="line">            stackIn.push(x);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;  </span><br><span class="line">            <span class="comment">// 把in的内容复制到out  </span></span><br><span class="line">            in2out();  </span><br><span class="line">            <span class="keyword">return</span> stackOut.pop();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">in2out</span><span class="params">()</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (stackOut.isEmpty()) &#123;  </span><br><span class="line">                <span class="keyword">while</span> (!stackIn.isEmpty()) &#123;  </span><br><span class="line">                    stackOut.push(stackIn.pop());  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/**  </span></span><br><span class="line"><span class="comment">         * 返回列表开头的数据  </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;  </span><br><span class="line">            <span class="comment">// 把in的内容复制到out  </span></span><br><span class="line">            in2out();  </span><br><span class="line">            <span class="keyword">return</span> stackOut.peek();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> stackIn.empty() &amp;&amp; stackOut.empty();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="225用队列实现栈">225用队列实现栈</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/implement-queue-using-stacks/description/" >https://leetcode.cn/problems/implement-queue-using-stacks/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LE225</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">MyStack</span> <span class="variable">myStack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyStack</span>();  </span><br><span class="line">        myStack.push(<span class="number">1</span>);  </span><br><span class="line">        myStack.push(<span class="number">2</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;myStack.top() = &quot;</span> + myStack.top());  </span><br><span class="line">        System.out.println(<span class="string">&quot;myStack.pop() = &quot;</span> + myStack.pop());  </span><br><span class="line">        System.out.println(<span class="string">&quot;myStack.empty() = &quot;</span> + myStack.empty());  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;  </span><br><span class="line">        Queue&lt;Integer&gt; queue;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;  </span><br><span class="line">            queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;  </span><br><span class="line">            queue.offer(x);  </span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size() - <span class="number">1</span>;  </span><br><span class="line">            <span class="keyword">while</span> (size != <span class="number">0</span>) &#123;  </span><br><span class="line">                size--;  </span><br><span class="line">                queue.offer(queue.poll());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> queue.poll();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> queue.peek();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/**  </span></span><br><span class="line"><span class="comment">         * 判断是否为空  </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> queue.isEmpty();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看讲解</h1><h2 id="232用栈实现队列-2">232用栈实现队列</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97.html" >https://programmercarl.com/0232.用栈实现队列.html<i class="fas fa-external-link-alt"></i></a>)<br>思路：用栈模拟队列需要两个栈。一个栈作为入栈，一个栈作为出栈。如果出栈为空，将入栈中的元素压入出栈。<br><img                       lazyload                     alt="image"                     data-src="https://blog-resources.oss-cn-hangzhou.aliyuncs.com/240530/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif"                      alt=""                ></p><h2 id="225用队列实现栈-2">225用队列实现栈</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0225.%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88.html" >https://programmercarl.com/0225.用队列实现栈.html<i class="fas fa-external-link-alt"></i></a>)<br>思路：用队列模拟栈，可以只用一个队列。每当有新元素入队列，将原有的旧元素重新入队列，这样新元素就变成栈顶元素。（<strong>一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了。</strong>）<br><img                       lazyload                     alt="image"                     data-src="https://blog-resources.oss-cn-hangzhou.aliyuncs.com/240530/Snipaste_2024-05-30_09-56-06.png"                      alt=""                ></p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：都是直接看的解析，不是很难。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.05.30 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="栈" scheme="https://kiml.github.io/tags/%E6%A0%88/"/>
    
    <category term="队列" scheme="https://kiml.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第八天-28实现 strStr() 、459重复的子字符串</title>
    <link href="https://kiml.github.io/2024/05/29/100000011/"/>
    <id>https://kiml.github.io/2024/05/29/100000011/</id>
    <published>2024-05-29T01:03:06.000Z</published>
    <updated>2024-06-03T02:20:52.062Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：28暴力（应为KMP）、459暴力（KMP不会）</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-05-29 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="28实现-strStr">28实现 strStr()</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/" >https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LE28</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);  </span><br><span class="line">        <span class="type">String</span> <span class="variable">haystack</span> <span class="operator">=</span> scanner.nextLine();  </span><br><span class="line">        <span class="type">String</span> <span class="variable">needle</span> <span class="operator">=</span> scanner.nextLine();  </span><br><span class="line">        System.out.println(strStr(haystack, needle));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 思路：一个指针针对haystack遍历，一个指针针对needle遍历  </span></span><br><span class="line"><span class="comment">     * 当指针指过的路径相等，输出两者的差（即初始相等的指针位置）  </span></span><br><span class="line"><span class="comment">     * 当指向元素不同，haystack指针指向初始对比的下一个，needle指针重置  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; haystack.length(); i++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (haystack.charAt(i) == needle.charAt(j)) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (j == needle.length() - <span class="number">1</span>) &#123;  </span><br><span class="line">                    <span class="keyword">return</span> i - j;  </span><br><span class="line">                &#125;  </span><br><span class="line">                j++;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                i = i - j;  </span><br><span class="line">                j = <span class="number">0</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span>  -<span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="459重复的子字符串">459重复的子字符串</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/repeated-substring-pattern/description/" >https://leetcode.cn/problems/repeated-substring-pattern/description/<i class="fas fa-external-link-alt"></i></a>)<br>（虽然讲了KMP应该就用KMP，但是不会）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力求解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LE459</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);  </span><br><span class="line">        <span class="type">String</span> <span class="variable">nextLine</span> <span class="operator">=</span> scanner.nextLine();  </span><br><span class="line">        System.out.println(repeatedSubstringPattern(nextLine));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i * <span class="number">2</span> &lt;= n; i++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;  </span><br><span class="line">                <span class="type">boolean</span> <span class="variable">match</span> <span class="operator">=</span> <span class="literal">true</span>;  </span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; j++) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (s.charAt(j) != s.charAt(j - i)) &#123;  </span><br><span class="line">                        match = <span class="literal">false</span>;  </span><br><span class="line">                        <span class="keyword">break</span>;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">if</span> (match) &#123;  </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看讲解</h1><h2 id="28实现-strStr-2">28实现 strStr()</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html" >https://programmercarl.com/0028.实现strStr.html<i class="fas fa-external-link-alt"></i></a>)<br>本题应该用KMP思路，这个算法主要用在字符串匹配上。KMP的经典思想就是:<strong>当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 思路：使用KMP算法。  </span></span><br><span class="line"><span class="comment"> * 之前双指针移动，不相等haystack的指针返回到初始匹配位置的下一位（暴力求解）  </span></span><br><span class="line"><span class="comment"> * 现在使用KMP算法，不相等移动到next表中标记的位置。  </span></span><br><span class="line"><span class="comment"> * 所以现在的关键就在于next表的计算：  </span></span><br><span class="line"><span class="comment"> * 1.初始化  </span></span><br><span class="line"><span class="comment"> * 2.当前后缀不相等时的思路（回退）  </span></span><br><span class="line"><span class="comment"> * 3.当前后缀相等时的思路（继续后移）  </span></span><br><span class="line"><span class="comment"> * 内部相当于也进行了KMP</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">strStr1</span><span class="params">(String haystack, String needle)</span> &#123;  </span><br><span class="line">    <span class="comment">// 获取Next表  </span></span><br><span class="line">    <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[needle.length()];  </span><br><span class="line">    <span class="type">int</span>[] next = getNext(ints, needle);  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span> (needle.length() == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; haystack.length(); i++) &#123;  </span><br><span class="line">        <span class="comment">// 不相等, j回退  </span></span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">0</span> &amp;&amp; haystack.charAt(i) != needle.charAt(j)) &#123;  </span><br><span class="line">            j = next[j - <span class="number">1</span>];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 相等  </span></span><br><span class="line">        <span class="keyword">if</span> (haystack.charAt(i) == needle.charAt(j)) &#123;  </span><br><span class="line">            <span class="comment">// 完全匹配，返回下标  </span></span><br><span class="line">            <span class="keyword">if</span> (j == needle.length() - <span class="number">1</span>) &#123;  </span><br><span class="line">                <span class="keyword">return</span> i - j;  </span><br><span class="line">            &#125;  </span><br><span class="line">            j++;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span>  -<span class="number">1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 获取next表，例：  </span></span><br><span class="line"><span class="comment"> * a a b a a f  </span></span><br><span class="line"><span class="comment"> * 0 1 0 1 2 0 * * 1.初始化  </span></span><br><span class="line"><span class="comment"> * 2.当前后缀不相等时的思路（回退）  </span></span><br><span class="line"><span class="comment"> * 3.当前后缀相等时的思路（继续后移）  </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> next 返回的next数组  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> s 要求的字符串  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> next数组  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] getNext(<span class="type">int</span>[] next, String s) &#123;  </span><br><span class="line">    <span class="comment">// 初始化 两个指针i和j，j指向前缀末尾位置(同时也是之前最长相等的前后缀长度)，i指向后缀末尾位置(随着字符串长度递增，递增)。  </span></span><br><span class="line">    <span class="comment">// 刚刚初始化时，字符串为a，所以j = 0  </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    next[<span class="number">0</span>] = j;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 这里i从1开始，没有搞懂(因为初始位置一定为0吗)  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++) &#123;  </span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j)) &#123;  </span><br><span class="line">            j = next[j - <span class="number">1</span>];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;  </span><br><span class="line">            j++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        next[i] = j;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> next;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="459重复的子字符串-2">459重复的子字符串</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0459.%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2.html" >https://programmercarl.com/0459.重复的子字符串.html<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * KMP思路  </span></span><br><span class="line"><span class="comment"> * 如果这个字符串是由重复子串组成的，那么字符串长度-最长相等前后缀就为重复子串的长度  </span></span><br><span class="line"><span class="comment"> * 反过来说，如果一个字符串的最长相等前后缀与长度的差值（即可能是重复子串长度的这个值）能被字符串长度整除，那么就说明这个字符串是由重复子串组成的  </span></span><br><span class="line"><span class="comment"> * 但是这个反过来说。需要证明。（虽然画了几种情况都是这样）  </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * KMP复习：  </span></span><br><span class="line"><span class="comment"> * 1.初始化  </span></span><br><span class="line"><span class="comment"> * 2.不相等的情况  </span></span><br><span class="line"><span class="comment"> * 3.相等的情况  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern1</span><span class="params">(String s)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[] next = getNext(s);  </span><br><span class="line">    <span class="comment">// 这里除了上面说的条件之外，还需要加上next[len - 1] != -1, 这说明字符串有最长相同的前后缀（就是字符串里的前缀子串和后缀子串相同的最长长度）  </span></span><br><span class="line">    <span class="keyword">return</span> next[s.length() - <span class="number">1</span>] != <span class="number">0</span> &amp;&amp; s.length() % (s.length() - next[s.length() - <span class="number">1</span>]) == <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] getNext(String s) &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];  </span><br><span class="line">    next[j] = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++) &#123;  </span><br><span class="line">        <span class="keyword">while</span> (j != <span class="number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j)) &#123;  </span><br><span class="line">            j = next[j - <span class="number">1</span>];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;  </span><br><span class="line">            j++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        next[i] = j;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> next;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：28暴力（应为KMP）、459暴力（KMP不会）&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-05-29 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="双指针" scheme="https://kiml.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="字符串" scheme="https://kiml.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="KMP" scheme="https://kiml.github.io/tags/KMP/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第七天-344反转字符串、541反转字符串II、卡码网54替换数字、151翻转字符串里的单词、卡码网55右旋转字符串</title>
    <link href="https://kiml.github.io/2024/05/27/100000010/"/>
    <id>https://kiml.github.io/2024/05/27/100000010/</id>
    <published>2024-05-27T01:25:11.000Z</published>
    <updated>2024-06-03T02:20:46.787Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：都是可以写出来的。但是有些与参考种给出的解析思路不同。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.05.27 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="344反转字符串">344反转字符串</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/reverse-string/description/" >https://leetcode.cn/problems/reverse-string/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LE344</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);  </span><br><span class="line">        reverseString(scanner.nextLine().toCharArray());  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = s.length - <span class="number">1</span>; i &lt;= j; i++, j--) &#123;  </span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> s[i];  </span><br><span class="line">            s[i] = s[j];  </span><br><span class="line">            s[j] = temp;  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println(Arrays.toString(s));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="541反转字符串II">541反转字符串II</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/reverse-string-ii/description/" >https://leetcode.cn/problems/reverse-string-ii/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LE541</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);  </span><br><span class="line">        System.out.println(reverseStr(scanner.nextLine(), Integer.parseInt(scanner.nextLine())));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 画图翻译了一下  </span></span><br><span class="line"><span class="comment">     * 大概意思就是奇数段反转  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;  </span><br><span class="line">        <span class="comment">// 判断能拆分成几段  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> s.length() / k;  </span><br><span class="line">        <span class="keyword">if</span> (s.length() % k != <span class="number">0</span>) &#123;  </span><br><span class="line">            size = size + <span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">reverseStr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= size; i++) &#123;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">substring</span> <span class="operator">=</span> s.substring((i - <span class="number">1</span>) * k, Math.min(i * k, s.length()));  </span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;  </span><br><span class="line">                <span class="type">char</span>[] chars = substring.toCharArray();  </span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>, m = chars.length - <span class="number">1</span>; n &lt;= m; n++, m--) &#123;  </span><br><span class="line">                    <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> chars[n];  </span><br><span class="line">                    chars[n] = chars[m];  </span><br><span class="line">                    chars[m] = temp;  </span><br><span class="line">                &#125;  </span><br><span class="line">                reverseStr.append(chars);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                reverseStr.append(substring);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> reverseStr.toString();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="卡码网54替换数字">卡码网54替换数字</h2><p>题目链接：(<a class="link"   href="https://kamacoder.com/problempage.php?pid=1064" >https://kamacoder.com/problempage.php?pid=1064<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CM54</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);  </span><br><span class="line">        System.out.println(replaceNumber(scanner.nextLine()));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">replaceNumber</span><span class="params">(String s)</span> &#123;  </span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();  </span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : chars) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; <span class="string">&#x27;9&#x27;</span> &gt;= c) &#123;  </span><br><span class="line">                stringBuilder.append(<span class="string">&quot;number&quot;</span>);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                stringBuilder.append(c);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="151翻转字符串里的单词">151翻转字符串里的单词</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/reverse-words-in-a-string/description/" >https://leetcode.cn/problems/reverse-words-in-a-string/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);  </span><br><span class="line">    System.out.println(reverseWords(scanner.nextLine()));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;  </span><br><span class="line">    String[] split = s.trim().split(<span class="string">&quot; &quot;</span>);  </span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> split.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">trim</span> <span class="operator">=</span> split[i].trim();  </span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(trim)) &#123;  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        stringBuilder.append(trim).append(<span class="string">&quot; &quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> stringBuilder.toString().trim();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="卡码网55右旋转字符串">卡码网55右旋转字符串</h2><p>题目链接：(<a class="link"   href="https://kamacoder.com/problempage.php?pid=1065" >https://kamacoder.com/problempage.php?pid=1065<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CM55</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);  </span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> Integer.parseInt(scanner.nextLine());  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();  </span><br><span class="line">        System.out.println(rightString(k, s));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">rightString</span><span class="params">(<span class="type">int</span> k, String s)</span> &#123;  </span><br><span class="line">        <span class="comment">// 过界判断  </span></span><br><span class="line">        <span class="keyword">if</span> (k &gt;= s.length() || k &lt;= <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> s;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> s.substring(s.length() - k) + s.substring(<span class="number">0</span>, s.length() - k);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看讲解</h1><h2 id="344反转字符串-2">344反转字符串</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0344.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2.html" >https://programmercarl.com/0344.反转字符串.html<i class="fas fa-external-link-alt"></i></a>)</p><h2 id="541反转字符串II-2">541反转字符串II</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0541.%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II.html" >https://programmercarl.com/0541.反转字符串II.html<i class="fas fa-external-link-alt"></i></a>)</p><h2 id="卡码网54替换数字-2">卡码网54替换数字</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/kamacoder/0054.%E6%9B%BF%E6%8D%A2%E6%95%B0%E5%AD%97.html" >https://programmercarl.com/kamacoder/0054.替换数字.html<i class="fas fa-external-link-alt"></i></a>)<br>根据讲解，这题本意是先扩充再分配。要用到双指针的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">replaceNumber</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 统计数字的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sOldSize</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(s.charAt(i)))&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩充字符串s的大小，也就是每个空格替换成&quot;number&quot;之后的大小</span></span><br><span class="line">        <span class="type">char</span>[] newS = <span class="keyword">new</span> <span class="title class_">char</span>[s.length() + count * <span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sNewSize</span> <span class="operator">=</span> newS.length;</span><br><span class="line">        <span class="comment">// 将旧字符串的内容填入新数组</span></span><br><span class="line">        System.arraycopy(s.toCharArray(), <span class="number">0</span>, newS, <span class="number">0</span>, sOldSize);</span><br><span class="line">        <span class="comment">// 从后先前将空格替换为&quot;number&quot;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> sNewSize - <span class="number">1</span>, j = sOldSize - <span class="number">1</span>; j &lt; i; j--, i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Character.isDigit(newS[j])) &#123;</span><br><span class="line">                newS[i] = newS[j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newS[i] = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">                newS[i - <span class="number">1</span>] = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">                newS[i - <span class="number">2</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">                newS[i - <span class="number">3</span>] = <span class="string">&#x27;m&#x27;</span>;</span><br><span class="line">                newS[i - <span class="number">4</span>] = <span class="string">&#x27;u&#x27;</span>;</span><br><span class="line">                newS[i - <span class="number">5</span>] = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">                i -= <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(newS);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        System.out.println(replaceNumber(s));</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="151翻转字符串里的单词-2">151翻转字符串里的单词</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0151.%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D.html" >https://programmercarl.com/0151.翻转字符串里的单词.html<i class="fas fa-external-link-alt"></i></a>)<br>这题。。。Java不好像没有办法空间复杂度为O(n)。（面试的话，不太清楚会不会这么细，平时可能就直接API搞定了。。。一般机考也不会考这个吧😶‍🌫️）只能说思路很重要：</p><ul class="lvl-0"><li class="lvl-2"><p>移除多余空格（）</p></li><li class="lvl-2"><p>将整个字符串反转</p></li><li class="lvl-2"><p>将每个单词反转</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LE151</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);  </span><br><span class="line">        System.out.println(reverseWords(scanner.nextLine()));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 本题考察点应该和上一题一样  </span></span><br><span class="line"><span class="comment">     * 步骤如下:  </span></span><br><span class="line"><span class="comment">     * 1.移除字符串中的空格  </span></span><br><span class="line"><span class="comment">     * 2.倒序  </span></span><br><span class="line"><span class="comment">     * 3.每个单词再反转  </span></span><br><span class="line"><span class="comment">     * 要求：不使用任何内置API  </span></span><br><span class="line"><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">removeSpace</span> <span class="operator">=</span> removeSpace(s);  </span><br><span class="line">        System.out.println(removeSpace);  </span><br><span class="line">        <span class="keyword">return</span> reverseWord(removeSpace);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 单个单词倒置  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">reverseWord</span><span class="params">(String s)</span> &#123;  </span><br><span class="line">        String[] list = s.split(<span class="string">&quot; &quot;</span>);  </span><br><span class="line">        <span class="keyword">if</span> (list.length &lt;= <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();  </span><br><span class="line">        <span class="keyword">for</span> (String s1 : list) &#123;  </span><br><span class="line">            <span class="type">char</span>[] chars = s1.toCharArray();  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = chars.length - <span class="number">1</span>; i &lt;= j; i++, j--) &#123;  </span><br><span class="line">                <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> chars[i];  </span><br><span class="line">                chars[i] = chars[j];  </span><br><span class="line">                chars[j] = temp;  </span><br><span class="line">            &#125;  </span><br><span class="line">            stringBuilder.append(chars).append(<span class="string">&quot; &quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> stringBuilder.substring(<span class="number">0</span>, stringBuilder.length() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 去除字符串中的多余空格  </span></span><br><span class="line"><span class="comment">     * 并进行倒序  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">removeSpace</span><span class="params">(String s)</span> &#123;  </span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();  </span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> s.length() - <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">while</span> (s.charAt(start) == <span class="string">&#x27; &#x27;</span>) &#123;  </span><br><span class="line">            start++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">while</span> (s.charAt(end) == <span class="string">&#x27; &#x27;</span>) &#123;  </span><br><span class="line">            end--;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> end; i &gt;= start; i--) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (chars[i] == <span class="string">&#x27; &#x27;</span> &amp;&amp; chars[i - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>) &#123;  </span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            stringBuilder.append(chars[i]);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="卡码网55右旋转字符串-2">卡码网55右旋转字符串</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/kama55.%E5%8F%B3%E6%97%8B%E5%AD%97%E7%AC%A6%E4%B8%B2.html" >https://programmercarl.com/kama55.右旋字符串.html<i class="fas fa-external-link-alt"></i></a>)<br>这题也是。。。反正直接用API了，看了说《剑指Offer》有差不多的题目。没有再写一遍，直接抄了解析中的写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> Integer.parseInt(in.nextLine());</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> in.nextLine();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();  <span class="comment">//获取字符串长度</span></span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        reverseString(chars, <span class="number">0</span>, len - <span class="number">1</span>);  <span class="comment">//反转整个字符串</span></span><br><span class="line">        reverseString(chars, <span class="number">0</span>, n - <span class="number">1</span>);  <span class="comment">//反转前一段字符串，此时的字符串首尾尾是0,n - 1</span></span><br><span class="line">        reverseString(chars, n, len - <span class="number">1</span>);  <span class="comment">//反转后一段字符串，此时的字符串首尾尾是n,len - 1</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(chars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] ch, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="comment">//异或法反转字符串，参照题目 344.反转字符串的解释</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            ch[start] ^= ch[end];</span><br><span class="line">            ch[end] ^= ch[start];</span><br><span class="line">            ch[start] ^= ch[end];</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：都是可以写出来的。但是有些与参考种给出的解析思路不同。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.05.27 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="双指针" scheme="https://kiml.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="字符串" scheme="https://kiml.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="反转" scheme="https://kiml.github.io/tags/%E5%8F%8D%E8%BD%AC/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第六天-454四数相加II、383赎金信、15三数之和、18四数之和</title>
    <link href="https://kiml.github.io/2024/05/24/100000009/"/>
    <id>https://kiml.github.io/2024/05/24/100000009/</id>
    <published>2024-05-24T07:04:00.000Z</published>
    <updated>2024-05-24T12:44:14.699Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：454和383可以AC，15超时，18根据15做出，还可以进一步优化</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.05.24 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="454四数相加II">454四数相加II</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/4sum-ii/" >https://leetcode.cn/problems/4sum-ii/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LE454</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);  </span><br><span class="line">        <span class="type">int</span>[] nums1 = Arrays.stream(scanner.nextLine().split(<span class="string">&quot;,&quot;</span>)).filter(Objects::nonNull).mapToInt(Integer::parseInt).toArray();  </span><br><span class="line">        <span class="type">int</span>[] nums2 = Arrays.stream(scanner.nextLine().split(<span class="string">&quot;,&quot;</span>)).filter(Objects::nonNull).mapToInt(Integer::parseInt).toArray();  </span><br><span class="line">        <span class="type">int</span>[] nums3 = Arrays.stream(scanner.nextLine().split(<span class="string">&quot;,&quot;</span>)).filter(Objects::nonNull).mapToInt(Integer::parseInt).toArray();  </span><br><span class="line">        <span class="type">int</span>[] nums4 = Arrays.stream(scanner.nextLine().split(<span class="string">&quot;,&quot;</span>)).filter(Objects::nonNull).mapToInt(Integer::parseInt).toArray();  </span><br><span class="line">        System.out.println(fourSumCount(nums1, nums2, nums3, nums4));  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 和昨天的最后一题差不多</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fourSumCount</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span>[] nums3, <span class="type">int</span>[] nums4)</span> &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k : nums1) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i : nums2) &#123;  </span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> k + i;  </span><br><span class="line">                map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums3) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : nums4) &#123;  </span><br><span class="line">                res += map.getOrDefault(-i - j, <span class="number">0</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> res;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="383赎金信">383赎金信</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/ransom-note/submissions/534463469/" >https://leetcode.cn/problems/ransom-note/submissions/534463469/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LE383</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);  </span><br><span class="line">        <span class="type">String</span> <span class="variable">ransomNote</span> <span class="operator">=</span> scanner.nextLine();  </span><br><span class="line">        <span class="type">String</span> <span class="variable">magazine</span> <span class="operator">=</span> scanner.nextLine();  </span><br><span class="line">        System.out.println(canConstruct(ransomNote, magazine));  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 和242一样的思路</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">canConstruct</span><span class="params">(String ransomNote, String magazine)</span> &#123;  </span><br><span class="line">        <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];  </span><br><span class="line">        <span class="comment">// 遍历存储数量  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; magazine.length(); i++) &#123;  </span><br><span class="line">            ints[magazine.charAt(i) - <span class="number">97</span>]++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 遍历扣除数量  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ransomNote.length(); i++) &#123;  </span><br><span class="line">            ints[ransomNote.charAt(i) - <span class="number">97</span>]--;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : ints) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15三数之和">15三数之和</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/3sum/description/" >https://leetcode.cn/problems/3sum/description/<i class="fas fa-external-link-alt"></i></a>)<br>暴力解法，但是这样超时了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    <span class="comment">// 判断是否重复  </span></span><br><span class="line">    HashMap&lt;String, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> j + <span class="number">1</span>; k &lt; nums.length; k++) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="number">0</span>) &#123;  </span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">                    list.add(nums[i]);  </span><br><span class="line">                    list.add(nums[j]);  </span><br><span class="line">                    list.add(nums[k]);  </span><br><span class="line">                    list.sort(Integer::compareTo);  </span><br><span class="line">                    map.put(list.stream().map(integer -&gt; integer + <span class="string">&quot;&quot;</span>).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>)), list);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;Integer&gt;&gt; stringListEntry : map.entrySet()) &#123;  </span><br><span class="line">        list.add(stringListEntry.getValue());  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> list;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了部分解析改用双指针，可以通过，但是比较慢。而且费时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    nums = Arrays.stream(nums).sorted().toArray();  </span><br><span class="line">    ArrayList&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    <span class="comment">// 递增序列，前三位和大于0，直接返回  </span></span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>] &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> list;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; j &amp;&amp; j &lt; k) &#123;  </span><br><span class="line">        System.out.println(i + <span class="string">&quot; &quot;</span> + j + <span class="string">&quot; &quot;</span> + k);  </span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[j] + nums[k];  </span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;  </span><br><span class="line">            list.add(Arrays.asList(nums[i], nums[j], nums[k]));  </span><br><span class="line">            j++;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">            j++;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            k--;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">while</span> (j &gt; i + <span class="number">1</span> &amp;&amp; j &lt;= nums.length - <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;  </span><br><span class="line">            j++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">while</span> (k &gt; j &amp;&amp; k != nums.length - <span class="number">1</span> &amp;&amp; nums[k] == nums[k + <span class="number">1</span>]) &#123;  </span><br><span class="line">            k--;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (j &gt;= k) &#123;  </span><br><span class="line">            i = i + <span class="number">1</span>;  </span><br><span class="line">            <span class="keyword">while</span> (i != <span class="number">0</span> &amp;&amp; i &lt;= nums.length - <span class="number">1</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;  </span><br><span class="line">                i++;  </span><br><span class="line">            &#125;  </span><br><span class="line">            j = i + <span class="number">1</span>;  </span><br><span class="line">            k = nums.length - <span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> list;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18四数之和">18四数之和</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/4sum/description/" >https://leetcode.cn/problems/4sum/description/<i class="fas fa-external-link-alt"></i></a>)<br>看到题目，就觉得是15的进阶版，按照上一题的思路写了一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;  </span><br><span class="line">    Arrays.sort(nums);  </span><br><span class="line">  </span><br><span class="line">    ArrayList&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (j != i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;  </span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;  </span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;  </span><br><span class="line">                <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">long</span>) nums[i] + (<span class="type">long</span>) nums[j] + (<span class="type">long</span>) nums[left] + (<span class="type">long</span>) nums[right];  </span><br><span class="line">                <span class="keyword">if</span> (sum &lt; target) &#123;  </span><br><span class="line">                    left++;  </span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;  </span><br><span class="line">                    right--;  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    list.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));  </span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;  </span><br><span class="line">                        left++;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;  </span><br><span class="line">                        right--;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    left++;  </span><br><span class="line">                    right--;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> list;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看讲解</h1><h2 id="454四数相加II-2">454四数相加II</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0454.%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II.html" >https://programmercarl.com/0454.四数相加II.html<i class="fas fa-external-link-alt"></i></a>)</p><h2 id="383赎金信-2">383赎金信</h2><p>题目链接/文章讲解：(<a class="link"   href="https://programmercarl.com/0383.%E8%B5%8E%E9%87%91%E4%BF%A1.html" >https://programmercarl.com/0383.赎金信.html<i class="fas fa-external-link-alt"></i></a>)</p><h2 id="15三数之和-2">15三数之和</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0015.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.html" >https://programmercarl.com/0015.三数之和.html<i class="fas fa-external-link-alt"></i></a>)<br>确实用for循环更好理解。题解的思路更加清晰，而且更快。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    Arrays.sort(nums);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;  </span><br><span class="line">        <span class="comment">// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了  </span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> result;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/**  </span></span><br><span class="line"><span class="comment">         * 只能是与前一个比较进行去重  </span></span><br><span class="line"><span class="comment">         */</span>  </span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;  </span><br><span class="line">            <span class="keyword">continue</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;  </span><br><span class="line">        <span class="keyword">while</span> (right &gt; left) &#123;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[left] + nums[right];  </span><br><span class="line">            <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                right--;  </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">                left++;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                result.add(Arrays.asList(nums[i], nums[left], nums[right]));  </span><br><span class="line">                <span class="comment">/**  </span></span><br><span class="line"><span class="comment">                 * 去重逻辑应该放在找到一个三元组之后  </span></span><br><span class="line"><span class="comment">                 * 否则获取不到结果集  </span></span><br><span class="line"><span class="comment">                 */</span>  </span><br><span class="line">                <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;  </span><br><span class="line">                    right--;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">while</span> (right &gt; left &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;  </span><br><span class="line">                    left++;  </span><br><span class="line">                &#125;  </span><br><span class="line">  </span><br><span class="line">                right--;  </span><br><span class="line">                left++;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18四数之和-2">18四数之和</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0018.%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C.html" >https://programmercarl.com/0018.四数之和.html<i class="fas fa-external-link-alt"></i></a>)<br>看了解析。加上剪枝操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">fourSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;  </span><br><span class="line">    Arrays.sort(nums);  </span><br><span class="line">  </span><br><span class="line">    ArrayList&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;  </span><br><span class="line">        <span class="comment">// nums[i] &gt; target 直接返回, 剪枝操作  </span></span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt; target) &#123;  </span><br><span class="line">            <span class="keyword">return</span> list;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123; </span><br><span class="line">        <span class="comment">// 二级剪枝</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] &gt; <span class="number">0</span> &amp;&amp; nums[i] + nums[j] &gt; target) &#123;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (j != i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>]) &#123;  </span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j + <span class="number">1</span>;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;  </span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;  </span><br><span class="line">                <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> (<span class="type">long</span>) nums[i] + (<span class="type">long</span>) nums[j] + (<span class="type">long</span>) nums[left] + (<span class="type">long</span>) nums[right];  </span><br><span class="line">                <span class="keyword">if</span> (sum &lt; target) &#123;  </span><br><span class="line">                    left++;  </span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target) &#123;  </span><br><span class="line">                    right--;  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    list.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));  </span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) &#123;  </span><br><span class="line">                        left++;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) &#123;  </span><br><span class="line">                        right--;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    left++;  </span><br><span class="line">                    right--;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> list;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：454和383可以AC，15超时，18根据15做出，还可以进一步优化&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.05.24 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="双指针" scheme="https://kiml.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="哈希表" scheme="https://kiml.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【代码模板】阿里云接口实现短信发送</title>
    <link href="https://kiml.github.io/2024/05/24/100000007/"/>
    <id>https://kiml.github.io/2024/05/24/100000007/</id>
    <published>2024-05-24T03:26:12.000Z</published>
    <updated>2024-06-01T02:43:13.820Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>阿里云接口实现短信发送。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.05.24 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>依赖</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--sms验证服务--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alicloud-sms<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1>代码</h1><ol><li class="lvl-3"><p><code>Service</code>中要添加的代码</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> Boolean <span class="title function_">sendCode</span><span class="params">(String phone)</span> &#123;  </span><br><span class="line">    <span class="comment">//非空校验  </span></span><br><span class="line">    <span class="keyword">if</span> (Strings.isNullOrEmpty(phone)) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LogicException</span>(<span class="string">&quot;手机号为空&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sbCode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();  </span><br><span class="line">    <span class="comment">// 6位随机密码</span></span><br><span class="line">    Stream.generate(() -&gt; <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>))  </span><br><span class="line">            .limit(<span class="number">6</span>)  </span><br><span class="line">            .forEach(sbCode::append);  </span><br><span class="line">    <span class="comment">//将验证码放入redis, 5分钟过期  </span></span><br><span class="line">    redisTemplate.opsForValue().set(phone, sbCode.toString(), Duration.ofMinutes(<span class="number">5</span>));  </span><br><span class="line">    log.info(<span class="string">&quot;短信验证码：&quot;</span> + sbCode.toString());  </span><br><span class="line">    <span class="keyword">return</span> smsSender.sendMsg(phone, sbCode.toString());  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p><code>SmsConfig.java</code></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@RefreshScope</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsConfig</span> &#123;  </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;sms.operator.signName&#125;&quot;)</span>  </span><br><span class="line">    <span class="keyword">private</span> String signName;  </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;sms.operator.templateCode&#125;&quot;)</span>  </span><br><span class="line">    <span class="keyword">private</span> String templateCode;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSignName</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> signName;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTemplateCode</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> templateCode;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p>配置文件中添加</p></li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sms:</span></span><br><span class="line">  <span class="attr">operator:</span></span><br><span class="line">    <span class="attr">signName:</span> <span class="string">你的signName</span></span><br><span class="line">    <span class="attr">templateCode:</span> <span class="string">你的templateCode</span>  </span><br></pre></td></tr></table></figure><ol start="4"><li class="lvl-3"><p><code>SmsSender.java</code></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="meta">@Slf4j</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsSender</span> &#123;  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> SmsConfig smsConfig;  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> ISmsService smsService;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 发送验证码短信  </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> telephone 手机号  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code     手机验证码  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sendMsg</span><span class="params">(String telephone, String code)</span> &#123;  </span><br><span class="line">        <span class="type">SendSmsRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SendSmsRequest</span>();  </span><br><span class="line">  </span><br><span class="line">        request.setPhoneNumbers(telephone);  </span><br><span class="line">        request.setSignName(smsConfig.getSignName());  </span><br><span class="line">        request.setTemplateCode(smsConfig.getTemplateCode());  </span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();  </span><br><span class="line">        <span class="type">JsonNode</span> <span class="variable">rootNode</span> <span class="operator">=</span> mapper.createObjectNode();  </span><br><span class="line">        <span class="comment">// 存入验证码  </span></span><br><span class="line">        ((ObjectNode) rootNode).put(<span class="string">&quot;code&quot;</span>, code);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            request.setTemplateParam(mapper.writeValueAsString(rootNode));  </span><br><span class="line">            <span class="type">val</span> <span class="variable">sendSmsResponse</span> <span class="operator">=</span> smsService.sendSmsRequest(request);  </span><br><span class="line">            log.info(<span class="string">&quot;短信发送接收：&quot;</span> + JSONUtil.toJsonPrettyStr(sendSmsResponse));  </span><br><span class="line">            <span class="keyword">if</span> (sendSmsResponse.getCode() != <span class="literal">null</span> &amp;&amp; <span class="string">&quot;OK&quot;</span>.equals(sendSmsResponse.getCode())) &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LogicException</span>(<span class="string">&quot;验证码发送失败：&quot;</span> + sendSmsResponse.getMessage());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            log.error(<span class="string">&quot;send sms error.&quot;</span> + e.getMessage());  </span><br><span class="line">            <span class="type">val</span> <span class="variable">operLog</span> <span class="operator">=</span> OperLog.builder().title(<span class="string">&quot;发送验证码&quot;</span>)  </span><br><span class="line">                    .businessType(BusinessType.OTHER.ordinal())  </span><br><span class="line">                    .operParam(JSONUtil.toJsonPrettyStr(request))  </span><br><span class="line">                    .status(BusinessStatus.FAIL.ordinal())  </span><br><span class="line">                    .errorMsg(e.getMessage())  </span><br><span class="line">                    .build();  </span><br><span class="line">            AsyncManager.me().execute(AsyncFactory.recordOper(operLog));  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LogicException</span>(<span class="string">&quot;验证码发送失败&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
阿里云接口实现短信发送。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.05.24 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="后端项目" scheme="https://kiml.github.io/categories/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="准备工作" scheme="https://kiml.github.io/categories/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
    
    
    <category term="Java" scheme="https://kiml.github.io/tags/Java/"/>
    
    <category term="代码模板" scheme="https://kiml.github.io/tags/%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第五天-242有效的字母异位词、349两个数组的交集、202快乐数、1两数之和</title>
    <link href="https://kiml.github.io/2024/05/23/100000006/"/>
    <id>https://kiml.github.io/2024/05/23/100000006/</id>
    <published>2024-05-23T07:55:10.000Z</published>
    <updated>2024-05-23T10:58:27.253Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：全部可以AC。看了解析之后，242、202可再优化。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.05.23 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="242有效的字母异位词">242有效的字母异位词</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/valid-anagram/description/" >https://leetcode.cn/problems/valid-anagram/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LE242</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();  </span><br><span class="line">        <span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> scanner.nextLine();  </span><br><span class="line">        System.out.println(isAnagram(s, t));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 思路：  </span></span><br><span class="line"><span class="comment">     * 1.用map接收每个字符出现的次数  </span></span><br><span class="line"><span class="comment">     * 2.比较次数是否相同  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;  </span><br><span class="line">        <span class="type">char</span>[] charsS = s.toCharArray();  </span><br><span class="line">        <span class="type">char</span>[] charsT = t.toCharArray();  </span><br><span class="line">  </span><br><span class="line">        HashMap&lt;String, Integer&gt; numMapS = getNumMap(charsS);  </span><br><span class="line">        HashMap&lt;String, Integer&gt; numMapT = getNumMap(charsT);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (numMapS.size() != numMapT.size()) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (String key : numMapS.keySet()) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (!numMapS.get(key).equals(numMapT.get(key))) &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 获取每个字符的数量  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> charsS 字符串  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 每个字符的数量  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, Integer&gt; <span class="title function_">getNumMap</span><span class="params">(<span class="type">char</span>[] charsS)</span> &#123;  </span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : charsS) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(String.valueOf(c))) &#123;  </span><br><span class="line">                map.put(String.valueOf(c) , map.get(String.valueOf(c)) + <span class="number">1</span>);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                map.put(String.valueOf(c), <span class="number">1</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> map;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="349两个数组的交集">349两个数组的交集</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/intersection-of-two-arrays/description/" >https://leetcode.cn/problems/intersection-of-two-arrays/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LE349</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span>[] nums1 = Arrays.stream(scanner.nextLine().split(<span class="string">&quot;,&quot;</span>)).filter(Objects::nonNull).mapToInt(Integer::parseInt).toArray();</span><br><span class="line">        <span class="type">int</span>[] nums2 = Arrays.stream(scanner.nextLine().split(<span class="string">&quot;,&quot;</span>)).filter(Objects::nonNull).mapToInt(Integer::parseInt).toArray();</span><br><span class="line">        <span class="type">int</span>[] intersection = intersection(nums1, nums2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] intersection(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; intersection = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            set.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(i)) &#123;</span><br><span class="line">                intersection.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> intersection.stream().filter(Objects::nonNull).mapToInt(i -&gt; i).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="202快乐数">202快乐数</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/happy-number/description/" >https://leetcode.cn/problems/happy-number/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LE202</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);  </span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> scanner.nextLine();  </span><br><span class="line">        System.out.println(isHappy(Integer.parseInt(s)));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 思路：放到set中，重复或者为1，跳出循环  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 数  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否是快乐数  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isHappy</span><span class="params">(<span class="type">int</span> n)</span> &#123;  </span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();  </span><br><span class="line">        <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> n + <span class="string">&quot;&quot;</span>;  </span><br><span class="line">        set.add(n);  </span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num.length(); i++) &#123;  </span><br><span class="line">                sum += Math.pow(Integer.parseInt(num.charAt(i) + <span class="string">&quot;&quot;</span>), <span class="number">2</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">1</span>) &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (set.contains(sum)) &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            num = sum + <span class="string">&quot;&quot;</span>;  </span><br><span class="line">            set.add(sum);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1两数之和">1两数之和</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/two-sum/" >https://leetcode.cn/problems/two-sum/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LE1</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);  </span><br><span class="line">        <span class="type">int</span>[] nums = Arrays.stream(scanner.nextLine().split(<span class="string">&quot;,&quot;</span>)).filter(Objects::nonNull).mapToInt(Integer::parseInt).toArray();  </span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> Integer.parseInt(scanner.next());  </span><br><span class="line">        twoSum(nums, target);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 暴力解法肯定是循环两遍  </span></span><br><span class="line"><span class="comment">     * 但是这题放在哈希表专题里，就应该哈希表也能解决  </span></span><br><span class="line"><span class="comment">     * 用值为key，下标为value放入map  </span></span><br><span class="line"><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;  </span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(target - nums[i])) &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;map.get(target - nums[i]), i&#125;;  </span><br><span class="line">            &#125;  </span><br><span class="line">            map.put(nums[i], i);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看讲解</h1><h2 id="242有效的字母异位词-2">242有效的字母异位词</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.html" >https://programmercarl.com/0242.有效的字母异位词.html<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 优化：  </span></span><br><span class="line"><span class="comment"> * 改为定义数组去接收数值（其实和map是一样的思想，但是这样代码量更少）  </span></span><br><span class="line"><span class="comment"> * 改为第二次遍历，在原数组上直接--（空间用得更少了）  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isAnagram1</span><span class="params">(String s, String t)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;  </span><br><span class="line">        record[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;  </span><br><span class="line">        record[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> count : record) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (count != <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="349两个数组的交集-2">349两个数组的交集</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0349.%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86.html" >https://programmercarl.com/0349.两个数组的交集.html<i class="fas fa-external-link-alt"></i></a>)</p><h2 id="202快乐数-2">202快乐数</h2><p>题目链接/文章讲解：(<a class="link"   href="https://programmercarl.com/0202.%E5%BF%AB%E4%B9%90%E6%95%B0.html" >https://programmercarl.com/0202.快乐数.html<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以再优化，一个数各个位数平方求和</span></span><br><span class="line"><span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> n % <span class="number">10</span>;  </span><br><span class="line">    sum += temp * temp;  </span><br><span class="line">    n = n / <span class="number">10</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1两数之和-2">1两数之和</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0001.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C.html" >https://programmercarl.com/0001.两数之和.html<i class="fas fa-external-link-alt"></i></a>)</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：全部可以AC。看了解析之后，242、202可再优化。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.05.23 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="哈希表" scheme="https://kiml.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>RestTemplate使用GET请求，返回中文乱码</title>
    <link href="https://kiml.github.io/2024/05/23/100000004/"/>
    <id>https://kiml.github.io/2024/05/23/100000004/</id>
    <published>2024-05-23T03:35:55.000Z</published>
    <updated>2024-05-23T06:46:43.190Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.05.23 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>问题</h1><p>测试 RestTemplate 的 Get 请求，返回中文乱码。</p><h1>原因</h1><p>当 RestTemplate 默认使用 String 存储 body 内容时默认使用 ISO_8859_1 字符集。</p><h1>解决</h1><p>配置 StringHttpMessageConverter 消息转换器，使用 utf-8 字符集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>  </span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>(<span class="keyword">new</span> <span class="title class_">OkHttp3ClientHttpRequestFactory</span>());  </span><br><span class="line">    <span class="comment">//消息转换器列表  </span></span><br><span class="line">    List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = restTemplate.getMessageConverters();  </span><br><span class="line">    <span class="comment">//配置消息转换器StringHttpMessageConverter，并设置utf‐8  </span></span><br><span class="line">    messageConverters.set(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">StringHttpMessageConverter</span>(StandardCharsets.UTF_8));  </span><br><span class="line">    <span class="keyword">return</span> restTemplate;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.05.23 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="bug记录" scheme="https://kiml.github.io/categories/bug%E8%AE%B0%E5%BD%95/"/>
    
    <category term="2024" scheme="https://kiml.github.io/categories/bug%E8%AE%B0%E5%BD%95/2024/"/>
    
    
    <category term="Java" scheme="https://kiml.github.io/tags/Java/"/>
    
    <category term="BUG" scheme="https://kiml.github.io/tags/BUG/"/>
    
    <category term="RestTemplate" scheme="https://kiml.github.io/tags/RestTemplate/"/>
    
  </entry>
  
  <entry>
    <title>聚合支付-功能实现</title>
    <link href="https://kiml.github.io/2024/05/23/100000008/"/>
    <id>https://kiml.github.io/2024/05/23/100000008/</id>
    <published>2024-05-23T01:59:53.000Z</published>
    <updated>2024-06-05T08:34:57.775Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>第一部分-商户注册和资质申请第二部分-对接SAAS<br>第三部分-闪聚支付</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">24.05.23 初始记录（商户注册&amp;资质申请）</span><br><span class="line">24.05.29 获取短信验证码</span><br><span class="line">24.05.30 文件上传</span><br><span class="line">24.06.02 Saas对接</span><br><span class="line">24.06.04 bug新增，烦，遇到bug，进展很缓慢。</span><br></pre></td></tr></table></figure><span id="more"></span><h1>商户注册&amp;资质申请</h1><h2 id="系统交互流程">系统交互流程</h2><p><img                       lazyload                     alt="image"                     data-src="https://blog-resources.oss-cn-hangzhou.aliyuncs.com/240523/Snipaste_2024-05-23_09-58-03.png"                      alt=""                ><br>商户注册的流程由商户平台应用、商户服务、SaaS平台、验证码服务四个微服务之间进行交互完成，各微服务的职责介绍如下：<br>1）商户平台应用：此应用主要为商户提供业务功能，包括：商户资质申请、员工管理、门店管理等功能。<br>2）商户服务： 提供商户管理的相关服务接口，供其它微服务调用，主要为商户平台应用提供接口服务，功能包括：商户基本信息管理、资质申请、商户应用管理、渠道参数配置、商户员工信息管理、商户门店管理等。<br>3）SaaS平台：闪聚支付项目是一个SaaS平台 ，所谓SaaS平台即多个用户租用平台的业务功能，这样用户即可省去软件系统开发的成本，每个商户就是一个租户，所以又称为多租户系统。 SaaS平台提供租户管理、账号管理、权限管理、资源管理、套餐管理、系统认证授权等功业务功能。在上图商户注册的流程中，商户注册的账号等信息需要写入SaaS平台，由SaaS平台统一管理账号，分配权限，商户统一通过SaaS平台登录闪聚支付。<br>4）验证码服务：提供获取短信验证码、校验验证码的接口。 商户使用手机号进行注册，平台通过校验手机验证码来确认是否本人在注册。<img                       lazyload                     alt="image"                     data-src="https://blog-resources.oss-cn-hangzhou.aliyuncs.com/240523/Snipaste_2024-05-23_09-58-03.png"                      alt="Snipaste_2024-05-23_09-58-03.png"                ><br><img                       lazyload                     alt="image"                     data-src="https://blog-resources.oss-cn-hangzhou.aliyuncs.com/240529/Snipaste_2024-05-29_17-04-38.png"                      alt=""                ></p><h2 id="获取短信验证码">获取短信验证码</h2><p>短信验证码为一个开源的服务，可单独开启使用。开源git地址：(<a class="link"   href="https://github.com/fightingape/sailing" >https://github.com/fightingape/sailing<i class="fas fa-external-link-alt"></i></a>)</p><blockquote><p>大致看了一下这个开源项目是根据传入的业务名称，获取配置好的code长度和Service实现。后续应该还可以加入别的实现（比如阿里云的短信服务等）</p><p>其中生成验证信息这个方法。<br>1.根据业务名称+随机UUID生成key存入redis。这个key会返回给服务请求方。<br>2.根据配置好的Map获取名称对应的len即code码长度，如果传入不存在的name，会直接报错。<br>3.验证服务就是根据返回给服务请求方的key，查询Redis缓存是否存在，不存在返回false，即验证码错误。</p></blockquote><p>本项目中没有使用，只是简单控制台打印了一下。也可以直接在这个服务里存入redis（因为要申请开通阿里云短信服务有点麻烦，又要多部署一个服务，而且这个功能比较简单不打算花时间开通了）。</p><p>之前有写过阿里云的短信，关联文章：</p><blockquote><p>内链：[[【代码模板】阿里云接口实现短信发送]]<br>外链：<a class="link"   href="https://kiml.site/2024/05/24/100000007/" >【代码模板】阿里云接口实现短信发送<i class="fas fa-external-link-alt"></i></a></p></blockquote><h2 id="文件上传">文件上传</h2><p>资质申请的流程中涉及到了文件上传的功能。之前已经写过使用Minio作为文件服务器和用阿里云OSS作为文件存储两种方式。这里的上传直接把七牛云换成了Minio。顺便整理了一下之前写过的两种方式。文件上传：</p><blockquote><p>内链：[[【代码模板】文件存储]]<br>外链：<a class="link"   href="https://kiml.site/2024/05/30/100000014/" >【代码模板】文件存储<i class="fas fa-external-link-alt"></i></a></p></blockquote><h1>支付参数配置</h1><blockquote><p>这个部分是项目的核心，之前做别的项目的时候，接触了微信支付和支付宝支付。就和这个项目中说的一样，用户只能先选择支付类型。再调用对应的接口获取支付二维码。而通过聚合支付这个平台，可以只生成一个链接，根据用户扫码，跳转不同的支付。</p></blockquote><p><strong>商户应该配置哪些第三方支付渠道的参数</strong><br>服务类型是闪聚支付平台为商户提供的聚合支付服务通道，共分为线上和线下两大类：</p><p>线上支付服务通道：</p><ol><li class="lvl-3"><p>手机APP支付</p></li><li class="lvl-3"><p>PC网页支付</p></li><li class="lvl-3"><p>手机网页支付</p></li><li class="lvl-3"><p>小程序支付线下支付服务通道：</p></li><li class="lvl-3"><p>收款码支付(C扫B)：即商户出示付款码，用户扫收款码完成支付。</p></li><li class="lvl-3"><p>B扫C：即顾客出示付款码，商户扫描付款码。</p></li></ol><h2 id="系统交互流程-2">系统交互流程</h2><ul class="lvl-0"><li class="lvl-2"><p>商户应用创建流程<br><img                       lazyload                     alt="image"                     data-src="https://blog-resources.oss-cn-hangzhou.aliyuncs.com/240530/Snipaste_2024-05-30_21-35-45.png"                      alt=""                ></p></li><li class="lvl-2"><p>商户渠道参数配置交互流程<img                       lazyload                     alt="image"                     data-src="https://blog-resources.oss-cn-hangzhou.aliyuncs.com/240530/Snipaste_2024-05-30_21-53-28.png"                      alt=""                ><br>交易服务职责：提供支付渠道参数配置、订单、发起支付、转账、退款等功能。</p></li></ul><h1>对接SAAS</h1><h2 id="系统交互流程-3">系统交互流程</h2><p>商户注册时与SAAS的交互流程已经在商户注册模块给出。</p><h2 id="分布式认证需求">分布式认证需求</h2><ol><li class="lvl-3"><p>统一认证授权分布式系统的每个服务（系统）都会有认证、授权的需求，如果每个服务都实现一套认证授权逻辑会非常冗余，考虑分布式系统共享性的特点，需要由独立的认证服务来处理系统认证授权的请求。如下图，闪聚支付平台包括：商户平台应用、运营平台应用、门户应用，每个应用都需要身份认证，闪聚支付平台统一由UAA认证服务完成认证。<br><img                       lazyload                     alt="image"                     data-src="https://blog-resources.oss-cn-hangzhou.aliyuncs.com/240531/Snipaste_2024-05-31_17-47-47.png"                      alt=""                ></p></li><li class="lvl-3"><p>开放认证体系考虑分布式系统开放性的特点，UAA认证服务不仅服务于平台自身，并且对第三方系统也要提供认证，平台应提供扩展和开放的认证机制，以开放API的方式供第三方应用接入，一方应用（内部系统服务）和三方应用（第三方应用）均采用统一机制接入。</p></li></ol><p>分布式系统认证技术方案详见下图：<img                       lazyload                     alt="image"                     data-src="https://blog-resources.oss-cn-hangzhou.aliyuncs.com/240603/Snipaste_2024-06-03_14-11-54.png"                      alt=""                ><br>流程所涉及到统一账号服务、UAA服务、API网关这三个组件职责如下:<br>1） 统一账号服务：提供商户和平台运营人员的登录账号、密码、角色、权限、资源等系统级信息的管理，不包含用户业务信息。<br>2） 统一认证服务：它承载了OAuth2.0接入方认证、登入用户的认证、授权以及生成令牌的职责，完成实际的用户认证、授权功能。<br>3） API网关：作为系统的唯一入口，API网关为接入方提供定制的API集合，它可能还具有其它职责，如身份验证、监控、负载 均衡、缓存等。API网关方式的核心要点是，所有的接入方和消费端都通过统一的网关接入微服务，在网关层处理 所有的非业务功能。</p><h1>BUG记录</h1><h2 id="RestTemplate使用GET请求，返回中文乱码">RestTemplate使用GET请求，返回中文乱码</h2><blockquote><p>内链：[[RestTemplate使用GET请求，返回中文乱码]]<br>外链：<a class="link"   href="https://kiml.site/2024/05/23/100000004/" >RestTemplate使用GET请求，返回中文乱码<i class="fas fa-external-link-alt"></i></a></p></blockquote><h2 id="项目中访问Swagger地址，404（未解决）">项目中访问Swagger地址，404（未解决）</h2><p>不管怎么访问swagger的页面地址，都返回404。但是直接用apifox的URL导入，是可以成功的🥴。</p><h2 id="使用mapstruct转换对象，报错Cannot-find-implementation-for……">使用mapstruct转换对象，报错Cannot find implementation for……</h2><p>这个项目中是因为User微服务没有依赖mapstruct。但是swagger中有这个依赖，他直接用了swagger中的依赖。网上搜索还有一种情况可能出现这个问题。</p><blockquote><p>内链：[[使用mapstruct转换对象，报错Cannot find implementation for……]]<br>外链：<a class="link"   href="https://kiml.site/2024/05/23/100000004/" >使用mapstruct转换对象，报错Cannot find implementation for……<i class="fas fa-external-link-alt"></i></a></p></blockquote>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
第一部分-商户注册和资质申请第二部分-对接SAAS&lt;br&gt;
第三部分-闪聚支付&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.05.23 初始记录（商户注册&amp;amp;资质申请）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24.05.29 获取短信验证码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24.05.30 文件上传&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24.06.02 Saas对接&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24.06.04 bug新增，烦，遇到bug，进展很缓慢。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="后端项目" scheme="https://kiml.github.io/categories/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="聚合支付" scheme="https://kiml.github.io/categories/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98/"/>
    
    
    <category term="Java" scheme="https://kiml.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
