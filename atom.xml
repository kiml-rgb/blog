<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Keep Theme</title>
  
  <subtitle>Keep theme quick starter</subtitle>
  <link href="https://kiml.github.io/atom.xml" rel="self"/>
  
  <link href="https://kiml.github.io/"/>
  <updated>2024-08-12T03:50:19.003Z</updated>
  <id>https://kiml.github.io/</id>
  
  <author>
    <name>Keep Team</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>聚合支付-【代码模板】微信支付接入</title>
    <link href="https://kiml.github.io/posts/5041bed3/"/>
    <id>https://kiml.github.io/posts/5041bed3/</id>
    <published>2024-07-24T09:06:43.000Z</published>
    <updated>2024-08-12T03:50:19.003Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>微信支付接入流程</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-07-24 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;微信支付接入流程&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-07-24 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="后端项目" scheme="https://kiml.github.io/categories/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="聚合支付" scheme="https://kiml.github.io/categories/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98/"/>
    
    
    <category term="Java" scheme="https://kiml.github.io/tags/Java/"/>
    
    <category term="代码模板" scheme="https://kiml.github.io/tags/%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>Freemarker 基础</title>
    <link href="https://kiml.github.io/posts/e9ae925d/"/>
    <id>https://kiml.github.io/posts/e9ae925d/</id>
    <published>2024-07-23T13:26:20.000Z</published>
    <updated>2024-08-12T03:50:06.319Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br><br>Java 开发的模板引擎。官网模板：<a class="link"   href="https://freemarker.apache.org/docs/dgui_quickstart_basics.html" >Template + data-model = output - Apache FreeMarker Manual<i class="fas fa-external-link-alt"></i></a></p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">24-07-23 初始记录</span><br><span class="line">24-07-26 bug记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="快速入门">快速入门</h2><p>freemarker 作为 springmvc 一种视图格式，默认情况下 SpringMVC 支持 freemarker 视图格式。</p><h3 id="Maven-依赖">Maven 依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--父工程指定SpringBoot版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐boot‐starter‐parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--freemarker依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐boot‐starter‐freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件">配置文件</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># freemarker基本配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">freemarker:</span></span><br><span class="line">    <span class="attr">charset:</span> <span class="string">utf-8</span></span><br><span class="line">    <span class="string">request‐context‐attribute:</span> <span class="string">rc</span></span><br><span class="line">    <span class="string">content‐type:</span> <span class="string">text/html</span></span><br><span class="line">    <span class="attr">suffix:</span> <span class="string">.html</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">resources:</span></span><br><span class="line">  <span class="string">add‐mappings:</span> <span class="literal">false</span> <span class="comment">#关闭工程中默认的资源处理</span></span><br><span class="line"><span class="attr">mvc:</span></span><br><span class="line">  <span class="string">throw‐exception‐if‐no‐handler‐found:</span> <span class="literal">true</span> <span class="comment">#出现错误时直接抛出异常</span></span><br></pre></td></tr></table></figure><h3 id="代码使用">代码使用</h3><ol><li class="lvl-3"><p>添加 view 映射</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> &#123;  </span><br><span class="line">    <span class="comment">// 注意这里不要添加后缀</span></span><br><span class="line">        registry.addViewController(<span class="string">&quot;/pay-page&quot;</span>).setViewName(<span class="string">&quot;pay&quot;</span>);  </span><br><span class="line">        registry.addViewController(<span class="string">&quot;/pay-error&quot;</span>).setViewName(<span class="string">&quot;pay_error&quot;</span>);  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>返回 Controller 注解不要加 <code>@ResponseBody</code> 或 <code>@RestController</code>（<mark>这个注解把返回的信息转成 json 返回，不能实现页面跳转的功能</mark>）</p></li><li class="lvl-3"><p>返回使用 <code>forward:</code></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">&quot;forward:/pay-error&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="基础指令">基础指令</h2><blockquote><p>1、注释，即 <code>&lt;#‐‐和‐‐&gt;</code>，介于其之间的内容会被 freemarker 忽略<br>2、插值（Interpolation）：即 <code>$&#123;..&#125;</code> 部分，freemarker 会用真实的值代替 <code>$&#123;..&#125; </code><br>3、FTL 指令：和 HTML 标记类似，名字前加 <code>#</code> 予以区分，Freemarker 会解析标签中的表达式或逻辑。<br>4、文本，仅文本信息，这些不是 freemarker 的注释、插值、FTL 指令的内容会被 freemarker 忽略解析，直接输出内容。</p></blockquote><h3 id="List-指令">List 指令</h3><blockquote><p>说明： <code>_index</code>：得到循环的下标，使用方法是在 stu 后边加 <code>_index</code>，它的值是从 0 开始</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; stus = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>序号<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>钱包<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  &lt;#list stus as stu&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;stu_index + 1&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;stu.name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;stu.age&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;stu.mondy&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  &lt;/#list&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Map-指令">Map 指令</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String,Student&gt; stuMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">输出stu1的学生信息：<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">姓名：$&#123;stuMap[&#x27;stu1&#x27;].name&#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">年龄：$&#123;stuMap[&#x27;stu1&#x27;].age&#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">输出stu1的学生信息：<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">姓名：$&#123;stuMap.stu1.name&#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">年龄：$&#123;stuMap.stu1.age&#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">遍历输出两个学生信息：<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>序号<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>钱包<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  &lt;#list stuMap?keys as k&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;k_index + 1&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;stuMap[k].name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;stuMap[k].age&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span> &gt;</span>$&#123;stuMap[k].mondy&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  &lt;/#list&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="if-指令">if 指令</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>钱包<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  &lt;#list stus as stu&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> &lt;#<span class="attr">if</span> <span class="attr">stu.name</span> ==<span class="string">&#x27;小明&#x27;</span>&gt;</span>style=&quot;background:red;&quot;&lt;/#if&gt;&gt;$&#123;stu.name&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;stu.age&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> &gt;</span>$&#123;stu.mondy&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  &lt;/#list&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="运算符">运算符</h3><ol><li class="lvl-3"><p>算数运算符 FreeMarker 表达式中完全支持算术运算，FreeMarker 支持的算术运算符包括:<code>+</code>, <code>-</code> , <code>*</code> , <code>/</code> , <code>%</code></p></li><li class="lvl-3"><p>逻辑 运算符 逻辑运算符有如下几个: 逻辑与 <code>&amp;&amp;</code> 逻辑或 <code>||</code> 逻辑非 <code>!</code> 逻辑运算符只能作用于布尔值，否则将产生错误</p></li><li class="lvl-3"><p>比较运算符 表达式中支持的比较运算符有如下几个:</p><ol><li class="lvl-7"><code>=</code> 或者 <code>==</code> 判断两个值是否相等</li><li class="lvl-7"><code>!=</code> 判断两个值是否不等</li><li class="lvl-7"><code>&gt;</code> 或者 <code>gt</code> 判断左边值是否大于右边值</li><li class="lvl-7"><code>&gt;=</code> 或者 <code>gte</code> 判断左边值是否大于等于右边值</li><li class="lvl-7"><code>&lt;</code> 或者 <code>lt</code> 判断左边值是否小于右边值</li><li class="lvl-7"><code>&lt;=</code> 或者 <code>lte</code> 判断左边值是否小于等于右边值</li></ol></li></ol><blockquote><p>注意：<code>=</code> 和 <code>!=</code> 可以用于字符串，数值和日期来比较是否相等，但 <code>=</code> 和 <code>!=</code> 两边必须是相同类型的值，否则会产生错误，而且 FreeMarker 是精确比较，“x”,&quot;x &quot;,“X” 是不等的。其它的运行符可以作用于数字和日期，但不能作用于字符串，大部分的时候,使用 <code>gt</code> 等字母运算符代替 <code>&gt;</code> 会有更好的效果,因为 FreeMarker 会把 <code>&gt;</code> 解释成 FTL 标签的结束字符,当然,也可以使用括号来避免这种情况，如：<code>&lt;#if (x&gt;y)&gt;</code></p></blockquote><h3 id="空值处理">空值处理</h3><ol><li class="lvl-3"><p>判断某变量是否存在使用 <code>??</code> 用法为：<code>variable??</code>，如果该变量存在，返回 true，否则返回 false</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#if stus??&gt;</span><br><span class="line">&lt;#list stus as stu&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>缺失变量默认值使用 <code>!</code> 使用 <code>!</code> 要以指定一个默认值，当变量为空时显示默认值。</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;#--如果name为空显示空字符串。--&gt;</span><br><span class="line">$&#123;name!&#x27;&#x27;&#125;</span><br><span class="line">&lt;#--如果stu或bestFriend或name为空默认显示空字符串。--&gt;</span><br><span class="line">$&#123;(stu.bestFriend.name)!&#x27;&#x27;&#125;</span><br></pre></td></tr></table></figure><h3 id="内置对象">内置对象</h3><p>在 freemarker 中可以访问 Request、Session 等内置对象。</p><p>Request： 用于获取 Request 对象中的 attribute 对象。</p><p>Session：用于获取 Session 对象中的 attribute 对象。</p><p>RequestParameters：用于获取 Request 对象的 parameter 参数（浏览器端发送的请求数据）</p><ol><li class="lvl-3"><p>配置</p></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line">  <span class="attr">freemarker:</span> </span><br><span class="line">    <span class="string">request‐context‐attribute:</span> <span class="string">rc</span> <span class="comment">#把Spring的RequestContext对象暴露为变量rc </span></span><br><span class="line">    <span class="string">expose‐request‐attributes:</span> <span class="literal">true</span> </span><br><span class="line">    <span class="string">expose‐session‐attributes:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>例子在 Controller 中设置 request、session 的属性值</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试内置对象 </span></span><br><span class="line">request.setAttribute(<span class="string">&quot;attr1&quot;</span>,<span class="string">&quot;test&quot;</span>); </span><br><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession(); </span><br><span class="line">session.setAttribute(<span class="string">&quot;session1&quot;</span>, <span class="string">&quot;user1&quot;</span>);</span><br></pre></td></tr></table></figure><p>页面获取数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">url请求参数：$&#123;RequestParameters[&#x27;param1&#x27;]!&quot;&quot;&#125; </span><br><span class="line">request Attribute:$&#123;Request[&quot;attr1&quot;]!&quot;&quot;&#125; </span><br><span class="line">session Attribute:$&#123;Session[&quot;session1&quot;]!&quot;&quot;&#125; </span><br><span class="line">工程路径：$&#123;rc.contextPath&#125; </span><br><span class="line">请求地址: $&#123;rc.requestUri&#125;</span><br></pre></td></tr></table></figure><h2 id="BUG">BUG</h2><h3 id="访问报错-404">访问报错 404</h3><ol><li class="lvl-3"><p>检查是否添加了 view 映射，注意不要加后缀。</p></li><li class="lvl-3"><p>检查 Controller 层使用的注解：不要加 <code>@ResponseBody</code> 或 <code>@RestController</code>（<mark>这个注解把返回的信息转成 json 返回，不能实现页面跳转的功能</mark>）</p></li><li class="lvl-3"><p><strong>nacos 配置文件读取失败</strong>（<s>不确定原因</s>重启 nacos 后就好了）：使用 nacos 读取配置文件，出现自动装配时 suffix 没有读取到的情况。（本地配置使用.html 可以读取成功，但是放到 nacos 后，FreeMarkerProperties 中的 suffix 属性始终为默认的 <code>.ftl</code>，并且从<strong>springboot2.0</strong>开始默认的 suffix 为 <code>.ftlh</code>）</p><ul class="lvl-2"><li class="lvl-6">但是这里还是建议使用 <code>.ftl</code>，不然后序接口调用处可能会出 bug</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;&lt;br&gt;
Java 开发的模板引擎。官网模板：&lt;a class=&quot;link&quot;   href=&quot;https://freemarker.apache.org/docs/dgui_quickstart_basics.html&quot; &gt;Template + data-model = output - Apache FreeMarker Manual&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-07-23 初始记录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24-07-26 bug记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="后端项目" scheme="https://kiml.github.io/categories/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="准备工作" scheme="https://kiml.github.io/categories/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
    
    
    <category term="Java" scheme="https://kiml.github.io/tags/Java/"/>
    
    <category term="Freemarker" scheme="https://kiml.github.io/tags/Freemarker/"/>
    
  </entry>
  
  <entry>
    <title>消息队列的选型与优缺点</title>
    <link href="https://kiml.github.io/posts/359ee88a/"/>
    <id>https://kiml.github.io/posts/359ee88a/</id>
    <published>2024-07-23T08:32:04.000Z</published>
    <updated>2024-08-12T03:50:13.669Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>针对<mark>消息队列</mark>做出的总结。</p></li><li class="lvl-2"><p>参考文章</p></li></ul><blockquote><p><a class="link"   href="https://blog.csdn.net/qq_45173404/article/details/116429302" >RabbitMQ超详细安装教程（Linux）<i class="fas fa-external-link-alt"></i></a></p></blockquote><ul class="lvl-0"><li class="lvl-2">更新</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">24-07-23 初始记录</span><br><span class="line">24-08-09 补充 RabbitMQ 的延迟消息</span><br></pre></td></tr></table></figure><span id="more"></span><blockquote><p>MQ 全称为 Message Queue。<br>MQ 也被称为消息中间件。<br>MQ 也是微服务之间的通信的一种方式。</p></blockquote><h2 id="为什么使用-MQ">为什么使用 MQ</h2><ol><li class="lvl-3"><p>任务<strong>异步</strong>处理将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。</p></li><li class="lvl-3"><p>应用程序<strong>解耦合</strong><br>MQ 相当于一个中介，生产方通过 MQ 与消费方交互，它将应用程序进行解耦合。</p></li><li class="lvl-3"><p><strong>削峰填谷</strong></p></li></ol><h2 id="技术选型对比">技术选型对比</h2><blockquote><p>市面上有哪些消息队列？<br>ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，Redis。</p></blockquote><table><thead><tr><th>消息队列</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>RabbitMQ</td><td>1.支持 AMQP 协议<br>2.基于 erlang 语言开发，高并发性能较好<br>3.工作模式较为灵活 <br>4.支持延迟消息 <br>5.提供较为友好的后台管理页面<br>6.单机部署，1~2WTPS<br></td><td>1.不支持水平扩容 <br>2.不支持事务 <br>3.消息吞吐量三者最差 <br>4.当产生消息堆积，性能下降明显 <br>5.消息重发机制需要手动设置 <br>6.不支持消息重复消费</td></tr><tr><td>RocketMQ</td><td>1.高可用，高吞吐量，海量消息堆积，低延迟性能上，都表现出色 <br>2.api 与架构设计更加贴切业务场景 <br>3.支持顺序消息 <br>4.支持事务消息 <br>5.支持消息过滤 <br>6.支持重复消费 <br>7.支持延迟消息 <br>8.支持消息跟踪 <br>9.天然支持集群、负载均衡 <br>10.支持指定次数和时间间隔的失败消息重发 <br>11.单机部署，5~10WTPS</td><td>1.生态圈相较 Kafka 有所不如 <br>2.消息吞吐量与消息堆积能力也不如 Kafka <br>3.不支持主从自动切换 <br>4.只支持 Java</td></tr><tr><td>Kafka</td><td>1.高可用，高吞吐量，低延迟性能上，都表现出色 <br>2.使用人数多，技术生态圈完善 <br>3.支持顺序消息 <br>4.支持多种客户端 <br>5.支持重复消费</td><td>1.依赖分区，消费者数量受限于分区数 <br>2.单机消息过多时，性能下降明显 <br>3.不支持事务消息 <br>4.不支持指定次数和时间间隔的失败消息重发</td></tr></tbody></table><h2 id="RabbitMQ">RabbitMQ</h2><h3 id="基础">基础</h3><p><img                         lazyload                       alt="image"                       data-src="https://blog-resources.oss-cn-hangzhou.aliyuncs.com/Z2408/Rabbit%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png"                        alt=""                 ></p><h3 id="安装">安装</h3><h4 id="Windows">Windows</h4><ol><li class="lvl-3"><p>下载 RabbitMQ（<a class="link"   href="https://www.rabbitmq.com/docs/download" >https://www.rabbitmq.com/docs/download<i class="fas fa-external-link-alt"></i></a>）</p></li><li class="lvl-3"><p>下载 Erlang（<a class="link"   href="https://packagecloud.io/rabbitmq/erlang" >https://packagecloud.io/rabbitmq/erlang<i class="fas fa-external-link-alt"></i></a>），并配置环境变量<br><code>Erlang</code> 和 <code>RabbitMQ</code> 版本对照：<a class="link"   href="https://www.rabbitmq.com/which-erlang.html" >https://www.rabbitmq.com/which-erlang.html<i class="fas fa-external-link-alt"></i></a></p></li><li class="lvl-3"><p>运行 RabbitMQ</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启管理插件</span></span><br><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动rabbitmq</span> </span><br><span class="line">systemctl start rabbitmq-server </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看rabbitmq状态</span> </span><br><span class="line">systemctl status rabbitmq-server</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置rabbitmq服务开机自启动</span></span><br><span class="line">systemctl enable rabbitmq-server</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭rabbitmq服务</span></span><br><span class="line">systemctl stop rabbitmq-server</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启rabbitmq服务</span></span><br><span class="line">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure><h4 id="Linux">Linux</h4><h5 id="docker-安装">docker 安装</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1.yum包更新到最新</span></span><br><span class="line">yum update</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2.安装需要的软件包(yum-utils提供yum-config-manager的功能,，并且device mapper存储驱动程序需要device-mapper-persistent-data和lvm2)</span></span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3.设置yum源为阿里云</span></span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4.安装docker</span></span><br><span class="line">yum install docker-ce -y</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5.安装后查看docker版本</span></span><br><span class="line">docker -v</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6.阿里云镜像加速</span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://73z5h6yb.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装启动rabbitmq容器</span></span><br><span class="line">docker run -d --name 容器名称 -e RABBITMQ_DEFAULT_USER=xxx -e RABBITMQ_DEFAULT_PASS=123456 -p 15672:15672 -p 5672:5672 rabbitmq:3.8.14-management</span><br></pre></td></tr></table></figure><p><strong>docker 常用命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止docker</span></span><br><span class="line">systemctl stop docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启docker</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看docker状态</span></span><br><span class="line">systemctl status docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开机启动</span></span><br><span class="line">systemctl enable docker</span><br><span class="line">systemctl unenable docker </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看docker概要信息</span></span><br><span class="line">docker info </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看docker帮助文档</span></span><br><span class="line">docker --help</span><br></pre></td></tr></table></figure><h5 id="不使用-docker">不使用 docker</h5><ol><li class="lvl-3"><p>下载 RabbitMQ（<a class="link"   href="https://www.rabbitmq.com/docs/download" >https://www.rabbitmq.com/docs/download<i class="fas fa-external-link-alt"></i></a>）</p></li><li class="lvl-3"><p>下载 Erlang（<a class="link"   href="https://packagecloud.io/rabbitmq/erlang" >https://packagecloud.io/rabbitmq/erlang<i class="fas fa-external-link-alt"></i></a>）<br><code>Erlang</code> 和 <code>RabbitMQ</code> 版本对照：<a class="link"   href="https://www.rabbitmq.com/which-erlang.html" >https://www.rabbitmq.com/which-erlang.html<i class="fas fa-external-link-alt"></i></a></p></li><li class="lvl-3"><p>安装 Erlang 和 RabbitMQ</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 Erlang</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 解压</span></span></span><br><span class="line">rpm -Uvh erlang-23.2.7-2.el7.x86_64.rpm</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 安装</span></span></span><br><span class="line">yum install -y erlang</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 安装完成后输入如下指令查看版本号</span></span></span><br><span class="line">erl -v</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 RabbitMQ</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 在 RabiitMQ 安装过程中需要依赖 socat 插件，首先安装该插件</span></span></span><br><span class="line">yum install -y socat</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 解压</span></span> </span><br><span class="line">rpm -Uvh rabbitmq-server-3.8.14-1.el7.noarch.rpm </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 安装</span></span> </span><br><span class="line">yum install -y rabbitmq-server</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 启动rabbitmq</span></span> </span><br><span class="line">systemctl start rabbitmq-server </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 查看rabbitmq状态</span></span> </span><br><span class="line">systemctl status rabbitmq-server</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其他命令</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 设置rabbitmq服务开机自启动</span></span></span><br><span class="line">systemctl enable rabbitmq-server</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 关闭rabbitmq服务</span></span></span><br><span class="line">systemctl stop rabbitmq-server</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 重启rabbitmq服务</span></span></span><br><span class="line">systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure><ol start="4"><li class="lvl-3"><p>RabbitMQWeb 管理界面及授权操作</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开RabbitMQWeb管理界面插件，然后访问服务器公网ip:15672。默认账号密码 guest，guest</span></span><br><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure><ol start="5"><li class="lvl-3"><p>添加远程账户</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加用户</span></span><br><span class="line">rabbitmqctl add_user 用户名 密码</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置用户角色,分配操作权限</span></span><br><span class="line">rabbitmqctl set_user_tags 用户名 角色</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">为用户添加资源权限(授予访问虚拟机根节点的所有权限)</span></span><br><span class="line">rabbitmqctl set_permissions -p / 用户名 &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改密码</span></span><br><span class="line">rabbitmqctl change_ password 用户名 新密码</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除用户</span></span><br><span class="line">rabbitmqctl delete_user 用户名</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看用户清单</span></span><br><span class="line">rabbitmqctl list_users</span><br></pre></td></tr></table></figure><p><strong>角色有四种</strong>：</p><ul class="lvl-0"><li class="lvl-2"><p><code>administrator</code>：可以登录控制台、查看所有信息、并对 rabbitMQ 进行管理</p></li><li class="lvl-2"><p><code>monToring</code>：监控者；登录控制台，查看所有信息</p></li><li class="lvl-2"><p><code>policymaker</code>：策略制定者；登录控制台指定策略</p></li><li class="lvl-2"><p><code>managment</code>：普通管理员；登录控制</p></li></ul><h3 id="基本使用">基本使用</h3><ol><li class="lvl-3"><p>添加依赖</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>配置信息</p></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span>  </span><br><span class="line">    <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5673</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">swsk33</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure><h3 id="五种模型">五种模型</h3><h4 id="Basic-Queue">Basic Queue</h4><blockquote><p>（简单队列模型）：一个生产者、一个消费者，不需要设置交换机（使用默认的交换机）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="meta">@Slf4j</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqSend</span> &#123;  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendQueryOrderMessage</span><span class="params">(Object msg)</span> &#123;  </span><br><span class="line">        amqpTemplate.convertAndSend(<span class="string">&quot;xxx&quot;</span>, msg);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接收消息</span></span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="meta">@Slf4j</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMQListener</span> &#123;    </span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;xxx&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerOrderQueryMsg</span><span class="params">(String msg)</span> &#123;  </span><br><span class="line">        log.info(<span class="string">&quot;xxx接收到信息：&quot;</span> + msg);  </span><br><span class="line">        <span class="comment">// 逻辑处理代码</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Work-Queue">Work Queue</h4><blockquote><p>（工作队列模式）：一个生产者、多个消费者（竞争关系），不需要设置交换机（使用默认的交换机）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="meta">@Slf4j</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqSend</span> &#123;  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendQueryOrderMessage</span><span class="params">(Object msg)</span> &#123;  </span><br><span class="line">        <span class="comment">// 队列名称  </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">queueName</span> <span class="operator">=</span> <span class="string">&quot;simple.queue&quot;</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;  </span><br><span class="line">        <span class="comment">// 发送消息 向队列中不停发送消息，模拟消息堆积。 </span></span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, msg + i);  </span><br><span class="line">        Thread.sleep(<span class="number">20</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收消息</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());  </span><br><span class="line">    Thread.sleep(<span class="number">20</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;  </span><br><span class="line">    System.err.println(<span class="string">&quot;消费者2........接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());  </span><br><span class="line">    Thread.sleep(<span class="number">200</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在不添加额外配置的情况下，两个消费者会平分消息进行消费。为了避免这种情况，可以多加一个配置。<code>prefetch</code> 这个配置可以控制消费者预取的消息数量。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span> <span class="comment"># 每次只能获取一条消息，处理完成才能获取下一个消息</span></span><br></pre></td></tr></table></figure><h4 id="Fanout">Fanout</h4><blockquote><p>（发布订阅模式<mark>群发</mark>）：需要设置类型为 fanout 的交换机，并且交换机和队列进行绑定，当发送消息到交换机后，交换机会将消息发送到绑定的队列。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  交换机与队列绑定</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Fanout类型交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;xxx.fanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="meta">@Slf4j</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqSend</span> &#123;  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendQueryOrderMessage</span><span class="params">(Object msg)</span> &#123;  </span><br><span class="line">        <span class="comment">// 队列名称  </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;xxx.fanout&quot;</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;  </span><br><span class="line">        rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;&quot;</span>, msg);</span><br><span class="line">        Thread.sleep(<span class="number">20</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收消息</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue1</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;  </span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());  </span><br><span class="line">    Thread.sleep(<span class="number">20</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenWorkQueue2</span><span class="params">(String msg)</span> <span class="keyword">throws</span> InterruptedException &#123;  </span><br><span class="line">    System.err.println(<span class="string">&quot;消费者2........接收到消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span> + LocalTime.now());  </span><br><span class="line">    Thread.sleep(<span class="number">200</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Direct">Direct</h4><blockquote><p>（路由模式）：需要设置类型为 direct 的交换机，交换机和队列进行绑定，并且指定 routing key，当发送消息到交换机后，交换机会根据 routing key 将消息发送到对应的队列</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="meta">@Slf4j</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqSend</span> &#123;  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendQueryOrderMessage</span><span class="params">(Object msg)</span> &#123;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;xxx.direct&quot;</span>;    </span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;red&quot;</span>, message);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收消息</span></span><br><span class="line"><span class="comment">// 基于注解声明队列和交换机</span></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;xxx.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;xxx.direct&quot;, type = ExchangeTypes.DIRECT),</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到direct.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Topic">Topic</h4><blockquote><p>（通配符模式）：需要设置类型为 topic 的交换机，交换机和队列进行绑定，并且指定通配 符方式的 routing key，当发送消息到交换机后，交换机会根据 routing key 将消息发送到对应的队列。<code>Topic</code> 类型的 <code>Exchange</code> 与 <code>Direct</code> 相比，都是可以根据 <code>RoutingKey</code> 把消息路由到不同的队列。只不过 <code>Topic</code> 类型 <code>Exchange</code> 可以让队列在绑定 <code>Routing key</code> 的时候使用通配符。</p></blockquote><p><strong>通配符规则</strong>：<code>#</code>：匹配一个或多个词<code>*</code>：匹配不多不少恰好 1 个词</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送消息</span></span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="meta">@Slf4j</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqSend</span> &#123;  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate amqpTemplate;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendQueryOrderMessage</span><span class="params">(Object msg)</span> &#123;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;xxx.topic&quot;</span>;    </span><br><span class="line">    rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;china.news&quot;</span>, message);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收消息</span></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;xxx.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;china.#&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;xxx.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;#.news&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息转换器">消息转换器</h3><blockquote><p>Spring 会把你发送的消息序列化为字节发送给 MQ，接收消息的时候，还会把字节反序列化为 Java 对象。默认情况下 Spring 采用的序列化方式是 JDK 序列化：<mark>数据体积过大、有安全漏洞、可读性差</mark>。</p></blockquote><ol><li class="lvl-3"><p>在 publisher 和 consumer 两个服务中都引入依赖</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>在启动类中添加一个 Bean</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">jsonMessageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="延迟消息">延迟消息</h3><blockquote><p>RbbitMQ 实现延时消息主要有两种方式：</p><ol><li class="lvl-3">死信消息（队列 ttl+ 死信 exchange）<br><mark>2. 延时插件 (rabbitmq-delayed-message-exchange)</mark></li></ol></blockquote><h4 id="死信消息">死信消息</h4><blockquote><p>RabbitMQ 为每个队列设置消息的超时时间。只要给队列设置 x-message-ttl 参数（也可以给单条消息设置存活时间），就设定了该队列所有消息的存活时间，时间单位是毫秒。如果声明队列时指定了死信交换器，则过期消息会成为死信消息。<br><img                         lazyload                       alt="image"                       data-src="https://blog-resources.oss-cn-hangzhou.aliyuncs.com/Z2408/RabbitMQ%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97.png"                        alt="|1000"                 ></p></blockquote><h4 id="延时插件">延时插件</h4><ol><li class="lvl-3"><p>进入 rabbitmq 的 docker 容器</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mq bash</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>下载插件并上传服务器（下载地址：[<a class="link"   href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases" >https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases<i class="fas fa-external-link-alt"></i></a>][<a class="link"   href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases" >https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases<i class="fas fa-external-link-alt"></i></a>]）</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将下载好的插件拷贝到docker容器中</span></span><br><span class="line">docker cp ./rabbitmq_delayed_message_exchange-3.9.0.ez rabbit:/plugins</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入RabbitMQ容器</span></span><br><span class="line">docker exec -it rabbit /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动插件</span></span><br><span class="line">rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以通过以下命令查看所有安装过的插件</span></span><br><span class="line">rabbitmq-plugins list</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">然后执行 <span class="built_in">exit</span> 命令退出 docker 容器</span></span><br></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p>pom 文件引入依赖</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li class="lvl-3"><p>在代码中配置延迟队列</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqConfig</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ORDER_DELAY_KEY</span> <span class="operator">=</span> <span class="string">&quot;order_delay&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 延时交换机，交换机类型为x-delayed-message  </span></span><br><span class="line"><span class="comment">     */</span>    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> CustomExchange <span class="title function_">customExchange</span><span class="params">()</span> &#123;  </span><br><span class="line">        Map&lt;String, Object&gt; args = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">        <span class="comment">//延时交换机一定要设置x-delayed-type属性  </span></span><br><span class="line">        args.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);  </span><br><span class="line">        <span class="comment">//第二个参数type需要设置成x-delayed-message  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CustomExchange</span>(<span class="string">&quot;order_delay_exchange&quot;</span>, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="literal">true</span>, <span class="literal">false</span>, args);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 订单延时队列  </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 延时队列  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayOrderQueue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;order_delay_queue&quot;</span>, <span class="literal">true</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 订单延时队列绑定交换机  </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 延时队列绑定交换机  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">delayOrderBinding</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayOrderQueue()).to(customExchange()).with(ORDER_DELAY_KEY).noargs();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li class="lvl-3"><p>编写方法向队列发送消息</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 发送订单延时消息  </span></span><br><span class="line"><span class="comment"> * delayTime 延迟的时间 单位是毫秒  </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msg 发送的信息  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendDelayOrderMessage</span><span class="params">(Object msg, String routingKey, Long delayTime)</span> &#123;  </span><br><span class="line">    amqpTemplate.convertAndSend(<span class="string">&quot;order_delay_exchange&quot;</span>, routingKey, msg,  </span><br><span class="line">            message -&gt; &#123;  </span><br><span class="line">                <span class="comment">//设置延迟时间  </span></span><br><span class="line">                message.getMessageProperties().setDelay(delayTime.intValue());  </span><br><span class="line">                <span class="keyword">return</span> message;  </span><br><span class="line">            &#125;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li class="lvl-3"><p>监听队列</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;order_delay_queue&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlerOrderDelayMsg</span><span class="params">(String msg)</span> &#123;  </span><br><span class="line">    log.info(<span class="string">&quot;order_delay_queue接收到信息：&quot;</span> + msg);  </span><br><span class="line">    <span class="type">val</span> <span class="variable">jsonObject</span> <span class="operator">=</span> JSONUtil.parseObj(msg);</span><br><span class="line">    <span class="comment">// 逻辑处理 ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息重试">消息重试</h3><p>添加如下配置实现消息重试：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">listener:</span>  </span><br><span class="line">      <span class="attr">simple:</span>  </span><br><span class="line">        <span class="attr">retry:</span>  </span><br><span class="line">          <span class="comment"># 开启重试机制  </span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span>  </span><br><span class="line">          <span class="comment"># 最多重试  </span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">10</span>  </span><br><span class="line">          <span class="comment"># 第一次间隔  </span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="string">3000ms</span>  </span><br><span class="line">          <span class="comment"># 最多间隔时间  </span></span><br><span class="line">          <span class="attr">max-interval:</span> <span class="string">86400000ms</span>  </span><br><span class="line">          <span class="comment"># 间隔间乘数  </span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>特别注意：</strong> 如果在消息接收端的 application.yml 配置文件中没有添加 RabbitMQ 重试机制的相关配置，当接收端收到消息后程序抛出异常，那么发送端将得不到消息确认（ACK），此时发送端将会循环的发送消息，最终导致内存溢出。</p><h2 id="RocketMQ">RocketMQ</h2><h3 id="基础-2">基础</h3><p>RocketMQ 组成结构图如下 ：</p><p><img                         lazyload                       alt="image"                       data-src="https://blog-resources.oss-cn-hangzhou.aliyuncs.com/Z2407/RocketMQ%E7%BB%84%E6%88%90%E7%BB%93%E6%9E%84.png"                        alt=""                 ></p><p><strong>交互过程</strong>如下：</p><ol><li class="lvl-3"><p>Brokder 定时发送自身状态 到 NameServer。</p></li><li class="lvl-3"><p>Producer 请求 NameServer 获取 Broker 的地址。</p></li><li class="lvl-3"><p>Producer 将消息发送到 Broker 中的消息队列。</p></li><li class="lvl-3"><p>Consumer 订阅 Broker 中的消息队列，通过拉取消息，或由 Broker 将消息推送至 Consumer。</p></li></ol><p><strong>具体介绍</strong>：</p><ol><li class="lvl-3"><p>Producer Cluster 消息生产者群</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>负责发送消息，一般由业务系统负责产生消息。</p></li></ul><ol start="2"><li class="lvl-3"><p>Consumer Cluster 消息费群</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>负责消费消息，一般是后台系统负责异步消费。</p></li><li class="lvl-2"><p>两种消费模式：</p><ul class="lvl-2"><li class="lvl-6">Push Consumer，服务端向消费者端推送消息</li><li class="lvl-6">Pull Consumer，消费者端向服务定时拉取消息</li></ul></li></ul><ol start="3"><li class="lvl-3"><p>NameServer 名称服务器</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>集群架构中的组织协调员，相当于注册中心，收集 broker 的工作情况，不负责消息的处理</p></li></ul><ol start="4"><li class="lvl-3"><p>Broker 消息服务器</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>是 RocketMQ 的核心，负责消息的接受，存储，发送等。</p></li><li class="lvl-2"><p>需要定时发送自身状态 到 NameServer，默认 10 秒发送一次，超时 2 分钟会认为该 broker 失效。</p></li></ul><h3 id="安装-2">安装</h3><h4 id="Windows-2">Windows</h4><ol><li class="lvl-3"><p>下载</p></li></ol><blockquote><p>下载地址：<a class="link"   href="https://archive.apache.org/dist/rocketmq/" >https://archive.apache.org/dist/rocketmq/<i class="fas fa-external-link-alt"></i></a></p><p>下载后解压到一个没有空格和中文的目录。并配置安装目录为环境变量。</p></blockquote><ol start="2"><li class="lvl-3"><p>启动</p></li></ol><blockquote><p>Broker 默认磁盘空间利用率达到 85% 就不再接收，这里在开发环境可以提高磁盘空间利用率报警阀值为 98%。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调整默认的内存大小参数（按机器的大小配置）</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 编辑runserver.cmd，修改并保存</span></span></span><br><span class="line">&quot;JAVA_OPT=%JAVA_OPT% ‐server ‐Xms512m ‐Xmx512m ‐Xmn512m ‐XX:MetaspaceSize=128m ‐ XX:MaxMetaspaceSize=320m&quot; </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行bin/mqnamesrv.cmd</span></span><br><span class="line">cd bin/</span><br><span class="line">start mqnamesrv.cmd</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动broker -n：指定NameServer的地址，运行bin/mqbroker.cmd ‐n 127.0.0.1:9876</span></span><br><span class="line">cd bin/</span><br><span class="line">start mqbroker.cmd -n 127.0.0.1:9876 autoCreateTopicEnable=true</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 启动失败可以删除 C:/user/用户名/store 这个目录及目录下的所有文件，然后重新执行命令</span></span></span><br></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p>测试</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发送消息</span></span><br><span class="line">cd bin/ </span><br><span class="line">set NAMESRV_ADDR=127.0.0.1:9876 </span><br><span class="line">tools.cmd org.apache.rocketmq.example.quickstart.Producer</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">接收消息</span></span><br><span class="line">set NAMESRV_ADDR=127.0.0.1:9876 </span><br><span class="line">tools.cmd org.apache.rocketmq.example.quickstart.Consumer</span><br></pre></td></tr></table></figure><ol start="4"><li class="lvl-3"><p>安装管理端</p></li></ol><blockquote><p>RocketMQ 提供了 UI 管理工具，名为 rocketmq-console，项目地址：<a class="link"   href="https://github.com/apache/rocketmq-externals/tree/release-rocketmq-console-1.0.0" >https://github.com/apache/rocketmq-externals/tree/release-rocketmq-console-1.0.0<i class="fas fa-external-link-alt"></i></a></p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载源文件，并切换到console分支</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改配置</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 修改rocketmq-console\src\main\resources\application.properties</span></span></span><br><span class="line">server.port=9877</span><br><span class="line">rocketmq.config.namesrvAddr=127.0.0.1:9876</span><br><span class="line">rocketmq.config.dataPath=/tmp/rocketmq-console/data</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打包</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 进入目录下</span></span></span><br><span class="line">mvn clean package ‐Dmaven.test.skip=true</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span></span><br><span class="line">cd /rocketmq-console/target</span><br><span class="line">java -jar rocketmq-console-ng-1.0.0.jar --server.port=9877 --rocketmq.config.namesrvAddr=127.0.0.1:9876</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">访问 http://127.0.0.1:9877</span></span><br></pre></td></tr></table></figure><h4 id="Linux-2">Linux</h4><blockquote><p>由于 RocketMQ 由 Java 编写，基本操作与 Windows 一致，上传包到服务器后解压运行即可（这里只记录部分 Linux 命令）。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编辑文件</span></span><br><span class="line">vim runserver.cmd </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件位置下运行命令（后台运行）</span></span><br><span class="line">nohup java -jar rocketmq-console-ng-1.0.0.jar</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">控制台相关</span></span><br><span class="line">tail -100 nohup.out</span><br><span class="line">tail -f nohup.out </span><br><span class="line">cp /dev/null nohup.out</span><br></pre></td></tr></table></figure><h3 id="基本使用-2">基本使用</h3><h4 id="三种消息发送方式">三种消息发送方式</h4><ol><li class="lvl-3"><p>同步消息（sync message）<br>producer 向 broker 发送消息，执行 API 时同步等待， 直到 broker 服务器返回发送结果 。</p></li><li class="lvl-3"><p>异步消息（async message）<br>producer 向 broker 发送消息时指定消息发送成功及发送异常的回调方法，调用 API 后立即返回，producer 发送消 息线程不阻塞 ，消息发送成功或失败的回调任务在一个新的线程中执行 。</p></li><li class="lvl-3"><p>单向消息（oneway message）<br>producer 向 broker 发送消息，执行 API 时直接返回，不等待 broker 服务器的结果 。</p></li></ol><h4 id="消息结构">消息结构</h4><p>RocketMQ 的消息包括基础属性和扩展属性两部分：</p><ol><li class="lvl-3"><p>基础属性</p><ol><li class="lvl-7">topic： 主题相当于消息的一级分类，具有相同 topic 的消息将发送至该 topic 下的消息队列中，比方说一个电商 系统可以分为商品消息、订单消息、物流消息等，就可以在 broker 中创建商品主题、订单主题等，所有商品的消息发送至该主题下的消息队列中。</li><li class="lvl-7">消息体：即消息的内容 ，可以的字符串、对象等类型（可系列化）。消息的最大长度是 4M。</li><li class="lvl-7">消息 Flag：消息的一个标记，RocketMQ 不处理，留给业务系统使用。</li></ol></li><li class="lvl-3"><p>扩展属性</p><ol><li class="lvl-7">tag：相当于消息的二级分类，用于消费消息时进行过滤，可为空 。</li><li class="lvl-7">keys：Message 索引键，在运维中可以根据这些 key 快速检索到消息， 可为空 。</li><li class="lvl-7">waitStoreMsgOK：消息 发送时是否等消息存储完成后再返回 。</li></ol></li></ol><p>Message 的基础属性主要包括消息所属主题 topic ， 消息 Flag（RocketMQ 不做处理）、 扩展属性、消息体 。</p><h4 id="生产者工程">生产者工程</h4><ol><li class="lvl-3"><p>添加依赖</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.rocketmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rocketmq-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>添加配置</p></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rocketmq:</span></span><br><span class="line">  <span class="attr">nameServer:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9876</span></span><br><span class="line">  <span class="attr">producer:</span></span><br><span class="line">    <span class="attr">group:</span> <span class="string">PID_PAY_PRODUCER</span></span><br></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p>发送同步消息</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>  </span><br><span class="line"><span class="meta">@Slf4j</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayChannelAgentServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">PayChannelAgentService</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Resource</span>  </span><br><span class="line">    <span class="keyword">private</span> PayProducer payProducer;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 调用支付宝手机WAP下单接口  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> aliConfigParam 支付渠道参数  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> alipayBean 请求支付参数  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BusinessException BusinessException  </span></span><br><span class="line"><span class="comment">     */</span>    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> PaymentResponseDTO <span class="title function_">createPayOrderByAliWAP</span><span class="params">(AliConfigParam aliConfigParam, AlipayBean alipayBean)</span> <span class="keyword">throws</span> BusinessException, UnsupportedEncodingException &#123;  </span><br><span class="line">        <span class="comment">// 拼接支付信息</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">//发送支付结果查询延迟消息  </span></span><br><span class="line">            PaymentResponseDTO&lt;AliConfigParam&gt; notice = <span class="keyword">new</span> <span class="title class_">PaymentResponseDTO</span>&lt;AliConfigParam&gt;();  </span><br><span class="line">            notice.setOutTradeNo(alipayBean.getOutTradeNo());  </span><br><span class="line">            notice.setContent(aliConfigParam);  </span><br><span class="line">            notice.setMsg(<span class="string">&quot;ALIPAY_WAP&quot;</span>);  </span><br><span class="line">            payProducer.payOrderNotice(notice);  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 调用SDK提交表单  </span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            ...</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li class="lvl-3"><p>测试（控制台出现 end… 表示消息发送成功。进入管理端，查询消息。）</p></li></ol><h4 id="消费者工程">消费者工程</h4><ol><li class="lvl-3"><p>配置文件</p></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rocketmq:</span></span><br><span class="line">  <span class="attr">nameServer:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9876</span></span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>消费消息（<mark>监听消息队列需要指定 topic 与 consumerGroup</mark>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span>  </span><br><span class="line"><span class="meta">@Service</span>  </span><br><span class="line"><span class="meta">@RocketMQMessageListener(topic = &quot;TP_PAYMENT_ORDER&quot;, consumerGroup = &quot;CID_PAYMENT_CONSUMER&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayConsumer</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;MessageExt&gt; &#123;  </span><br><span class="line">    <span class="meta">@Resource</span>  </span><br><span class="line">    <span class="keyword">private</span> PayChannelAgentService payAgentService;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(MessageExt messageExt)</span> &#123;  </span><br><span class="line">        log.info(<span class="string">&quot;开始消费支付结果查询消息:&#123;&#125;&quot;</span>, messageExt);  </span><br><span class="line">        <span class="comment">// 取出消息内容  </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(messageExt.getBody(), StandardCharsets.UTF_8);  </span><br><span class="line">        <span class="type">PaymentResponseDTO</span> <span class="variable">response</span> <span class="operator">=</span> JSON.parseObject(body, PaymentResponseDTO.class);  </span><br><span class="line">        <span class="type">String</span> <span class="variable">outTradeNo</span> <span class="operator">=</span> response.getOutTradeNo();  </span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> response.getMsg();  </span><br><span class="line">        <span class="type">String</span> <span class="variable">param</span> <span class="operator">=</span> String.valueOf(response.getContent());  </span><br><span class="line">        <span class="type">AliConfigParam</span> <span class="variable">aliConfigParam</span> <span class="operator">=</span> JSON.parseObject(param, AliConfigParam.class);  </span><br><span class="line">        <span class="comment">// 判断是支付宝还是微信  </span></span><br><span class="line">        <span class="type">PaymentResponseDTO</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PaymentResponseDTO</span>();  </span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;ALIPAY_WAP&quot;</span>.equals(msg)) &#123;  </span><br><span class="line">            <span class="comment">// 查询支付宝支付结果  </span></span><br><span class="line">            result = payAgentService.queryPayOrderByAli(aliConfigParam, outTradeNo);  </span><br><span class="line">            <span class="comment">//不管支付成功还是失败都需要发送支付结果消息  </span></span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;WX_JSAPI&quot;</span>.equals(msg)) &#123;  </span><br><span class="line">            <span class="comment">// 查询微信支付结果  </span></span><br><span class="line">            ...</span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//返回查询获得的支付状态  </span></span><br><span class="line">        <span class="keyword">if</span> (TradeStatus.UNKNOWN.equals(result.getTradeState()) || TradeStatus.USERPAYING.equals(result.getTradeState())) &#123;  </span><br><span class="line">        <span class="comment">// 在支付状态未知或支付中，抛出异常会重新消息此消息  </span></span><br><span class="line">            log.info(<span class="string">&quot;支付代理‐‐‐支付状态未知，等待重试&quot;</span>);  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;支付状态未知，等待重试&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息发送过程">消息发送过程</h3><p><img                         lazyload                       alt="image"                       data-src="https://blog-resources.oss-cn-hangzhou.aliyuncs.com/Z2408/RocketMQ%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E7%9A%84%E8%BF%87%E7%A8%8B.png"                        alt=""                 ></p><p>消息发送流程如下：</p><ol><li class="lvl-3"><p>Producer 从 NameServer 中获取主题路由信息<br>Broker 将自己的状态上报给 NameServer，NameServer 中存储了每个 Broker 及主题、消息队列的信息。<br>Producer 根据 topic 从 NameServer 查询所有消息队列，查询到的结果例如：</p></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span> </span><br><span class="line">  <span class="punctuation">&#123;</span><span class="attr">&quot;brokerName&quot;</span><span class="punctuation">:</span><span class="string">&quot;Broker‐1&quot;</span><span class="punctuation">,</span><span class="attr">&quot;queueId&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="punctuation">&#123;</span><span class="attr">&quot;brokerName&quot;</span><span class="punctuation">:</span><span class="string">&quot;Broker‐1&quot;</span><span class="punctuation">,</span><span class="attr">&quot;queueId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="punctuation">&#123;</span><span class="attr">&quot;brokerName&quot;</span><span class="punctuation">:</span><span class="string">&quot;Broker‐2&quot;</span><span class="punctuation">,</span><span class="attr">&quot;queueId&quot;</span><span class="punctuation">:</span><span class="number">0</span><span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="punctuation">&#123;</span><span class="attr">&quot;brokerName&quot;</span><span class="punctuation">:</span><span class="string">&quot;Broker‐2&quot;</span><span class="punctuation">,</span><span class="attr">&quot;queueId&quot;</span><span class="punctuation">:</span><span class="number">1</span><span class="punctuation">&#125;</span> </span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>Producer 按选择算法从以上队列中选择一个进行消息发送，如果发送消息失败则在下次选择的时候 会规避掉失败的 broker。</p><ol start="2"><li class="lvl-3"><p>构建消息，发送消息发送消息前进行校验，比如消息的内容长度不能为 0、消息最大长度、消息必要的属性是否具备等（topic、消息体，生产组等）。如果该 topic 下还没有队列则自动创建，默认一个 topic 下自动创建 4 个写队列，4 个读队列 。</p></li></ol><p><strong>为什么要多个队列？</strong></p><ol><li class="lvl-3"><p>高可用：当某个队列不可用时其它队列顶上。</p></li><li class="lvl-3"><p>提高并发：发送消息是选择队列进行发送，提高发送消息的并发能力。 消息消费时每个消费者可以监听多个队列，提高消费消息的并发能力。<br><strong>生产组有什么用？</strong><br>在事务消息中 broker 需要回查 producer，同一个生产组的 producer 组成一个集群，提高并发能力。</p></li></ol><ol start="3"><li class="lvl-3"><p>监听队列，消费消息一个消费组可以包括多个消费者，一个消费组可以订阅多个主题。一个队列同时只允许一个消费者消费，一个消费者可以消费多个队列中的消息。消费组有两种消费模式：</p><ol><li class="lvl-6">集群模式：一个消费组内的消费者组成一个集群，主题下的一条消息只能被一个消费者消费。</li><li class="lvl-6">广播模式：主题下的一条消息能被消费组下的所有消费者消费。消费者和 broker 之间通过推模式和拉模式接收消息，推模式即 broker 推送给消费者，拉模式是消费者主动从 broker 查询消息。</li></ol></li></ol><h3 id="三种消息发送方式-2">三种消息发送方式</h3><h4 id="同步消息">同步消息</h4><p>见基本使用的例子。</p><h4 id="异步消息">异步消息</h4><p>producer 向 broker 发送消息时指定消息发送成功及发送异常的回调方法，调用 API 后立即返回，producer 发送消 息线程不阻塞 ，消息发送成功或失败的回调任务在一个新的线程中执行 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 发送异步消息  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> topic  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msg  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendASyncMsg</span><span class="params">(String topic, String msg)</span>&#123;  </span><br><span class="line">    rocketMQTemplate.asyncSend(topic,msg,<span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;  </span><br><span class="line">            <span class="comment">// 成功回调  </span></span><br><span class="line">            System.out.println(sendResult.getSendStatus());  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable e)</span> &#123;  </span><br><span class="line">            <span class="comment">// 异常回调  </span></span><br><span class="line">            System.out.println(e.getMessage());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="meta">@Test</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSendASyncMsg</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;  </span><br><span class="line">    <span class="built_in">this</span>.producerSimple.sendASyncMsg(<span class="string">&quot;my‐topic&quot;</span>, <span class="string">&quot;第一条异步步消息&quot;</span>);  </span><br><span class="line">    System.out.println(<span class="string">&quot;end...&quot;</span>);  </span><br><span class="line">    <span class="comment">// 异步消息，为跟踪回调线程这里加入延迟  </span></span><br><span class="line">    Thread.sleep(<span class="number">3000</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单向消息">单向消息</h4><p>producer 向 broker 发送消息，执行 API 时直接返回，不等待 broker 服务器的结果 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 发送单向消息  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> topic  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msg  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendOneWayMsg</span><span class="params">(String topic, String msg)</span>&#123;  </span><br><span class="line">    <span class="built_in">this</span>.rocketMQTemplate.sendOneWay(topic,msg);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义消息格式">自定义消息格式</h3><ol><li class="lvl-3"><p>使用 String 传递数据</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsgByJson</span><span class="params">(String topic, OrderExt orderExt)</span> &#123;  </span><br><span class="line">    <span class="comment">// 发送同步消息，消息内容将orderExt转为json  </span></span><br><span class="line">    <span class="built_in">this</span>.rocketMQTemplate.convertAndSend(topic, orderExt);  </span><br><span class="line">    System.out.printf(<span class="string">&quot;send msg : %s&quot;</span>, orderExt);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消费端：使用 JSON 工具将字符串转为对象</span></span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="meta">@RocketMQMessageListener(topic = &quot;my‐topic&quot;, consumerGroup = &quot;demo‐consumer‐group&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerSimple</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;String&gt; &#123;  </span><br><span class="line">    <span class="comment">//接手到消息调用此方法  </span></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String s)</span> &#123;  </span><br><span class="line">        <span class="comment">// 如果是json数据，可以将json转为对象  </span></span><br><span class="line">        <span class="comment">// OrderExt orderExt = JSON.parseObject(s, OrderExt.class);  </span></span><br><span class="line">        System.out.println(s);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>使用对象接收数据</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="meta">@RocketMQMessageListener(topic = &quot;my‐topic‐obj&quot;, consumerGroup = &quot;demo‐consumer‐group‐obj&quot;)</span>  </span><br><span class="line"><span class="comment">// RocketMQListener 泛型指定要转换的对象类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerSimpleObj</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;OrderExt&gt; &#123;  </span><br><span class="line">    <span class="comment">// 接手到消息调用此方法  </span></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(OrderExt orderExt)</span> &#123;  </span><br><span class="line">        System.out.println(orderExt);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="延迟消息-2">延迟消息</h3><blockquote><p>RocketMQ 的延迟消息实现非常简单，只需要发送消息前设置延迟的时间，延迟时间存在十八个等级 （1s/5s/10s/30s/1m/2m/3m/4m/5m/6m/7m/8m/9m/10m/20m/30m/1h/2h），调用 setDelayTimeLevel() 设置与时间相对应的延迟级别即可。</p></blockquote><ol><li class="lvl-3"><p>同步消息延迟</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产端</span></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 发送延迟消息  </span></span><br><span class="line"><span class="comment"> * 消息内容为json格式  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMsgByJsonDelay</span><span class="params">(String topic, OrderExt orderExt)</span> <span class="keyword">throws</span> JsonProcessingException, InterruptedException, RemotingException, MQClientException, MQBrokerException &#123;  </span><br><span class="line">    <span class="comment">// 发送同步消息，消息内容将orderExt转为json  </span></span><br><span class="line">    Message&lt;OrderExt&gt; message = MessageBuilder.withPayload(orderExt).build();  </span><br><span class="line">    <span class="comment">// 指定发送超时时间（毫秒）和延迟等级  </span></span><br><span class="line">    <span class="built_in">this</span>.rocketMQTemplate.syncSend(topic, message, <span class="number">1000</span>, <span class="number">3</span>);  </span><br><span class="line">    System.out.printf(<span class="string">&quot;send msg : %s&quot;</span>, orderExt);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>异步消息延迟</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 发送异步延迟消息  </span></span><br><span class="line"><span class="comment"> * 消息内容为json格式  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendAsyncMsgByJsonDelay</span><span class="params">(String topic, OrderExt orderExt)</span> <span class="keyword">throws</span> JsonProcessingException, InterruptedException, RemotingException, MQClientException, MQBrokerException &#123;  </span><br><span class="line">    <span class="comment">// 消息内容将orderExt转为json  </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> <span class="built_in">this</span>.rocketMQTemplate.getObjectMapper().writeValueAsString(orderExt);  </span><br><span class="line">    org.apache.rocketmq.common.message.<span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">org</span>.apache.rocketmq.common.message.Message(topic, json.getBytes(Charset.forName(<span class="string">&quot;utf‐8&quot;</span>)));  </span><br><span class="line">    <span class="comment">// 设置延迟等级  </span></span><br><span class="line">    message.setDelayTimeLevel(<span class="number">3</span>);  </span><br><span class="line">    <span class="comment">// 发送异步消息  </span></span><br><span class="line">    <span class="built_in">this</span>.rocketMQTemplate.getProducer().send(message, <span class="keyword">new</span> <span class="title class_">SendCallback</span>() &#123;  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSuccess</span><span class="params">(SendResult sendResult)</span> &#123;  </span><br><span class="line">            System.out.println(sendResult);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onException</span><span class="params">(Throwable throwable)</span> &#123;  </span><br><span class="line">            System.out.println(throwable.getMessage());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;);  </span><br><span class="line">    System.out.printf(<span class="string">&quot;send msg : %s&quot;</span>, orderExt);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费重试">消费重试</h3><p>当消息发送到 Broker 成功，在被消费者消费时如果消费者没有正常消费，此时消息会重试消费。消费重试存在两种场景：</p><ol><li class="lvl-3"><p>消息没有被消费者接收，比如消费者与 broker 存在网络异常。此种情况消息会一直被消费重试。</p></li><li class="lvl-3"><p>当消息已经被消费者成功接收，但是在进行消息处理时出现异常，消费端无法向 Broker 返回成功，这种情况下 RocketMQ 会不断重试。<mark>borker 是怎么知道重试呢？</mark> 消费者在消费消息成功会向 broker 返回成功状态，否则会不断进行消费重试。</p></li></ol><h4 id="处理策略">处理策略</h4><blockquote><p>消息会按照延迟消息的延迟时间等级（1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h）从第 3 级开始重试，每试一次如果还不成功则延迟等级加 1。<em>重试了 16 次还未被成功消费将会投递到死信队列，到达死信队列的消息将不再被消费。</em></p></blockquote><p><strong>实际生产中不会让消息重试这么多次，通常在重试一定的次数后将消息写入数据库，由另外单独的程序或人工去处理。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerSimple</span> <span class="keyword">implements</span> <span class="title class_">RocketMQListener</span>&lt;MessageExt&gt; &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(MessageExt messageExt)</span> &#123;  </span><br><span class="line">        <span class="comment">// 取出当前重试次数  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">reconsumeTimes</span> <span class="operator">=</span> messageExt.getReconsumeTimes();  </span><br><span class="line">        <span class="comment">// 当大于一定的次数后将消息写入数据库，由单独的程序或人工去处理  </span></span><br><span class="line">        <span class="keyword">if</span> (reconsumeTimes &gt;= <span class="number">2</span>) &#123;  </span><br><span class="line">            <span class="comment">// 将消息写入数据库，之后正常返回  </span></span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(String.format(<span class="string">&quot;第%s次处理失败..&quot;</span>, reconsumeTimes));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Kafka">Kafka</h2><p>暂未学习，后序更新</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;针对&lt;mark&gt;消息队列&lt;/mark&gt;做出的总结。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;参考文章&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a class=&quot;link&quot;   href=&quot;https://blog.csdn.net/qq_45173404/article/details/116429302&quot; &gt;RabbitMQ超详细安装教程（Linux）&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;更新&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-07-23 初始记录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24-08-09 补充 RabbitMQ 的延迟消息&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="后端项目" scheme="https://kiml.github.io/categories/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="准备工作" scheme="https://kiml.github.io/categories/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
    
    
    <category term="Java" scheme="https://kiml.github.io/tags/Java/"/>
    
    <category term="RocketMQ" scheme="https://kiml.github.io/tags/RocketMQ/"/>
    
    <category term="RabbitMQ" scheme="https://kiml.github.io/tags/RabbitMQ/"/>
    
    <category term="Kafka" scheme="https://kiml.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>使用 git 提交报错：error RPC failed; HTTP 413 curl 22 The requested URL returned error 413</title>
    <link href="https://kiml.github.io/posts/5a672f0a/"/>
    <id>https://kiml.github.io/posts/5a672f0a/</id>
    <published>2024-07-19T11:28:07.000Z</published>
    <updated>2024-08-12T03:50:56.795Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>参考文章：<a class="link"   href="https://blog.csdn.net/m0_55868614/article/details/120597702" >使用git提交时报错：error: RPC failed； HTTP 413 curl 22 The requested URL returned error: 413 Request Entity<i class="fas fa-external-link-alt"></i></a></p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-07-19 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="问题">问题</h2><p>使用 git push 时报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Total 254 (delta 50), reused 0 (delta 0), pack-reused 0</span><br><span class="line">error: RPC failed; HTTP 413 curl 22 The requested URL returned error: 413</span><br><span class="line">send-pack: unexpected disconnect while reading sideband packet</span><br><span class="line">fatal: the remote end hung up unexpectedly</span><br></pre></td></tr></table></figure><h2 id="原因">原因</h2><blockquote><p>413 Request Entity Too Large 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。</p></blockquote><h2 id="解决">解决</h2><ol><li class="lvl-3"><p>修改上传的数据限制<mark>好像没用</mark></p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.postBuffer 52428800</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>使用 ssh 方式上传<mark>还是不行</mark></p></li></ol><p>（1）查看当前 git 的提交地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>（2）查看 ssh 仓库地址</p><p>（3）设置更换远程仓库地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin 复制过来的ssh地址</span><br></pre></td></tr></table></figure><p>（4）再次提交</p><ol start="3"><li class="lvl-3"><p>原先在提交目录下加了一个 1G 多的 doc 目录，删除了这个文件，但是返回如下报错信息。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">remote: This repository(including wiki) size 2.25 GB, exceeds 1024.00 MB.        </span><br><span class="line">remote: You only have 3 push opportunities        </span><br><span class="line">remote: HelpLink:       https://gitee.com/help/articles/4232        </span><br><span class="line">remote: Repository GC:  https://gitee.com/kiml_rgb/shanjupay/settings#git-gcerror: File: 1e079cdcb1b8f36ed4bb8a17a78df5582ca9db14 2.24 GB, exceeds 100.00 MB.    </span><br></pre></td></tr></table></figure><p>（1）按照提示执行命令查看超大的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rev-list --objects --all | grep 1e079cdcb1b8f36ed4bb8a17a78df5582ca9db14</span><br></pre></td></tr></table></figure><p>（2）执行命令忽略掉超大的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached file_name</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果是文件夹</span></span><br><span class="line">git rm -r --cached directory_name</span><br></pre></td></tr></table></figure><p>（3）在 commit 的提交历史里面去除这个超大文件（注意这里要填写步骤 1 查询出的文件全称，包括文件路径）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch --tree-filter &#x27;rm -f 文件名&#x27; HEAD</span><br></pre></td></tr></table></figure><p>（4）<mark>如果报错</mark>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WARNING: git-filter-branch has a glut of gotchas generating mangled history</span><br><span class="line">         rewrites.  Hit Ctrl-C before proceeding to abort, then use an</span><br><span class="line">         alternative filtering tool such as &#x27;git filter-repo&#x27;</span><br><span class="line">         (https://github.com/newren/git-filter-repo/) instead.  See the</span><br><span class="line">         filter-branch manual page for more details; to squelch this warning,</span><br><span class="line">         set FILTER_BRANCH_SQUELCH_WARNING=1.</span><br></pre></td></tr></table></figure><p>执行以下命令，然后重新执行移除命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p>出现 <code>… was rewritten</code> 记录说明执行成功。再次使用 <code>git push</code> 成功。</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;参考文章：&lt;a class=&quot;link&quot;   href=&quot;https://blog.csdn.net/m0_55868614/article/details/120597702&quot; &gt;使用git提交时报错：error: RPC failed； HTTP 413 curl 22 The requested URL returned error: 413 Request Entity&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-07-19 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="bug记录" scheme="https://kiml.github.io/categories/bug%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="Git" scheme="https://kiml.github.io/tags/Git/"/>
    
    <category term="BUG" scheme="https://kiml.github.io/tags/BUG/"/>
    
  </entry>
  
  <entry>
    <title>04 聚合支付-【代码模板】支付宝支付接入</title>
    <link href="https://kiml.github.io/posts/fc17a9b8/"/>
    <id>https://kiml.github.io/posts/fc17a9b8/</id>
    <published>2024-07-19T10:15:31.000Z</published>
    <updated>2024-08-12T03:50:17.788Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>支付宝支付接入流程</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-07-19 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="支付产品">支付产品</h2><p>支付宝为普通商户提供如下支付产品 <a class="link"   href="https://b.alipay.com/page/product-workspace/all-product" >https://b.alipay.com/page/product-workspace/all-product<i class="fas fa-external-link-alt"></i></a>：</p><p><img                         lazyload                       alt="image"                       data-src="https://blog-resources.oss-cn-hangzhou.aliyuncs.com/Z2407/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%94%AF%E4%BB%98%E4%BA%A7%E5%93%81%E4%B8%AD%E5%BF%83.png"                        alt=""                 ></p><h2 id="配置支付宝沙箱环境">配置支付宝沙箱环境</h2><p>接入手机网站支付需要具备如下条件：</p><ol><li class="lvl-3"><p>申请前必须拥有经过实名认证的支付宝账户；</p></li><li class="lvl-3"><p>企业或个体工商户可申请；</p></li><li class="lvl-3"><p>需提供真实有效的营业执照，且支付宝账户名称需与营业执照主体一致；</p></li><li class="lvl-3"><p>网站能正常访问且页面显示完整，网站需要明确经营内容且有完整的商品信息；</p></li><li class="lvl-3"><p>网站必须通过 ICP 备案。如为个体工商户，网站备案主体需要与支付宝账户主体名称一致；</p></li><li class="lvl-3"><p>如为个体工商户，则团购不开放，且古玩、珠宝等奢侈品、投资类行业无法申请本产品。具体见：<a class="link"   href="https://opendocs.alipay.com/open/203" >https://opendocs.alipay.com/open/203<i class="fas fa-external-link-alt"></i></a><br>支付宝沙箱环境配置见：<a class="link"   href="https://opendocs.alipay.com/open/200/105311/" >沙箱环境 - 支付宝文档中心 (alipay.com)<i class="fas fa-external-link-alt"></i></a></p></li></ol><h3 id="注册开放平台账号">注册开放平台账号</h3><p>支付宝开放平台地址：<a class="link"   href="https://developers.alipay.com/" >支付宝开放平台 (alipay.com)<i class="fas fa-external-link-alt"></i></a></p><h3 id="配置密钥">配置密钥</h3><p>进入沙箱页面：<a class="link"   href="https://open.alipay.com/develop/sandbox/app" >https://open.alipay.com/develop/sandbox/app<i class="fas fa-external-link-alt"></i></a></p><p><img                         lazyload                       alt="image"                       data-src="https://blog-resources.oss-cn-hangzhou.aliyuncs.com/Z2407/%E6%B2%99%E7%AE%B1%E9%85%8D%E7%BD%AE%E9%A1%B5%E9%9D%A2.png"                        alt=""                 ></p><p>启用证书模式，并根据提示完成对应的配置。</p><h3 id="测试环境准备">测试环境准备</h3><p>我们在测试支付宝下单接口时需要使用支付宝扫描二维码，需要在手机安装支付宝客户端（沙箱版本），用沙箱账号登录支付宝，扫二维码，二维码的地址即为下单接口的地址。</p><p>或者使用模拟器进行测试。模拟器安装地址：<a class="link"   href="https://mumu.163.com/" >MuMu模拟器官网_安卓12模拟器_网易手游模拟器 (163.com)<i class="fas fa-external-link-alt"></i></a></p><p>安装完成后进行登录。</p><h2 id="手机网站支付接口（H5）">手机网站支付接口（H5）</h2><blockquote><p><a class="link"   href="https://opendocs.alipay.com/open/203/" >小程序文档 - 支付宝文档中心 (alipay.com)<i class="fas fa-external-link-alt"></i></a></p><p>商家在网页应用中调用支付宝提供的网页支付接口，接口会调起支付宝客户端内的支付模块，此时会从商家网页应 用跳转到支付宝客户端中并开始支付；支付完成后会跳转回商家网页应用内，最后商家展示支付结果。</p></blockquote><h3 id="接口交互">接口交互</h3><p><a class="link"   href="https://opendocs.alipay.com/open/203/105285/" >手机网站支付快速接入 - 支付宝文档中心 (alipay.com)<i class="fas fa-external-link-alt"></i></a></p><ol><li class="lvl-3"><p>用户在商户的 H5 网站下单支付后，商户系统按照手机网站支付接口 <code>alipay.trade.wap.payAPI</code> 的参数规范生成订 单数据</p></li><li class="lvl-3"><p>前端页面通过 Form 表单的形式请求到支付宝。此时支付宝会自动将页面跳转至支付宝 H5 收银台页面，如果用户手机上安装了支付宝 APP，则自动唤起支付宝 APP。</p></li><li class="lvl-3"><p>输入支付密码完成支付。</p></li><li class="lvl-3"><p>用户在支付宝 APP 或 H5 收银台完成支付后，会根据商户在手机网站支付 API 中传入的前台回跳地址 <code>return_url</code> 自动跳转回商户页面，同时在 URL 请求中以 Query String 的形式附带上支付结果参数，详细回跳参数见“手机网站支付接口 <code>alipay.trade.wap.pay</code>”前台回跳参数。</p></li><li class="lvl-3"><p>支付宝还会根据原始支付 API 中传入的异步通知地址 notify_url，通过 POST 请求的形式将支付结果作为参数通知 到商户系统，详情见支付结果异步通知。</p></li></ol><h3 id="下单接口定义">下单接口定义</h3><p><strong>请求地址</strong>：</p><table><thead><tr><th>环境</th><th>Https 请求地址</th></tr></thead><tbody><tr><td>沙箱环境</td><td><a class="link"   href="https://openapi.alipaydev.com/gateway.do" >https://openapi.alipaydev.com/gateway.do<i class="fas fa-external-link-alt"></i></a></td></tr><tr><td>正式环境</td><td><a class="link"   href="https://openapi.alipay.com/gateway.do" >https://openapi.alipay.com/gateway.do<i class="fas fa-external-link-alt"></i></a></td></tr></tbody></table><p><strong>公共请求参数</strong>：<a class="link"   href="https://opendocs.alipay.com/open/203/107090/" >请求参数说明 - 支付宝文档中心 (alipay.com)<i class="fas fa-external-link-alt"></i></a></p><h3 id="下单接口测试">下单接口测试</h3><ol><li class="lvl-3"><p><a class="link"   href="https://opendocs.alipay.com/common/02n6z6" >maven 依赖<i class="fas fa-external-link-alt"></i></a></p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alipay.sdk<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>alipay-sdk-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>对应的最新版本<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>代码编写：可参考示例</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span>  </span><br><span class="line"><span class="meta">@Controller</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PayTestController</span> &#123;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">APP_ID</span> <span class="operator">=</span> <span class="string">&quot;XXX&quot;</span>;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">APP_PRIVATE_KEY</span> <span class="operator">=</span> <span class="string">&quot;XXX&quot;</span>;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">ALIPAY_PUBLIC_KEY</span> <span class="operator">=</span> <span class="string">&quot;XXX&quot;</span>;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">CHARSET</span> <span class="operator">=</span> <span class="string">&quot;utf‐8&quot;</span>;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">serverUrl</span> <span class="operator">=</span> <span class="string">&quot;https://openapi.alipaydev.com/gateway.do&quot;</span>;  </span><br><span class="line">    <span class="comment">// 正式 &quot;https://openapi.alipay.com/gateway.do&quot;@GetMapping(&quot;/alipaytest&quot;)  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">alipaytest</span><span class="params">(HttpServletRequest httpRequest, HttpServletResponse httpResponse)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">       <span class="comment">// 获得初始化的AlipayClient   </span></span><br><span class="line"><span class="type">AlipayClient</span> <span class="variable">alipayClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultAlipayClient</span>(serverUrl, APP_ID, APP_PRIVATE_KEY, <span class="string">&quot;json&quot;</span>, CHARSET, ALIPAY_PUBLIC_KEY, <span class="string">&quot;RSA2&quot;</span>);  </span><br><span class="line">       <span class="comment">// 创建API对应的 request        </span></span><br><span class="line">       <span class="type">AlipayTradeWapPayRequest</span> <span class="variable">alipayRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlipayTradeWapPayRequest</span>();  </span><br><span class="line">       <span class="comment">// 填充业务参数  </span></span><br><span class="line">        alipayRequest.setBizContent(<span class="string">&quot;&#123;&quot;</span> + <span class="string">&quot; \&quot;out_trade_no\&quot;:\&quot;20150320010101123\&quot;,&quot;</span> + <span class="string">&quot; \&quot;total_amount\&quot;:\&quot;0.01\&quot;,&quot;</span> + <span class="string">&quot; \&quot;subject\&quot;:\&quot;Iphone6 16G\&quot;,&quot;</span> + <span class="string">&quot; \&quot;product_code\&quot;:\&quot;QUICK_WAP_PAY\&quot;&quot;</span> + <span class="string">&quot; &#125;&quot;</span>);  </span><br><span class="line">        <span class="type">String</span> <span class="variable">form</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="comment">// 调用SDK生成表单  </span></span><br><span class="line">            form = alipayClient.pageExecute(alipayRequest).getBody();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (AlipayApiException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        httpResponse.setContentType(<span class="string">&quot;text/html;charset=&quot;</span> + CHARSET);  </span><br><span class="line">       <span class="comment">// 直接将完整的表单html输出到页面  </span></span><br><span class="line">        httpResponse.getWriter().write(form);  </span><br><span class="line">        httpResponse.getWriter().flush();  </span><br><span class="line">        httpResponse.getWriter().close();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p>二维码生成指定二维码的 URL，模拟器/手机必须可以访问到此地址。（<em>本机测试需要在同一个局域网内并使用局域网地址，或者使用内网穿透的地址</em>）</p></li></ol><h3 id="完整代码">完整代码</h3><ol><li class="lvl-3"><p>工具类</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlipayUtil</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AlipayConfig alipayConfig;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AlipayUtil</span><span class="params">(AlipayConfig alipayConfig)</span>&#123;  </span><br><span class="line">        AlipayUtil.alipayConfig = alipayConfig;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 创建阿里云链接  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> alipayConfig 支付宝支付配置  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> AlipayClient  </span></span><br><span class="line"><span class="comment">     */</span>    <span class="keyword">public</span> <span class="keyword">static</span> AlipayClient <span class="title function_">createClient</span><span class="params">(AlipayConfig alipayConfig)</span> &#123;  </span><br><span class="line">        <span class="type">AlipayClient</span> <span class="variable">alipayClient</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            alipayConfig.setAppCertContent(ResourceUtil.readUtf8Str(alipayConfig.getAppCertPath()));  </span><br><span class="line">            alipayConfig.setAlipayPublicCertContent(ResourceUtil.readUtf8Str(alipayConfig.getAlipayPublicCertPath()));  </span><br><span class="line">            alipayConfig.setRootCertContent(ResourceUtil.readUtf8Str(alipayConfig.getRootCertPath()));  </span><br><span class="line">            alipayClient = <span class="keyword">new</span> <span class="title class_">DefaultAlipayClient</span>(alipayConfig);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (AlipayApiException e) &#123;  </span><br><span class="line">            log.error(<span class="string">&quot;AlipayClient创建失败:&quot;</span> + e.getMessage());  </span><br><span class="line">            <span class="comment">// 构建异常日志  </span></span><br><span class="line">            <span class="type">val</span> <span class="variable">operLog</span> <span class="operator">=</span> OperLog.builder().title(<span class="string">&quot;支付宝支付&quot;</span>)  </span><br><span class="line">                    .businessType(BusinessType.OTHER.ordinal())  </span><br><span class="line">                    .operUrl(alipayConfig.getServerUrl())  </span><br><span class="line">                    .operParam(JSONUtil.toJsonPrettyStr(alipayConfig))  </span><br><span class="line">                    .status(BusinessStatus.FAIL.ordinal())  </span><br><span class="line">                    .errorMsg(e.getErrMsg())  </span><br><span class="line">                    .build();  </span><br><span class="line">            AsyncManager.me().execute(AsyncFactory.recordOper(operLog));  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> alipayClient;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 预支付接口调用  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> alipayTradePrecreateRequest 支付宝预支付接口请求  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> AlipayTradePrecreateResponse 支付宝预支付接口返回  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AlipayTradePrecreateResponse <span class="title function_">alipayTradePrecreate</span><span class="params">(AlipayTradePrecreateRequest alipayTradePrecreateRequest)</span> &#123;  </span><br><span class="line">        alipayTradePrecreateRequest.setNotifyUrl(alipayConfig.getNotifyUrl());  </span><br><span class="line">        <span class="type">AlipayTradePrecreateResponse</span> <span class="variable">alipayTradePrecreateResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlipayTradePrecreateResponse</span>();  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            alipayTradePrecreateResponse = createClient(alipayConfig).certificateExecute(alipayTradePrecreateRequest);  </span><br><span class="line">  </span><br><span class="line">            log.info(<span class="string">&quot;[返回参数]：\n&quot;</span> + JSONUtil.toJsonPrettyStr(alipayTradePrecreateResponse));  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span>(alipayTradePrecreateResponse.isSuccess())&#123;  </span><br><span class="line">                <span class="keyword">return</span> alipayTradePrecreateResponse;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                log.error(alipayTradePrecreateResponse.getOutTradeNo() + <span class="string">&quot;支付宝支付失败:&quot;</span> + alipayTradePrecreateResponse.getMsg());  </span><br><span class="line">                <span class="comment">// 构建异常日志  </span></span><br><span class="line">                <span class="type">val</span> <span class="variable">operLog</span> <span class="operator">=</span> OperLog.builder().title(<span class="string">&quot;支付宝支付&quot;</span>)  </span><br><span class="line">                        .businessType(BusinessType.OTHER.ordinal())  </span><br><span class="line">                        .operUrl(alipayConfig.getServerUrl())  </span><br><span class="line">                        .requestMethod(alipayTradePrecreateRequest.getApiMethodName())  </span><br><span class="line">                        .operParam(JSONUtil.toJsonPrettyStr(alipayTradePrecreateRequest))  </span><br><span class="line">                        .status(BusinessStatus.FAIL.ordinal())  </span><br><span class="line">                        .errorMsg(JSONUtil.toJsonPrettyStr(alipayTradePrecreateResponse))  </span><br><span class="line">                        .build();  </span><br><span class="line">                AsyncManager.me().execute(AsyncFactory.recordOper(operLog));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (AlipayApiException e) &#123;  </span><br><span class="line">            log.error(alipayTradePrecreateResponse.getOutTradeNo() + <span class="string">&quot;支付宝支付失败:&quot;</span> + e.getMessage());  </span><br><span class="line">            <span class="comment">// 构建异常日志  </span></span><br><span class="line">            <span class="type">val</span> <span class="variable">operLog</span> <span class="operator">=</span> OperLog.builder().title(<span class="string">&quot;支付宝支付&quot;</span>)  </span><br><span class="line">                    .businessType(BusinessType.OTHER.ordinal())  </span><br><span class="line">                    .operUrl(alipayConfig.getServerUrl())  </span><br><span class="line">                    .operParam(JSONUtil.toJsonPrettyStr(alipayTradePrecreateRequest))  </span><br><span class="line">                    .status(BusinessStatus.FAIL.ordinal())  </span><br><span class="line">                    .errorMsg(e.getMessage())  </span><br><span class="line">                    .build();  </span><br><span class="line">            AsyncManager.me().execute(AsyncFactory.recordOper(operLog));  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> alipayTradePrecreateResponse;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 订单查询接口调用  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> alipayTradeQueryRequest 支付宝查单接口请求  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> AlipayTradeQueryResponse 支付宝查单接口返回  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AlipayTradeQueryResponse <span class="title function_">alipayTradeQuery</span><span class="params">(AlipayTradeQueryRequest alipayTradeQueryRequest)</span> &#123;  </span><br><span class="line">        <span class="type">AlipayTradeQueryResponse</span> <span class="variable">alipayTradeQueryResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlipayTradeQueryResponse</span>();  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            alipayTradeQueryResponse = createClient(alipayConfig).certificateExecute(alipayTradeQueryRequest);  </span><br><span class="line">            <span class="keyword">if</span>(alipayTradeQueryResponse.isSuccess())&#123;  </span><br><span class="line">                log.info(<span class="string">&quot;支付宝查单返回：&quot;</span> + JSONUtil.toJsonPrettyStr(alipayTradeQueryResponse));  </span><br><span class="line">                <span class="keyword">return</span> alipayTradeQueryResponse;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                log.error(alipayTradeQueryResponse.getOutTradeNo() + <span class="string">&quot;支付宝查单失败:&quot;</span> + alipayTradeQueryResponse.getMsg());  </span><br><span class="line">                <span class="comment">// 构建异常日志  </span></span><br><span class="line">                <span class="type">val</span> <span class="variable">operLog</span> <span class="operator">=</span> OperLog.builder().title(<span class="string">&quot;支付宝查单&quot;</span>)  </span><br><span class="line">                        .businessType(BusinessType.OTHER.ordinal())  </span><br><span class="line">                        .operUrl(alipayConfig.getServerUrl())  </span><br><span class="line">                        .requestMethod(alipayTradeQueryRequest.getApiMethodName())  </span><br><span class="line">                        .operParam(JSONUtil.toJsonPrettyStr(alipayTradeQueryRequest))  </span><br><span class="line">                        .status(BusinessStatus.FAIL.ordinal())  </span><br><span class="line">                        .errorMsg(alipayTradeQueryResponse.getMsg())  </span><br><span class="line">                        .build();  </span><br><span class="line">                AsyncManager.me().execute(AsyncFactory.recordOper(operLog));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (AlipayApiException e) &#123;  </span><br><span class="line">            log.error(alipayTradeQueryResponse.getOutTradeNo() + <span class="string">&quot;支付宝查单失败:&quot;</span> + e.getMessage());  </span><br><span class="line">            <span class="comment">// 构建异常日志  </span></span><br><span class="line">            <span class="type">val</span> <span class="variable">operLog</span> <span class="operator">=</span> OperLog.builder().title(<span class="string">&quot;支付宝查单&quot;</span>)  </span><br><span class="line">                    .businessType(BusinessType.OTHER.ordinal())  </span><br><span class="line">                    .operUrl(alipayConfig.getServerUrl())  </span><br><span class="line">                    .operParam(JSONUtil.toJsonPrettyStr(alipayTradeQueryRequest))  </span><br><span class="line">                    .status(BusinessStatus.FAIL.ordinal())  </span><br><span class="line">                    .errorMsg(e.getMessage())  </span><br><span class="line">                    .build();  </span><br><span class="line">            AsyncManager.me().execute(AsyncFactory.recordOper(operLog));  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> alipayTradeQueryResponse;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 支付宝订单关闭  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> alipayTradeCloseRequest 支付宝关单接口请求  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> AlipayTradeCloseResponse 支付宝关单接口返回  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AlipayTradeCloseResponse <span class="title function_">alipayTradeClose</span><span class="params">(AlipayTradeCloseRequest alipayTradeCloseRequest)</span> &#123;  </span><br><span class="line">        <span class="type">AlipayTradeCloseResponse</span> <span class="variable">alipayTradeQueryResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlipayTradeCloseResponse</span>();  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            alipayTradeQueryResponse = createClient(alipayConfig).certificateExecute(alipayTradeCloseRequest);  </span><br><span class="line">            <span class="keyword">if</span>(alipayTradeQueryResponse.isSuccess())&#123;  </span><br><span class="line">                <span class="keyword">return</span> alipayTradeQueryResponse;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                log.error(alipayTradeQueryResponse.getOutTradeNo() + <span class="string">&quot;支付宝关单失败:&quot;</span> + alipayTradeQueryResponse.getMsg());  </span><br><span class="line">                <span class="comment">// 构建异常日志  </span></span><br><span class="line">                <span class="type">val</span> <span class="variable">operLog</span> <span class="operator">=</span> OperLog.builder().title(<span class="string">&quot;支付宝关单&quot;</span>)  </span><br><span class="line">                        .businessType(BusinessType.OTHER.ordinal())  </span><br><span class="line">                        .operUrl(alipayConfig.getServerUrl())  </span><br><span class="line">                        .requestMethod(alipayTradeCloseRequest.getApiMethodName())  </span><br><span class="line">                        .operParam(JSONUtil.toJsonPrettyStr(alipayTradeCloseRequest))  </span><br><span class="line">                        .status(BusinessStatus.FAIL.ordinal())  </span><br><span class="line">                        .errorMsg(alipayTradeQueryResponse.getSubMsg())  </span><br><span class="line">                        .build();  </span><br><span class="line">                AsyncManager.me().execute(AsyncFactory.recordOper(operLog));  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (AlipayApiException e) &#123;  </span><br><span class="line">            log.error(alipayTradeQueryResponse.getOutTradeNo() + <span class="string">&quot;支付宝关单失败:&quot;</span> + e.getMessage());  </span><br><span class="line">            <span class="comment">// 构建异常日志  </span></span><br><span class="line">            <span class="type">val</span> <span class="variable">operLog</span> <span class="operator">=</span> OperLog.builder().title(<span class="string">&quot;支付宝关单&quot;</span>)  </span><br><span class="line">                    .businessType(BusinessType.OTHER.ordinal())  </span><br><span class="line">                    .operUrl(alipayConfig.getServerUrl())  </span><br><span class="line">                    .operParam(JSONUtil.toJsonPrettyStr(alipayTradeCloseRequest))  </span><br><span class="line">                    .status(BusinessStatus.FAIL.ordinal())  </span><br><span class="line">                    .errorMsg(e.getMessage())  </span><br><span class="line">                    .build();  </span><br><span class="line">            AsyncManager.me().execute(AsyncFactory.recordOper(operLog));  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> alipayTradeQueryResponse;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>创建支付宝 V3 版本请求对象</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AlipayTradePrecreateRequest <span class="title function_">createAlipayBeanV3ByOrder</span><span class="params">(Order order)</span> &#123;  </span><br><span class="line">    <span class="type">AlipayTradePrecreateRequest</span> <span class="variable">alipayTradePrecreateRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlipayTradePrecreateRequest</span>();  </span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">bizContent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();  </span><br><span class="line">    bizContent.set(<span class="string">&quot;out_trade_no&quot;</span>, order.getOrderNo());  </span><br><span class="line">    <span class="comment">// 支付宝支付 订单总金额，单位为元，精确到小数点后两位，取值范围为 [0.01,100000000]，金额不能为 0。  </span></span><br><span class="line">    bizContent.set(<span class="string">&quot;total_amount&quot;</span>, order.getTotal());  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 标题部分根据需求修改</span></span><br><span class="line">    <span class="comment">// String subject = order.getGoodName();  </span></span><br><span class="line">    <span class="comment">// if (ObjectUtil.isNotEmpty(order.getSize())) &#123;  </span></span><br><span class="line">    <span class="comment">//     subject = subject + &quot;[&quot; + order.getSize() + &quot;]&quot;;  </span></span><br><span class="line">    <span class="comment">// &#125;  </span></span><br><span class="line">    <span class="comment">// subject = &quot;x-design风格化定制周边订单_&quot; + subject;  </span></span><br><span class="line">  </span><br><span class="line">    bizContent.set(<span class="string">&quot;subject&quot;</span>, subject);  </span><br><span class="line">  </span><br><span class="line">    alipayTradePrecreateRequest.setBizContent(bizContent.toString());  </span><br><span class="line">    <span class="keyword">return</span> alipayTradePrecreateRequest;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p>支付宝查单</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> BaseResponse&lt;Integer&gt; <span class="title function_">getAlipayBaseResponse</span><span class="params">(Order order, HttpServletRequest request)</span> &#123;  </span><br><span class="line">    <span class="type">AlipayTradeQueryRequest</span> <span class="variable">alipayTradeQueryRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlipayTradeQueryRequest</span>();  </span><br><span class="line">    <span class="type">JSONConfig</span> <span class="variable">jsonConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONConfig</span>();  </span><br><span class="line">    jsonConfig.setIgnoreNullValue(<span class="literal">false</span>);  </span><br><span class="line">    <span class="type">JSONObject</span> <span class="variable">bizContent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>(jsonConfig);  </span><br><span class="line">    bizContent.set(<span class="string">&quot;out_trade_no&quot;</span>, order.getOrderNo());  </span><br><span class="line">    bizContent.set(<span class="string">&quot;trade_no&quot;</span>, <span class="literal">null</span>);  </span><br><span class="line">    alipayTradeQueryRequest.setBizContent(bizContent.toString());  </span><br><span class="line">    log.info(<span class="string">&quot;订单：&quot;</span> + order.getOrderNo() + <span class="string">&quot;支付宝查单：&quot;</span> + JSONUtil.parse(alipayTradeQueryRequest));  </span><br><span class="line">    <span class="type">AlipayTradeQueryResponse</span> <span class="variable">alipayTradeQueryResponse</span> <span class="operator">=</span> AlipayUtil.alipayTradeQuery(alipayTradeQueryRequest);  </span><br><span class="line">    log.info(<span class="string">&quot;订单：&quot;</span> + order.getOrderNo() + <span class="string">&quot;支付宝查单结果：&quot;</span> + JSONUtil.parse(alipayTradeQueryResponse));  </span><br><span class="line">    <span class="comment">// 支付宝订单号  </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">tradeNo</span> <span class="operator">=</span> alipayTradeQueryResponse.getTradeNo();  </span><br><span class="line">    <span class="type">OtherPayInfo</span> <span class="variable">otherPayInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OtherPayInfo</span>();  </span><br><span class="line">    otherPayInfo.setTradeNo(tradeNo);  </span><br><span class="line">    <span class="comment">// 支付时间  </span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">time</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">    <span class="keyword">if</span> (ObjectUtil.isNotNull(alipayTradeQueryResponse.getSendPayDate())) &#123;  </span><br><span class="line">        time =  LocalDateTime.ofInstant(alipayTradeQueryResponse.getSendPayDate().toInstant(), ZoneId.systemDefault());  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 客户未扫码直接调用会出现订单不存在  </span></span><br><span class="line">    <span class="keyword">if</span> (ObjectUtil.isNull(alipayTradeQueryResponse.getTradeStatus())) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BaseResponse</span>&lt;&gt;(VMSystem.ORDER_STATUS_CREATE);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;TRADE_SUCCESS&quot;</span>.equals(alipayTradeQueryResponse.getTradeStatus())) &#123;  </span><br><span class="line">    <span class="comment">// 其他业务需求 修改订单信息 发送打印邮件等</span></span><br><span class="line">        <span class="comment">// // 修改订单信息  </span></span><br><span class="line">        <span class="comment">// val updateOrderByWx = this.updateOrderStatusByPay(order.getOrderNo(), time, VMSystem.ORDER_STATUS_PAYED, otherPayInfo);  </span></span><br><span class="line">        <span class="comment">// // 发送打印邮件  </span></span><br><span class="line">        <span class="comment">// this.sendMailtoPrint(order);  </span></span><br><span class="line">        <span class="comment">// if (updateOrderByWx) &#123;  </span></span><br><span class="line">        <span class="comment">//     return new BaseResponse&lt;&gt;(VMSystem.ORDER_STATUS_PAYED);  </span></span><br><span class="line">        <span class="comment">// &#125; else &#123;  </span></span><br><span class="line">        <span class="comment">//     throw new LogicException(&quot;订单状态更新异常&quot;);  </span></span><br><span class="line">        <span class="comment">// &#125;  </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;WAIT_BUYER_PAY&quot;</span>.equals(alipayTradeQueryResponse.getTradeStatus())) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BaseResponse</span>&lt;&gt;(VMSystem.ORDER_STATUS_CREATE);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        log.error(order.getOrderNo() + <span class="string">&quot;支付宝支付失败:网关描述：&quot;</span> + alipayTradeQueryResponse.getMsg() + <span class="string">&quot;业务描述：&quot;</span> + alipayTradeQueryResponse.getSubMsg());  </span><br><span class="line">        <span class="comment">// 构建异常日志  </span></span><br><span class="line">        <span class="type">OperLog</span> <span class="variable">operLog</span> <span class="operator">=</span> OperLog.builder().title(<span class="string">&quot;支付宝支付&quot;</span>)  </span><br><span class="line">                .businessType(BusinessType.OTHER.ordinal())  </span><br><span class="line">                .operIp(IpUtils.getIpAddr(request))  </span><br><span class="line">                .operParam(JSONUtil.toJsonPrettyStr(alipayTradeQueryRequest.getTextParams()))  </span><br><span class="line">                .status(BusinessStatus.FAIL.ordinal())  </span><br><span class="line">                .method(alipayTradeQueryRequest.getApiMethodName())  </span><br><span class="line">                .requestMethod(<span class="string">&quot;GET&quot;</span>)  </span><br><span class="line">                .errorMsg(<span class="string">&quot;支付宝支付失败:网关描述：&quot;</span> + alipayTradeQueryResponse.getMsg() + <span class="string">&quot;业务描述：&quot;</span> + alipayTradeQueryResponse.getSubMsg())  </span><br><span class="line">                .build();  </span><br><span class="line">        AsyncManager.me().execute(AsyncFactory.recordOper(operLog));  </span><br><span class="line">        <span class="comment">// 修改订单信息  </span></span><br><span class="line">        <span class="built_in">this</span>.updateOrderStatusByPay(order.getOrderNo(), time, VMSystem.ORDER_STATUS_FAILED, otherPayInfo);  </span><br><span class="line">        <span class="type">val</span> <span class="variable">baseResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BaseResponse</span>&lt;&gt;(VMSystem.ORDER_STATUS_FAILED);  </span><br><span class="line">        baseResponse.setMessage(<span class="string">&quot;支付宝支付失败:网关描述：&quot;</span> + alipayTradeQueryResponse.getMsg() + <span class="string">&quot;业务描述：&quot;</span> + alipayTradeQueryResponse.getSubMsg());  </span><br><span class="line">        <span class="keyword">return</span> baseResponse;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li class="lvl-3"><p>订单关闭</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 支付宝订单关闭  </span></span><br><span class="line"><span class="type">AlipayTradeCloseRequest</span> <span class="variable">alipayTradeCloseRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AlipayTradeCloseRequest</span>();  </span><br><span class="line"><span class="type">JSONConfig</span> <span class="variable">jsonConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONConfig</span>();  </span><br><span class="line">jsonConfig.setIgnoreNullValue(<span class="literal">false</span>);  </span><br><span class="line"><span class="type">JSONObject</span> <span class="variable">bizContent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();  </span><br><span class="line">bizContent.set(<span class="string">&quot;out_trade_no&quot;</span>, order.getOrderNo());  </span><br><span class="line">bizContent.set(<span class="string">&quot;trade_no&quot;</span>, order.getTradeNo());  </span><br><span class="line">alipayTradeCloseRequest.setBizContent(bizContent.toString());  </span><br><span class="line">AlipayUtil.alipayTradeClose(alipayTradeCloseRequest);</span><br></pre></td></tr></table></figure><h2 id="BUG">BUG</h2><h3 id="验签出错，建议检查签名字符串或签名私钥与应用公钥是否匹配">验签出错，建议检查签名字符串或签名私钥与应用公钥是否匹配</h3><blockquote><p>技术文档：<a class="link"   href="https://opendocs.alipay.com/support/01ravw" >https://opendocs.alipay.com/support/01ravw<i class="fas fa-external-link-alt"></i></a></p><p><strong>问题原因</strong><br>密钥不匹配、编码格式不统一（<em>本次测试后更换中文编码格式</em>）、请求参数数据有误、接口调用加签方式和应用上选择的加签方式不对应、SDK 调用的提交方法有误、SDK 运行环境有误</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;支付宝支付接入流程&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-07-19 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="后端项目" scheme="https://kiml.github.io/categories/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="聚合支付" scheme="https://kiml.github.io/categories/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE/%E8%81%9A%E5%90%88%E6%94%AF%E4%BB%98/"/>
    
    
    <category term="Java" scheme="https://kiml.github.io/tags/Java/"/>
    
    <category term="代码模板" scheme="https://kiml.github.io/tags/%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第四十六天-42接雨水、84柱状图中最大的矩形</title>
    <link href="https://kiml.github.io/posts/82b551fe/"/>
    <id>https://kiml.github.io/posts/82b551fe/</id>
    <published>2024-07-13T01:06:09.000Z</published>
    <updated>2024-07-16T09:49:11.804Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：42 看解析。84 看解析。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">24-07-13 初始记录</span><br><span class="line">24-07-16 完成</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="初步题解">初步题解</h2><h3 id="42-接雨水">42 接雨水</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/trapping-rain-water/" >https://leetcode.cn/problems/trapping-rain-water/<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="84-柱状图中最大的矩形">84 柱状图中最大的矩形</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/largest-rectangle-in-histogram" >https://leetcode.cn/problems/largest-rectangle-in-histogram<i class="fas fa-external-link-alt"></i></a>)</p><h2 id="看解析">看解析</h2><h3 id="42-接雨水-2">42 接雨水</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0042.%E6%8E%A5%E9%9B%A8%E6%B0%B4.html" >https://programmercarl.com/0042.接雨水.html<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>当前高度小于等于栈顶高度，入栈，指针后移。</p></li><li class="lvl-3"><p>当前高度大于栈顶高度，出栈，计算出当前墙和栈顶的墙之间水的多少，然后计算当前的高度和新栈的高度的关系，重复第 2 步。直到当前墙的高度不大于栈顶高度或者栈空，然后把当前墙入栈，指针后移。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;  </span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    stack.push(<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; height.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (height[i] &lt;= height[stack.peek()]) &#123;  </span><br><span class="line">            stack.push(i);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// 当前元素小于栈顶元素  </span></span><br><span class="line">            <span class="keyword">if</span> (height[stack.peek()] &gt;= height[i]) &#123;  </span><br><span class="line">                stack.push(i);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) &#123;  </span><br><span class="line">                    <span class="comment">// 当前的栈顶  </span></span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">mid</span> <span class="operator">=</span> stack.pop();  </span><br><span class="line">                    <span class="keyword">if</span> (!stack.isEmpty()) &#123;  </span><br><span class="line">                        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> Math.min(height[stack.peek()], height[i]) - height[mid];  </span><br><span class="line">                        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> i - stack.peek() - <span class="number">1</span>;  </span><br><span class="line">                        area += h * w;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                &#125;  </span><br><span class="line">                stack.push(i);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> area;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="84-柱状图中最大的矩形-2">84 柱状图中最大的矩形</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0084.%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2.html" >https://programmercarl.com/0084.柱状图中最大的矩形.html<i class="fas fa-external-link-alt"></i></a>)</p><p><em>本题是要找每个柱子左右两边第一个小于该柱子的柱子，所以从栈头（元素从栈头弹出）到栈底的顺序应该是从大到小的顺序</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;  </span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  </span><br><span class="line">    <span class="comment">// 首末尾加零防止无法进入循环  </span></span><br><span class="line">    <span class="type">int</span>[] newHeights = <span class="keyword">new</span> <span class="title class_">int</span>[heights.length + <span class="number">2</span>];  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; newHeights.length - <span class="number">1</span>; i++) &#123;  </span><br><span class="line">        newHeights[i] = heights[i - <span class="number">1</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">    newHeights[heights.length + <span class="number">1</span>] = <span class="number">0</span>;  </span><br><span class="line">    newHeights[<span class="number">0</span>] = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    stack.push(<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; newHeights.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; newHeights[i] &lt; newHeights[stack.peek()]) &#123;  </span><br><span class="line">            <span class="comment">// 当前元素的前一个元素  </span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">mid</span> <span class="operator">=</span> stack.pop();  </span><br><span class="line">            <span class="comment">// 右侧数据与左侧数据的差值  </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> i - stack.peek() - <span class="number">1</span>;  </span><br><span class="line">            area = Math.max(area, w * newHeights[mid]);  </span><br><span class="line">        &#125;  </span><br><span class="line">        stack.push(i);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> area;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：42 看解析。84 看解析。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-07-13 初始记录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24-07-16 完成&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="单调栈" scheme="https://kiml.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第四十五天-739每日温度、496下一个更大元素 I、503下一个更大元素II</title>
    <link href="https://kiml.github.io/posts/d0198d2/"/>
    <id>https://kiml.github.io/posts/d0198d2/</id>
    <published>2024-07-11T02:53:32.000Z</published>
    <updated>2024-07-16T09:44:58.106Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：739 看解析。496 看解析。503 根据 739 写出。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-07-11 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="初步题解">初步题解</h2><h3 id="739-每日温度">739 每日温度</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/daily-temperatures" >https://leetcode.cn/problems/daily-temperatures<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="496-下一个更大元素-I">496 下一个更大元素 I</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/next-greater-element-i" >https://leetcode.cn/problems/next-greater-element-i<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="503-下一个更大元素-II">503 下一个更大元素 II</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/next-greater-element-ii" >https://leetcode.cn/problems/next-greater-element-ii<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] nextGreaterElements(<span class="type">int</span>[] nums) &#123;  </span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];  </span><br><span class="line">    Arrays.fill(result, -<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  </span><br><span class="line">    stack.push(<span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length * <span class="number">2</span>; i++) &#123;  </span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[i % nums.length] &gt; nums[stack.peek()]) &#123;  </span><br><span class="line">            result[stack.peek()] = nums[i % nums.length];  </span><br><span class="line">            stack.pop();  </span><br><span class="line">        &#125;  </span><br><span class="line">        stack.push(i % nums.length);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="看解析">看解析</h2><h3 id="739-每日温度-2">739 每日温度</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0739.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6.html" >https://programmercarl.com/0739.每日温度.html<i class="fas fa-external-link-alt"></i></a>)</p><ul class="lvl-0"><li class="lvl-2"><p>情况一：当前遍历的元素 <code>T[i]</code> 小于栈顶元素 <code>T[st.top()]</code> 的情况</p></li><li class="lvl-2"><p>情况二：当前遍历的元素 <code>T[i]</code> 等于栈顶元素 <code>T[st.top()]</code> 的情况</p></li><li class="lvl-2"><p>情况三：当前遍历的元素 <code>T[i]</code> 大于栈顶元素 <code>T[st.top()]</code> 的情况</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;  </span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();  </span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[temperatures.length];  </span><br><span class="line">  </span><br><span class="line">    stack.push(<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; temperatures.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 当前元素小于等于栈顶元素，直接继续放入  </span></span><br><span class="line">        <span class="keyword">if</span> (temperatures[i] &lt;= temperatures[stack.peek()]) &#123;  </span><br><span class="line">            stack.push(i);  </span><br><span class="line">        <span class="comment">// 当前元素大于栈顶元素，弹出元素，计算result，（直到当前元素不大于栈顶元素），将当前元素加入栈</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;  </span><br><span class="line">                result[stack.peek()] = i - stack.peek();  </span><br><span class="line">                stack.pop();  </span><br><span class="line">            &#125;  </span><br><span class="line">            stack.push(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;  </span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();  </span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[temperatures.length];  </span><br><span class="line">  </span><br><span class="line">    stack.push(<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; temperatures.length; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;  </span><br><span class="line">                result[stack.peek()] = i - stack.peek();  </span><br><span class="line">                stack.pop();  </span><br><span class="line">            &#125;  </span><br><span class="line">        stack.push(i);    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="496-下一个更大元素-I-2">496 下一个更大元素 I</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0496.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0I.html" >https://programmercarl.com/0496.下一个更大元素I.html<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;  </span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];  </span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    Arrays.fill(result, -<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;  </span><br><span class="line">        map.put(nums1[i], i);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    stack.push(<span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums2.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (nums2[i] &lt;= nums2[stack.peek()]) &#123;  </span><br><span class="line">            stack.push(i);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">// 栈中保存了上个需要比较的对象</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums2[i] &gt; nums2[stack.peek()]) &#123;  </span><br><span class="line">                <span class="comment">// num1中包含整这个元素  </span></span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(nums2[stack.peek()])) &#123;  </span><br><span class="line">                    <span class="comment">// result中的对应下标为这个元素的后一位  </span></span><br><span class="line">                    result[map.get(nums2[stack.peek()])] = nums2[i];  </span><br><span class="line">                &#125;  </span><br><span class="line">                stack.pop();  </span><br><span class="line">            &#125;  </span><br><span class="line">            stack.push(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="503-下一个更大元素-II-2">503 下一个更大元素 II</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0503.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0II.html" >https://programmercarl.com/0503.下一个更大元素II.html<i class="fas fa-external-link-alt"></i></a>)</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：739 看解析。496 看解析。503 根据 739 写出。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-07-11 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="单调栈" scheme="https://kiml.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第四十四天-647回文子串、516最长回文子序列</title>
    <link href="https://kiml.github.io/posts/aa7c5f5/"/>
    <id>https://kiml.github.io/posts/aa7c5f5/</id>
    <published>2024-07-09T09:13:45.000Z</published>
    <updated>2024-07-10T14:19:12.457Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：647 看解析，516 看解析</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">24-07-09 初始记录</span><br><span class="line">24-07-10 完成</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="初步题解">初步题解</h2><h3 id="647-回文子串">647 回文子串</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/palindromic-substrings" >https://leetcode.cn/problems/palindromic-substrings<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="516-最长回文子序列">516 最长回文子序列</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/longest-palindromic-subsequence" >https://leetcode.cn/problems/longest-palindromic-subsequence<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i][j]</code> 的含义：表示区间范围 <code>[i,j]</code> （注意是左闭右闭）的子串的最长回文子串的长度。</p></li><li class="lvl-3"><p>递推公式：<code>s[i]</code> 与 <code>s[j]</code> 相等，<code>s[i]</code> 与 <code>s[j]</code> 不相等这两种情况：不相等取左右指针向内移动的最大值；相等 <code>dp[i][j] = dp[i + 1][j - 1] + 2;  </code></p></li><li class="lvl-3"><p>dp 数组的初始化：相等时，取 1。</p></li><li class="lvl-3"><p>遍历顺序：<strong>从下到上，从左到右遍历</strong></p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()][s.length()];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;  </span><br><span class="line">        dp[i][i] = <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> max= <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; s.length(); j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;  </span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">2</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                dp[i][j] = Math.max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);  </span><br><span class="line">            &#125;  </span><br><span class="line">            max = Math.max(dp[i][j], max);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> max;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="看解析">看解析</h2><h3 id="647-回文子串-2">647 回文子串</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0647.%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.html" >https://programmercarl.com/0647.回文子串.html<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i][j]</code> 的含义：表示区间范围 <code>[i,j]</code> （注意是左闭右闭）的子串是否是回文子串，如果是 <code>dp[i][j]</code> 为 true，否则为 false。</p></li><li class="lvl-3"><p>递推公式：<code>s[i]</code> 与 <code>s[j]</code> 相等，<code>s[i]</code> 与 <code>s[j]</code> 不相等这两种情况：不相等即为 false；相等分为三种情况：下标 i 与 j 相同，同一个字符返回 true；下标 i 与 j 相差为 1，返回 true；i 与 j 相差大于 1 的时候，判断 <code>dp[i + 1][j - 1]</code> 是否为 true</p></li><li class="lvl-3"><p>dp 数组的初始化：全为 false</p></li><li class="lvl-3"><p>遍历顺序：<strong>从下到上，从左到右遍历</strong></p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;  </span><br><span class="line">    <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length()][s.length()];  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; s.length(); j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(j)) &#123;  </span><br><span class="line">                dp[i][j] = <span class="literal">false</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="keyword">if</span> (j - i &lt;= <span class="number">1</span>) &#123;  </span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;  </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (dp[i][j]) &#123;  </span><br><span class="line">                num++;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> num;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="516-最长回文子序列-2">516 最长回文子序列</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0516.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.html" >https://programmercarl.com/0516.最长回文子序列.html<i class="fas fa-external-link-alt"></i></a>)</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：647 看解析，516 看解析&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-07-09 初始记录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24-07-10 完成&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="动态规划" scheme="https://kiml.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第四十三天-115不同的子序列、583两个字符串的删除操作、72编辑距离</title>
    <link href="https://kiml.github.io/posts/ca280c35/"/>
    <id>https://kiml.github.io/posts/ca280c35/</id>
    <published>2024-07-08T08:02:07.000Z</published>
    <updated>2024-07-08T13:25:23.863Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：115 不会、583 根据 115AC、72 不会</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-07-08 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="初步题解">初步题解</h2><h3 id="115-不同的子序列">115 不同的子序列</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/distinct-subsequences/" >https://leetcode.cn/problems/distinct-subsequences/<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="583-两个字符串的删除操作">583 两个字符串的删除操作</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/delete-operation-for-two-strings/" >https://leetcode.cn/problems/delete-operation-for-two-strings/<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i][j]</code> 的含义：s 到 i - 1；t 到 j - 1 位置的删除相同需要的最小步数。</p></li><li class="lvl-3"><p>递推公式：如果当前位置元素相同：<code>dp[i][j] = dp[i - 1][j - 1]; </code>（即不加这个元素时的子序列个数 + 加上这个元素的子序列个数）， 如果当前位置元素不同：<code>dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1); </code>（画图即当前位置的上左再去除一个元素并取较小值）。</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[i][0]</code> 、<code>dp[0][j]</code> 都是与元素个数有关。</p></li><li class="lvl-3"><p>遍历顺序：从上到下，从左到右。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; i++) &#123;  </span><br><span class="line">        dp[i][<span class="number">0</span>] = i;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp[<span class="number">0</span>].length; i++) &#123;  </span><br><span class="line">        dp[<span class="number">0</span>][i] = i;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= word1.length(); i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= word2.length(); j++) &#123;  </span><br><span class="line">            <span class="comment">// 当前指针位置相同，dp[i][j] = dp[i - 1][j - 1] + 1  </span></span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;  </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j] + <span class="number">1</span>, dp[i][j - <span class="number">1</span>] + <span class="number">1</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[word1.length()][word2.length()];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="72-编辑距离">72 编辑距离</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/edit-distance" >https://leetcode.cn/problems/edit-distance<i class="fas fa-external-link-alt"></i></a>)</p><h2 id="看解析">看解析</h2><h3 id="115-不同的子序列-2">115 不同的子序列</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0115.%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97.html" >https://programmercarl.com/0115.不同的子序列.html<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i][j]</code> 的含义：s 到 i - 1；t 到 j - 1 位置的子序列个数。</p></li><li class="lvl-3"><p>递推公式：如果当前位置元素相同：<code>dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; </code>（即不加这个元素时的子序列个数 + 加上这个元素的子序列个数）， 如果当前位置元素不同：<code>dp[i][j] = dp[i - 1][j];</code>。</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[i][0]</code> 一定都是 1，因为也就是把以 i-1 为结尾的 s，删除所有元素，出现空字符串的个数就是 1。<code>dp[0][j]</code> 一定都是 0。<code>dp[0][0]</code> 应该是 1。</p></li><li class="lvl-3"><p>遍历顺序：从上到下，从左到右。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length() + <span class="number">1</span>][t.length() + <span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; i++) &#123;  </span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s.length(); i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= t.length(); j++) &#123;  </span><br><span class="line">            <span class="comment">// 当前指针位置相同，dp[i][j] = dp[i - 1][j - 1] + 1  </span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>)) &#123;  </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[s.length()][t.length()];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="583-两个字符串的删除操作-2">583 两个字符串的删除操作</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0583.%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.html" >https://programmercarl.com/0583.两个字符串的删除操作.html<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="72-编辑距离-2">72 编辑距离</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0072.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB.html" >https://programmercarl.com/0072.编辑距离.html<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i][j]</code> 的含义：word1 到 i - 1；word2 到 j - 1 位置的最小编辑数。</p></li><li class="lvl-3"><p>递推公式：需要确认四种情况：<code>word1[i - 1] == word2[j - 1]</code> 时，不操作；<code>word1[i - 1] != word2[j - 1]</code>，增删换。具体公式看代码。</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[i][0]</code> 、<code>dp[0][j]</code> 都是与元素个数有关，即删除所有元素。</p></li><li class="lvl-3"><p>遍历顺序：从上到下，从左到右。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[word1.length() + <span class="number">1</span>][word2.length() + <span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; i++) &#123;  </span><br><span class="line">        dp[i][<span class="number">0</span>] = i;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp[<span class="number">0</span>].length; i++) &#123;  </span><br><span class="line">        dp[<span class="number">0</span>][i] = i;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= word1.length(); i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= word2.length(); j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>)) &#123;  </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="comment">// 三数比较  </span></span><br><span class="line">                <span class="comment">// word1删除一个元素，那么就是以下标i - 2为结尾的word1 与 j-1为结尾的word2的最近编辑距离 再加上一个操作。  </span></span><br><span class="line">                <span class="comment">// word2删除一个元素，那么就是以下标i - 1为结尾的word1 与 j-2为结尾的word2的最近编辑距离 再加上一个操作。  </span></span><br><span class="line">                <span class="comment">// 替换元素，word1替换word1[i - 1]，使其与word2[j - 1]相同，此时不用增删加元素。  </span></span><br><span class="line">                dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]), Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])) + <span class="number">1</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[word1.length()][word2.length()];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：115 不会、583 根据 115AC、72 不会&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-07-08 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="动态规划" scheme="https://kiml.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第四十二天-1143最长公共子序列、1035不相交的线、53最大子序和、392判断子序列</title>
    <link href="https://kiml.github.io/posts/2b15070f/"/>
    <id>https://kiml.github.io/posts/2b15070f/</id>
    <published>2024-07-05T06:14:16.000Z</published>
    <updated>2024-07-08T13:12:56.825Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：1143AC（方法不是最简的）、1035AC（和上一题一样）、53AC、392AC（根据 1143）</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">24-07-05 初始记录</span><br><span class="line">24-07-06 1143</span><br><span class="line">24-07-07 1143优化、1035、53、392</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="初步题解">初步题解</h2><h3 id="1143-最长公共子序列">1143 最长公共子序列</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/longest-common-subsequence/" >https://leetcode.cn/problems/longest-common-subsequence/<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i][j]</code> 的含义：text1 到 i；text2 到 j 位置的最长重复数组。</p></li><li class="lvl-3"><p>递推公式：如果当前位置元素相同：<code>dp[i][j] = dp[i - 1][j - 1] + 1; </code>， 如果当前位置元素不同：<code>dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); </code>。</p></li><li class="lvl-3"><p>dp 数组的初始化：针对初始元素是否相同及 i = 0 和 j = 0 的两种情况，都需要分别判断。</p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[text1.length()][text2.length()];  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; text1.length(); i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; text2.length(); j++) &#123;  </span><br><span class="line">            <span class="comment">// 当前指针位置相同，dp[i][j] = dp[i - 1][j - 1] + 1  </span></span><br><span class="line">            <span class="keyword">if</span> (text1.charAt(i) == text2.charAt(j)) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;  </span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;  </span><br><span class="line">                    maxLength = Math.max(dp[i][j], maxLength);  </span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;  </span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;  </span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;  </span><br><span class="line">                    dp[i][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>];  </span><br><span class="line">                    maxLength = Math.max(dp[i][j], maxLength);  </span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;  </span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][<span class="number">0</span>];  </span><br><span class="line">                    maxLength = Math.max(dp[i][j], maxLength);  </span><br><span class="line">                    <span class="keyword">continue</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);  </span><br><span class="line">            &#125;  </span><br><span class="line">            maxLength = Math.max(dp[i][j], maxLength);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> maxLength;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1035-不相交的线">1035 不相交的线</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/uncrossed-lines" >https://leetcode.cn/problems/uncrossed-lines<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i][j]</code> 的含义：text1 到 i - 1；text2 到 j - 1 位置的最长重复数组。</p></li><li class="lvl-3"><p>递推公式：如果当前位置元素相同：<code>dp[i][j] = dp[i - 1][j - 1] + 1; </code>， 如果当前位置元素不同：<code>dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); </code>。</p></li><li class="lvl-3"><p>dp 数组的初始化：i = 0 或 j = 0 时，dp 值为 0</p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxUncrossedLines</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length + <span class="number">1</span>][nums2.length + <span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums1.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= nums2.length; j++) &#123;  </span><br><span class="line">            <span class="comment">// 当前位置加入计数  </span></span><br><span class="line">            <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;  </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// System.out.println(Arrays.deepToString(dp));  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[nums1.length][nums2.length];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="53-最大子序和">53 最大子序和</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/maximum-subarray/" >https://leetcode.cn/problems/maximum-subarray/<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i]</code> 的含义：数组长度为 i 时的最大子序和。</p></li><li class="lvl-3"><p>递推公式：如果当前位置元素相同：<code>dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]); </code>。</p></li><li class="lvl-3"><p>dp 数组的初始化：i = 0 时，取 <code>nums[0]</code> 的值</p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];  </span><br><span class="line">  </span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];  </span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> dp[<span class="number">0</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; dp.length; i++) &#123;  </span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>] + nums[i], nums[i]);  </span><br><span class="line">        max = Math.max(max, dp[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.toString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> max;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="392-判断子序列">392 判断子序列</h3><ol><li class="lvl-3"><p>确定 <code>dp[i][j]</code> 的含义：s 到 i - 1；t 到 j - 1 位置的相同子序列长度。</p></li><li class="lvl-3"><p>递推公式：如果当前位置元素相同：<code>dp[i][j] = dp[i - 1][j - 1] + 1; </code>， 如果当前位置元素不同：<code>dp[i][j] = dp[i][j - 1]; </code>。</p></li><li class="lvl-3"><p>dp 数组的初始化：i = 0 或 j = 0 时，dp 值为 0</p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/is-subsequence" >https://leetcode.cn/problems/is-subsequence<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length() + <span class="number">1</span>][t.length() + <span class="number">1</span>];  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= s.length(); i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= t.length(); j++) &#123;  </span><br><span class="line">            <span class="comment">// 当前指针位置相同，dp[i][j] = dp[i - 1][j - 1] + 1  </span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>)) &#123;  </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>];  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[s.length()][t.length()] == s.length();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="看解析">看解析</h2><h3 id="1143-最长公共子序列-2">1143 最长公共子序列</h3><p>解析：(<a class="link"   href="https://programmercarl.com/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html" >https://programmercarl.com/1143.最长公共子序列.html<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>二维数组优化</p><ol><li class="lvl-7">dp 数组的定义修改为 <code>dp[i][j]</code>：长度为 <code>[0, i - 1]</code> 的字符串 text1 与长度为 <code>[0, j - 1]</code> 的字符串 text2 的最长公共子序列为 <code>dp[i][j]</code>（即多）</li><li class="lvl-7">初始化即 i 为 0，j 为 0 时，<code>dp[i][j]</code> 的值也为 0</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[text1.length() + <span class="number">1</span>][text2.length() + <span class="number">1</span>];  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= text1.length(); i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= text2.length(); j++) &#123;  </span><br><span class="line">            <span class="comment">// 当前指针位置相同，dp[i][j] = dp[i - 1][j - 1] + 1  </span></span><br><span class="line">            <span class="keyword">if</span> (text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>)) &#123;  </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// System.out.println(Arrays.deepToString(dp));  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[text1.length()][text2.length()];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>一维数组优化</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> text1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> text2.length();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 多从二维dp数组过程分析  </span></span><br><span class="line">        <span class="comment">// 关键在于  如果记录  dp[i - 1][j - 1]</span></span><br><span class="line">        <span class="comment">// 因为 dp[i - 1][j - 1]  &lt;!=&gt;  dp[j - 1]  &lt;=&gt;  dp[i][j - 1]</span></span><br><span class="line">        <span class="type">int</span> [] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n2 + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n1; i++)&#123;</span><br><span class="line">            <span class="comment">// 这里pre相当于 dp[i - 1][j - 1]</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> dp[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n2; j++)&#123;</span><br><span class="line">                <span class="comment">//用于给pre赋值</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> dp[j];</span><br><span class="line">                <span class="keyword">if</span>(text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                    <span class="comment">//这里pre相当于dp[i - 1][j - 1]   千万不能用dp[j - 1] !!</span></span><br><span class="line">                    dp[j] = pre + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// dp[j]     相当于   dp[i - 1][j]</span></span><br><span class="line">                    <span class="comment">// dp[j - 1] 相当于   dp[i][j - 1]</span></span><br><span class="line">                    dp[j] = Math.max(dp[j], dp[j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//更新dp[i - 1][j - 1], 为下次使用做准备</span></span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1035-不相交的线-2">1035 不相交的线</h3><p>解析：(<a class="link"   href="https://programmercarl.com/1035.%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF.html" >https://programmercarl.com/1035.不相交的线.html<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="53-最大子序和-2">53 最大子序和</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html" >https://programmercarl.com/0053.最大子序和（动态规划）.html<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="392-判断子序列-2">392 判断子序列</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0392.%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97.html" >https://programmercarl.com/0392.判断子序列.html<i class="fas fa-external-link-alt"></i></a>)</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：1143AC（方法不是最简的）、1035AC（和上一题一样）、53AC、392AC（根据 1143）&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-07-05 初始记录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24-07-06 1143&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24-07-07 1143优化、1035、53、392&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="动态规划" scheme="https://kiml.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第四十一天-300最长递增子序列、674最长连续递增序列、718最长重复子数组</title>
    <link href="https://kiml.github.io/posts/825964fb/"/>
    <id>https://kiml.github.io/posts/825964fb/</id>
    <published>2024-07-01T03:04:29.000Z</published>
    <updated>2024-07-03T10:51:56.018Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：300 看解析，674AC，718看解析</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-07-01 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="初步题解">初步题解</h2><h3 id="300-最长递增子序列">300 最长递增子序列</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/longest-increasing-subsequence" >https://leetcode.cn/problems/longest-increasing-subsequence<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i]</code> 的含义：<code>dp[i]</code> 表示第 i 个下标前的最长递增子序列的长度</p></li><li class="lvl-3"><p>递推公式：<code>dp[i] = Math.max(dp[i], dp[j] + 1)</code>。</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp</code> 数组所有元素的初始化值都为 1。</p></li><li class="lvl-4"><p>遍历顺序：从前向后遍历。</p></li><li class="lvl-4"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];  </span><br><span class="line">  </span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; dp.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;  </span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        maxLength = Math.max(maxLength, dp[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> maxLength;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="674-最长连续递增序列">674 最长连续递增序列</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence" >https://leetcode.cn/problems/longest-continuous-increasing-subsequence<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i]</code> 的含义：<code>dp[i]</code> 表示第 i 个下标前的最长连续递增子序列的长度</p></li><li class="lvl-3"><p>递推公式：<code>dp[i] = Math.max(dp[i], dp[i - 1] + 1)</code>。</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp</code> 数组所有元素的初始化值都为 1。</p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLengthOfLCIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];  </span><br><span class="line">  </span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; dp.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) &#123;  </span><br><span class="line">            dp[i] = Math.max(dp[i], dp[i - <span class="number">1</span>] + <span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        maxLength = Math.max(maxLength, dp[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> maxLength;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="718-最长重复子数组">718 最长重复子数组</h3><ol><li class="lvl-3"><p>确定 <code>dp[i][j]</code> 的含义：num1 到 i - 1；num2 到 j - 1 位置的最长重复数组。</p></li><li class="lvl-3"><p>递推公式：<code>dp[i][j] = dp[i - 1][j - 1] + 1; </code>。</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp</code> 数组所有元素的初始化值都为 0。</p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）题目链接：(<a class="link"   href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray" >https://leetcode.cn/problems/maximum-length-of-repeated-subarray<i class="fas fa-external-link-alt"></i></a>)</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length + <span class="number">1</span>][nums2.length + <span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums1.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= nums2.length; j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]) &#123;  </span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            maxLength = Math.max(dp[i][j], maxLength);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> maxLength;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="看解析">看解析</h2><h3 id="300-最长递增子序列-2">300 最长递增子序列</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0300.%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97.html" >https://programmercarl.com/0300.最长上升子序列.html<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="674-最长连续递增序列-2">674 最长连续递增序列</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0674.%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97.html" >https://programmercarl.com/0674.最长连续递增序列.html<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="718-最长重复子数组-2">718 最长重复子数组</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0718.%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84.html" >https://programmercarl.com/0718.最长重复子数组.html<i class="fas fa-external-link-alt"></i></a>)</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：300 看解析，674AC，718看解析&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-07-01 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="动态规划" scheme="https://kiml.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>【代码模板】二维码的生成</title>
    <link href="https://kiml.github.io/posts/5ee0f6a5/"/>
    <id>https://kiml.github.io/posts/5ee0f6a5/</id>
    <published>2024-06-28T09:57:09.000Z</published>
    <updated>2024-08-12T03:49:39.574Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>ZXing 是一个开源的，用 Java 编写的多格式的 1D / 2D 条码图像处理库，使用 ZXing 可以生成、识别 QR Code（二维码）。常用的二维码处理库还有 zbar，近几年已经不再更新代码，下边介绍 ZXing 生成二维码的方法。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-28 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="ZXing">ZXing</h2><ol><li class="lvl-3"><p>引入依赖</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 二维码生成&amp;识别组件--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.zxing<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.zxing<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javase<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>生成二维码方法</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QRCodeUtil</span> &#123;  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 生成二维码  </span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content 二维码对应的URL  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> width   二维码图片宽度  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> height  二维码图片高度  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 二维码二进制流  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createQRCode</span><span class="params">(String content, <span class="type">int</span> width, <span class="type">int</span> height)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">resultImage</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;  </span><br><span class="line">        <span class="comment">// 除了尺寸，传入内容不能为空  </span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(content)) &#123;  </span><br><span class="line">            <span class="type">ServletOutputStream</span> <span class="variable">stream</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">            <span class="type">ByteArrayOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();  </span><br><span class="line">            <span class="comment">// 二维码参数  </span></span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;rawtypes&quot;)</span>  </span><br><span class="line">            HashMap&lt;EncodeHintType, Comparable&gt; hints = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">            <span class="comment">// 指定字符编码为“utf-8”  </span></span><br><span class="line">            hints.put(EncodeHintType.CHARACTER_SET, <span class="string">&quot;utf-8&quot;</span>);  </span><br><span class="line">            <span class="comment">// L M Q H四个纠错等级从低到高，指定二维码的纠错等级为M  </span></span><br><span class="line">            <span class="comment">// 纠错级别越高，可以修正的错误就越多，需要的纠错码的数量也变多，相应的二维吗可储存的数据就会减少  </span></span><br><span class="line">            hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.M);  </span><br><span class="line">            <span class="comment">// 设置图片的边距  </span></span><br><span class="line">            hints.put(EncodeHintType.MARGIN, <span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="comment">// zxing生成二维码核心类  </span></span><br><span class="line">                <span class="type">QRCodeWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QRCodeWriter</span>();  </span><br><span class="line">                <span class="comment">// 把输入文本按照指定规则转成二维吗  </span></span><br><span class="line">                <span class="type">BitMatrix</span> <span class="variable">bitMatrix</span> <span class="operator">=</span> writer.encode(content, BarcodeFormat.QR_CODE, width, height, hints);  </span><br><span class="line">                <span class="comment">// 生成二维码图片流  </span></span><br><span class="line">                <span class="type">BufferedImage</span> <span class="variable">bufferedImage</span> <span class="operator">=</span> MatrixToImageWriter.toBufferedImage(bitMatrix);  </span><br><span class="line">                <span class="comment">// 输出流  </span></span><br><span class="line">                ImageIO.write(bufferedImage, <span class="string">&quot;png&quot;</span>, os);  </span><br><span class="line">                <span class="comment">/**  </span></span><br><span class="line"><span class="comment">                 * 原生转码前面没有 data:image/png;base64 这些字段，返回给前端是无法被解析，所以加上前缀  </span></span><br><span class="line"><span class="comment">                 */</span>  </span><br><span class="line">                resultImage = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;data:image/png;base64,&quot;</span> + EncryptUtil.encodeBase64(os.toByteArray()));  </span><br><span class="line">                <span class="keyword">return</span> resultImage;  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(CommonErrorCode.E_200007);  </span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">                <span class="keyword">if</span> (stream != <span class="literal">null</span>) &#123;  </span><br><span class="line">                    stream.flush();  </span><br><span class="line">                    stream.close();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
ZXing 是一个开源的，用 Java 编写的多格式的 1D / 2D 条码图像处理库，使用 ZXing 可以生成、识别 QR Code（二维码）。常用的二维码处理库还有 zbar，近几年已经不再更新代码，下边介绍 ZXing 生成二维码的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-28 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="后端项目" scheme="https://kiml.github.io/categories/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="准备工作" scheme="https://kiml.github.io/categories/%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第四十天-188买卖股票的最佳时机IV、309最佳买卖股票时机含冷冻期、714买卖股票的最佳时机含手续费</title>
    <link href="https://kiml.github.io/posts/ab0ba29f/"/>
    <id>https://kiml.github.io/posts/ab0ba29f/</id>
    <published>2024-06-28T01:12:43.000Z</published>
    <updated>2024-06-28T03:31:07.446Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：188 根据 123AC 了。309用另一种方法AC了。714AC。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-28 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="初步题解">初步题解</h2><h3 id="188-买卖股票的最佳时机-IV">188 买卖股票的最佳时机 IV</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv" >https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span> * k];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 初始化数据  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;  </span><br><span class="line">        dp[<span class="number">0</span>][i * <span class="number">2</span>] = -prices[<span class="number">0</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; dp.length; i++) &#123;  </span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; <span class="number">2</span> * k; j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (j % <span class="number">2</span> == <span class="number">0</span>) &#123;  </span><br><span class="line">                <span class="comment">// 偶数买入  </span></span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] - prices[i]);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="comment">// 奇数卖出  </span></span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + prices[i]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">2</span> * k - <span class="number">1</span>];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="309-最佳买卖股票时机含冷冻期">309 最佳买卖股票时机含冷冻期</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown" >https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown<i class="fas fa-external-link-alt"></i></a>)</p><p>思路：买卖股票 + 打家劫舍结合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;  </span><br><span class="line">    <span class="comment">// 0 表示持有股票的状态; 1 表示不持有股票的状态  </span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];  </span><br><span class="line">  </span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; dp.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;  </span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// 持有：前一天持有；前一天不持有（不可能）：前两天不持有  </span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">2</span>][<span class="number">1</span>] - prices[i]);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 不持有：前一天不持有；前一天持有  </span></span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="714-买卖股票的最佳时机含手续费">714 买卖股票的最佳时机含手续费</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee" >https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加上手续费就行</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 假设买入的时候支付手续费  </span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>] - fee;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; dp.length; i++) &#123;  </span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i] - fee);  </span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="看解析">看解析</h2><h3 id="188-买卖股票的最佳时机-IV-2">188 买卖股票的最佳时机 IV</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0188.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV.html" >https://programmercarl.com/0188.买卖股票的最佳时机IV.html<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="309-最佳买卖股票时机含冷冻期-2">309 最佳买卖股票时机含冷冻期</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0309.%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F.html" >https://programmercarl.com/0309.最佳买卖股票时机含冷冻期.html<i class="fas fa-external-link-alt"></i></a>)</p><p><strong>注意这里的每一个状态，例如状态一，是持有股票股票状态并不是说今天一定就买入股票，而是说保持买入股票的状态即：可能是前几天买入的，之后一直没操作，所以保持买入股票的状态</strong>。</p><p><strong>达到买入股票状态</strong>（状态一）即：<code>dp[i][0]</code>，有两个具体操作：</p><ul class="lvl-0"><li class="lvl-2"><p>操作一：前一天就是持有股票状态（状态一），<code>dp[i][0] = dp[i - 1][0]</code></p></li><li class="lvl-2"><p>操作二：今天买入了，有两种情况</p><ul class="lvl-2"><li class="lvl-6">前一天是冷冻期（状态四），<code>dp[i - 1][3] - prices[i]</code></li><li class="lvl-6">前一天是保持卖出股票的状态（状态二），<code>dp[i - 1][1] - prices[i]</code></li></ul></li></ul><p>那么 <code>dp[i][0] = max(dp[i - 1][0], dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i]);</code></p><p><strong>达到保持卖出股票状态</strong>（状态二）即：dp[i][1]，有两个具体操作：</p><ul class="lvl-0"><li class="lvl-2"><p>操作一：前一天就是状态二</p></li><li class="lvl-2"><p>操作二：前一天是冷冻期（状态四），<code>dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);</code></p></li></ul><p><strong>达到今天就卖出股票状态</strong>（状态三），即：<code>dp[i][2]</code>，只有一个操作：</p><p>昨天一定是持有股票状态（状态一），今天卖出，即：<code>dp[i][2] = dp[i - 1][0] + prices[i]</code>;</p><p><strong>达到冷冻期状态</strong>（状态四），即：<code>dp[i][3]</code>，只有一个操作：</p><p>昨天卖出了股票（状态三）， <code>dp[i][3] = dp[i - 1][2];</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="literal">null</span> || prices.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// bad case</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = Math.max(dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>] + prices[<span class="number">1</span>]);</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = Math.max(dp[<span class="number">0</span>][<span class="number">1</span>], -prices[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="comment">// dp公式</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">2</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="714-买卖股票的最佳时机含手续费-2">714 买卖股票的最佳时机含手续费</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0714.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html" >https://programmercarl.com/0714.买卖股票的最佳时机含手续费（动态规划）.html<i class="fas fa-external-link-alt"></i></a>)</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：188 根据 123AC 了。309用另一种方法AC了。714AC。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-28 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="动态规划" scheme="https://kiml.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第三十九天-121买卖股票的最佳时机、122买卖股票的最佳时机II、123买卖股票的最佳时机III</title>
    <link href="https://kiml.github.io/posts/f80b512c/"/>
    <id>https://kiml.github.io/posts/f80b512c/</id>
    <published>2024-06-27T01:13:33.000Z</published>
    <updated>2024-06-28T03:23:35.471Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：121 直接看的解析。122 可以写出。123 看了部分解析（主要是 dp 的定义那块）。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-27 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="初步题解">初步题解</h2><h3 id="121-买卖股票的最佳时机">121 买卖股票的最佳时机</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/" >https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/<i class="fas fa-external-link-alt"></i></a>)：可以进行一笔交易</p><ol><li class="lvl-3"><p>确定 <code>dp[i]</code> 的含义：<code>dp[i][0]</code> 表示第 i 天持有股票所得最多现金，<code>dp[i][1]</code> 表示第 i 天不持有股票所得最多现金。</p></li><li class="lvl-3"><p>递推公式：<code>dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);</code>。（分为两种情况，当前持有/不持有）</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[0][0] = -prices[0]; dp[0][1] = 0;</code>。还有一点要注意：<strong>不持有股票状态所得金钱一定比持有股票状态得到的多！</strong></p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;  </span><br><span class="line">    <span class="comment">// `dp[i][0]` 表示第 i 天持有股票所得最多现金，`dp[i][1]` 表示第 i 天不持有股票所得最多现金。  </span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 初始化  </span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];  </span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;  </span><br><span class="line">        <span class="comment">// 1. 求 dp[i][0]: 前一天也持有就为 dp[i - 1][0]，前一天不持有就为 -prices[i]        </span></span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);  </span><br><span class="line">        <span class="comment">// 2. 求 dp[i][1]: 前一天也不持有就为 dp[i - 1][1]，前一天持有就为 dp[i - 1][0] + prices[i]        </span></span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 手中不持有股票时，利润才会最大</span></span><br><span class="line">    <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="122-买卖股票的最佳时机-II">122 买卖股票的最佳时机 II</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii" >https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii<i class="fas fa-external-link-alt"></i></a>)：可以进行多笔交易</p><ol><li class="lvl-3"><p>确定 <code>dp[i]</code> 的含义：<code>dp[i][0]</code> 表示第 i 天持有股票所得最多现金，<code>dp[i][1]</code> 表示第 i 天不持有股票所得最多现金。</p></li><li class="lvl-3"><p><mark>递推公式</mark>：<code>dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);</code>。（与上一题的唯一区别为 <code>dp[i][0]</code> 的推导公式，由于可以持续买入卖出，当天持有的价格为<strong>前一天不持有的价格 - 当天价格</strong>）</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[0][0] = -prices[0]; dp[0][1] = 0;</code>。还有一点要注意：<strong>不持有股票状态所得金钱一定比持有股票状态得到的多！</strong></p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;  </span><br><span class="line">    <span class="comment">// `dp[i][0]` 表示第 i 天持有股票所得最多现金，`dp[i][1]` 表示第 i 天不持有股票所得最多现金。  </span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 初始化  </span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];  </span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;  </span><br><span class="line">        <span class="comment">// 1. 求 dp[i][0]: 前一天也持有就为 dp[i - 1][0]，前一天不持有就为 dp[i - 1][1] - prices[i]        </span></span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);  </span><br><span class="line">        <span class="comment">// 2. 求 dp[i][1]: 前一天也不持有就为 dp[i - 1][1]，前一天持有就为 dp[i - 1][0] + prices[i]        </span></span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="123-买卖股票的最佳时机-III">123 买卖股票的最佳时机 III</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/" >https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/<i class="fas fa-external-link-alt"></i></a>)：可以进行两笔交易</p><ol><li class="lvl-3"><p>确定 <code>dp[i]</code> 的含义：当天的状态一共有 5 种：没有操作，不计入。<code>dp[i][0]</code> 表示第 i 天第一次持有股票所得最多现金，<code>dp[i][1]</code> 表示第 i 天第一次不持有股票所得最多现金，<code>dp[i][2]</code> 表示第 i 天第二次持有股票所得最多现金，<code>dp[i][2]</code> 表示第 i 天第二次不持有股票所得最多现金。（这题重点把这个写出来，后面就能做题了）</p></li><li class="lvl-3"><p><mark>递推公式</mark>：<code>dp[i][0] = Math.max(dp[i - 1][0], -prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]); dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] - prices[i]); dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] + prices[i]);</code>。</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[0][0] = -prices[0]; dp[0][2] = -prices[0];</code>。</p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;  </span><br><span class="line">    <span class="comment">// `dp[i][0]` 表示第 i 天第一次持有股票所得最多现金，`dp[i][1]` 表示第 i 天第一次不持有股票所得最多现金，`dp[i][2]` 表示第 i 天第二次持有股票所得最多现金，`dp[i][2]` 表示第 i 天第二次不持有股票所得最多现金 </span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">4</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 初始化  </span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];  </span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">2</span>] = -prices[<span class="number">0</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;  </span><br><span class="line">        <span class="comment">// 1. 求 dp[i][0]: 前一天也持有就为 dp[i - 1][0]，前一天不持有就为 -prices[i]        </span></span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);  </span><br><span class="line">        <span class="comment">// 2. 求 dp[i][1]: 前一天也不持有就为 dp[i - 1][1]，前一天持有就为 dp[i - 1][0] + prices[i]        </span></span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);  </span><br><span class="line">        <span class="comment">// 3. 求 dp[i][2]: 前一天也持有为 dp[i - 1][2]，前一天不持有就为 dp[i - 1][1] - prices[i]        </span></span><br><span class="line">        dp[i][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);  </span><br><span class="line">        <span class="comment">// 4. 求 dp[i][3]: 前一天也不持有为 dp[i - 1][3]，前一天持有就为 dp[i - 1][2] + prices[i]        </span></span><br><span class="line">        dp[i][<span class="number">3</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] + prices[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[prices.length - <span class="number">1</span>][<span class="number">3</span>];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="看解析">看解析</h2><h3 id="121-买卖股票的最佳时机-2">121 买卖股票的最佳时机</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA.html" >https://programmercarl.com/0121.买卖股票的最佳时机.html<i class="fas fa-external-link-alt"></i></a>)</p><p>补充贪心算法的思路：如果第 i 天卖出股票，则最大利润为 (该天的股价 - 前面天数中最小的股价)，然后与已知的最大利润比较，如果大于则更新当前最大利润的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 贪心解法  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">minPrice</span> <span class="operator">=</span> Integer.MAX_VALUE;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">maxProfit</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> price : prices) &#123;  </span><br><span class="line">        minPrice = Math.min(price, minPrice);  </span><br><span class="line">        maxProfit = Math.max(maxProfit, price - minPrice);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> maxProfit;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="122-买卖股票的最佳时机-II-2">122 买卖股票的最佳时机 II</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0122.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html" >https://programmercarl.com/0122.买卖股票的最佳时机II（动态规划）.html<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="123-买卖股票的最佳时机-III-2">123 买卖股票的最佳时机 III</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0123.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII" >https://programmercarl.com/0123.买卖股票的最佳时机III<i class="fas fa-external-link-alt"></i></a>)</p><p>版本二：（<em>不做要求</em>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>]; </span><br><span class="line">    <span class="comment">// 存储两次交易的状态就行了</span></span><br><span class="line">    <span class="comment">// dp[0]代表第一次交易的买入</span></span><br><span class="line">    dp[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// dp[1]代表第一次交易的卖出</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// dp[2]代表第二次交易的买入</span></span><br><span class="line">    dp[<span class="number">2</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// dp[3]代表第二次交易的卖出</span></span><br><span class="line">    dp[<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= prices.length; i++)&#123;</span><br><span class="line">        <span class="comment">// 要么保持不变，要么没有就买，有了就卖</span></span><br><span class="line">        dp[<span class="number">0</span>] = Math.max(dp[<span class="number">0</span>], -prices[i-<span class="number">1</span>]);</span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(dp[<span class="number">1</span>], dp[<span class="number">0</span>]+prices[i-<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 这已经是第二次交易了，所以得加上前一次交易卖出去的收获</span></span><br><span class="line">        dp[<span class="number">2</span>] = Math.max(dp[<span class="number">2</span>], dp[<span class="number">1</span>]-prices[i-<span class="number">1</span>]);</span><br><span class="line">        dp[<span class="number">3</span>] = Math.max(dp[<span class="number">3</span>], dp[<span class="number">2</span>]+ prices[i-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：121 直接看的解析。122 可以写出。123 看了部分解析（主要是 dp 的定义那块）。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-27 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="动态规划" scheme="https://kiml.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第三十八天-198打家劫舍、213打家劫舍II、337打家劫舍III</title>
    <link href="https://kiml.github.io/posts/f5901d56/"/>
    <id>https://kiml.github.io/posts/f5901d56/</id>
    <published>2024-06-26T01:35:36.000Z</published>
    <updated>2024-06-28T01:09:01.615Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：都是看了解析写出。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-26 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="初步题解">初步题解</h2><h3 id="198-打家劫舍">198 打家劫舍</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/house-robber" >https://leetcode.cn/problems/house-robber<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i]</code> 的含义：下标 i 及之前的房间能偷的最大金币数。</p></li><li class="lvl-3"><p>递推公式：<code>dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])</code>。（分为两种情况，偷/不偷）</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[0] = num[0], dp[1] = Math.max(num[0], num[1])</code>。</p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];  </span><br><span class="line">  </span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];  </span><br><span class="line">    <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">    dp[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; dp.length; i++) &#123;  </span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i]);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="213-打家劫舍-II">213 打家劫舍 II</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/house-robber-ii" >https://leetcode.cn/problems/house-robber-ii<i class="fas fa-external-link-alt"></i></a>)</p><p>本题的递推与上一题相同。区别在于要不要统计头尾。思路是去除尾和去除头分别求一次最大值。然后选较大的那个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LE213</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">rob</span> <span class="operator">=</span> rob(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">200</span>, <span class="number">3</span>, <span class="number">140</span>, <span class="number">20</span>, <span class="number">10</span>&#125;);  </span><br><span class="line">        System.out.println(rob);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> Math.max(rob1(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>), rob1(nums, <span class="number">1</span>, nums.length));  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;  </span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[end - start];  </span><br><span class="line">  </span><br><span class="line">        dp[<span class="number">0</span>] = nums[start];  </span><br><span class="line">        <span class="keyword">if</span> (dp.length == <span class="number">1</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> dp[<span class="number">0</span>];  </span><br><span class="line">        &#125;  </span><br><span class="line">        dp[<span class="number">1</span>] = Math.max(nums[start], nums[start + <span class="number">1</span>]);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; dp.length; i++) &#123;  </span><br><span class="line">            dp[i] = Math.max(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[start + <span class="number">2</span>]);  </span><br><span class="line">            start++;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        System.out.println(Arrays.toString(dp));  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> dp[dp.length - <span class="number">1</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 方法二：直接交换  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rob1</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;  </span><br><span class="line">        <span class="comment">// x为上上层的最大值，y为上一层的最大值。  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; end; i++) &#123;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> Math.max(x + nums[i], y);  </span><br><span class="line">            x = y;  </span><br><span class="line">            y = temp;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> y;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="337-打家劫舍-III">337 打家劫舍 III</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/house-robber-iii" >https://leetcode.cn/problems/house-robber-iii<i class="fas fa-external-link-alt"></i></a>)</p><p>动态规划其实就是使用状态转移容器来记录状态的变化，这里可以使用一个长度为 2 的数组，记录当前节点偷与不偷所得到的的最大金钱。</p><p><strong>这道题目算是树形 dp 的入门题目，因为是在树上进行状态转移，我们在讲解二叉树的时候说过递归三部曲，那么下面我以递归三部曲为框架，其中融合动规五部曲的内容来进行讲解</strong>。</p><p><strong>递归三部曲：</strong></p><ol><li class="lvl-3"><p>确定递归函数的参数和返回值。求一个节点两个状态的金钱值，返回值就是一个长度为 2 的数组。<strong>本题 dp 数组就是一个长度为 2 的数组</strong></p></li><li class="lvl-3"><p>确定终止条件。遇到空节点返回。</p></li><li class="lvl-3"><p>确定遍历顺序。后序遍历。</p></li></ol><p><strong>动规五部曲：</strong></p><ol><li class="lvl-3"><p>确定 <code>dp[i]</code> 的含义：下标 0 表示不偷的最大，下标 1 表示偷的最大。</p></li><li class="lvl-3"><p>递推公式即单层递归的逻辑：<code>dp[0] = cur-&gt;val + left[0] + right[0]</code>，<code>dp[1] = max(left[0], left[1]) + max(right[0], right[1])</code>。（分为两种情况，偷/不偷：<em>偷当前节点 <code>dp[1]</code>，值为当前节点值 + 不偷左右的节点的值；不偷当前节点 <code>dp[0]</code>，值为左孩子偷/不偷的最大值 + 右孩子偷/不偷的最大值</em>）</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[0] = 0, dp[1] = 0</code>，这里的初始化与递归的终止条件相。</p></li><li class="lvl-3"><p>遍历顺序：后序遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">int</span>[] dp = robDFS(root);  </span><br><span class="line">    <span class="keyword">return</span> Math.max(dp[<span class="number">0</span>], dp[<span class="number">1</span>]);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] robDFS(TreeNode root) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span>[] left = robDFS(root.left);  </span><br><span class="line">    <span class="type">int</span>[] right = robDFS(root.right);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;Math.max(left[<span class="number">0</span>], left[<span class="number">1</span>]) + Math.max(right[<span class="number">0</span>], right[<span class="number">1</span>]), root.val + left[<span class="number">0</span>] + right[<span class="number">0</span>]&#125;;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="看解析">看解析</h2><h3 id="198-打家劫舍-2">198 打家劫舍</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0198.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D.html" >https://programmercarl.com/0198.打家劫舍.html<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="213-打家劫舍-II-2">213 打家劫舍 II</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0213.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII.html" >https://programmercarl.com/0213.打家劫舍II.html<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="337-打家劫舍-III-2">337 打家劫舍 III</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0337.%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII.html" >https://programmercarl.com/0337.打家劫舍III.html<i class="fas fa-external-link-alt"></i></a>)</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：都是看了解析写出。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-26 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="动态规划" scheme="https://kiml.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="树形dp" scheme="https://kiml.github.io/tags/%E6%A0%91%E5%BD%A2dp/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第三十七天-322零钱兑换、279完全平方数、139单词拆分</title>
    <link href="https://kiml.github.io/posts/f80db845/"/>
    <id>https://kiml.github.io/posts/f80db845/</id>
    <published>2024-06-25T01:07:33.000Z</published>
    <updated>2024-06-25T08:39:26.748Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：322 递推公式看了题解。279 与 322 一样，AC 了。139 用回溯超时。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-25 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="初步题解">初步题解</h2><h3 id="322-零钱兑换">322 零钱兑换</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/coin-change" >https://leetcode.cn/problems/coin-change<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i]</code> 的含义：填满 i（包括 i）这么大容积的包，需要的最小个数为 <code>dp[i]</code></p></li><li class="lvl-3"><p>递推公式：<code>dp[i] = Math.min(dp[i], dp[i - coin] + 1)</code>。（这里比较难想，<mark>背包放这个硬币的计算为不放的结果加一</mark>）</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[0] = 0</code>。背包大小为 0，方法数也为 0。（<em>根据题中给出的示例 3</em>）</p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历（<em>完全背包</em>）。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 思路：  </span></span><br><span class="line"><span class="comment"> * 1. 硬币获取可以重复（完全背包）  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> coins 硬币数组  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> amount 数量  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;  </span><br><span class="line">    <span class="comment">// dp 表示凑成金额所需要的最小个数  </span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];  </span><br><span class="line">    Arrays.fill(dp, amount + <span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> coin; i &lt; dp.length; i++) &#123;  </span><br><span class="line">            <span class="keyword">if</span>(dp[i - coin] != amount + <span class="number">1</span>) &#123;  </span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i- coin] + <span class="number">1</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.toString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[amount] == amount + <span class="number">1</span> ? -<span class="number">1</span> : dp[amount];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="279-完全平方数">279 完全平方数</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/perfect-squares" >https://leetcode.cn/problems/perfect-squares<i class="fas fa-external-link-alt"></i></a>)</p><p>和上题完全一样，区别只有取值数组的值需要自己计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 思路：背包大小为n，从1-根号n之间取数  </span></span><br><span class="line"><span class="comment"> * 1. 数可以重复取值，完全背包  </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 和为n  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;  </span><br><span class="line">    <span class="comment">// dp[i] 表示和为n的完全平方数的最小数量  </span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];  </span><br><span class="line">    Arrays.fill(dp, n + <span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>) Math.sqrt(n);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= num; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i * i; j &lt; dp.length; j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (dp[j - i * i] != n + <span class="number">1</span>) &#123;  </span><br><span class="line">                dp[j] = Math.min(dp[j], dp[j - i * i] + <span class="number">1</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.toString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[n];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="139-单词拆分">139 单词拆分</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/word-break" >https://leetcode.cn/problems/word-break<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回溯方法。这样写会超时🤕</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;  </span><br><span class="line">    wordDict.sort(Comparator.comparingInt(String::length));  </span><br><span class="line">    <span class="keyword">return</span> wordBreakBFS(s, wordDict, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">wordBreakBFS</span><span class="params">(String s, List&lt;String&gt; wordDict, List&lt;String&gt; word)</span> &#123;  </span><br><span class="line">    <span class="type">String</span> <span class="variable">join</span> <span class="operator">=</span> String.join(<span class="string">&quot;&quot;</span>, word);  </span><br><span class="line">    <span class="keyword">if</span> (s.length() &lt;= join.length()) &#123;  </span><br><span class="line">        <span class="keyword">return</span> s.equals(String.join(<span class="string">&quot;&quot;</span>, word));  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!s.startsWith(join)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (String string : wordDict) &#123;  </span><br><span class="line">        word.add(string);  </span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> wordBreakBFS(s, wordDict, word);  </span><br><span class="line">        <span class="keyword">if</span> (b) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        word.remove(word.size() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="看解析">看解析</h2><h3 id="322-零钱兑换-2">322 零钱兑换</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html" >https://programmercarl.com/0322.零钱兑换.html<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="279-完全平方数-2">279 完全平方数</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html" >https://programmercarl.com/0279.完全平方数.html<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="139-单词拆分-2">139 单词拆分</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0139.%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86.html" >https://programmercarl.com/0139.单词拆分.html<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i]</code> 的含义：字符串长度为 i，<code>dp[i]</code> 表示是否可以拆分，可以返回 true。</p></li><li class="lvl-3"><p>递推公式：如果 <code>dp[j]</code> 为 true，并且字符串下标 <code>j-i</code> 截取的字符在字典内，说明可以拆分。</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[0] = true</code>。初始值为了保证后续计算不会一直为 false。</p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历（<em>完全背包</em>）。由于是排列问题，所以先遍历背包大小。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;  </span><br><span class="line">    <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[s.length() + <span class="number">1</span>];  </span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; dp.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (String word : wordDict) &#123;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> word.length();  </span><br><span class="line">            <span class="keyword">if</span> (i &gt;= len &amp;&amp; dp[i - len] &amp;&amp; word.equals(s.substring(i - len, i))) &#123;  </span><br><span class="line">                dp[i] = <span class="literal">true</span>;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.toString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[s.length()];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回溯记忆法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; set;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] memo;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()];</span><br><span class="line">        set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordDict);</span><br><span class="line">        <span class="keyword">return</span> backtracking(s, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backtracking</span><span class="params">(String s, <span class="type">int</span> startIndex)</span> &#123;</span><br><span class="line">        <span class="comment">// System.out.println(startIndex);</span></span><br><span class="line">        <span class="keyword">if</span> (startIndex == s.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[startIndex] == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> s.substring(startIndex, i + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 拆分出来的单词无法匹配</span></span><br><span class="line">            <span class="keyword">if</span> (!set.contains(sub)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> backtracking(s, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (res) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里是关键，找遍了startIndex~s.length()也没能完全匹配，标记从startIndex开始不能找到</span></span><br><span class="line">        memo[startIndex] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;状态：322 递推公式看了题解。279 与 322 一样，AC 了。139 用回溯超时。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-25 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="动态规划" scheme="https://kiml.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="完全背包" scheme="https://kiml.github.io/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>面试 Redis</title>
    <link href="https://kiml.github.io/posts/25de1bd9/"/>
    <id>https://kiml.github.io/posts/25de1bd9/</id>
    <published>2024-06-24T13:09:59.000Z</published>
    <updated>2024-06-25T07:51:44.404Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br><br>❗表示必掌握，❔表示基本不会问</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-24 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="什么是-Redis">什么是 Redis</h2><p>Redis(Remote Dictionary Server) 是一个使用 C 语言编写的，开源的（BSD 许可）高性能非关系型（NoSQL）的键值对数据库。</p><p>Redis 可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。</p><h3 id="什么是-NoSQL？">什么是 NoSQL？</h3><p>NoSQL 的全称是 Not-Only SQL，指的是非关系型数据库，它是关系型数据库的补充，没有表与表之间的关系，主要用于海量数据的处理问题。</p><h3 id="除了-Redis，你还了解其它的-NoSQL-吗">除了 Redis，你还了解其它的 NoSQL 吗?</h3><p>nosql 数据库有很多，比如 HBase、MongoDB、Memcached 等，Redis 相比于其他的 nosql 而言，效率高，数据结构比较丰富。</p><ul class="lvl-0"><li class="lvl-2"><p>MongoDB</p><ul class="lvl-2"><li class="lvl-6">高性能、无模式的文档型数据库 (一个文档相当于关系数据库中的一条记录，格式是 xml 或者 json 等)，支持二级索引，非常适合文档化格式的存储及查询。MongoDB 的官方定位是通用数据库，确实和 MySQL 有些像，现在也很流行，但它还是有事务、join 等短板，在事务、复杂查询应用下无法取代关系型数据库。但 MongoDB 更注重庞大数据的存储和操作，但不适合用于临时存储的缓存，如果将数据做缓存使用，还是 Redis 性能更高。</li></ul></li><li class="lvl-2"><p>Redis</p><ul class="lvl-2"><li class="lvl-6">内存型 Key/Value 系统，读写性能非常好，支持操作原子性，很适合用来做高速缓存。</li></ul></li><li class="lvl-2"><p>HBase</p><ul class="lvl-2"><li class="lvl-6">存储容量大，一个表可以容纳上亿行、上百万列，可应对超大数据量要求扩展简单的需求。</li></ul></li></ul><h2 id="Redis-有哪些优缺点？">Redis 有哪些优缺点？</h2><p>优点</p><ul class="lvl-0"><li class="lvl-2"><p>读写性能优异。Redis 能读的速度是 110000 次/s，写的速度是 81000 次/s。</p></li><li class="lvl-2"><p>支持数据持久化。支持 AOF 和 RDB 两种持久化方式。</p></li><li class="lvl-2"><p>支持事务。Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作合并后的原子性执行。</p></li><li class="lvl-2"><p>数据结构丰富。除了支持 string 类型的 value 外还支持 hash、set、zset、list 等数据结构。</p></li><li class="lvl-2"><p>支持主从复制。主机会自动将数据同步到从机，可以进行读写分离。缺点</p></li><li class="lvl-2"><p>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写。因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。</p></li><li class="lvl-2"><p>Redis 不具备自动容错和恢复功能。主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的 IP 才能恢复。</p></li><li class="lvl-2"><p>数据不同步。主机宕机，宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题，降低了系统的可用性。</p></li><li class="lvl-2"><p>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。</p></li></ul><h2 id="为什么要用-Redis-为什么要用缓存？">为什么要用 Redis/为什么要用缓存？</h2><p><strong>高性能</strong><br>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！<br><strong>高并发</strong><br>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p><h2 id="为什么要用-Redis-而不用-map-guava-做缓存">为什么要用 Redis 而不用 map/guava 做缓存?</h2><p>缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p><p>使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached 服务的高可用，整个程序架构上较为复杂。</p><h3 id="redis-与-Memcached-的区别是什么？为什么不选-Memcached">redis 与 Memcached 的区别是什么？为什么不选 Memcached?</h3><ol><li class="lvl-3"><p>memcached 所有的值均是简单的字符串，且只支持 k/v 类型，redis 作为其替代者，支持更为丰富的数据类型。</p></li><li class="lvl-3"><p>redis 可以持久化其数据，memcached 只用做缓存提升性能，不能做持久化。</p></li><li class="lvl-3"><p>memcached 存储数据有限制：1M 【大于 1M，认为就行分割】（内存碎片）</p></li><li class="lvl-3"><p>memcached 集群数据没有复制和同步机制（崩溃不会影响程序，会从数据库中取数据）。</p></li><li class="lvl-3"><p>memcached 内存不能及时回收，它只有 LRU(算法) 这一种方式，而 redis 有多种内存回收方式。</p></li></ol><h2 id="Redis-为什么这么快？">Redis 为什么这么快？</h2><ol><li class="lvl-3"><p>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O(1)；</p></li><li class="lvl-3"><p>数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；</p></li><li class="lvl-3"><p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p></li><li class="lvl-3"><p>使用多路 I/O 复用模型，非阻塞 IO；</p></li><li class="lvl-3"><p>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p></li></ol><h2 id="Redis-的主要缺点是什么？">Redis 的主要缺点是什么？</h2><ol><li class="lvl-3"><p>[[07 Redis面试#在工作中，如果数据库修改了数据，那就跟redis数据不同步了，此时该办？（缓存双写一致性问题）|缓存和数据库双写一致性问题]]</p></li><li class="lvl-3"><p>[[07 Redis面试#缓存雪崩|缓存雪崩问题]]</p></li><li class="lvl-3"><p>[[07 Redis面试#缓存穿透|缓存穿透问题]]</p></li><li class="lvl-3"><p>[[07 Redis面试#那怎么解决缓存的并发竞争问题？比如多个子系统去set一个key但最后执行顺序和我们期望顺序不一样。|缓存的并发竞争问题]]</p></li></ol><h2 id="数据类型">数据类型</h2><h3 id="Redis-的数据类型有哪些？它的数据操作是怎么样的？">Redis 的数据类型有哪些？它的数据操作是怎么样的？</h3><ul class="lvl-0"><li class="lvl-2"><p>数据类型</p><ul class="lvl-2"><li class="lvl-6">string、hash、list(有序、可重复)、set(无序、不可重复)、zset(不可重复，基于 score 实现排序)</li></ul></li><li class="lvl-2"><p>数据操作</p><ul class="lvl-2"><li class="lvl-6">Redis 中的数据存储方式是 key-value 形式</li><li class="lvl-6">Redis 不能保存 JAVA 对象，需要转为 JSON 对象后存入 Redis</li></ul></li></ul><table><thead><tr><th>数据类型</th><th>可以存储的值</th><th>操作</th><th>应用场景</th></tr></thead><tbody><tr><td>String</td><td>字符串、整数或浮点数</td><td>1.对整个字符串或者字符串的其中一部分执行操作 2.对整数和浮点数执行自增或自减操作</td><td>做简单的键值对缓存</td></tr><tr><td>List</td><td>列表</td><td>1.从两端压入或弹出元素 2.对单个或多个元素进行修剪，只保留一个范围内的元素</td><td>存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的数据</td></tr><tr><td>Set</td><td>无序集合</td><td>1.添加、获取、移除单个元素 2.检查一个元素是否在集合中 3.计算交集、并集、差集 从集合里面随机获取元素</td><td>交集、并集、差集的操作，比如两人的粉丝列表做交集</td></tr><tr><td>Hash</td><td>包含键值对的无序散列表</td><td>1.添加、获取、移除单个键值对 2.获取所有键值对 3.检查某个键是否存在</td><td>结构化的数据，比如一个对象</td></tr><tr><td>ZSet</td><td>有序集合</td><td>1.添加、获取、移除元素 2.根据分值范围或成员来获取元素 3.计算一个键的排名</td><td>去重，但可以排序，如获取前几名用户</td></tr></tbody></table><h3 id="Redis-的应用场景">Redis 的应用场景</h3><ol><li class="lvl-3"><p>计数器</p><ul class="lvl-2"><li class="lvl-6">可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</li></ul></li><li class="lvl-3"><p>缓存</p><ul class="lvl-2"><li class="lvl-6">将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</li></ul></li><li class="lvl-3"><p>会话缓存</p><ul class="lvl-2"><li class="lvl-6">可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</li></ul></li><li class="lvl-3"><p>全页缓存（FPC）</p><ul class="lvl-2"><li class="lvl-6">除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</li></ul></li><li class="lvl-3"><p>查找表</p><ul class="lvl-2"><li class="lvl-6">例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</li></ul></li><li class="lvl-3"><p>消息队列 (发布/订阅功能)</p><ul class="lvl-2"><li class="lvl-6">List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。</li></ul></li><li class="lvl-3"><p>分布式锁实现</p><ul class="lvl-2"><li class="lvl-6">在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</li></ul></li><li class="lvl-3"><p>其它</p><ul class="lvl-2"><li class="lvl-6">Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。</li></ul></li></ol><h3 id="Redis-应用场景（根据类型）">Redis 应用场景（根据类型）</h3><ul class="lvl-0"><li class="lvl-2"><p>String</p><ul class="lvl-2"><li class="lvl-6">适合最简单的 k-v 存储，类似于 memcached 的存储结构，短信验证码，配置信息等，就用这种类型来存储。</li></ul></li><li class="lvl-2"><p>Hash</p><ul class="lvl-2"><li class="lvl-6">一般 key 为 ID 或者唯一标示，value 对应的就是详情了。如商品详情，个人信息详情，新闻详情等。</li></ul></li><li class="lvl-2"><p>List</p><ul class="lvl-2"><li class="lvl-6">因为 list 是有序的，比较适合存储一些有序且数据相对固定的数据。如省市区表、字典表等。因为 list 是有序的，适合根据写入的时间来排序，如：最新的***，消息队列等。</li></ul></li><li class="lvl-2"><p>Set</p><ul class="lvl-2"><li class="lvl-6">可以简单的理解为 ID-List 的模式，如微博中一个人有哪些好友，set 最牛的地方在于，可以对两个 set 提供交集、并集、差集操作。例如：查找两个人共同的好友等。</li></ul></li><li class="lvl-2"><p>ZSet</p><ul class="lvl-2"><li class="lvl-6">自动会根据 score 的值进行排序。比较适合类似于 top 10 等不根据插入的时间来排序的数据。</li></ul></li></ul><h2 id="Redis-持久化">Redis 持久化</h2><h3 id="什么是-Redis-持久化？">什么是 Redis 持久化？</h3><ul class="lvl-0"><li class="lvl-2"><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p></li></ul><h3 id="Redis-的持久化机制是什么？各自的优缺点？">Redis 的持久化机制是什么？各自的优缺点？</h3><h4 id="RDB">RDB</h4><ul class="lvl-0"><li class="lvl-2"><p>简述</p><ul class="lvl-2"><li class="lvl-6">RDB 是二进制快照形式，数据体量小，保存效率高，但丢失风险也较大，因为它是定时定量更改才会自动持久化，无法实时存储，如果在快照之前丢失，则无法找回。</li></ul></li><li class="lvl-2"><p>优点</p><ol><li class="lvl-7">只有一个文件 dump.rdb，方便持久化。</li><li class="lvl-7">容灾性好，一个文件可以保存到安全的磁盘。</li><li class="lvl-7">性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能</li><li class="lvl-7">相对于数据集大时，比 AOF 的启动效率更高。</li></ol></li><li class="lvl-2"><p>缺点</p><ol><li class="lvl-7">数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)</li></ol></li></ul><h4 id="AOF">AOF</h4><ul class="lvl-0"><li class="lvl-2"><p>简述</p><ul class="lvl-2"><li class="lvl-6">AOF 是过程命令形式，数据体量大 (可以用 AOF 重写解决该问题)，效率低于 RDB，记录每个操作，存储格式也更复杂，但数据相对完整 (最快可以每秒同步一次)，且弥补了 RDB 不能实时存储的缺点。</li></ul></li><li class="lvl-2"><p>优点</p><ol><li class="lvl-7">数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。</li><li class="lvl-7">通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</li><li class="lvl-7">AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)</li></ol></li><li class="lvl-2"><p>缺点</p><ol><li class="lvl-7">AOF 文件比 RDB 文件大，且恢复速度慢。</li><li class="lvl-7">数据集大的时候，比 rdb 启动效率低。</li></ol></li></ul><h5 id="AOF-数据体量大，那有什么办法可以解决这个问题吗？">AOF 数据体量大，那有什么办法可以解决这个问题吗？</h5><ul class="lvl-0"><li class="lvl-2"><p>Redis 中引入了 AOF 重写机制可以压缩文件体积——执行压缩命令即可。</p></li><li class="lvl-2"><p>AOF 重写可以降低磁盘占用量，也能提高数据恢复效率，它会对同一数据的多条写命令合并为一条写命令，且为了防止数据量过大造成缓冲区溢出，每条指令最多为 64 个元素。</p></li><li class="lvl-2"><p>AOF 重写其实是一个同步开启的子进程，Redis 执行指令时，子进程也会开启重写，主进程会将写入的数据同步到子进程，子进程则开始重写 AOF 文件，写完后再返回给主进程，完成 AOF 重写。</p></li></ul><h4 id="选用">选用</h4><ul class="lvl-0"><li class="lvl-2"><p>AOF 文件比 RDB 更新频率高，优先使用 AOF 还原数据。</p></li><li class="lvl-2"><p>AOF 比 RDB 更安全也更大</p></li><li class="lvl-2"><p>RDB 性能比 AOF 好</p></li><li class="lvl-2"><p>如果两个都配了优先加载 AOF</p></li><li class="lvl-2"><p>如果对数据非常敏感用 AOF，如果追求大数据集的恢复速度选 RDB。</p></li></ul><h3 id="Redis-持久化数据和缓存怎么做扩容？">Redis 持久化数据和缓存怎么做扩容？</h3><ul class="lvl-0"><li class="lvl-2"><p>如果 Redis 被当做缓存使用，使用一致性哈希实现动态扩容缩容。</p></li><li class="lvl-2"><p>如果 Redis 被当做一个持久化存储使用，必须使用固定的 keys-to-nodes 映射关系，节点的数量一旦确定不能变化。否则的话 (即 Redis 节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有 Redis 集群可以做到这样。</p></li></ul><h2 id="数据删除">数据删除</h2><h3 id="Redis-是怎么进行数据删除的？过期删除策略？">Redis 是怎么进行数据删除的？过期删除策略？</h3><h4 id="三种过期策略">三种过期策略</h4><h5 id="定时删除">定时删除</h5><ul class="lvl-0"><li class="lvl-2"><p>创建一个定时器，当 key 设置过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作。</p></li><li class="lvl-2"><p>这样的好处是及时快速释放内存，坏处时，消耗过多的处理器性能。</p></li></ul><h5 id="惰性删除">惰性删除</h5><ul class="lvl-0"><li class="lvl-2"><p>定时删除策略中，从删除方法来看，必然会导致有 key 过期了但未从 redis 中删除的情况。</p></li><li class="lvl-2"><p>面对这种情况，redis 在操作一个 key 时，会先判断这个值是否过期，若已过期，则删除该 key；若未过期，则进行后续操作。</p></li></ul><h5 id="定期删除（常用）">定期删除（常用）</h5><ul class="lvl-0"><li class="lvl-2"><p>Redis 默认会每秒进行十次过期扫描，过期扫描不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策略。</p><ol><li class="lvl-7">从过期字典中随机 20 个 key；</li><li class="lvl-7">删除这 20 个 key 中已经过期的 key；</li><li class="lvl-7">如果过期的 key 比率超过 1/4，那就重复步骤 1；</li><li class="lvl-7">同时，为了保证过期扫描不会出现循环过度，导致线程卡死现象，算法还增加了扫描时间的上限，默认不会超过 25ms。</li><li class="lvl-7">如果某一时刻，有大量 key 同时过期，Redis 会持续扫描过期字典，造成客户端响应卡顿，因此设置过期时间时，就尽量避免这个问题，在设置过期时间时，可以给过期时间设置一个随机范围，避免同一时刻过期。</li></ol></li><li class="lvl-2"><p>(expires 字典会保存所有设置了过期时间的 key 的过期时间数据，其中，key 是指向键空间中的某个键的指针，value 是该键的毫秒精度的 UNIX 时间戳表示的过期时间。键空间是指该 Redis 集群中保存的所有键。)<br><strong>Redis 中同时使用了惰性过期和定期过期两种过期策略。</strong></p></li></ul><h3 id="怎么判断一个-Key-还有多少时间">怎么判断一个 Key 还有多少时间</h3><ul class="lvl-0"><li class="lvl-2"><p>TTL 命令（命令行）</p><ul class="lvl-2"><li class="lvl-6">正数 -&gt; 剩余时间</li><li class="lvl-6">-1 -&gt; 永久 Key</li><li class="lvl-6">-2 -&gt; Key 已经过期或者不存在</li></ul></li></ul><h3 id="如何配置定期删除执行时间间隔？">如何配置定期删除执行时间间隔？</h3><ul class="lvl-0"><li class="lvl-2"><p>redis 的定时任务默认是 10s 执行一次，如果要修改这个值，可以在 redis.conf 中修改 hz 的值。</p></li><li class="lvl-2"><p>redis.conf 中，hz 默认设为 10，提高它的值将会占用更多的 cpu，当然相应的 redis 将会更快的处理同时到期的许多 key，以及更精确的去处理超时。</p></li><li class="lvl-2"><p>hz 的取值范围是 1~500，通常不建议超过 100，只有在请求延时非常低的情况下可以将值提升到 100。</p></li></ul><h3 id="单线程的-redis，如何知道要运行定时任务">单线程的 redis，如何知道要运行定时任务</h3><ul class="lvl-0"><li class="lvl-2"><p>redis 是单线程的，线程不但要处理定时任务，还要处理客户端请求，线程不能阻塞在定时任务或处理客户端请求上，那么，redis 是如何知道何时该运行定时任务的呢？</p></li><li class="lvl-2"><p>Redis 的定时任务会记录在一个称为最小堆的数据结构中。这个堆中，最快要执行的任务排在堆的最上方。在每个循环周期，Redis 都会将最小堆里面已经到点的任务立即进行处理。处理完毕后，将最快要执行的任务还需要的时间记录下来，这个时间就是接下来处理客户端请求的最大时长，若达到了该时长，则暂时不处理客户端请求而去运行定时任务。</p></li></ul><h3 id="Redis-key-的过期时间和永久有效分别怎么设置？">Redis key 的过期时间和永久有效分别怎么设置？</h3><ul class="lvl-0"><li class="lvl-2"><p>EXPIRE 和 PERSIST 命令。</p></li></ul><h2 id="内存淘汰">内存淘汰</h2><h3 id="Redis-的内存淘汰策略有哪些？">Redis 的内存淘汰策略有哪些？</h3><ul class="lvl-0"><li class="lvl-2"><p>Redis 的内存淘汰策略是指在 Redis 的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。</p></li></ul><table><thead><tr><th>操作的数据集</th><th>内存淘汰策略</th><th>说明</th></tr></thead><tbody><tr><td><strong>设置过期时间的键空间选择性移除</strong>（可能会过期的数据集 server.db[i].expires）</td><td>volatile-lru</td><td>淘汰最近一次使用时间距现在<strong>最久</strong>的数据（Least Recently Used）<strong>最常用</strong></td></tr><tr><td></td><td>volatile-lfu</td><td>淘汰使用<strong>次数最少</strong>的数据（Least Frequently Used）</td></tr><tr><td></td><td>volatile-ttl</td><td>淘汰过期时间最近的数据</td></tr><tr><td></td><td>volatile-random</td><td>淘汰随机数据</td></tr><tr><td><strong>全局的键空间选择性移除</strong>（所有数据集）</td><td>allkeys-lru</td><td>淘汰最近一次使用时间距现在最久的数据</td></tr><tr><td></td><td>allkeys-lfu</td><td>淘汰使用次数最少的数据</td></tr><tr><td></td><td>allkeys-random</td><td>淘汰随机数据</td></tr><tr><td><strong>放弃数据驱逐</strong></td><td>no-enviction</td><td>禁止驱逐数据（redis4.0 中默认策略），会引发错误 OOM(Out Of Memory)</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p><strong>总结</strong></p><ul class="lvl-2"><li class="lvl-6">Redis 的内存淘汰策略的选取并不会影响过期的 key 的处理。内存淘汰策略用于处理内存不足时的需要申请额外空间的数据；过期策略用于处理过期的缓存数据。</li></ul></li></ul><h3 id="MySQL-里有-2000w-数据，redis-中只存-20w-的数据，如何保证-redis-中的数据都是热点数据？">MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据？</h3><ul class="lvl-0"><li class="lvl-2"><p>redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略 (上面的 allkeys-lru，移除最近最少使用的 key)。</p></li></ul><h3 id="Redis-主要消耗什么物理资源？">Redis 主要消耗什么物理资源？</h3><ul class="lvl-0"><li class="lvl-2"><p>内存。</p></li></ul><h3 id="Redis-的内存用完了会发生什么？">Redis 的内存用完了会发生什么？</h3><ul class="lvl-0"><li class="lvl-2"><p>如果达到设置的上限，Redis 的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当 Redis 达到内存上限时会冲刷掉旧的内容。</p></li></ul><h3 id="Redis-如何做内存优化？">Redis 如何做内存优化？</h3><ul class="lvl-0"><li class="lvl-2"><p>可以好好利用 Hash,list,sorted set,set 等集合类型数据，因为通常情况下很多小的 Key-Value 可以用更紧凑的方式存放到一起。尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的 web 系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key，而是应该把这个用户的所有信息存储到一张散列表里面</p></li></ul><h2 id="集群方案">集群方案</h2><h3 id="说一说-Redis-的主从复制">说一说 Redis 的主从复制</h3><ul class="lvl-0"><li class="lvl-2"><p>对于大型网站来说，每秒需要读取的数据远远超过单台 redis 服务所能承受的压力，而写入的数据相对来说较少，这时候用 redis 的主从复制模式可以很好的提升同一个内容的读取速度。</p></li><li class="lvl-2"><p>redis 主从复制模式其实是一个读写分离模型，将主服务器用来处理写操作，从服务器只提供读操作，不过主从复制是所有内容完全一致的，而不是分库分表的，严格来说不算集群。</p></li><li class="lvl-2"><p>主从复制模式最大的问题是只有一个主节点，没有实现高可用，所以还需要哨兵机制来实现高可用。</p></li></ul><h4 id="主从同步过程">主从同步过程</h4><ul class="lvl-0"><li class="lvl-2"><p>当启动一个 slave node 的时候，它会发送一个 <code>PSYNC &lt;runid&gt; &lt;offset&gt;</code> 命令给 master node。</p></li><li class="lvl-2"><p>如果这是 slave node 初次连接到 master node，那么会触发一次 <code>full resynchronization</code> 全量复制（<strong>接收命令判断 runid 是否匹配，判定 offset 是否在复制缓冲区中</strong>）。此时 master 会启动一个后台线程，开始生成一份 <code>RDB</code> 快照文件，</p><ul class="lvl-2"><li class="lvl-6">同时还会将从客户端 client 新收到的所有写命令缓存在 <code>replication buffer</code>（redis server 会为每一个连接到自己的客户端创建一个 replication buffer，用来缓存主库执行的命令）中。<code>RDB</code> 文件生成完毕后， master 会将这个 <code>RDB</code> 发送给 slave，slave 会先<strong>写入本地磁盘，然后再从本地磁盘加载到内存</strong>中，过程中基于旧的数据对外提供服务。<ul class="lvl-4"><li class="lvl-10">如果 <code>replication buffer</code> 写满了（client-output-buffer-limit），无论客户端是普通客户端还是从库，只能断开跟这个客户端的连接了。这样从库全量同步失败，只能再次尝试全量同步。</li></ul></li><li class="lvl-6">接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。<ul class="lvl-4"><li class="lvl-10">如果 slave node 开启了 AOF，那么立即执行重写 AOF</li></ul></li></ul></li><li class="lvl-2"><p>slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。（主库的写命令，除了传给从库后，还会写入 <code>repl_backlog_buffer</code>）</p><ul class="lvl-2"><li class="lvl-6">如果从给的 runid 和 offset 都是对的，那么主服务器就会从上次同步的 offset 位置开始进行增量同步</li><li class="lvl-6">如果 offset 已经小于了主的复制缓冲区中最小的那个偏移量，就会进行全量复制</li><li class="lvl-6">切换了主服务器也会进行全量复制</li></ul></li></ul><p>![[Pasted image 20221107210154.png|600]]</p><h3 id="什么是-Redis-哨兵？">什么是 Redis 哨兵？</h3><ul class="lvl-0"><li class="lvl-2"><p>sentinel(哨兵) 是用于监控 redis 集群中 Master 状态的工具，其本质就是一个独立运行的进程，是 Redis 的高可用解决方案。</p></li><li class="lvl-2"><p>sentinel 可以监视一个或者多个 redis master 服务，以及这些 master 服务的所有从服务；当某个 master 服务下线时，自动将该 master 下的某个从服务升级为 master 服务替代已下线的 master 服务继续处理请求，并且其余从节点开始从新的主节点复制数据。（它会直接修改配置文件，来实现修改主服务器）</p></li><li class="lvl-2"><p>在 redis 安装完成后，会有一个 redis-sentinel 的文件，这就是启动 sentinel 的脚本文件，同时还有一个 sentinel.conf 文件，这个是 sentinel 的配置文件。</p></li><li class="lvl-2"><p>但哨兵也可能会挂，所以需要对哨兵也实现高可用（<strong>集群</strong>）。</p></li></ul><h4 id="哨兵的核心知识">哨兵的核心知识</h4><ul class="lvl-0"><li class="lvl-2"><p>哨兵至少需要 3 个实例，来保证自己的健壮性。</p></li><li class="lvl-2"><p>哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。</p></li><li class="lvl-2"><p>对于哨兵 + redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。</p></li></ul><h3 id="redis-cluster-集群">redis cluster 集群</h3><p>![[04 Redis面试 2022-11-07.excalidraw]]</p><h4 id="为什么要搭建-Redis-集群？">为什么要搭建 Redis 集群？</h4><ul class="lvl-0"><li class="lvl-2"><p>Redis 有内置集群 cluster，redis Cluster 是无中心节点的集群架构，本身就是去中心化的，也就是说，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。</p></li><li class="lvl-2"><p>cluster 集群中内置了哨兵机制，不需要再额外启动哨兵程序。</p></li><li class="lvl-2"><p>Redis cluster 为了保证数据的高可用，加入了主从模式，主节点只用来存，从节点只用来取，如果主节点挂掉了，就会在从节点中选取一个来充当主节点。当然，如果通过集群命令，还可以使现在任何一个节点写入。</p></li></ul><h5 id="Redis-集群工作流程">Redis 集群工作流程</h5><ol><li class="lvl-4"><p>通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽 (哈希值) 区间的数据，默认分配了 16384 个槽位</p></li><li class="lvl-4"><p>每份数据分片会存储在多个互为主从的多节点上</p></li><li class="lvl-4"><p>数据写入先写主节点，再同步到从节点 (支持配置为阻塞同步)</p></li><li class="lvl-4"><p>同一分片多个节点间的数据不保持一致性</p></li><li class="lvl-4"><p>读取数据时，当客户端操作的 key 没有分配在该节点上时，redis 会返回转向指令，指向正确的节点</p></li><li class="lvl-4"><p>扩容时时需要需要把旧节点的数据迁移一部分到新节点在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是 加 1w 的端口号，比如 16379。<br>16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议，<code>gossip</code> 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。</p></li></ol><h5 id="你知道哪些分布式寻址法？">你知道哪些分布式寻址法？</h5><ul class="lvl-0"><li class="lvl-2"><p>hash 算法（大量缓存重建）</p></li><li class="lvl-2"><p>一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）</p></li><li class="lvl-2"><p>redis cluster 的 hash slot （槽）算法</p></li></ul><h6 id="你了解一致性哈希吗？">你了解一致性哈希吗？</h6><ul class="lvl-0"><li class="lvl-2"><p>简单来说，一致性 Hash 算法将整个哈希值空间组织成一个虚拟的圆环，整个空间圆按顺时针方向布局，正上方点代表 0，也代表 2^32-1，即一共 2^32 个点组成的圆环称为 Hash 环。</p></li><li class="lvl-2"><p>一致性哈希算法可用于 Redis 的集群搭建，当然这种用法已经过时了，现在可以用 Redis cluster 的哈希槽来替代一致性哈希算法，实现集群搭建。</p></li><li class="lvl-2"><p>使用一致性哈希算法时，多个服务器也会落在这个 Hash 环上，并且能确定各自的位置，这样用户访问的时候，会根据用户 IP 计算出哈希值，对应到哈希环上，并顺时针行走，遇到的第一台服务器就是该用户被分配到的服务器。</p></li><li class="lvl-2"><p>但是一致性哈希会有数据倾斜的问题，也就是可能多台服务器聚集在相近的地方，这时就需要将服务器多构建几个虚拟节点，来分散到 Hash 环上的各个位置，来使数据分配的服务器较为均衡，设置的虚拟节点约多，数据分配的越是相对均匀。</p></li></ul><h4 id="Redis-集群是同步复制还是异步复制？是否会有写操作丢失情况？为什么？">Redis 集群是同步复制还是异步复制？是否会有写操作丢失情况？为什么？</h4><ul class="lvl-0"><li class="lvl-2"><p>异步复制。</p><ul class="lvl-2"><li class="lvl-6">Redis 主节点与从节点之间的数据复制是异步复制的，当客户端发送写请求给 master 节点的时候，客户端会直接返回 OK，然后主节点同步到各个从节点中。</li></ul></li><li class="lvl-2"><p>如果主节点没来得及同步给从节点时发生宕机，那么主节点内存中的数据就会丢失。</p></li></ul><h5 id="如果主节点中开启持久化，能不能保证数据不丢失呢？">如果主节点中开启持久化，能不能保证数据不丢失呢？</h5><ul class="lvl-0"><li class="lvl-2"><p>不能。</p><ul class="lvl-2"><li class="lvl-6">主节点宕机后（脑裂也会有相同的数据丢失问题），会自动启动哨兵机制，重新选举新的主节点，如果这时候旧的主节点恢复故障重启了，它就会去同步新的主节点数据，而这时新的主节点并没有同步那之前丢失的数据，旧的主节点的上的数据则会在同步新主节点上数据时，刷新掉，此时数据还是会丢失。</li></ul></li></ul><h5 id="怎么才能保证数据不丢失？或者如保证尽量少的数据丢失？">怎么才能保证数据不丢失？或者如保证尽量少的数据丢失？</h5><ul class="lvl-0"><li class="lvl-2"><p>没办法完全保证数据不丢失。但是可以通过设置主从节点间的同步复制延迟时间来尽量少的数据丢失。</p></li><li class="lvl-2"><p>比如，在 Redis 集群中，在 redis 配置文件中修改同步复制延迟的时间不超过 10s，一但延迟超过这个时间，说明主节点可能出了问题（不一定是宕机），那么配置生效，主节点只能读，不能再写入。</p><ul class="lvl-2"><li class="lvl-6">min-slaves-to-write 1</li><li class="lvl-6">min-slaves-max-lag 10</li><li class="lvl-6">要求至少有 1 个 slave，数据复制和同步的延迟不能超过 10 秒（这样脑裂最多就丢失 10s 数据）</li></ul></li><li class="lvl-2"><p>同时在客户端做降级处理，把数据写到本地磁盘。</p></li></ul><h4 id="什么是-Redis-脑裂？会存在什么问题？">什么是 Redis 脑裂？会存在什么问题？</h4><ul class="lvl-0"><li class="lvl-2"><p>一个集群中的 master 恰好网络故障，导致与 sentinal 联系不上了，sentinal 把另一个 slave 提升为了 master。此时就存在两个 master 了。</p></li><li class="lvl-2"><p>当我们发现的时候，停止掉其中的一个 master，手动切换成 slave，当它连接到提升后的 master 的时候，会开始同步数据，那么自己脑裂期间接收的写数据就被丢失了。</p></li></ul><h4 id="Redis-集群如何选择数据库？">Redis 集群如何选择数据库？</h4><ul class="lvl-0"><li class="lvl-2"><p>Redis 集群目前无法做数据库选择，默认在 0 数据库。</p></li></ul><h4 id="Redis-集群最大节点个数是多少？">Redis 集群最大节点个数是多少？</h4><ul class="lvl-0"><li class="lvl-2"><p>16384 个</p></li></ul><h4 id="生产环境中的-redis-是怎么部署的？">生产环境中的 redis 是怎么部署的？</h4><ul class="lvl-0"><li class="lvl-2"><p>redis cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署了 redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰 qps 可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求/s。</p></li><li class="lvl-2"><p>机器是什么配置？32G 内存 + 8 核 CPU + 1T 磁盘，但是分配给 redis 进程的是 10g 内存，一般线上生产环境，redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。</p></li><li class="lvl-2"><p>5 台机器对外提供读写，一共有 50g 内存。</p></li><li class="lvl-2"><p>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，redis 从实例会自动变成主实例继续提供读写服务。</p></li><li class="lvl-2"><p>你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。其实大型的公司，会有基础架构的 team 负责缓存集群的运维。</p></li></ul><h2 id="缓存异常">缓存异常</h2><h3 id="缓存预热">缓存预热</h3><ul class="lvl-0"><li class="lvl-2"><p>系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。用户直接查询事先被预热的缓存数据。<br><strong>解决方法</strong></p></li><li class="lvl-2"><p>自动：使用监听器（web/Spring boot）监听某个事件（项目启动/容器的创建），在事件触发时查询数据库，把一些热门数据提前缓存到 Redis 中</p></li><li class="lvl-2"><p>手动：使用单元测试脚本 动态的往 Redis 中进行数据的添加</p></li></ul><h3 id="缓存雪崩">缓存雪崩</h3><ul class="lvl-0"><li class="lvl-2"><p>缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。<br><strong>解决方法</strong></p></li><li class="lvl-2"><p>设置缓存的失效时间尽量错开（比如 30 天 + 随机数 (s)），热门数据时间长点，不热门的时间短点。</p></li><li class="lvl-2"><p>设置多级缓存，Nginx 缓存 +redis 缓存 +ehcache 缓存……每一个缓存都是一个集群，相同的数据会在多种服务器进行缓存，可以 100% 解决缓存雪崩。</p></li><li class="lvl-2"><p>侧面解决：优化数据库，提升效率，使用页面静态技术（多级缓存）代替从 redis 中取值。</p></li><li class="lvl-2"><p>限流/降级</p></li><li class="lvl-2"><p>超热数据使用永久 Key（定期维护）</p></li></ul><h3 id="缓存穿透">缓存穿透</h3><ul class="lvl-0"><li class="lvl-2"><p>就是指反复查询一个数据库一定不存在的数据，导致数据库压力过大，这种情况一般只有恶意攻击才会出现。<br><strong>解决方法</strong></p></li><li class="lvl-2"><p>接口层增加校验，如用户鉴权校验，id 做基础校验，id&lt;=0 的直接拦截</p></li><li class="lvl-2"><p>从缓存取不到的数据，在数据库中也没有取到，这时也可以将 key-value 对写为 key-null，缓存有效时间可以设置短点，如 30 秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个 id 暴力攻击</p></li><li class="lvl-2"><p>采用布隆过滤器（在海量数据中判断一个数据是否存在），将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。根据 Hash 判断，如果数据不存在，那么一定不存在。</p></li><li class="lvl-2"><p>加密参数，符合加密规则的参数才会被接收</p></li></ul><h3 id="缓存击穿">缓存击穿</h3><ul class="lvl-0"><li class="lvl-2"><p>是指一个热点 key 的 redis 缓存失效，导致大量请求瞬间集中到数据库。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。<br><strong>解决方法</strong></p></li><li class="lvl-2"><p>多级缓存</p></li><li class="lvl-2"><p>延长热点数据有效期。</p></li><li class="lvl-2"><p>限流/降级</p></li></ul><h3 id="缓存降级">缓存降级</h3><ul class="lvl-0"><li class="lvl-2"><p>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p></li></ul><h3 id="热点数据和冷数据">热点数据和冷数据</h3><ul class="lvl-0"><li class="lvl-2"><p>热点数据，缓存才有价值</p><ul class="lvl-2"><li class="lvl-6">某 IM 产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。某导航产品，我们将导航信息，缓存以后可能读取数百万次。</li></ul></li><li class="lvl-2"><p>对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。</p></li><li class="lvl-2"><p>频繁修改的数据，看情况考虑使用缓存</p><ul class="lvl-2"><li class="lvl-6">这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到 Redis 缓存，减少数据库压力。</li></ul></li></ul><h2 id="线程模型">线程模型</h2><h3 id="为什么-Redis-是单线程的？">为什么 Redis 是单线程的？</h3><ul class="lvl-0"><li class="lvl-2"><p>Redis 的底层主要是三大部分：IO 多路复用程序 + 队列 + 文件事件分派器。而文件事件分派器就是用来分派执行任务的，且它是单线程的，所以说 Redis 也是单线程的。</p></li><li class="lvl-2"><p>此外，Redis 底层是基于 C 语言所写，且是基于内存运行，所以他的 IO 速度很快，相对来说主要要占用的是 CPU 的资源，如果实用多线程反而会因为线程的切换增大开销，降低效率，对于不是处理海量数据，多用于缓存使用的 Redis 来说，使用单线程是效率最优的。</p></li></ul><h3 id="redis-是单线程的，为什么还需要用它实现分布式锁？">redis 是单线程的，为什么还需要用它实现分布式锁？</h3><p>redis 单线程与分布式锁没有关系。redis 单线程只能保证在 redis 中的读写是按一定顺序执行（reids 不保证原子性，也不会回滚，某条命令运行失败也会继续执行），但在分布式中，是多台机器间的多进程调用，为了保证执行过程中，不被其他进程抢断执行，需要有一个第三方组件来实现分布式锁。即使数据就在 redis 中，也无法保证数据在进行其他服务处理的时候，被其他进程抢走。</p><h3 id="Redis-是单线程的，如何提高多核-CPU-的利用率？">Redis 是单线程的，如何提高多核 CPU 的利用率？</h3><p>可以在同一个服务器部署多个 Redis 的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个 CPU，你可以考虑一下分区。</p><h2 id="Redis-分区">Redis 分区</h2><h3 id="为什么要做-Redis-分区">为什么要做 Redis 分区</h3><ul class="lvl-0"><li class="lvl-2"><p>分区可以让 Redis 管理更大的内存，Redis 将可以使用所有机器的内存，提升内存和计算能力。</p></li></ul><h3 id="怎么实现-Redis-分区？">怎么实现 Redis 分区？</h3><ul class="lvl-0"><li class="lvl-2"><p>Cluster 集群就很好的实现了 Redis 分区。客户端随机地请求任意一个 redis 实例，然后由 Redis 将请求转发给正确的 Redis 节点。Redis Cluster 实现了一种混合形式的查询路由，但并不是直接将请求从一个 redis 节点转发到另一个 redis 节点，而是在客户端的帮助下直接 redirected 到正确的 redis 节点。</p></li></ul><h3 id="Redis-分区的缺点是什么？">Redis 分区的缺点是什么？</h3><ul class="lvl-0"><li class="lvl-2"><p>涉及多个 key 的操作时可能会比较麻烦一点：比如两个集合 key 在不同的机子上，那就不能直接在 redis 中做交集。</p></li></ul><h3 id="Redis-分区和集群有什么区别？">Redis 分区和集群有什么区别？</h3><ul class="lvl-0"><li class="lvl-2"><p>分区是逻辑概念，即一个 master 可以分为一个 master+n 个 slave。</p></li><li class="lvl-2"><p>集群是系统结构，集群是分区概念的一种实现方式。</p></li></ul><h2 id="分布式问题">分布式问题</h2><h3 id="那怎么解决缓存的并发竞争问题？比如多个子系统去-set-一个-key-但最后执行顺序和我们期望顺序不一样">那怎么解决缓存的并发竞争问题？比如多个子系统去 set 一个 key 但最后执行顺序和我们期望顺序不一样</h3><ul class="lvl-0"><li class="lvl-2"><p>可以采用分布式锁（zookeeper 和 redis 都可以实现分布式锁）的方案。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）</p></li><li class="lvl-2"><p>基于 zookeeper 临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在 zookeeper 上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p></li><li class="lvl-2"><p>在实践中，当然是从以可靠性为主。所以首推 Zookeeper。</p></li></ul><h3 id="说一说-Redis-分布式锁">说一说 Redis 分布式锁</h3><ul class="lvl-0"><li class="lvl-2"><p>首先，分布式锁是一种思想，是为了解决多机器多进程之间的同步问题，需要引入第三方来做锁处理。</p></li><li class="lvl-2"><p>Redis 分布式锁的加锁，其实就是给 Key 键设置一个值（SET lock_key random_value NX PX 5000，NX 表示键不存在时才设置），其他进程执行前会判断 Redis 中这个 Key 是否有值，如果发现这个 Key 有值了，就说明已有其他进程在执行，则循环等待，超时则获取失败。</p></li><li class="lvl-2"><p>解锁就是将 Key 键删除，为了保证解锁的原子性操作，用 Redis 自带的 LUA 脚本完成操作。</p></li><li class="lvl-2"><p>Redis 做为分布式锁的优点是性能高，缺点是不可靠，比如在 Redis 集群架构中，一旦主节点宕机，新的主节点会给新进程也加锁。</p></li><li class="lvl-2"><p>但不论如何，分布式锁一定会带来性能消耗问题，且实际中使用查询的比例远大于写的比例，除非是重要的敏感数据，不然为了更高的性能，一般会选择舍弃使用分布式锁。</p></li></ul><h3 id="这里为什么要用-Lua-脚本来完成解锁操作？">这里为什么要用 Lua 脚本来完成解锁操作？</h3><ul class="lvl-0"><li class="lvl-2"><p>Redis 只能保证单个指令进入 redis 是单线程原子性的，但不能保证多个命令之间的顺序是原子性的，但是 Lua 指令可以将这个命令绑定，相当于只有一个执行命令，保证它们是顺序执行的。</p></li></ul><h3 id="为什么-Redis-分布式解锁要何证原子性？">为什么 Redis 分布式解锁要何证原子性？</h3><ul class="lvl-0"><li class="lvl-2"><p>主要是怕误将其他客户端的锁解开。</p></li><li class="lvl-2"><p>比如客户端 A 加锁，一段时间之后客户端 A 解锁，在进入 unlock 后执行 jedis.del() 之前，锁突然过期了，此时客户端 B 尝试加锁成功，然后客户端 A 再执行 del() 方法，这时候客户端 A 已经执行过 Random_Value 的判断，虽然和客户端 B 的不一样，但我们总不能每一行代码都做一个值判断吧，这时候客户端 A 就会将客户端 B 的锁给解除了。</p></li></ul><h3 id="Redis-分布式锁应该注意什么？">Redis 分布式锁应该注意什么？</h3><ul class="lvl-0"><li class="lvl-2"><p>加锁的时候，应考虑到执行一半宕机或故障导致没能执行到解锁的命令，产生死锁，所以需要给定一个过期时间，防止死锁。</p></li><li class="lvl-2"><p>解锁要保证原子一致性。</p></li><li class="lvl-2"><p>redis 的解锁就是把 key 删除即可，但是删除的时候不能随便删，比如线程 A 不能删除线程 B 的 key，这个时候 value 就起到作用了，random_value 我们设置为随机值，每一个线程都生成一个随机值作为 random_value，删除 key 的时候先判断随机值是否和本线程的一致，一致的才可以删除。</p></li></ul><h2 id="Redis-事务">Redis 事务</h2><h3 id="Redis-事务的概念">Redis 事务的概念</h3><ul class="lvl-0"><li class="lvl-2"><p>Redis 事务的本质是通过 MULTI、EXEC、WATCH 等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p></li><li class="lvl-2"><p>总结说：redis 事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p></li></ul><h3 id="Redis-事务的三个阶段">Redis 事务的三个阶段</h3><ol><li class="lvl-4"><p>事务开始 MULTI</p></li><li class="lvl-4"><p>命令入队</p></li><li class="lvl-4"><p>事务执行 EXEC</p><ul class="lvl-2"><li class="lvl-6">事务执行过程中，如果服务端收到有 EXEC、DISCARD、WATCH、MULTI 之外的请求，将会把请求放入队列中排队</li></ul></li></ol><h3 id="Redis-事务相关问题">Redis 事务相关问题</h3><ul class="lvl-0"><li class="lvl-2"><p>Redis 事务功能是通过 MULTI、EXEC、DISCARD 和 WATCH 四个原语实现的。（Redis 事务很鸡肋）</p></li></ul><ol><li class="lvl-3"><p>Redis 会将一个事务中的所有命令序列化，然后按顺序执行。</p></li><li class="lvl-3"><p>redis 不支持回滚，“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。</p></li><li class="lvl-3"><p>如果在一个事务中的命令出现错误，那么所有的命令都不会执行（就是除非你的命令写错了，导致所有命令不执行）；</p></li><li class="lvl-3"><p>如果在一个事务中出现运行错误，那么正确的命令会被执行。</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到 EXEC 命令。</p></li><li class="lvl-2"><p>MULTI 命令用于开启一个事务，它总是返回 OK。 MULTI 执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当 EXEC 命令被调用时，所有队列中的命令才会被执行。</p></li><li class="lvl-2"><p>EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。</p></li><li class="lvl-2"><p>通过调用 DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。</p></li><li class="lvl-2"><p>UNWATCH 命令可以取消 watch 对所有 key 的监控。</p></li></ul><h3 id="Redis-事务保证原子性吗？">Redis 事务保证原子性吗？</h3><p>Redis 中，单条命令是原子性执行的，但事务<strong>不保证原子性</strong>，且<strong>没有回滚</strong>，事务过程中任意命令执行失败，其余的命令仍会被执行。</p><h3 id="Redis-事务保证隔离性吗？">Redis 事务保证隔离性吗？</h3><p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是<strong>带有隔离性</strong>的。</p><h2 id="其他问题">其他问题</h2><h3 id="在工作中，如果数据库修改了数据，那就跟-redis-数据不同步了，此时该办？（缓存双写一致性问题）">在工作中，如果数据库修改了数据，那就跟 redis 数据不同步了，此时该办？（缓存双写一致性问题）</h3><ul class="lvl-0"><li class="lvl-2"><p>第一种是硬编码方式；</p><ul class="lvl-2"><li class="lvl-6">让服务的更新和查询分先后进行执行，服务将数据库更新后，再查返更新后的数据，把更新后的数据再更新到 redis。如果有多个服务同时调用，就用 MQ 获取 Mysql 的 binlog 中的修改顺序，依次发送消息给 redis，MySQL 的顺序记录就是先后更改的执行顺序，MQ 根据这个顺序即可保证先后的更新顺序，让 redis 的更新顺序不出问题。</li></ul></li><li class="lvl-2"><p>第二种是 Redis 缓存二次开发解决（MyBatisPlus+redis 整合：餐饮项目中使用到）。</p><ul class="lvl-2"><li class="lvl-6">用 Mybatis 二级缓存对外开放的 cache 接口进行二次开发，Cache 支持 SPI 机制，通过注解来调动相关配置类，通过实现 Mybatis 二级缓存接口 Cache 集成 Redis 缓存，可以自动更新到 MySQL 数据到 Redis 缓存中。</li><li class="lvl-6">为了防止在读写的过程中出现高并发问题，还需要加上 ReentrantReadWriteLock 读写锁，ReentrantLock 只能进入一个线程，ReentrantReadWriteLock 允许多个线程访问，提高高并发，但只支持多个线程读，不支持同时读写或写写。</li><li class="lvl-6">但是以上方式也不能完全解决同步问题，仍存在分布式的高并发问题，如果需要完全保证一致性，就需要使用分布式锁，对每个事务上锁。但这样对系统资源消耗过大，得不偿失，毕竟读取的量是远大于增删改的量的。</li></ul></li></ul><h3 id="假如-Redis-里面有-1-亿个-key，其中有-10W-个-key-是以某个固定的已知前缀开头的，如何将它们全部找出来？">假如 Redis 里面有 1 亿个 key，其中有 10W 个 key 是以某个固定的已知前缀开头的，如何将它们全部找出来？</h3><ul class="lvl-0"><li class="lvl-2"><p>使用 keys 指令可以扫出指定模式的 key 列表。</p></li></ul><h4 id="如果这个-redis-正给线上的业务提供服务，那使用-keys-指令会有什么问题？">如果这个 redis 正给线上的业务提供服务，那使用 keys 指令会有什么问题？</h4><ul class="lvl-0"><li class="lvl-2"><p>由于 redis 是单线程的，而 keys 是遍历查询，每个数据都会遍历一次，所以 keys 指令去查找大量数据会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。</p></li><li class="lvl-2"><p>可替代方式是，可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。</p></li><li class="lvl-2"><p>但这里要注意的是，scan 指令有一个坑，不会自动释放连接，需要手动释放连接。具体的解决方案我有做笔记。</p></li></ul><h4 id="scan-为什么可以不阻塞提取-key-列表？为什么会有重复问题？">scan 为什么可以不阻塞提取 key 列表？为什么会有重复问题？</h4><ul class="lvl-0"><li class="lvl-2"><p>Scan 命令其实是迭代器方式对数据进行遍历获取，但它是分次进行的，可以在中途返回查到的数据，做到不阻塞，且因为 redis 底层是 Hash 字典，会有扩容和缩容问题，所以 scan 每次都会往前退一定数索开始继续遍历，所以会有重复问题。（具体见笔记）。</p></li></ul><h3 id="使用-Redis-做过异步队列吗，是如何实现的？">使用 Redis 做过异步队列吗，是如何实现的？</h3><ul class="lvl-0"><li class="lvl-2"><p>使用 list 类型保存数据信息，rpush 生产消息，lpop 消费消息，当 lpop 没有消息时，可以 sleep 一段时间，然后再检查有没有信息，如果不想 sleep 的话，可以使用 blpop, 在没有信息的时候，会一直阻塞，直到信息的到来。redis 可以通过 pub/sub 主题订阅模式实现一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产的消息会丢失。</p></li></ul><h3 id="Redis-如何实现延时队列？">Redis 如何实现延时队列？</h3><p>使用 sortedset，使用时间戳做 score，消息内容作为 key，调用 zadd 来生产消息，消费者使用 zrangbyscore 获取 n 秒之前的数据做轮询处理。</p><h3 id="Redis-回收进程如何工作的？">Redis 回收进程如何工作的？</h3><ol><li class="lvl-3"><p>一个客户端运行了新的命令，添加了新的数据。</p></li><li class="lvl-3"><p>Redis 检查内存使用情况，如果大于 maxmemory 的限制， 则根据设定好的策略进行回收。</p></li><li class="lvl-3"><p>一个新的命令被执行，等等。</p></li><li class="lvl-3"><p>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</p></li><li class="lvl-3"><p>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p></li></ol><h3 id="Redis-回收使用的是什么算法？">Redis 回收使用的是什么算法？</h3><p>LRU 算法（将最近最久未使用的页面予以淘汰。）</p><h3 id="Redis-常见性能问题和解决方案？">Redis 常见性能问题和解决方案？</h3><ol><li class="lvl-4"><p>Master 最好不要做任何持久化工作，包括内存快照和 AOF 日志文件，特别是不要启用内存快照做持久化。</p></li><li class="lvl-4"><p>如果数据比较关键，某个 Slave 开启 AOF 备份数据，策略为每秒同步一次。</p></li><li class="lvl-4"><p>为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内。</p></li><li class="lvl-4"><p>尽量避免在压力较大的主库上增加从库</p></li><li class="lvl-4"><p>Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。</p></li><li class="lvl-4"><p>为了 Master 的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现 Slave 对 Master 的替换，也即，如果 Master 挂了，可以立马启用 Slave1 做 Master，其他不变。</p></li></ol><h3 id="Redis-官方为什么不提供-Windows-版本？">Redis 官方为什么不提供 Windows 版本？</h3><p>因为目前 Linux 版本已经相当稳定，而且用户量很大，无需开发 windows 版本，反而会带来兼容性等问题。</p><h3 id="一个字符串类型的值能存储最大容量是多少？">一个字符串类型的值能存储最大容量是多少？</h3><p>512M</p><h3 id="Redis-如何做大量数据插入？">Redis 如何做大量数据插入？</h3><p>Redis2.6 开始 redis-cli 支持一种新的被称之为 pipe mode 的新模式用于执行大量数据插入工作。</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;&lt;br&gt;
❗表示必掌握，❔表示基本不会问&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-24 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="八股文" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="面试" scheme="https://kiml.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="八股文" scheme="https://kiml.github.io/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第三十六天-完全背包、518零钱兑换 II、377组合总和 Ⅳ、CM70爬楼梯（进阶）</title>
    <link href="https://kiml.github.io/posts/b717497e/"/>
    <id>https://kiml.github.io/posts/b717497e/</id>
    <published>2024-06-22T01:08:05.000Z</published>
    <updated>2024-06-25T07:51:44.433Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：看完完全组合的解析之后，完成 518 和 377。CM70就是377。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-22 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="初步题解">初步题解</h2><h3 id="518-零钱兑换-II">518 零钱兑换 II</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/coin-change-ii/" >https://leetcode.cn/problems/coin-change-ii/<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i]</code> 的含义：填满 i（包括 i）这么大容积的包，有 <code>dp[i]</code> 种方法</p></li><li class="lvl-3"><p>递推公式：<code>dp[i] += dp[i - coin]</code>。</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[0] = 1</code>。假设数组个数为 0，获取 dp[0]，就是 1。</p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 思路：  </span></span><br><span class="line"><span class="comment"> * 1. 这是一个完全背包的题目（正序）  </span></span><br><span class="line"><span class="comment"> * 2. 求的是组合数量 dp[i] += dp[i - coin];  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> amount 总数  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> coins 硬币总和  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 有几种组合方法  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;  </span><br><span class="line">    <span class="comment">// 填满 i（包括 i）这么大容积的包，有 `dp[i]` 种方法  </span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> coin; i &lt; dp.length; i++) &#123;  </span><br><span class="line">            dp[i] += dp[i - coin];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.toString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[amount];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="377-组合总和-Ⅳ">377 组合总和 Ⅳ</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/combination-sum-iv" >https://leetcode.cn/problems/combination-sum-iv<i class="fas fa-external-link-alt"></i></a>)</p><p><strong>如果求组合数就是外层 for 循环遍历物品，内层 for 遍历背包</strong>。</p><p><strong>如果求排列数就是外层 for 遍历背包，内层 for 循环遍历物品</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 完全背包+排列</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums   数组  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target 总数  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 有几种排列</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (i &gt;= num) &#123;  </span><br><span class="line">                dp[i] += dp[i - num];  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.toString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[target];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="70-爬楼梯-（进阶）">70 爬楼梯 （进阶）</h3><p>题目链接：(<a class="link"   href="https://kamacoder.com/problempage.php?pid=1067" >https://kamacoder.com/problempage.php?pid=1067<i class="fas fa-external-link-alt"></i></a>)</p><p>就是完全背包 + 排列，解法和上题一模一样。nums 取值为 <code>1- 每次最多爬的阶梯数量</code></p><h2 id="看解析">看解析</h2><h3 id="完全背包">完全背包</h3><p>有 N 件物品和一个最多能背重量为 W 的背包。第 i 件物品的重量是 <code>weight[i]</code>，得到的价值是 <code>value[i] </code>。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p><p><strong>完全背包和 01 背包问题唯一不同的地方就是，每种物品有无限件</strong>。</p><p><strong>二维数组</strong>：</p><ol><li class="lvl-3"><p>递推公式：<code>dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - item[i][0]] + item[i][1])</code>（即，不重复存放当前物品/重复存放当前物品）</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[i][0]</code> 均为 0。<code>dp[0][j]</code> 为第一格按背包大小取重复值。</p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">    integerBreak(<span class="number">4</span>, <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">15</span>&#125;, &#123;<span class="number">3</span>, <span class="number">20</span>&#125;, &#123;<span class="number">4</span>, <span class="number">30</span>&#125;&#125;);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] item)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[item.length][n + <span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 纵列初始化为0（数组定义，不用初始化）  </span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 横列初始化不一样了  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; dp[<span class="number">0</span>].length &amp;&amp; n &gt;= item[<span class="number">0</span>][<span class="number">0</span>]; j++) &#123;  </span><br><span class="line">        dp[<span class="number">0</span>][j] = j / item[<span class="number">0</span>][<span class="number">0</span>] * item[<span class="number">0</span>][<span class="number">1</span>];  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; item.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (j - item[i][<span class="number">0</span>] &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="comment">// 如果当前物品不能放入，背包值 = 当前值的前一列</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// 如果当前物品可以放入</span></span><br><span class="line"><span class="comment">// 比较前一列和（范围大小还是[0, i]，如果是 i - 1，范围大小就是[0, i - 1]）</span></span><br><span class="line"><span class="comment">// 也就是说，包不包含这个数本身（可不可以重复计数）</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - item[i][<span class="number">0</span>]] + item[i][<span class="number">1</span>]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.deepToString(dp));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一维数组（状态压缩）</strong>：</p><ol><li class="lvl-3"><p>递推公式：<code>dp[i] = Math.max(dp[i], dp[i - item[0]] + item[1]);</code></p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[0] = 0</code></p></li><li class="lvl-3"><p>遍历顺序：从前向后遍历。（<strong>而完全背包的物品是可以添加多次的，所以要从小到大去遍历</strong>。（😅老实说，看了好几几遍都没懂））</p></li><li class="lvl-3"><p><strong>这里完全背包一维 dp 数组可以交换遍历顺序</strong>：因为 <code>dp[j]</code> 是用到其左边的数据 <code>dp[j - weight[i]]</code> 的，而先遍历背包再遍历物品也是满足的。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">integerBreak1</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] items)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] item : items) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp.length; i++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (i &gt;= item[<span class="number">0</span>]) &#123;  </span><br><span class="line">                dp[i] = Math.max(dp[i], dp[i - item[<span class="number">0</span>]] + item[<span class="number">1</span>]);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.toString(dp));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="518-零钱兑换-II-2">518 零钱兑换 II</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html" >https://programmercarl.com/0518.零钱兑换II.html<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="377-组合总和-Ⅳ-2">377 组合总和 Ⅳ</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html" >https://programmercarl.com/0377.组合总和Ⅳ.html<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="70-爬楼梯-（进阶）-2">70 爬楼梯 （进阶）</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html" >https://programmercarl.com/0070.爬楼梯完全背包版本.html<i class="fas fa-external-link-alt"></i></a>)</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;状态：看完完全组合的解析之后，完成 518 和 377。CM70就是377。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-22 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="动态规划" scheme="https://kiml.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="完全背包" scheme="https://kiml.github.io/tags/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>实操：AI编程</title>
    <link href="https://kiml.github.io/posts/6501e090/"/>
    <id>https://kiml.github.io/posts/6501e090/</id>
    <published>2024-06-21T07:24:04.000Z</published>
    <updated>2024-06-25T07:51:44.441Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="7b68bbf314f78420abde5afe57101de647673b42dbed569e58a9f4796a764cd7">abeb8d7735f0ac1430d5930ae71b6720b0442317ed254a69c11041c65159e9be845a26339db56165385334e2c44d7c39d657f984d7b54ce1264d731e88a779b97bdcdaeecae33d3b87425235ece4c6220beb7e0801b3573a077dd101bd52db2668440aef62c87726f9518ccdb768ba4369515c9d3bfd2bc58ea114f5c5aac954afeee389f2ebcfa47bbbef0f1c09afd7491396fc843d696151d6f3e8704d3c6b1efb2f03cb162e5ad211adc364abe91b8842443388b201959b0a9cf55999b77c92e771ecfa0b21186bf4e3613678a24a41221c34f2dfc9391fcc23e8fa9235ec811f7ec10a5e6b8c7abde4bc2b79ae29b1ddd5eb58ecd45de728fa7d5f927ebecf559ecdd43b9548d189c43ce3a228e802750848c312ee3a3b2fd57e8c97da878827b253e37fad528653530bbffc8e1299b3309334d3a2cf92c930e6e8d6bf7c2514915f000145ed5f2574793f1dce7abf1355b3bed71460355bc7fbc0be95fcd0881c1c278fbbae27c87831a952e2605c55d7f00cc3e7125abf36eb75a1531b9b0e1df2eaab03a6d6519975f165067fb15823c2a526dc1508e899c507fced2773071f95c6e27293a9503e41309e5323a0c7e6ff103bb487c370f24439b71eed88fdb7605d6d80692b00bbe2db5918a089d1654b51c356bdcdefd193880d4b185fd20e92fc0bb172a83c4c9b30e8551cfd1352cc85aec8ead1ca5c0fe4fb371b2c8947888d0230f464dad150d061e55da231a0fc57b387c6805258384f9b6be12a7ab2450d8d729391828b211149a5e449a437f5d00b10a4baf802dfd442a50161b2679bf83b6e0083bb134f7ec2344d38a34decc42282e6699c2537582b20c669780b06d8c874ad2b9a96cf6bf8898800219131b1d19e76a7fd784e93137784fda809b7e9ebf414895234e48693b24f9a4017f2b97bba8b4f19e257bde0068ae86159350a946774712c0bec60cac841163e7da1e0b838c3fb3065934e9125902014721ee666d556593011842488b1b8498a87a4b3c63ba88450c52c9a9e5106f89db563833db37a8fa2a88db81248c43e7c3c492c6609a08f311310e5fcd37512e05e5710211e73c0e80fb0734b852a09c0d4703ba26cf3a08a6797195f11f4d503ff2ca4ae7a96df66a72a91c65943eace4f1b521e9d9861cbbd0ea2b282e6c1dd5c2ea9f56ca72f12007450ebf73265d25a1f083c447e3f243aa5fa06819f4b7945e8724ae7ab7413db17b43c2179496e204f66b39fb5c140f8783486582280edf6479f066f47ec5a16c6feac423d05c1cadbf974a38146722cac65ce97daed222cf38f1ee2c9023d8a24a3ff04d50fec0928ee68ff7aebd1c86019aefaddca24d97ae46e3976dc6c6a8c6ec7000e7500fb3b5fe9e71a3ecded19f6dac0b87d406ef73109abda629c4c4b80ef91870be195c4b1336899f7a4ff217cf877cc6662c2530efe3251e9cc5ded31c620094c2908ed53c5aa621c881683c02530e5b684962c8d4bcd905e2c45a2159afb2faac23cd0e584f259b4530d475099562185454a9297a12f0b9c27d632e39438f4ccf0321814121689e49c22bcd7fca37f8b5d065fa5e7c9504eb0f1b3b620b20117e65f7954ea09a661ba348e0c40f30e8a49a2321dee6c42fa2319be949fb3ffb7f5214f61eeb6c3f6da5a8df54bf55e33fd4db8a4f08f4b8c0137ca8fac1aad6e1964178fc0c49acdcb92b78eba9b0f1f0f5cb0971be0cfba7c33705d3ce3425543eec3c8e0560f2391b6ec4dba5d1ddb9f004109dde230c057c2f92be55e3e1fe945e6b205edb82a92f7ac2dcc95ea31d557fa46b1f8dfbca567db7da8a9682833f40768e42eac3f2a8329148c2792b893444557ce1d3d9c80b1590e92da5d39966edf7abdae35243cc6f222cc3163070bc8cfa6c2c7d20df508d9d48614014e8462babf27fcb5953bc93c59e89f5e396b8936f60929888cfb7051b7639663111c720d0bd017067ed94ed947c16065e9fcad4adb69b8ff9e033e8af40508d74660d04af101510e37e11c5d892f20f4df43fa883f0c6e949e060ea9df408243e7f4192cbf3afd0e4050f883b3506ac63dec2dc66eabb40ec54ec9778b1cfd6f5a0e4c4ac9b3a5a6c40877bb48a522ba681c062b4abefc11ac031575889c30d863b6587ba9670bca9a4ac75bcdaa606ba00fa9708e8157245d065c22f01602e7a0075bf294df0c59c4e6621d57d7384e73d72008ef2e1be18dba49843328af2488c8781b1af1733a798b4eb140b2287db1184a2573aebc622008935da9a3d8bc2946233c40233952bf387c5ffb84e33bb5b501cdba9ade7e3b2411652bb5286a355265f6d5e97708dfe11fbcac1467aa27ee1bde313d83e643674eda852344073768f20d397b91781b578c75fc427db93380507d91649f2dd15a6d815a3a98dc6a8857f099cecf196bd74ea0f465cdebfe50920ab18b1941e9d17436c1d1c728aae0f1119a563d70db1808893d2addaf004bef34c80b49cd78a474c709ae5c0a2cae5a9cbc437925c9c8a7bf37c09a3128d8bef79d8dfd4686f3424b2ed11911b87051108d38094639e4830899fcfc2c5afaaafc2436f2bd2b7b512d0becf3d2b529a3d2b44e80edb98fa8da75b941c38df47453744f4a24373d7832be0857be68d3c642fbc61c33490cac82cacca9c6</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    <category term="阅读" scheme="https://kiml.github.io/categories/%E9%98%85%E8%AF%BB/"/>
    
    <category term="AI大模型全栈" scheme="https://kiml.github.io/categories/%E9%98%85%E8%AF%BB/AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%85%A8%E6%A0%88/"/>
    
    
    <category term="AI" scheme="https://kiml.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第三十五天-1049最后一块石头的重量 II、494目标和、474一和零</title>
    <link href="https://kiml.github.io/posts/bde30672/"/>
    <id>https://kiml.github.io/posts/bde30672/</id>
    <published>2024-06-21T01:19:10.000Z</published>
    <updated>2024-06-25T07:51:44.433Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：1049 和昨天那题差不多。494、474。。。☠️动规还是先了解解法。后面刷别的题组的时候再说。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-21 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="初步题解">初步题解</h2><h3 id="1049-最后一块石头的重量-II">1049 最后一块石头的重量 II</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/last-stone-weight-ii" >https://leetcode.cn/problems/last-stone-weight-ii<i class="fas fa-external-link-alt"></i></a>)</p><p>本题可以抽象成让石头分成尽量相同的两堆，然后进行相撞。即背包大小为总和除以 2，求能放入的最大价值。</p><ol><li class="lvl-3"><p>确定 <code>dp[i]</code> 的含义：从石头里任取，背包大小为 i，能放入的最大价值。<code>weight[i] = store[i]</code>，<code>value[i] = store[i]</code>。</p></li><li class="lvl-3"><p>递推公式：<code>dp[i] = Math.max(dp[i], dp[i - weight[j]] + value[j])</code>。</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[0] = 0</code>。</p></li><li class="lvl-3"><p>遍历顺序：从后向前遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(stones).sum();  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[sum / <span class="number">2</span> + <span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> stone : stones) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> dp.length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (j &gt;= stone) &#123;  </span><br><span class="line">    dp[j] = Math.max(dp[j], dp[j - stone] + stone);  </span><br><span class="line">&#125; </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> sum - dp[sum / <span class="number">2</span>] * <span class="number">2</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="494-目标和">494 目标和</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/target-sum" >https://leetcode.cn/problems/target-sum<i class="fas fa-external-link-alt"></i></a>)</p><p>完全没思路</p><h3 id="474-一和零">474 一和零</h3><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/ones-and-zeroes" >https://leetcode.cn/problems/ones-and-zeroes<i class="fas fa-external-link-alt"></i></a>)</p><p>看不懂，题目都看不懂☠️</p><h2 id="看解析">看解析</h2><h3 id="1049-最后一块石头的重量-II-2">1049 最后一块石头的重量 II</h3><p>解析：(<a class="link"   href="https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html" >https://programmercarl.com/1049.最后一块石头的重量II.html<i class="fas fa-external-link-alt"></i></a>)</p><h3 id="494-目标和-2">494 目标和</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html" >https://programmercarl.com/0494.目标和.html<i class="fas fa-external-link-alt"></i></a>)</p><p>假设正数集合总和是 left，负数集合总和是 right。总和 <code>sum = left + right</code>。目标值 <code>target = left - right</code>。可以得到 left 即正数之和 <code>= (sum + target)/2</code>。</p><p><strong>本题是装满有几种方法。这是一个组合问题</strong>，用的解法就和之前不一样。</p><ol><li class="lvl-3"><p>确定 <code>dp[i]</code> 的含义：填满 i（包括 i）这么大容积的包，有 <code>dp[i]</code> 种方法</p></li><li class="lvl-3"><p>递推公式：<code>dp[j] += dp[j - nums[i]]</code>。</p></li></ol><blockquote><ul class="lvl-1"><li class="lvl-2"><p>已经有一个 1（nums[i]） 的话，有 dp[4] 种方法 凑成 容量为 5 的背包。</p></li><li class="lvl-2"><p>已经有一个 2（nums[i]） 的话，有 dp[3] 种方法 凑成 容量为 5 的背包。</p></li><li class="lvl-2"><p>已经有一个 3（nums[i]） 的话，有 dp[2] 种方法 凑成 容量为 5 的背包</p></li><li class="lvl-2"><p>已经有一个 4（nums[i]） 的话，有 dp[1] 种方法 凑成 容量为 5 的背包</p></li><li class="lvl-2"><p>已经有一个 5 （nums[i]）的话，有 dp[0] 种方法 凑成 容量为 5 的背包</p></li></ul><p>那么凑整 dp[5] 有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。</p></blockquote><ol start="3"><li class="lvl-3"><p>dp 数组的初始化：<code>dp[0] = 1</code>。假设数组个数为 0，获取 dp[0]，就是 1。</p></li><li class="lvl-3"><p>遍历顺序：从后向前遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(nums).sum();  </span><br><span class="line">    <span class="keyword">if</span> ((sum + target) % <span class="number">2</span> == <span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (sum &lt; Math.abs(target)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> (sum + target) / <span class="number">2</span>;  </span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[left + <span class="number">1</span>];  </span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> dp.length - <span class="number">1</span>; j &gt;= num; j--) &#123;  </span><br><span class="line">    <span class="comment">// 这里比较难理解</span></span><br><span class="line">            dp[j] += dp[j - num];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    System.out.println(Arrays.toString(dp));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> dp[left];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="474-一和零-2">474 一和零</h3><p>解析：(<a class="link"   href="https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html" >https://programmercarl.com/0474.一和零.html<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p>确定 <code>dp[i][j]</code> 的含义：<strong>最多有 i 个 0 和 j 个 1 的 strs 的最大子集的大小为 <code>dp[i][j]</code></strong>。物品的重量是 0 的个数，1 的个数。价值就是 1。（难点在二维数组。。反正看了解析又感觉懂了，自己写又不会☠️）</p></li><li class="lvl-3"><p>递推公式：<code>dp[i][j] = Math.max(dp[i][j], dp[i - x][j - y]) + 1</code>。</p></li><li class="lvl-3"><p>dp 数组的初始化：<code>dp[0][0] = 0</code>。</p></li><li class="lvl-3"><p>遍历顺序：从后向前遍历。</p></li><li class="lvl-3"><p>打印 dp 数组（<em>用于 debug</em>）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;  </span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 这里x计算0的数量， y计算1的数量  </span></span><br><span class="line">    <span class="type">int</span> x, y;  </span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;  </span><br><span class="line">        x = <span class="number">0</span>;  </span><br><span class="line">        y = <span class="number">0</span>;  </span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : chars) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>) &#123;  </span><br><span class="line">                x++;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                y++;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m; i &gt;= <span class="number">0</span>; i--) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n; j &gt;= <span class="number">0</span>; j--) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (i &gt;= x &amp;&amp; j &gt;= y) &#123;  </span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i - x][j - y] + <span class="number">1</span>);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> dp[m][n];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;状态：1049 和昨天那题差不多。494、474。。。☠️动规还是先了解解法。后面刷别的题组的时候再说。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-21 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="动态规划" scheme="https://kiml.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="01背包" scheme="https://kiml.github.io/tags/01%E8%83%8C%E5%8C%85/"/>
    
  </entry>
  
</feed>
